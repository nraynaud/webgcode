<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>webgcode test</title>
    <link rel="stylesheet" href="assets/qunit.css">
    <style>        .chart {
        position: relative;
        clear: both;
        width: 100%;
        height: 200px;
    }
    </style>
</head>
<body>
<div id="qunit"></div>
<div id="qunit-fixture"></div>
<h1>Testing random speed planning</h1>

<h2>Speed/position</h2>

<div class="chart" id="chart1"></div>
<h2>Position/time</h2>

<div class="chart" id="chart2"></div>
<script src="assets/qunit.js"></script>
<script src="assets/jquery.min.js"></script>
<script src="assets/jquery.flot.min.js"></script>
<script src="simulation.js"></script>
<script src="parser.js"></script>
<script src="tests.js"></script>
<script>
    function limitSpeed(speedSegments, acceleration, direction) {
        for (var i = 0; i < speedSegments.length; i++) {
            var segment = speedSegments[i];
            var previousSquaredSpeed = 0;
            if (i > 0)
                previousSquaredSpeed = speedSegments[i - 1].squaredSpeed;
            var accelerationLength = previousSquaredSpeed / (2 * acceleration);
            var maxSquaredSpeed = 2 * acceleration * (accelerationLength + segment.length);
            segment.squaredSpeed = Math.min(segment.squaredSpeed, maxSquaredSpeed);
            segment[direction] = {length: previousSquaredSpeed / (2 * acceleration)};
        }
    }

    function planSpeed(data, acceleration) {
        limitSpeed(data, acceleration, 'acceleration');
        data.reverse();
        limitSpeed(data, acceleration, 'decceleration');
        data.reverse();
        for (var i = 0; i < data.length; i++) {
            var nextSquaredSpeed = (i < data.length - 1 ? data[i + 1].squaredSpeed : 0);
            var previousSquaredSpeed = (i >= 1 ? data[i - 1].squaredSpeed : 0);
            var segment = data[i];
            segment.fragments = [];
            var accelerationLength = segment.acceleration.length;
            var deccelerationLength = segment.decceleration.length;
            var meetingPoint = (deccelerationLength + segment.length - accelerationLength) / 2;
            var meetingSquaredSpeed = 2 * acceleration * (accelerationLength + meetingPoint);
            var maxAccelerationPoint = (segment.squaredSpeed - 2 * acceleration * accelerationLength) / (2 * acceleration);
            var maxDeccelerationPoint = (2 * acceleration * (deccelerationLength + segment.length) - segment.squaredSpeed) / (2 * acceleration);
            var maxSquaredSpeed = segment.squaredSpeed;
            if (meetingPoint >= 0 && meetingPoint <= segment.length && meetingSquaredSpeed <= segment.squaredSpeed) {
                maxSquaredSpeed = meetingSquaredSpeed;
                maxAccelerationPoint = meetingPoint;
                maxDeccelerationPoint = meetingPoint;
                segment.squaredSpeed = meetingSquaredSpeed;
            }
            var hasAcceleration = maxAccelerationPoint > 0 && maxAccelerationPoint <= segment.length;
            var hasDecceleration = maxDeccelerationPoint >= 0 && maxDeccelerationPoint < segment.length;
            if (hasAcceleration)
                segment.fragments.push({type: 'acceleration', segment: segment, fromSpeed: previousSquaredSpeed, toSpeed: maxSquaredSpeed, startX: 0, stopX: maxAccelerationPoint});
            var constantSpeedStart = hasAcceleration ? maxAccelerationPoint : 0;
            var constantSpeedStop = hasDecceleration ? maxDeccelerationPoint : segment.length;
            if (constantSpeedStart != constantSpeedStop)
                segment.fragments.push({type: 'constant', segment: segment, speed: maxSquaredSpeed, startX: constantSpeedStart, stopX: constantSpeedStop});
            if (hasDecceleration)
                segment.fragments.push({type: 'decceleration', segment: segment, fromSpeed: maxSquaredSpeed, toSpeed: nextSquaredSpeed, startX: maxDeccelerationPoint, stopX: segment.length});
            $.each(segment.fragments, function (_, fragment) {
                fragment.length = fragment.stopX - fragment.startX;
                fragment.duration = fragment.type == 'constant' ? fragment.length / Math.sqrt(fragment.speed) : Math.abs(Math.sqrt(fragment.fromSpeed) - Math.sqrt(fragment.toSpeed)) / acceleration;
            });
            console.log("segment", segment);
        }
    }

    var rawData = [
        [2, 2],
        [3, 1],
        [5, 2],
        [4, 2],
        [2, 4],
        [4, 1],
        [5, 1],
        [6, 2],
        [5, 2],
        [6, 2],
        [5, 1],
        [6, 1],
        [4, 3],
        [6, 3],
        [5, 2]
    ];
    rawData = [
        [1, 1]
    ];
    rawData = [];
    for (i = 0; i < 20; i++)
        rawData.push([Math.random() * 10, Math.random() * 10]);

    var acceleration = 4;
    data = [];
    for (i = 0; i < rawData.length; i++)
        data.push({length: rawData[i][1], speed: rawData[i][0], squaredSpeed: rawData[i][0] * rawData[i][0], originalSpeed: rawData[i][0]});
    var i;
    var speedData = [
        {label: 'reference speed(mm->mm/s)', points: {show: true, radius: 1, fill: false, symbol: "circle"}, lines: {show: true}, shadowSize: 0, color: 'red', data: []},
        {label: 'planned speed(mm->mm/s)', shadowSize: 0, color: 'blue', data: []},
        {points: {show: true, radius: 4, fill: false, symbol: "circle"}, color: 'rgba(0, 255, 0, 0.5)', lines: {show: false}, data: []},
        {points: {show: true, radius: 2, fill: false, symbol: "circle"}, color: 'rgba(150, 150, 0, 0.95)', lines: {show: false}, data: []},
        {points: {show: true, radius: 5, fill: false, symbol: "circle"}, color: 'rgba(255, 127, 80, 0.5)', lines: {show: false}, data: []},
        {label: 'planned max(mm->mm/s)', shadowSize: 0, color: 'rgba(0, 128, 0, 0.5)', data: []}
    ];
    var positionData = [
        {label: 'position/time(s->mm)', lines: {show: true}, shadowSize: 0, color: 'red', data: []},
        {points: {show: true, radius: 4, fill: false, symbol: "circle"}, color: 'rgba(0, 255, 0, 0.5)', lines: {show: false}, data: []},
        {points: {show: true, radius: 2, fill: false, symbol: "circle"}, color: 'rgba(150, 150, 0, 1)', lines: {show: false}, data: []},
        {points: {show: true, radius: 5, fill: false, symbol: "circle"}, color: 'rgba(255, 127, 80, 0.5)', lines: {show: false}, data: []},
        {points: {show: true, radius: 1, fill: false, symbol: "circle"}, lines: {show: false}, shadowSize: 0, color: 'red', data: []}
    ];
    planSpeed(data, acceleration);
    var steps = 100;
    speedData[1].data.push([0, 0]);
    var position = 0;
    positionData[0].data.push([0, 0]);
    positionData[4].data.push([0, 0]);
    function speedForAccelerationFragment(fragment, ratio) {
        var accelerationLength = fragment.segment.acceleration.length;
        return Math.sqrt(2 * acceleration * (accelerationLength + fragment.startX + fragment.length * ratio));
    }
    function speedForDeccelerationFragment(fragment, ratio) {
        var deccelerationLength = fragment.segment.decceleration.length;
        return Math.sqrt(2 * acceleration * (deccelerationLength + fragment.length * (1 - ratio)));
    }
    function timeForAccelerationFragment(fragment, ratio) {
        var accelerationLength = fragment.segment.acceleration.length;
        return Math.sqrt(2 * (accelerationLength + fragment.length * ratio) / acceleration) - Math.sqrt(fragment.fromSpeed) / acceleration;
    }
    function timeForDeccelerationFragment(fragment, ratio) {
        var deccelerationLength = fragment.segment.decceleration.length;
        return Math.sqrt(fragment.toSpeed) / acceleration + fragment.duration - Math.sqrt(2 * (deccelerationLength + fragment.length * (1 - ratio)) / acceleration);
    }
    var t = 0;
    for (i = 0; i < data.length; i++) {
        var segment = data[i];
        var startX = position;
        $.each(segment.fragments, function (_, fragment) {
            if (fragment.type == 'acceleration' || fragment.type == 'decceleration') {
                if (fragment.type == 'acceleration') {
                    for (var r = 0; r <= steps; r++) {
                        speedData[1].data.push([position + fragment.stopX * r / steps, speedForAccelerationFragment(fragment, r / steps)]);
                        positionData[0].data.push([t + timeForAccelerationFragment(fragment, r / steps), position + fragment.startX + fragment.length * r / steps]);
                    }
                    speedData[3].data.push([position + fragment.stopX, Math.sqrt(fragment.toSpeed)]);
                    positionData[2].data.push([t + fragment.duration, startX + fragment.stopX]);
                }
                if (fragment.type == 'decceleration') {
                    for (r = 0; r <= steps; r++) {
                        speedData[1].data.push([position + fragment.startX + fragment.length * r / steps, speedForDeccelerationFragment(fragment, r / steps)]);
                        positionData[0].data.push([t + timeForDeccelerationFragment(fragment, r / steps), position + fragment.startX + fragment.length * r / steps]);
                    }
                    speedData[4].data.push([position + fragment.startX, Math.sqrt(fragment.fromSpeed)]);
                    positionData[3].data.push([t, startX + fragment.startX]);
                }
            } else
                speedData[1].data.push([position + fragment.stopX, Math.sqrt(fragment.speed)]);
            t += fragment.duration;
        });
        speedData[0].data.push([position, segment.originalSpeed]);
        speedData[5].data.push([position, Math.sqrt(segment.squaredSpeed)]);
        position += segment.length;
        speedData[0].data.push([position, segment.originalSpeed]);
        speedData[5].data.push([position, Math.sqrt(segment.squaredSpeed)]);
        positionData[4].data.push([t, position]);
    }
    var chart1 = $.plot("#chart1", speedData);
    var chart2 = $.plot("#chart2", positionData);
</script>
</body>
</html>