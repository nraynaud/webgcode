{"version":3,"file":"emscripten/Debug/part1.js","sources":["./src/utility/simple_svg_1.0.0.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/string","./src/utility/vd2svg.hpp","./src/common/halfedgediagram.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/algorithm","./src/voronoidiagram.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/foreach.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/vector","hello_tutorial.cc","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/iterator","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/range/end.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/aligned_storage.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/range/begin.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/memory","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/cstddef","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/limits","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/type_traits","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/list","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/tuple/detail/tuple_basic.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/graph/detail/adjacency_list.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/__split_buffer","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/utility","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/__functional_base","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/iterator/iterator_facade.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/iterator/iterator_adaptor.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/graph/detail/edge.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/graph/adjacency_list.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/pending/property.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/var.h","./src/offset.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/sstream","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/ostream","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/iosfwd","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/ios","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/__locale","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/locale","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/utility/addressof.hpp","clipper.cpp","./clipper.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/set","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/__tree","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/functional","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/exception","src/checker.cpp","src/common/halfedgediagram.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/map","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/tools/toms748_solve.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/policies/error_handling.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/special_functions/sign.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/tools/precision.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/cmath","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libc/math.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/format_implementation.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/format_class.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/typeinfo","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/format_fwd.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/policies/policy.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/group.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/iomanip","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/stdexcept","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/throw_exception.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/exception/exception.hpp","src/medial_axis_pocket.cpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/alt_sstream.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/optional/optional.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/parsing.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/internals.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/alt_sstream_impl.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/exceptions.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/__bit_reference","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/format/feed_args.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/utility/base_from_member.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/smart_ptr/shared_ptr.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/smart_ptr/detail/shared_count.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/smart_ptr/detail/sp_counted_base_sync.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/smart_ptr/detail/sp_counted_impl.hpp","src/offset.cpp","src/offset.hpp","src/vertex_positioner.cpp","src/solvers/solver_ppp.hpp","src/solvers/solver_lll.hpp","src/solvers/solver_qll.hpp","src/solvers/solver_sep.hpp","src/solvers/solver_alt_sep.hpp","src/solvers/solver_lll_para.hpp","src/solvers/solution.hpp","src/vertex_positioner.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/math/tools/minima.hpp","src/solvers/solver.hpp","src/site.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/array.hpp","src/common/numeric.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/assert.hpp","src/edge.cpp","src/vertex.cpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/assign/list_of.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/preprocessor/iteration/detail/local.hpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/deque","src/voronoidiagram.cpp","/usr/local/Cellar/emscripten/1.22.1/libexec/system/include/libcxx/queue","src/kdtree.hpp","src/voronoidiagram.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/pending/container_traits.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/graph/named_graph.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/next_prior.hpp","src/graph.hpp","src/vertex.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/smart_ptr/scoped_ptr.hpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/toolchain/mac_pnacl/usr/local/include/boost/checked_delete.hpp","src/common/numeric.cpp","src/common/point.cpp","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/instance.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/rect.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/c/pp_bool.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/instance.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/resource.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/module_impl.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/module.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/view.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/url_loader.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/core.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/ppp_entrypoints.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/resource.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/cpp/module.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/url_loader.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/var.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/include/ppapi/c/pp_var.h","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/view.cc","/Users/nraynaud/dev/nacl_sdk/pepper_35/src/ppapi_cpp/input_event.cc","/Users/nraynaud/dev/pepper.js/examples/ppapi/stub.cc"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDA;AAAA;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;ACqxHA;AAAA;AAAA;AACA;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AA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AAEA;;AAAA;;;;;;;AAAA;;AAGA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;;;AADA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;;AAEA;;;;;;AAHA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;AADA;AAAA;;;;;;;;;;;;AACA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;AAAA;;;;;;AADA;AAAA;;;;;;;AACA;AAAA;;;;AAAA;;;;;;AADA;AAAA;;;;;;;;;;;AAMA;;;;;;;;AACA;;;;;;;AACA;;AAAA;;;;;;;AACA;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;;AADA;AAAA;AACA;;;;;;;;;;;;;;;;;;AAlLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AAwEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAmIA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAOA;AAAA;;AANA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;AC7XA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADgZA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AASA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;;;;;;;;;;;;AA3OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;AAgPA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;AAFA;AAAA;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AACA;AAEA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAaA;AAAA;AAAA;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AAzQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;;AA6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAGA;;;AADA;AACA;;AA/CA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;AACA;AAMA;;;;;;;;;;;;;;;;;;;AAmKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;;;AADA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;;;AApWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAyWA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAAA;;;AAKA;AAGA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;A9BxjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA0xBA;AAAA;AAAA;AAAA;;;;;;;;;AApxBA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;A8B2lGA;;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;;;;AAEA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAOA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAlFA;AAAA;AAAA;;AAqFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvnBA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AASA;AAAA;AAAA;;;;AAGA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;;;AAXA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;AAhBA;AACA;AAAA;AAAA;AAwBA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AA2lBA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAGA;;;;;;;;;AA52DA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AADA;AAAA;AAAA;;AAEA;AAAA;AACA;;;;;;;;;;;;;AE18CA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAlDA;AAAA;AAAA;AAAA;;;;;;;;;AC0MA;AAAA;AAAA;;;;;;;;;;;;;;;AD3HA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AF4mCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;A9B1+BA;;AACA;;;;AACA;;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;A8B6+BA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAAA;AAAA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AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAIA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAAA;AAAA;;AAEA;AAAA;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AANA;AAAA;AAAA;AAAA;;;;;;;;;AASA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;;AAMA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAIA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AACA;;AADA;AAAA;AACA;;;;;;;;;;;;AAhQA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAKA;;;;AAJA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;;AAoBA;;;;;;;;;;AA/RA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;;;;;AACA;AAEA;AAAA;;;AADA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AAAA;AAAA;;AA6CA;;AA1CA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAOA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AjCz1BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAhEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AiCk4BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;AA+DA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AASA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AA8EA;AAAA;AAAA;;AAvEA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAiIA;AAAA;AAAA;;AAhIA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAsHA;AAAA;AAAA;;AAnHA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AA2GA;AAAA;AAAA;;;;;AAxGA;AAAA;;AAsDA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAyCA;AAAA;AAAA;;;AAvCA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AA8BA;AAAA;AAAA;;;AA3BA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAcA;AAAA;AAAA;;AAXA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;;;;;AA1BA;AAAA;AA0BA;AAAA;AAAA;;AAnGA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAkFA;AAAA;AAAA;;AA7EA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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;;;;;;;;;;;;;;;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AMzOA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;;;AAIA;;AACA;;AACA;;;;;;;;AAEA;;;;;;;;;;AAqIA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;;;;;AADA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7GA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AADA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;AAEA;;;;;;;AACA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;;;;AAAA;AAAA;;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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAQA;AAAA;AAAA;;;AAHA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AC+ZA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;AAFA;AAAA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ADtaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AA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;;;;;;;;;;;;AFnWA;AAAA;;AAAA;AAAA;;;;;;;;;;;ADkHA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;ADvJA;AAAA;AAAA;;;;;;;;;;;;;AAyBA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AAzBA;AAAA;;;;;;;;;;;;;AJMA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;AAAA;AAAA;;ADCA;;AAAA;;;;ACCA;;;;ADDA;AAAA;;ACCA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;;A9C+bA;AAAA;;;;;;;;;AAg8DA;AAAA;;;;;;;;;;;AwDr4EA;AAAA;AAAA;;;;;;;;;AC2cA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxGA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AACA;AAAA;AACA;AACA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAEA;AAAA;AACA;A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AA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;A/D27DA;AAAA;AAAA;;;;;;;;;A8DloEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;A9DqtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;A8D7rEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ATTA;AAAA;AAGA;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AQCA;AAAA;AAAA;AAAA;;;;;;;;;AALA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE4EA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAGA;;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAEA;;AAAA;;;;;;AACA;AAAA;;AAoBA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;;;;;;;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;;;;;AACA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAGA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AACA;;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;;;AACA;;;;;;;AACA;;AAAA;;;;;;AACA;;AAAA;;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AACA;;;;;;;;AAGA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;;;;AAAA;;AAEA;AAAA;AAAA;AAAA;;;;;AAAA;;;;;;AAAA;;;;AAEA;;;;;;;;;;;;AApCA;AAAA;;AAoCA;;;;;;AAAA;AAAA;;;;;;;AA7EA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AACA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;;;;;;;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAmEA;;AAAA;;;;;;AAIA;AAAA;;;;;;;;;;;AAjGA;AAAA;;;AAiGA;;;;;;AANA;AAAA;;AAMA;AAAA;;;;;;;;;;ANufA;AAAA;AAAA;;;;;;;;;AArZA;AAAA;;AAAA;;;;;AAAA;;;;;;;;;;;;;;AD/LA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;AAAA;;AADA;;;;;;AAAA;;;;;AAAA;AAAA;;AAAA;AACA;;;;;AADA;AAAA;AACA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AGvCA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAMA;;AALA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAIA;;;;;;;;;;;AI9BA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;AASA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;APtBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AO1CA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAEA;;;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAqBA;;;;;;;;;;;;;;;;AH/CA;AAAA;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;;AAGA;;AAHA;AAAA;AAAA;;AAGA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;ApCkwBA;;AAAA;;;;;;;;AACA;;;;;;AAGA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAGA;;;;;;;AAMA;AAAA;;;;;AApBA;AAAA;;AAcA;;;;;;AAAA;AAAA;;;;;;;;;AAfA;AAAA;;AAeA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AACA;AAEA;AAAA;;;;AAHA;AAAA;;AACA;;;;;;AAJA;AAAA;;AAIA;AAAA;;;;;;;;;;;;;AgC9rBA;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;ADAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ACAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ADAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ASIA;AAAA;;;;;;;;;ACslBA;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AChWA;AAKA;;;;;;;;;AAJA;AAAA;;AAIA;;AAJA;AAAA;AAIA;;;;;;;;;ACzPA;AAAA;AAAA;;AAKA;;AAHA;AAAA;AAAA;AAAA;AACA;AAEA;;;;;;;;AAnFA;AAAA;AAAA;;;;;;;;;AA4FA;AAAA;AAAA;;AAIA;;AAFA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;AjB5EA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;AAoPA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAhQA;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAWA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AA4OA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAxPA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;;;;;;;;;;ACyKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AzBqQA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;AA9CA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;AsC7SA;AAAA;AAAA;AAAA;;;;;;;;;ARIA;AAAA;AAAA;;;;;;;;;ASugBA;AAAA;;;;;;;;;;;;;AA9SA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;AACA;;;;AADA;AAAA;;AACA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;ACpLA;AAAA;AAAA;AAAA;;;;;;;;;;;ADkHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;AAlEA;;;;;;;;;;;;;;AC5EA;;AAQA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAmBA;;;AAlBA;AAAA;;AAGA;;;;;AACA;;;;;;;;;AADA;AAAA;;AAEA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AE5BA;AAAA;AAAA;AAAA;;;;;;;;;;AZjBA;AAAA;;;;;;;;;;;;;AYgBA;;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;ADrDA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;ACkCA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA0BA;AAAA;AAAA;AACA;;;;;;;;;AD9CA;;AACA;;AADA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;ACiDA;AAAA;;AAAA;;;;;AAAA;;;;;;;;;AAKA;AAAA;;;;;;;;;;;ArBlEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AqB8BA;AAAA;;;;;;;;AD9BA;;;;;;;;;AADA;AACA;;;;;;;;;;AADA;;;;AAAA;AACA;;;;AADA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AN9BA;AAAA;;;;;;;;;;;;;AAKA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AALA;AAAA;AAAA;;;;;;;;AASA;;;;;;;;;APiZA;AAAA;AAAA;;;;;;;;;AAlGA;AAAA;AAAA;;;;;;;;;AA0EA;AAAA;AAAA;AACA;;;;;;;;;AA1HA;AACA;;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;ACAA;AAAA;AAAA;AAAA;;;;;;;;;;;ADyHA;AAAA;;;;;;;;ACAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;ADDA;AAAA;AACA;;;;;;;;;;;;AAOA;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAMA;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;ADtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AA/GA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AO9PA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;APyQA;AAAA;AACA;;;;;;;;ACAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AD0GA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;;;;AAAA;;;;AAAA;;;;;;AAAA;AAAA;AACA;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAhHA;AAAA;AAAA;;;;;;;;;;;AADA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;;AAAA;AACA;;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAuHA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AACA;AAAA;AAAA;;;;AAAA;;;;AAAA;;;;;;AAAA;AAAA;AACA;;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;ALoYA;;;;;;;;;;;ADvyBA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;AAAA;AAAA;;;;;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;;;;;;AKqCA;AAAA;AAGA;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AQbA;AAAA;AAAA;AAAA;;;;;;;;;AALA;AAAA;;;;;;;;;;;;AhB2MA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;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;AACA;AAAA;;AAoBA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;;;;;;;AAAA;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;;;;;AACA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAGA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AACA;;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;;;AACA;;;;;;;AACA;;AAAA;;;;;;AACA;;AAAA;;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;;AACA;;;;;;;;AAGA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;AAAA;;;;;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;A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;;;;;;;;;;;;;;;;;;;;;;;;AA2QA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;;AAXA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AADA;AAAA;;;;;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAFA;AAAA;;;;;;AAEA;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAYA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAXA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;;;;;;;AAlBA;AAAA;;;AAAA;;;;;;AAFA;AAAA;;AAAA;AAAA;;;;;;;;;AACA;AAAA;;;AAAA;;;;;;AADA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;AvE48BA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;;AADA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AuEt7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AADA;AAAA;;;;;;AACA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;AAAA;;AAAA;;;;;;AAFA;AAAA;;;;;;;;;AAEA;AAAA;;;AAAA;;;;;;AAFA;AAAA;;AAAA;AAAA;;;;;;;;;AACA;AAAA;;;AAAA;;;;;;AADA;AAAA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;AO5jBA;AAAA;;;;;;;;;A9EmeA;AAAA;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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;A/E4tBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AwE1fA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AAEA;AAAA;AAAA;;;;;AACA;;;;;;;AACA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;AACA;AAAA;AAEA;;AAAA;;;;;;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AACA;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;;;AAEA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;;;;AALA;AAAA;;AAKA;;;;;;AANA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AALA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;;;;;;AAA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;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AACA;AACA;AAAA;AAAA;AAAA;;;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;;;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAFA;AAAA;;;;;;AAEA;;;;;;;;AAAA;;;;;;;AACA;;AAeA;AACA;AAAA;;;;;;AAjBA;AAAA;;;AAAA;;;;;;AAFA;AAAA;;;;;AAMA;AAAA;AAAA;;;AAAA;AAAA;AAAA;;;;;AACA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;;;;AAQA;;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;AAtCA;AAAA;;;AAsCA;;;;;;AAnBA;AAAA;;AAmBA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AWXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AXvDA;AAAA;;;;;;;;;ADqDA;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAEA;;;;;;;;;AACA;;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;;AAEA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;AAAA;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;;;;;;;;;AAAA;;;;;;;;;;;;AACA;;;;;;;;AACA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;;;;AAHA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;AADA;AAAA;;;;;;;;;;AAIA;AAAA;;AAAA;;;;;;AAJA;AAAA;;;;;;;AAMA;;;;;;;;;AAAA;;;;;;;AAAA;;;AACA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;AAAA;;;AAAA;;;;;;AAAA;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;AAAA;;;AAAA;;;;;;AAAA;;;AAAA;;;;;;;;AAAA;;;;;;;;AAGA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;;AACA;;;;;;;;AACA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AA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;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AAFA;AAAA;AAAA;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;AAmCA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;AAtBA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAnCA;AAAA;;;;;;;;;;;;;;;;;;;;;;AA8GA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAiBA;;AAdA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AACA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AASA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;AA3RA;AAAA;;AACA;AA0BA;AAAA;;AAzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;AAsEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AARA;AAAA;;;;;AADA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAaA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAIA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;;;;;;AAAA;;;;;AAAA;;;;AAAA;;AAAA;;;;;;;AAAA;;AACA;;;;;;;;AAAA;;;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A;;;;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;;;;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;AC8mBA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;;;;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;AC1mBA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AD+YA;AAAA;;;;;;;;;AAxGA;AAAA;;;;;;;;;AlDmcA;AAAA;;;;;;;;;;;;;;;;;AiDpuBA;AAAA;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;AAAA;;;;;;;AACA;;;;AADA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AACA;;;;;;AADA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;AAoCA;AAAA;;AAAA;;;;AAAA;AACA;AAAA;AAAA;AACA;;;;AAFA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAlCA;AAAA;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AACA;;;;;;;AADA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AACA;;;;;;AADA;AAAA;;AACA;AAAA;;;;;;;;;;;;;;;;;;;AAqCA;AAAA;AAAA;;AAAA;;;;AAAA;AACA;AACA;;;;AAFA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAnCA;AAAA;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AACA;;;;;;;AADA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;AACA;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A;;;;;;;;AGxkBA;AAAA;;;;;;;;;;AHoEA;;;;;;;;;;;;;;;;;;AO5vCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;AP+6DA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAjLA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AGxkBA;AAAA;;;;;;;;;A6BrwBA;AAAA;;;;;;;;;AkDncA;AAAA;;;;;;;;;AEk1BA;AAAA;;;;;;;;;AAAA;AAAA;;;;;AHAA;AAAA;;;;;;;;;;;;;;;;;;;;AIxnCA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;;AAEA;;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAEA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;;;;;AACA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;;;;;;AACA;AAAA;AACA;;;;;;;;;;AAZA;AAAA;;;AAYA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;ArDuxBA;AAAA;AAAA;;;;;;;;;AsDtbA;AAAA;;;;;;;;;AvD9TA;AAAA;;;;;;;;;ArCyaA;AAAA;;;;;;;;;;;AgC/EA;AAAA;AAAA;;;;;;;;;;;A6DjWA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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A;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;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AA;AAAA;;;AAEA;AAAA;;;AAnBA;AAAA;;AAsBA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAGA;;AAHA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0OA;AAAA;AAAA;;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AACA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;;AACA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAGA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAEA;;;;;;;AA9BA;AAAA;AAAA;;;;;AA4BA;;;;;;AAAA;;;;;;AARA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAWA;AAAA;AAAA;;AACA;AAAA;;;AADA;;;;;;AACA;AAAA;;;;;;;;AA9BA;AAAA;;;;;AAOA;AAAA;;;;;AAWA;;;;;;AAAA;AAAA;;;;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;;AAUA;;;;;;AAVA;AAAA;;;;;;;AAYA;;;;;;AAZA;AAAA;;AAYA;AAAA;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;AAAA;AAGA;AAAA;;;;;;;AAHA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;A5Fn4BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAxFA;AAAA;AAAA;AAAA;;;;;;;;;AATA;AAAA;;;;;;;;;;;;AAqEA;;;;;;;;;;;;;;AA2DA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAwCA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AA6BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;AA6BA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;A4F0wBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;A5FtxBA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;A4F0pCA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAsGA;AAAA;AAAA;;AAKA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAHA;;;AAAA;AAAA;;AAAA;AAAA;;;;;AACA;AAAA;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AADA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAGA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAGA;AAAA;AACA;AAAA;AACA;;;;;;;;;A7E3xDA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6EUA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AACA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;;;;;;;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAIA;AAAA;;;AAAA;;;;;;;AAAA;;;AAMA;;;;;;;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAEA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;;;;;;;AAAA;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAEA;;AAAA;;;;;;;AAIA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AAAA;AAEA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAIA;AAAA;;AAAA;;;;;;;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AAAA;AAAA;;;AAAA;AAAA;AAAA;;AAGA;;;;;;;;AAAA;;;;;;;AAQA;AAAA;;;AAAA;;;;;;;AAAA;;;AACA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAAA;AACA;;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAEA;;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAKA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAGA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAEA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAEA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;AAEA;AAAA;AAAA;;;AAAA;;;;;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;AANA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;AASA;AAAA;AAAA;;;AAAA;;;;;;;;AAGA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAIA;;;;;;;AAEA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;AACA;AAAA;AAAA;;;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;;AAAA;;;;;;;AADA;;;AAAA;AAAA;;AAAA;;AAA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A;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AACA;AAAA;;;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;;AAAA;AAAA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxwBA;AAAA;;AAyHA;;AAtHA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAFA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqXA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;;AAKA;AAAA;AAAA;AACA;AACA;;AAAA;AAAA;AAAA;;;;;AACA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;;AAAA;;;;;;;AAHA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;;AACA;AAAA;;;AADA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;;;;;;;;;AALA;AAAA;;;AAKA;;;;;;AALA;AAAA;;AAKA;AAAA;;;;;;;;;;;;;;;A7EljCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6E26CA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AA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;;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;AAAA;;;AACA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAEA;;AAAA;;;;;;;;AAAA;;;;;;;;AAwIA;AAAA;;;;;;;AAnJA;AAAA;;;AAAA;;;;;;AAjBA;AAAA;;;;;;;;;;AAiBA;AAAA;;;AAAA;;;;;;AAjBA;AAAA;;;;;AAgCA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;;AACA;AACA;AACA;AAGA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAGA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAIA;AAAA;;AAAA;AAAA;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAEA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;AAOA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAAA;;;;;;;;;AAKA;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;AACA;;AAHA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;AACA;;;;;;;AAAA;;;;;;;AAIA;;;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;AAAA;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AACA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;;;AAIA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AAEA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AA6CA;AAAA;;;AAzCA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;AAAA;;;;;;;AAAA;;AACA;AAAA;AAAA;;;AAAA;;;;;;;;AACA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;AAcA;AAAA;;AAEA;AAAA;AAAA;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAGA;AAAA;AAAA;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAGA;AAAA;;;AAnCA;AAAA;AAAA;;;AACA;;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;;AAAA;;;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAxIA;AAAA;;;;;AAwIA;;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AA0BA;AAAA;;;;;;;;;;AAnKA;AAAA;;;AAmKA;;;;;;AApKA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;A3D1HA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AK7VA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;AA5BA;AAAA;;;;;;;;;;;;;;AvB2PA;AAAA;;;;;;;;;;;;;;;;;AuBlFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsD0dA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AADA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;AApBA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;AARA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtDhQA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AALA;AAAA;;;;;;;;;;;;A1B0OA;AAAA;AAAA;AAAA;;;;;;;;;;;AApSA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAyLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AA3iBA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;A0B4VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAFA;AAAA;;;;;;;;;;AuDxFA;AAAA;;;;;;;;;;;AjF6YA;AAAA;AAAA;AAAA;;;;;;;;;;;AApSA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AiFvGA;AAAA;;;;;;;;;;;;;;;AAyMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ADg4CA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;;;AAJA;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAKA;AAAA;AAGA;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAEA;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAHA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;;;;;;;;AAMA;;;AAAA;;;;;;AAAA;;AAGA;AAAA;AAAA;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;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;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAXA;AAAA;;;;;;AAWA;;;;;;;;AAAA;;;;;;;AAIA;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;;;AAQA;;;;;;;AAGA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;;AAAA;AACA;AAAA;AAAA;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AACA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;AAEA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;AACA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;AAA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AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;AADA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAGA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AAPA;AAAA;;AAOA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;AADA;AAAA;;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AtDp6BA;AAAA;AACA;AAAA;;;;AACA;;;;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;;AAEA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;;AACA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;AAAA;AAAA;AAAA;;AAEA;;;;;;;AAAA;;;;;;;AACA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;;AAAA;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;AACA;;AAAA;;;;;;AACA;AAAA;;;;AAxBA;;;;AAAA;;;;;;AADA;;;;AAAA;;;;;;AAAA;AAAA;;AAyBA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;AL6DA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A2D66CA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAAA;;AAAA;;;;;AAAA;;;;;AAAA;;;;;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;;;;AAAA;;;;;;;;;AAAA;;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;AAAA;;;AACA;;;;;;;AAFA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;AAFA;;;AAAA;AAAA;;AAAA;;AAAA;;;;;;;;;;;;;AACA;;;;;;AAAA;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;;;AAAA;;;;;;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;AAAA;;;;;;AAAA;;AACA;AAAA;;AACA;AAAA;;AAAA;;AAAA;AAAA;;;;;AAVA;AAAA;;AAUA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AAqEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAzTA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;;;;;;AAMA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AACA;AACA;AAAA;AAAA;;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;;;;;;AACA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlWA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAUA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;AAAA;;AAAA;;;;AAAA;AAAA;;AACA;;;;;;;AAAA;;;;;;;;AAFA;AAAA;;AAEA;;;;;;AAAA;AAAA;;;;;;;;;AAHA;AAAA;;;AAGA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;;AACA;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AALA;AAAA;;;;;;AAKA;;;;;;AACA;AAAA;;AAAA;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;AAAA;;AAAA;;;;;;AAAA;AAAA;;AACA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;;;;;;AAFA;AAAA;;AAEA;;;;;;AARA;AAAA;;;;;;;;;;;;AAKA;AAAA;;;AAGA;;;;;;AARA;AAAA;;;;;;;;;AAIA;AAAA;;;AAIA;;;;;;AARA;AAAA;;;;;;;;;;;AAGA;AAAA;;;AAKA;;;;;;AARA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AATA;AAAA;;;;;AASA;AAAA;;AAAA;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;AAAA;AAAA;;AAAA;;;;;;AAVA;AAAA;;;;;;;;;AAUA;AAAA;;;AAAA;;;;;;AAVA;AAAA;;AAAA;AAAA;;;;;;;;;AASA;AAAA;;;AAAA;;;;;;AATA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AACA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;;;;;AACA;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;AA5BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;;;AAAA;AAAA;;;AAAA;;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AAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AA/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A;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AuEeA;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;AADA;;;;AAAA;;;;;AADA;AAAA;;AAEA;;;;;;AAAA;AAAA;;;;;;;AAAA;;;;;;AAAA;AAAA;;;;;;;;;;AAdA;AAAA;;;AAcA;;;;;;AAAA;AAAA;;AAAA;AAAA;;;;;;;;;;;AAQA;AAAA;;;;;;;;;;AAAA;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;;AACA;;;;;;;;AAAA;;;;;;AAAA;AAAA;AACA;AAAA;;;AACA;;AAAA;;;;;;;;;AACA;AAAA;;AACA;;AAAA;;;;;;;;;;AAEA;AAAA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;;AAAA;;;;;;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;;;;;;;;AAAA;;;;;;;;;;;;;;;AAAA;AAAA;;;AAAA;;;;;;AAAA;AAAA;;;;;;;AAEA;;;;;;;AAAA;AAAA;;;;;;;AARA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","sourcesContent":["\n// from: http://code.google.com/p/simple-svg/\n\n/*******************************************************************************\n*  The \"New BSD License\" : http://www.opensource.org/licenses/bsd-license.php  *\n********************************************************************************\n\nCopyright (c) 2010, Mark Turney\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the <organization> nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n******************************************************************************/\n\n#ifndef SIMPLE_SVG_HPP\n#define SIMPLE_SVG_HPP\n\n#include <vector>\n#include <string>\n#include <sstream>\n#include <fstream>\n\n#include <iostream>\n\nnamespace svg\n{\n    // Utility XML/String Functions.\n    template <typename T>\n    std::string attribute(std::string const & attribute_name,\n        T const & value, std::string const & unit = \"\")\n    {\n        std::stringstream ss;\n        ss << attribute_name << \"=\\\"\" << value << unit << \"\\\" \";\n        return ss.str();\n    }\n    std::string elemStart(std::string const & element_name)\n    {\n        return \"\\t<\" + element_name + \" \";\n    }\n    std::string elemEnd(std::string const & element_name)\n    {\n        return \"</\" + element_name + \">\\n\";\n    }\n    std::string emptyElemEnd()\n    {\n        return \"/>\\n\";\n    }\n\n    // Quick optional return type.  This allows functions to return an invalid\n    //  value if no good return is possible.  The user checks for validity\n    //  before using the returned value.\n    template <typename T>\n    class optional\n    {\n    public:\n        optional<T>(T const & itype)\n            : valid(true), type(itype) { }\n        optional<T>() : valid(false), type(T()) { }\n        T * operator->()\n        {\n            // If we try to access an invalid value, an exception is thrown.\n            if (!valid)\n                throw std::exception();\n\n            return &type;\n        }\n        // Test for validity.\n        bool operator!() const { return !valid; }\n    private:\n        bool valid;\n        T type;\n    };\n\n    struct Dimensions\n    {\n        Dimensions(double iwidth, double iheight) : width(iwidth), height(iheight) { }\n        Dimensions(double icombined = 0) : width(icombined), height(icombined) { }\n        double width;\n        double height;\n    };\n\n    struct Point\n    {\n        Point(double ix = 0, double iy = 0) : x(ix), y(iy) { }\n        double x;\n        double y;\n    };\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    optional<Point> getMinPoint(std::vector<Point> const & points)\n    {\n        if (points.empty())\n            return optional<Point>();\n\n        Point min = points[0];\n        for (unsigned i = 0; i < points.size(); ++i) {\n            if (points[i].x < min.x)\n                min.x = points[i].x;\n            if (points[i].y < min.y)\n                min.y = points[i].y;\n        }\n        return optional<Point>(min);\n    }*/\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    optional<Point> getMaxPoint(std::vector<Point> const & points)\n    {\n        if (points.empty())\n            return optional<Point>();\n\n        Point max = points[0];\n        for (unsigned i = 0; i < points.size(); ++i) {\n            if (points[i].x > max.x)\n                max.x = points[i].x;\n            if (points[i].y > max.y)\n                max.y = points[i].y;\n        }\n        return optional<Point>(max);\n    }\n    */\n\n    // Defines the dimensions, scale, origin, and origin offset of the document.\n    struct Layout\n    {\n        enum Origin { TopLeft, BottomLeft, TopRight, BottomRight };\n\n        Layout(Dimensions const & idimensions = Dimensions(400, 300), Origin iorigin = BottomLeft,\n            double iscale = 1, Point const & iorigin_offset = Point(0, 0))\n            : dimensions(idimensions), scale(iscale), origin(iorigin), origin_offset(iorigin_offset) { }\n        Dimensions dimensions;\n        double scale;\n        Origin origin;\n        Point origin_offset;\n    };\n\n    // Convert coordinates in user space to SVG native space.\n    double translateX(double x, Layout const & layout)\n    {\n        if (layout.origin == Layout::BottomRight || layout.origin == Layout::TopRight)\n            return layout.dimensions.width - ((x + layout.origin_offset.x) * layout.scale);\n        else\n            return (layout.origin_offset.x + x) * layout.scale;\n    }\n\n    double translateY(double y, Layout const & layout)\n    {\n        if (layout.origin == Layout::BottomLeft || layout.origin == Layout::BottomRight)\n            return layout.dimensions.height - ((y + layout.origin_offset.y) * layout.scale);\n        else\n            return (layout.origin_offset.y + y) * layout.scale;\n    }\n    double translateScale(double dimension, Layout const & layout)\n    {\n        return dimension * layout.scale;\n    }\n\n    class Serializeable\n    {\n    public:\n        Serializeable() { }\n        virtual ~Serializeable() { }\n        virtual std::string toString(Layout const & layout) const = 0;\n    };\n\n    class Color : public Serializeable\n    {\n    public:\n        enum Defaults { Transparent = -1, Aqua, Black, Blue, Brown, Cyan, Fuchsia,\n            Green, Lime, Magenta, Orange, Purple, Red, Silver, White, Yellow };\n\n        Color(int r, int g, int b) : transparent(false), red(r), green(g), blue(b) { }\n        Color(Defaults color)\n            : transparent(false), red(0), green(0), blue(0)\n        {\n            switch (color)\n            {\n                case Aqua: assign(0, 255, 255); break;\n                case Black: assign(0, 0, 0); break;\n                case Blue: assign(0, 0, 255); break;\n                case Brown: assign(165, 42, 42); break;\n                case Cyan: assign(0, 255, 255); break;\n                case Fuchsia: assign(255, 0, 255); break;\n                case Green: assign(0, 128, 0); break;\n                case Lime: assign(0, 255, 0); break;\n                case Magenta: assign(255, 0, 255); break;\n                case Orange: assign(255, 165, 0); break;\n                case Purple: assign(128, 0, 128); break;\n                case Red: assign(255, 0, 0); break;\n                case Silver: assign(192, 192, 192); break;\n                case White: assign(255, 255, 255); break;\n                case Yellow: assign(255, 255, 0); break;\n                default: transparent = true; break;\n            }\n        }\n        virtual ~Color() { }\n        std::string toString(Layout const &) const\n        {\n            std::stringstream ss;\n            if (transparent)\n                ss << \"transparent\";\n            else\n                ss << \"rgb(\" << red << \",\" << green << \",\" << blue << \")\";\n            return ss.str();\n        }\n    private:\n            bool transparent;\n            int red;\n            int green;\n            int blue;\n\n            void assign(int r, int g, int b)\n            {\n                red = r;\n                green = g;\n                blue = b;\n            }\n    };\n\n    class Fill : public Serializeable\n    {\n    public:\n        Fill(Color::Defaults icolor) : color(icolor) { }\n        Fill(Color icolor = Color::Transparent)\n            : color(icolor) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << attribute(\"fill\", color.toString(layout));\n            return ss.str();\n        }\n    private:\n        Color color;\n    };\n\n    class Stroke : public Serializeable\n    {\n    public:\n        Stroke(double iwidth = -1, Color icolor = Color::Transparent)\n            : width(iwidth), color(icolor) { }\n        std::string toString(Layout const & layout) const\n        {\n            // If stroke width is invalid.\n            if (width < 0)\n                return std::string();\n\n            std::stringstream ss;\n            ss << attribute(\"stroke-width\", translateScale(width, layout)) << attribute(\"stroke\", color.toString(layout));\n            return ss.str();\n        }\n    private:\n        double width;\n        Color color;\n    };\n\n    class Font : public Serializeable\n    {\n    public:\n        Font(double isize = 12, std::string const & ifamily = \"Verdana\") : size(isize), family(ifamily) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << attribute(\"font-size\", translateScale(size, layout)) << attribute(\"font-family\", family);\n            return ss.str();\n        }\n    private:\n        double size;\n        std::string family;\n    };\n\n    class Shape : public Serializeable\n    {\n    public:\n        Shape(Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : fill(ifill), stroke(istroke) { }\n        virtual ~Shape() { }\n        virtual std::string toString(Layout const & layout) const = 0;\n        virtual void offset(Point const & offset) = 0;\n    protected:\n        Fill fill;\n        Stroke stroke;\n    };\n    template <typename T>\n    std::string vectorToString(std::vector<T> collection, Layout const & layout)\n    {\n        std::string combination_str;\n        for (unsigned i = 0; i < collection.size(); ++i)\n            combination_str += collection[i].toString(layout);\n\n        return combination_str;\n    }\n    \n    \n    class Circle : public Shape\n    {\n    public:\n        Circle(Point const & icenter, double idiameter, Fill const & ifill,\n            Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke), center(icenter), radius(idiameter / 2) { }\n        \n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"circle\") << attribute(\"cx\", translateX(center.x, layout))\n                << attribute(\"cy\", translateY(center.y, layout))\n                << attribute(\"r\", translateScale(radius, layout)) << fill.toString(layout)\n                << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            center.x += ioffset.x;\n            center.y += ioffset.y;\n        }\n    private:\n        Point center;\n        double radius;\n    };\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class Elipse : public Shape\n    {\n    public:\n        Elipse(Point const & icenter, double iwidth, double iheight,\n            Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke), center(icenter), radius_width(iwidth / 2),\n            radius_height(iheight / 2) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"ellipse\") << attribute(\"cx\", translateX(center.x, layout))\n                << attribute(\"cy\", translateY(center.y, layout))\n                << attribute(\"rx\", translateScale(radius_width, layout))\n                << attribute(\"ry\", translateScale(radius_height, layout))\n                << fill.toString(layout) << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            center.x += ioffset.x;\n            center.y += ioffset.y;\n        }\n    private:\n        Point center;\n        double radius_width;\n        double radius_height;\n    };\n    */\n    \n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class Rectangle : public Shape\n    {\n    public:\n        Rectangle(Point const & iedge, double iwidth, double iheight,\n            Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke), edge(iedge), width(iwidth),\n            height(iheight) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"rect\") << attribute(\"x\", translateX(edge.x, layout))\n                << attribute(\"y\", translateY(edge.y, layout))\n                << attribute(\"width\", translateScale(width, layout))\n                << attribute(\"height\", translateScale(height, layout))\n                << fill.toString(layout) << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            edge.x += ioffset.x;\n            edge.y += ioffset.y;\n        }\n    private:\n        Point edge;\n        double width;\n        double height;\n    };\n    */\n    \n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class Line : public Shape\n    {\n    public:\n        Line(Point const & istart_point, Point const & iend_point,\n            Stroke const & istroke = Stroke())\n            : Shape(Fill(), istroke), start_point(istart_point),\n            end_point(iend_point) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"line\") << attribute(\"x1\", translateX(start_point.x, layout))\n                << attribute(\"y1\", translateY(start_point.y, layout))\n                << attribute(\"x2\", translateX(end_point.x, layout))\n                << attribute(\"y2\", translateY(end_point.y, layout))\n                << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            start_point.x += ioffset.x;\n            start_point.y += ioffset.y;\n\n            end_point.x += ioffset.x;\n            end_point.y += ioffset.y;\n        }\n    private:\n        Point start_point;\n        Point end_point;\n    };\n    */\n    \n    class EllipticalArc : public Shape\n    {\n    public:\n        EllipticalArc(Point const & istart_point, double ix_radius, double iy_radius,\n            double ix_axis_rotation, bool ilarge_arc_flag, bool isweep_flag,\n            Point const & iend_point, Stroke const & istroke = Stroke())\n            : Shape(Fill(), istroke), start_point(istart_point),\n            x_radius(ix_radius), y_radius(iy_radius), x_axis_rotation(ix_axis_rotation),\n            large_arc_flag((ilarge_arc_flag)?(1):(0)), sweep_flag((isweep_flag)?(1):(0)),\n            end_point(iend_point) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"path\");\n            ss << \"d=\\\"M\";\n            ss << translateX(start_point.x, layout) << \",\" << translateY(start_point.y, layout) << \" \";\n            ss << \"A\" << x_radius << \",\" << y_radius << \" \";\n            ss << x_axis_rotation << \" \";\n            ss << large_arc_flag << \",\" << sweep_flag << \" \";\n            ss << translateX(end_point.x, layout) << \",\" << translateY(end_point.y, layout) << \"\\\" \";\n            ss << fill.toString(layout) << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            start_point.x += ioffset.x;\n            start_point.y += ioffset.y;\n\n            end_point.x += ioffset.x;\n            end_point.y += ioffset.y;\n        }\n    private:\n        Point start_point;\n        double x_radius, y_radius, x_axis_rotation;\n        int large_arc_flag, sweep_flag;\n        Point end_point;\n    };\n\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class Polygon : public Shape\n    {\n    public:\n        Polygon(Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke) { }\n        Polygon(Stroke const & istroke = Stroke()) : Shape(Color::Transparent, istroke) { }\n        Polygon & operator<<(Point const & point)\n        {\n            points.push_back(point);\n            return *this;\n        }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"polygon\");\n\n            ss << \"points=\\\"\";\n            for (unsigned i = 0; i < points.size(); ++i)\n                ss << translateX(points[i].x, layout) << \",\" << translateY(points[i].y, layout) << \" \";\n            ss << \"\\\" \";\n\n            ss << fill.toString(layout) << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            for (unsigned i = 0; i < points.size(); ++i) {\n                points[i].x += ioffset.x;\n                points[i].y += ioffset.y;\n            }\n        }\n    private:\n        std::vector<Point> points;\n    };\n    */\n    \n    class Polyline : public Shape\n    {\n    public:\n        Polyline(Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke) { }\n        Polyline(Stroke const & istroke = Stroke()) : Shape(Color::Transparent, istroke) { }\n        Polyline(std::vector<Point> const & ipoints,\n            Fill const & ifill = Fill(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke), points(ipoints) { }\n        Polyline & operator<<(Point const & point)\n        {\n            points.push_back(point);\n            return *this;\n        }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"polyline\");\n\n            ss << \"points=\\\"\";\n            for (unsigned i = 0; i < points.size(); ++i)\n                ss << translateX(points[i].x, layout) << \",\" << translateY(points[i].y, layout) << \" \";\n            ss << \"\\\" \";\n\n            ss << fill.toString(layout) << stroke.toString(layout) << emptyElemEnd();\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            for (unsigned i = 0; i < points.size(); ++i) {\n                points[i].x += ioffset.x;\n                points[i].y += ioffset.y;\n            }\n        }\n        std::vector<Point> points;\n    };\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class Text : public Shape\n    {\n    public:\n        Text(Point const & iorigin, std::string const & icontent, Fill const & ifill = Fill(),\n             Font const & ifont = Font(), Stroke const & istroke = Stroke())\n            : Shape(ifill, istroke), origin(iorigin), content(icontent), font(ifont) { }\n        std::string toString(Layout const & layout) const\n        {\n            std::stringstream ss;\n            ss << elemStart(\"text\") << attribute(\"x\", translateX(origin.x, layout))\n                << attribute(\"y\", translateY(origin.y, layout))\n                << fill.toString(layout) << stroke.toString(layout) << font.toString(layout)\n                << \">\" << content << elemEnd(\"text\");\n            return ss.str();\n        }\n        void offset(Point const & ioffset)\n        {\n            origin.x += ioffset.x;\n            origin.y += ioffset.y;\n        }\n    private:\n        Point origin;\n        std::string content;\n        Font font;\n    };\n    */\n    \n    \n    // Sample charting class.\n    // AW 2012-03-20: code-coverage shows no use for this. comment out.\n    /*\n    class LineChart : public Shape\n    {\n    public:\n        LineChart(Dimensions imargin = Dimensions(), double iscale = 1,\n                  Stroke const & iaxis_stroke = Stroke(.5, Color::Purple))\n            : axis_stroke(iaxis_stroke), margin(imargin), scale(iscale) { }\n        LineChart & operator<<(Polyline const & polyline)\n        {\n            if (polyline.points.empty())\n                return *this;\n\n            polylines.push_back(polyline);\n            return *this;\n        }\n        std::string toString(Layout const & layout) const\n        {\n            if (polylines.empty())\n                return \"\";\n\n            std::string ret;\n            for (unsigned i = 0; i < polylines.size(); ++i)\n                ret += polylineToString(polylines[i], layout);\n\n            return ret + axisString(layout);\n        }\n        void offset(Point const & ioffset)\n        {\n            for (unsigned i = 0; i < polylines.size(); ++i)\n                polylines[i].offset(ioffset);\n        }\n    private:\n        Stroke axis_stroke;\n        Dimensions margin;\n        double scale;\n        std::vector<Polyline> polylines;\n\n        optional<Dimensions> getDimensions() const\n        {\n            if (polylines.empty())\n                return optional<Dimensions>();\n\n            optional<Point> min = getMinPoint(polylines[0].points);\n            optional<Point> max = getMaxPoint(polylines[0].points);\n            for (unsigned i = 0; i < polylines.size(); ++i) {\n                if (getMinPoint(polylines[i].points)->x < min->x)\n                    min->x = getMinPoint(polylines[i].points)->x;\n                if (getMinPoint(polylines[i].points)->y < min->y)\n                    min->y = getMinPoint(polylines[i].points)->y;\n                if (getMaxPoint(polylines[i].points)->x > max->x)\n                    max->x = getMaxPoint(polylines[i].points)->x;\n                if (getMaxPoint(polylines[i].points)->y > max->y)\n                    max->y = getMaxPoint(polylines[i].points)->y;\n            }\n\n            return optional<Dimensions>(Dimensions(max->x - min->x, max->y - min->y));\n        }\n        std::string axisString(Layout const & layout) const\n        {\n            optional<Dimensions> dimensions = getDimensions();\n            if (!dimensions)\n                return \"\";\n\n            // Make the axis 10% wider and higher than the data points.\n            double width = dimensions->width * 1.1;\n            double height = dimensions->height * 1.1;\n\n            // Draw the axis.\n            Polyline axis(Color::Transparent, axis_stroke);\n            axis << Point(margin.width, margin.height + height) << Point(margin.width, margin.height)\n                << Point(margin.width + width, margin.height);\n\n            return axis.toString(layout);\n        }\n        std::string polylineToString(Polyline const & polyline, Layout const & layout) const\n        {\n            Polyline shifted_polyline = polyline;\n            shifted_polyline.offset(Point(margin.width, margin.height));\n\n            std::vector<Circle> vertices;\n            for (unsigned i = 0; i < shifted_polyline.points.size(); ++i)\n                vertices.push_back(Circle(shifted_polyline.points[i], getDimensions()->height / 30.0, Color::Black));\n\n            return shifted_polyline.toString(layout) + vectorToString(vertices, layout);\n        }\n    };\n    */\n\n    class Document\n    {\n    public:\n        Document(std::string const & ifile_name, Layout ilayout = Layout())\n            : file_name(ifile_name), layout(ilayout) { }\n\n        Document & operator<<(Shape const & shape)\n        {\n            body_nodes_str += shape.toString(layout);\n            return *this;\n        }\n        std::string toString() const\n        {\n            std::stringstream ss;\n            ss << \"<?xml \" << attribute(\"version\", \"1.0\") << attribute(\"standalone\", \"no\")\n                << \"?>\\n<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\" \"\n                << \"\\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\\n<svg \"\n                << attribute(\"width\", layout.dimensions.width, \"px\")\n                << attribute(\"height\", layout.dimensions.height, \"px\")\n                << attribute(\"xmlns\", \"http://www.w3.org/2000/svg\")\n                << attribute(\"version\", \"1.1\") << \">\\n\" << body_nodes_str << elemEnd(\"svg\");\n            return ss.str();\n        }\n        bool save() const\n        {\n            std::ofstream ofs(file_name.c_str());\n            if (!ofs.good())\n                return false;\n\n            ofs << toString();\n            ofs.close();\n            return true;\n        }\n    private:\n        std::string file_name;\n        Layout layout;\n\n        std::string body_nodes_str;\n    };\n}\n\n#endif\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n);\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n);\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n);\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2) const;\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s) {return strlen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    _LIBCPP_INLINE_VISIBILITY\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    _LIBCPP_INLINE_VISIBILITY\n    static _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__a == __str.__alloc() || !__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign recieved nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign recieved nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append recieved nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append recieved nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert recieved nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace recieved nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz || __sz - __pos < __n)\n        return npos;\n    if (__n == 0)\n        return __pos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::search(__p + __pos, __p + __sz, __s, __s + __n,\n                                     __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return find(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): recieved nullptr\");\n    return find(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos >= __sz)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = traits_type::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): recieved nullptr\");\n    size_type __sz = size();\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_end(__p, __p + __pos, __s, __s + __n,\n                                       __traits_eq<traits_type>());\n    if (__n > 0 && __r == __p + __pos)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return rfind(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): recieved nullptr\");\n    return rfind(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__sz)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            if (traits_type::eq(*--__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos >= __sz || __n == 0)\n        return npos;\n    const value_type* __p = data();\n    const value_type* __r = _VSTD::find_first_of(__p + __pos, __p + __sz, __s,\n                                            __s + __n, __traits_eq<traits_type>());\n    if (__r == __p + __sz)\n        return npos;\n    return static_cast<size_type>(__r - __p);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find_first_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): recieved nullptr\");\n    return find_first_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): recieved nullptr\");\n    if (__n != 0)\n    {\n        size_type __sz = size();\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        const value_type* __p = data();\n        for (const value_type* __ps = __p + __pos; __ps != __p;)\n        {\n            const value_type* __r = traits_type::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<size_type>(__ps - __p);\n        }\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return find_last_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): recieved nullptr\");\n    return find_last_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (traits_type::find(__s, __n, *__ps) == 0)\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return find_first_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): recieved nullptr\");\n    return find_first_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n    {\n        const value_type* __p = data();\n        const value_type* __pe = __p + __sz;\n        for (const value_type* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!traits_type::eq(*__ps, __c))\n                return static_cast<size_type>(__ps - __p);\n    }\n    return npos;\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (traits_type::find(__s, __n, *--__ps) == 0)\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return find_last_not_of(__str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): recieved nullptr\");\n    return find_last_not_of(__s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    size_type __sz = size();\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    const value_type* __p = data();\n    for (const value_type* __ps = __p + __pos; __ps != __p;)\n        if (!traits_type::eq(*--__ps, __c))\n            return static_cast<size_type>(__ps - __p);\n    return npos;\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): recieved nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): recieved nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): recieved nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","/*  \n *  Copyright 2010-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <string>\n#include <iostream>\n\n#include \"../voronoidiagram.hpp\"\n#include \"../common/point.hpp\"\n\n#include <boost/foreach.hpp>\n\n#include \"simple_svg_1.0.0.hpp\"\n\n#include <cmath>\n\n#define PI 3.1415926535897932384626433832795\n#define CIRCLE_FUZZ 1.e-9\n\novd::Point scale(ovd::Point p) {\n    double s = 500;\n    return s*p+s*ovd::Point(1,1);\n}\n\ndouble scale(double d) {\n    double s = 500;\n    return s*d;\n}\n\nsvg::Color get_edge_color(ovd::HEGraph& g, ovd::HEEdge e) {\n    if ( g[e].type == ovd::LINESITE )\n        return svg::Color::Yellow;\n    if ( g[e].type == ovd::PARABOLA )\n        return svg::Color::Cyan;\n    if ( g[e].type == ovd::SEPARATOR )\n        return svg::Color::Magenta;\n    return svg::Color::Blue;\n}\n\nvoid write_line_to_svg(ovd::HEGraph& g, svg::Document& doc, ovd::Point src, ovd::Point trg, svg::Color col) {\n    ovd::Point src_p = scale( src );\n    ovd::Point trg_p = scale( trg );\n    \n    svg::Polyline polyline( svg::Stroke(1, col) );\n    polyline << svg::Point( src_p.x, src_p.y ) << svg::Point( trg_p.x, trg_p.y );\n    doc << polyline;\n}\n\nvoid write_arc_to_svg(ovd::HEGraph& g, svg::Document& doc, ovd::Point src, ovd::Point trg, double r, ovd::Point ctr, bool cw, svg::Color col) {\n    ovd::Point src_p = scale( src );\n    ovd::Point trg_p = scale( trg );\n    double radius = scale( r );\n    ovd::Point ctr_p = scale( ctr );\n\n    // determine angle theta\n    ovd::Point start( src - ctr );\n    ovd::Point end( trg - ctr );\n    double theta1 = atan2( start.x, start.y );\n    double theta2 = atan2( end.x, end.y );\n    if ( !cw ) {\n        while( (theta2 - theta1) > -CIRCLE_FUZZ )\n            theta2 -= 2*PI;\n    } else {\n        while( (theta2 - theta1) < CIRCLE_FUZZ )\n            theta2 += 2*PI;\n    }\n    double theta = theta2-theta1;\n\n    double x_radius(radius), y_radius(radius), x_axis_rotation(0.);\n    bool large_arc_flag( PI <= theta );\n    bool sweep_flag( cw );\n    svg::EllipticalArc arc(\n        svg::Point( src_p.x, src_p.y ),\n        x_radius, y_radius, x_axis_rotation,\n        large_arc_flag, sweep_flag,\n        svg::Point( trg_p.x, trg_p.y ),\n        svg::Stroke(1, col)\n    );\n    doc << arc;\n}\n\nvoid write_edge_to_svg(ovd::HEGraph& g, svg::Document& doc, ovd::HEEdge e) {\n    ovd::HEVertex src = g.source(e);\n    ovd::HEVertex trg = g.target(e);\n    ovd::Point src_p = scale( g[src].position );\n    ovd::Point trg_p = scale( g[trg].position );\n    \n    svg::Color col = get_edge_color(g,e);\n    svg::Polyline polyline( svg::Stroke(1, col) );\n    if ( (g[e].type == ovd::SEPARATOR) || (g[e].type == ovd::LINE) || \n                     (g[e].type == ovd::LINESITE) || (g[e].type == ovd::OUTEDGE) || \n                     (g[e].type == ovd::LINELINE)  || (g[e].type == ovd::PARA_LINELINE)\n        ) {\n        // edge drawn as two points\n        polyline << svg::Point( src_p.x, src_p.y) << svg::Point( trg_p.x, trg_p.y );\n    } else if ( g[e].type == ovd::PARABOLA ) { \n        double t_src = g[src].dist();\n        double t_trg = g[trg].dist();\n        double t_min = std::min(t_src,t_trg);\n        double t_max = std::max(t_src,t_trg);\n        int nmax=40;\n        for (int n=0;n<nmax;n++) {\n            double t = t_min + ((t_max-t_min)/((nmax-1)*(nmax-1)))*n*n;\n            ovd::Point pt = scale( g[e].point(t) );\n            polyline <<  svg::Point(pt.x, pt.y) ;\n        }\n    }\n    doc << polyline;\n}\n\nvoid write_pointsite_to_svg(ovd::HEGraph& g, svg::Document& doc, ovd::HEVertex v) {\n    if ( g[v].type == ovd::POINTSITE ) {\n        ovd::Point p = scale( g[v].position );\n        doc << svg::Circle( svg::Point(p.x, p.y), 0.1, \n                              svg::Fill( svg::Color(100, 200, 120)), svg::Stroke(0.01, svg::Color(200, 250, 150) ) \n                            );\n    }\n}\n\nvoid vd2svg(std::string filename, ovd::VoronoiDiagram* vd) {\n    svg::Dimensions dimensions(1024, 1024);\n    svg::Document doc(filename, svg::Layout(dimensions, svg::Layout::BottomLeft));\n    \n    ovd::HEGraph& g = vd->get_graph_reference();\n    BOOST_FOREACH( ovd::HEEdge e, g.edges() ) {\n        write_edge_to_svg(g,doc,e);\n    }\n    BOOST_FOREACH( ovd::HEVertex v, g.vertices() ) {\n        write_pointsite_to_svg(g,doc,v);\n    }\n    doc.save();\n}\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <vector>\n#include <list>\n\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/foreach.hpp> \n#include <boost/iterator/iterator_facade.hpp>\n#include <boost/assign/list_of.hpp>\n\n// bundled BGL properties, see: http://www.boost.org/doc/libs/1_44_0/libs/graph/doc/bundles.html\n\n// dcel notes from http://www.holmes3d.net/graphics/dcel/\n\n// vertex (boost::out_edges)\n//  -leaving pointer to HalfEdge that has this vertex as origin\n//   if many HalfEdges have this vertex as origin, choose one arbitrarily\n\n// HalfEdge\n//  - origin pointer to vertex (boost::source)\n//  - face to the left of halfedge\n//  - twin pointer to HalfEdge (on the right of this edge)\n//  - next pointer to HalfEdge\n//     this edge starts from h->twin->origin and ends at next vertex in h->face\n//     traveling ccw around boundary\n//     (allows face traverse, follow h->next until we arrive back at h)\n\n// Face\n//  - edge pointer to HalfEdge\n//    this edge has this Face object as face\n//    half-edge can be any one on the boundary of face\n// special \"infinite face\", face on \"outside\" of boundary\n// may or may not store edge pointer\n\n\n\n\n\nnamespace hedi  { \n/*! \n * \\namespace hedi\n * \\brief Half-edge diagram\n */\n\n/// \\brief half-edge diagram, based on the boost graph-library\n///\n/// half_edge_diagram is a half-edge diagram class.\n/// Templated on Vertex/Edge/Face property classes which allow\n/// attaching information to vertices/edges/faces that is \n/// required for a particular algorithm.\n/// \n/// Inherits from boost::adjacency_list\n/// minor additions allow storing face-properties.\n///\n/// the hedi namespace contains functions for manipulating HEDIGraphs\n///\n/// For a general description of the half-edge data structure see e.g.:\n///  - http://www.holmes3d.net/graphics/dcel/\n///  - http://openmesh.org/index.php?id=228\ntemplate <class TOutEdgeList, \n          class TVertexList,\n          class TDirected, \n          class TVertexProperties,\n          class TEdgeProperties,\n          class TFaceProperties,\n          class TGraphProperties,\n          class TEdgeList \n          >\nclass half_edge_diagram {\npublic:\n    /// type of face descriptor\n    typedef unsigned int Face; \n    /// underlying boost graph type\n    typedef typename boost::adjacency_list< TOutEdgeList,            \n                                            TVertexList,            \n                                            TDirected,   \n                                            TVertexProperties,             \n                                            TEdgeProperties,                \n                                            TGraphProperties,\n                                            TEdgeList\n                                            > BGLGraph;\n    /// edge descriptor\n    typedef typename boost::graph_traits< BGLGraph >::edge_descriptor   Edge;\n    /// vertex descriptor\n    typedef typename boost::graph_traits< BGLGraph >::vertex_descriptor Vertex;\n    /// vertex iterator type\n    typedef typename boost::graph_traits< BGLGraph >::vertex_iterator   VertexItr;\n    /// out edge iterator type\n    typedef typename boost::graph_traits< BGLGraph >::out_edge_iterator OutEdgeItr;\n    /// edge iterator type\n    typedef typename boost::graph_traits< BGLGraph >::edge_iterator     EdgeItr; \n\n    /// vertex descriptor\n    typedef typename boost::graph_traits< BGLGraph >::vertex_descriptor      vertex_descriptor;\n    /// edge descriptor\n    typedef typename boost::graph_traits< BGLGraph >::edge_descriptor        edge_descriptor;\n    /// edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::edge_iterator          edge_iterator;\n    /// out edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::out_edge_iterator      out_edge_iterator;\n    /// in edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::in_edge_iterator       in_edge_iterator;\n    /// vertex iterator\n    typedef typename boost::graph_traits< BGLGraph >::vertex_iterator        vertex_iterator;\n    /// directed or underected graph\n    typedef typename boost::graph_traits< BGLGraph >::directed_category      directed_category;\n    /// allow or disallow parallel edges\n    typedef typename boost::graph_traits< BGLGraph >::edge_parallel_category edge_parallel_category;\n    /// ?\n    typedef typename boost::graph_traits< BGLGraph >::traversal_category     traversal_category;\n    /// vertex size type\n    typedef typename boost::graph_traits< BGLGraph >::vertices_size_type     vertices_size_type;\n    /// edge size type\n    typedef typename boost::graph_traits< BGLGraph >::edges_size_type        edges_size_type;\n    /// degree size type\n    typedef typename boost::graph_traits< BGLGraph >::degree_size_type       degree_size_type;\n    /// adjacency iterator\n    typedef typename boost::graph_traits< BGLGraph >::adjacency_iterator     adjacency_iterator;\n\n    /// vector of vertices\n    typedef std::vector<Vertex> VertexVector;\n    /// vector of faces\n    typedef std::vector<Face>   FaceVector;\n    /// vector of edges\n    typedef std::vector<Edge>   EdgeVector;  \n    \n    /// access to Face properties\n    inline TFaceProperties& operator[](Face f) { return faces[f]; }\n    /// const access to Face properties\n    inline const TFaceProperties& operator[](Face f) const { return faces[f]; } \n    /// access to Edge properties\n    inline TEdgeProperties& operator[](Edge e) { return g[e]; }\n    /// const access to Edge properties\n    inline const TEdgeProperties& operator[](Edge e) const { return g[e]; }\n    /// access to Vertex properties\n    inline TVertexProperties& operator[](Vertex v)  { return g[v]; }\n    /// const access to Vertex properties\n    inline const TVertexProperties& operator[](Vertex v) const  { return g[v]; }\n\n//DATA\n    /// container for face properties\n    std::vector< TFaceProperties > faces; // this could maybe be held as a GraphProperty of the BGL-graph?\n    /// underlying BGL graph\n    BGLGraph g;\n    \n// NOTE: there is no HEDIGraph constructor, we use the default one..\n\n/// dtor\nvirtual ~half_edge_diagram(){\n    // sites are associated with faces. go through all faces and delete the site\n    //std::cout << \"~half_edge_diagram()...\";\n    /*\n    BOOST_FOREACH( TFaceProperties fprop, faces ) {\n        if (fprop.site)\n            delete fprop.site;\n    }\n    g.clear();\n    */\n    //std::cout << \"DONE.\";\n}\n\n// One-liner wrappers around boost-graph-library functions:\n\n/// return an invalid face_descriptor\nFace HFace() { return std::numeric_limits<Face>::quiet_NaN(); }\n/// add a blank vertex and return its descriptor\nVertex add_vertex() { return boost::add_vertex( g ); }\n/// add a vertex with given properties, return vertex descriptor\nVertex add_vertex(const TVertexProperties& prop) { return boost::add_vertex( prop, g ); }\n/// return the target vertex of the given edge\nVertex target(const Edge e ) const { return boost::target( e, g ); }\n/// return the source vertex of the given edge\nVertex source(const Edge e ) const { return boost::source( e, g ); }\n/// return degree of given vertex\nunsigned int degree( Vertex v)  { return boost::degree( v, g); }\n/// return number of faces in graph\nunsigned int num_faces() const { return faces.size(); }\n/// return number of vertices in graph\nunsigned int num_vertices() const { return boost::num_vertices( g ); }\n/// return number of edges in graph\nunsigned int num_edges() const { return boost::num_edges( g ); }\n/// return number of edges on Face f\nunsigned int num_edges(Face f) { return face_edges(f).size(); }\n/// add an edge between vertices v1-v2\nEdge add_edge(Vertex v1, Vertex v2) { return boost::add_edge( v1, v2, g).first; }\n/// add an edge with given properties between vertices v1-v2\nEdge add_edge( Vertex v1, Vertex  v2, const TEdgeProperties& prop ) { return boost::add_edge( v1, v2, prop, g).first; }\n/// return begin/edge iterators for out-edges of Vertex \\a v\nstd::pair<OutEdgeItr, OutEdgeItr> out_edge_itr( Vertex v ) { return boost::out_edges( v, g ); } // FIXME: change name to out_edges!!\n/// return true if v1-v2 edge exists\ninline bool has_edge( Vertex v1, Vertex v2) { return boost::edge( v1, v2, g ).second; }\n/// return v1-v2 Edge\nEdge edge( Vertex v1, Vertex v2) { assert(has_edge(v1,v2)); return boost::edge( v1, v2, g ).first; }\n/// clear given vertex. this removes all edges connecting to the vertex.\nvoid clear_vertex( Vertex v ) { boost::clear_vertex( v, g ); }\n/// remove given vertex. call clear_vertex() before this!\nvoid remove_vertex( Vertex v ) { boost::remove_vertex( v , g ); }\n/// remove given edge\nvoid remove_edge( Edge e ) { boost::remove_edge( e , g ); }\n/// delete a vertex. clear and remove.\nvoid delete_vertex(Vertex v) { clear_vertex(v); remove_vertex(v); }\n\n/// insert Vertex \\a v into the middle of Edge \\a e\nvoid add_vertex_in_edge( Vertex v, Edge e) {\n    // the vertex v is inserted into the middle of edge e\n    // edge e and its twin are replaced by four new edges: e1,e2 and their twins te2,te1\n    // before:             face\n    //                      e\n    // previous-> source  ------> target -> next\n    //  tw_next<- tw_trg  <-----  tw_src <- tw_previous\n    //                      twin \n    //                    twin_face\n    //\n    // after:               face\n    //                    e1   e2\n    // previous-> source  -> v -> target -> next\n    //  tw_next<- tw_trg  <- v <- tw_src <- tw_previous\n    //                    te2  te1\n    //                    twin_face\n    //\n\n    Edge e_twin = g[e].twin;\n    assert( e_twin != Edge() );\n    Vertex esource = boost::source(e,g); \n    Vertex etarget = boost::target(e,g); \n    Face face = g[e].face;\n    Face twin_face = g[e_twin].face;\n    Edge previous = previous_edge(e);\n    Edge twin_previous = previous_edge(e_twin);\n    \n    assert( g[previous].face == g[e].face );\n    assert( g[twin_previous].face == g[e_twin].face );\n    \n    Edge e1 = boost::add_edge( esource, v, g).first;\n    Edge te2 = boost::add_edge( v, esource,  g).first;\n    g[e1].twin = te2; g[te2].twin = e1;\n    //boost::tie(e1,te2) = add_twin_edges( esource, v ); \n    //Edge e2, te1;\n    //boost::tie(e2,te1) = add_twin_edges( v, etarget );    \n    Edge e2 = boost::add_edge( v, etarget, g).first;\n    Edge te1 = boost::add_edge( etarget, v,  g).first;\n    g[e2].twin = te1; g[te1].twin = e2;\n\n\n    // next-pointers\n    g[previous].next = e1; g[e1].next=e2; g[e2].next = g[e].next;\n    //set_next_chain( boost::assign::list_of(previous)(e1)(e2)(g[e].next) );\n    //set_next_chain( boost::assign::list_of(twin_previous)(te1)(te2)(g[e_twin].next) );\n    g[twin_previous].next = te1; g[te1].next=te2; g[te2].next = g[e_twin].next;    \n    // this copies params, face, k, type\n    g[e1] = g[e];       g[e2] = g[e];       // NOTE: we use EdgeProperties::operator= here to copy !\n    g[te1] = g[e_twin]; g[te2] = g[e_twin];\n    // update the faces \n    faces[face].edge = e1;\n    faces[twin_face].edge = te1;\n    // finally, remove the old edge\n    //remove_twin_edges(esource, etarget);\n    boost::remove_edge( e , g );\n    boost::remove_edge( e_twin , g );\n}\n/// ad two edges, one from \\a v1 to \\a v2 and one from \\a v2 to \\a v1\nstd::pair<Edge,Edge> add_twin_edges(Vertex v1, Vertex v2) {\n    //Edge e1,e2;\n    //bool b;\n    //boost::tie( e1 , b ) = boost::add_edge( v1, v2, g);\n    //boost::tie( e2 , b ) = boost::add_edge( v2, v1, g);\n    Edge e1 = boost::add_edge( v1, v2, g).first;\n    Edge e2 = boost::add_edge( v2, v1, g).first;\n    //twin_edges(e1,e2);\n    g[e1].twin = e2;\n    g[e2].twin = e1;\n    return std::make_pair(e1,e2);\n}\n\n/// make e1 the twin of e2 (and vice versa)\nvoid twin_edges( Edge e1, Edge e2 ) {\n    if (target(e1) != source(e2)) {\n        std::cout << \" error target(e1)= \" << g[target(e1)].index << \" != \" << g[source(e2)].index << \" = source(e2) \\n\";\n        std::cout << \"target(e1) = \" << target(e1) << \"\\n\";\n        std::cout << \"source(e2) = \" << source(e2) << \"\\n\";\n    }\n    assert( target(e1) == source(e2) );\n    assert( source(e1) == target(e2) );\n    \n    g[e1].twin = e2;\n    g[e2].twin = e1;\n}\n\n/// add a face \nFace add_face() {\n    TFaceProperties f_prop;\n    faces.push_back( f_prop); \n    Face index = faces.size()-1;\n    faces[index].idx = index;\n    return index;    \n}\n\n/// add a face, with given properties\nFace add_face(const TFaceProperties& prop) {\n    faces.push_back( prop ); \n    Face index = faces.size()-1;\n    faces[index].idx = index;\n    return index;    \n}\n\n/// return all vertices in a vector of vertex descriptors\nVertexVector vertices()  const {\n    VertexVector vv;\n    VertexItr it_begin, it_end, itr;\n    boost::tie( it_begin, it_end ) = boost::vertices( g );\n    for ( itr=it_begin ; itr != it_end ; ++itr ) {\n        vv.push_back( *itr );\n    }\n    return vv;\n}\n\n/// return all vertices adjecent to given vertex\nVertexVector adjacent_vertices(  Vertex v) {\n    VertexVector vv;\n    BOOST_FOREACH( Edge e, out_edges( v ) ) {\n        vv.push_back( target( e ) );\n    }\n    return vv;\n}\n\n/// return all vertices of given face\nVertexVector face_vertices(Face face_idx) const {\n    VertexVector verts;\n    Edge startedge = faces[face_idx].edge; // the edge where we start\n    Vertex start_target = boost::target( startedge, g ); \n    verts.push_back(start_target);\n    Edge current = g[startedge].next;\n    int count=0;\n    EdgeVector f_edges; // for debug.\n    f_edges.push_back(current);\n    do {\n        Vertex current_target = boost::target( current, g ); \n        //assert( current_target != start_target );\n        verts.push_back(current_target);\n        f_edges.push_back(current);\n        assert( g[current].face == g[ g[current].next ].face );\n        current = g[current].next;\n        \n        if (count >= 3000000 ) {\n            std::cout << \" ERROR too many vertices on face! count=\" << count << \"\\n\";\n            std::cout << \" verts.size() = \" << verts.size();\n            std::cout << \" edges.size()=\" << f_edges.size() <<\"\\n\";\n            for (unsigned int n=0;n<verts.size()-10;n++) {\n                std::cout << n << \"   : \" << g[ verts[n] ].index << \"\\n\"; \n            }\n        }\n        assert( count < 3000000 ); // stop at some max limit\n        count++;\n    } while ( current != startedge );\n    return verts;\n}\n\n/// return edges of face f as a vector\n/// NOTE: it is faster to write a do-while loop in client code than to call this function!\nEdgeVector face_edges( Face f) {\n    Edge start_edge = faces[f].edge;\n    Edge current_edge = start_edge;\n    EdgeVector out;\n    std::cout << \" edges on face \" << f << \" :\\n \";\n    do {\n        Vertex src = source(current_edge);\n        Vertex trg = target(current_edge);\n           std::cout << out.size() << \" \" << g[src].index << \"[\" << g[src].type <<\"]\";\n           std::cout << \" - \" << g[trg].index << \"[\" << g[trg].type <<\"]\" <<\"\\n \";\n        out.push_back(current_edge);\n        current_edge = g[current_edge].next;\n    } while( current_edge != start_edge );\n    return out;\n}\n\n/// return out_edges of given vertex\nEdgeVector out_edges( Vertex v) { \n    EdgeVector ev;\n    OutEdgeItr it, it_end;\n    boost::tie( it, it_end ) = boost::out_edges( v, g );\n    for ( ; it != it_end ; ++it ) {\n        ev.push_back(*it);\n    }\n    return ev;\n}\n\n/// return all edges as a vector\n// FIXME: provide std::pair<edge_iterator,edge_iterator> version of this function also?\nEdgeVector edges() {\n    EdgeVector ev;\n    EdgeItr it, it_end;\n    boost::tie( it, it_end ) = boost::edges( g );\n    for ( ; it != it_end ; ++it ) {\n        ev.push_back(*it);\n    }\n    return ev;\n}\n\n/// return the previous edge. traverses all edges in face until previous found.\nEdge previous_edge( Edge e ) {\n    Edge previous = g[e].next;\n    while ( g[previous].next != e ) {\n        previous = g[previous].next;\n    }\n    return previous;\n}\n\n/// return adjacent faces to the given vertex\nFaceVector adjacent_faces( Vertex q ) {\n    std::set<Face> face_set;\n    OutEdgeItr itr, itr_end;\n    boost::tie( itr, itr_end) = boost::out_edges(q, g);\n    for ( ; itr!=itr_end ; ++itr ) {\n        face_set.insert( g[*itr].face );\n    }\n    //assert( face_set.size() == 3); // true for normal vertices, but SPLIT/APEX are degree 2..\n    FaceVector fv(face_set.begin(), face_set.end());\n    return fv;\n}\n\n/// inserts given vertex into edge e, and into the twin edge e_twin\n/// maintain next-pointers, face-assignment, and k-values\nvoid insert_vertex_in_edge(Vertex v, Edge e ) {\n    // the vertex v is in the middle of edge e\n    //                    face\n    //                    e1   e2\n    // previous-> source  -> v -> target -> next\n    //            tw_trg  <- v <- tw_src <- tw_previous\n    //                    te2  te1\n    //                    twin_face\n    \n    Edge twin = g[e].twin;\n    Vertex src = boost::source( e , g);\n    Vertex trg = boost::target( e , g);\n    Vertex twin_source = boost::source( twin , g);\n    Vertex twin_target = boost::target( twin , g);\n    assert( src == twin_target );    \n    assert( trg == twin_source );\n    \n    Face face = g[e].face;\n    Face twin_face = g[twin].face;\n    Edge previous = previous_edge(e);\n    assert( g[previous].face == g[e].face );\n    Edge twin_previous = previous_edge(twin);\n    assert( g[twin_previous].face == g[twin].face );\n    \n    Edge e1 = add_edge( src, v ); // these replace e\n    Edge e2 = add_edge( v, trg );\n    \n    // preserve the left/right face link\n    g[e1].face = face;\n    g[e2].face = face;\n    // next-pointers\n    g[previous].next = e1;\n    g[e1].next = e2;\n    g[e2].next = g[e].next;\n    \n    Edge te1 = add_edge( twin_source, v  ); // these replace twin\n    Edge te2 = add_edge( v, twin_target  );\n    \n    g[te1].face = twin_face;\n    g[te2].face = twin_face;\n    \n    g[twin_previous].next = te1;\n    g[te1].next = te2;\n    g[te2].next = g[twin].next;\n    \n    // TWINNING (note indices 'cross', see ASCII art above)\n    g[e1].twin = te2;\n    g[te2].twin = e1;\n    g[e2].twin = te1;\n    g[te1].twin = e2;\n    \n    // update the faces \n    faces[face].edge = e1;\n    faces[twin_face].edge = te1;\n    \n    // finally, remove the old edge\n    boost::remove_edge( e   , g);\n    boost::remove_edge( twin, g);\n}\n\n/// remove given v1-v2 edge\nvoid remove_edge( Vertex v1, Vertex v2) { \n    assert( has_edge(v1,v2) );\n    typedef typename std::pair<Edge, bool> EdgeBool;\n    EdgeBool result = boost::edge(v1, v2, g );    \n    boost::remove_edge( result.first , g );\n}\n\n/// remove given v1-v2 edge and its twin\nvoid remove_twin_edges( Vertex v1, Vertex v2) { \n    assert( has_edge(v1,v2) );\n    assert( has_edge(v2,v1) );\n    typedef typename std::pair<Edge, bool> EdgeBool;\n    EdgeBool result1 = boost::edge(v1, v2, g ); \n    EdgeBool result2 = boost::edge(v2, v1, g );    \n    boost::remove_edge( result1.first , g );\n    boost::remove_edge( result2.first , g );\n}\n\n/// remove a degree-two Vertex from the middle of an Edge\n// preserve edge-properties (next, face, k)\nvoid remove_deg2_vertex( Vertex v ) {\n    //                    face1 e[1]\n    //    v1_prev -> v1 -> SPLIT -> v2 -> v2_next\n    //    v1_next <- v1 <- SPLIT <- v2 <- v2_prev\n    //                  e[0]  face2\n    //\n    // is replaced with a single edge:\n    //                    face1\n    //    v1_prev -> v1 ----------> v2 -> v2_next\n    //    v1_next <- v1 <---------- v2 <- v2_prev\n    //                     face2\n    \n    EdgeVector v_edges = out_edges(v);\n    assert( v_edges.size() == 2);\n    assert( source(v_edges[0]) == v && source(v_edges[1]) == v );\n     \n    Vertex v1 = target( v_edges[0] );\n    Vertex v2 = target( v_edges[1] );\n    Edge v1_next = g[ v_edges[0] ].next;\n    Edge v1_prev = previous_edge( g[ v_edges[0] ].twin );\n    Edge v2_next = g[ v_edges[1] ].next;\n    Edge v2_prev = previous_edge( g[ v_edges[1] ].twin );\n    Face face1 = g[ v_edges[1] ].face;\n    Face face2 = g[ v_edges[0] ].face;\n    \n    Edge new1, new2;\n    boost::tie(new1,new2) = add_twin_edges(v1,v2);\n    set_next(new1,v2_next);\n    set_next(new2,v1_next);\n    set_next(v2_prev,new2);\n    set_next(v1_prev,new1);\n    faces[face1].edge = new1;\n    faces[face2].edge = new2;\n    g[new1] = g[ v_edges[1] ]; // NOTE: uses EdgeProperties::operator= to copy edge properties\n    g[new2] = g[ v_edges[0] ]; //  this sets: params, type, k, face\n    remove_twin_edges(v,v1);\n    remove_twin_edges(v,v2);\n    remove_vertex(v);\n}\n/// set next-pointer of e1 to e2\nvoid set_next(Edge e1, Edge e2) {\n    if (target(e1) != source(e2) ){\n        std::cout << \" ERROR target(e1) = \" << g[target(e1)].index << \" source(e2)= \" << g[source(e2)].index << \"\\n\"; \n    }\n    assert( target(e1) == source(e2) );\n    g[e1].next = e2;\n}\n\n/// form a face from the edge-list:\n/// e1->e2->...->e1\n/// for all edges, set edge.face=f, and edge.k=k\nvoid set_next_cycle( std::list<Edge> list, Face f, double k) {\n    typename std::list<Edge>::iterator begin,it,nxt,end;\n    it= list.begin();\n    begin = it;\n    faces[f].edge = *it;\n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n        else\n            set_next(*it,*begin);\n            \n        g[*it].face = f;\n        g[*it].k = k;\n    }\n}\n\n/// set next-pointers for the given list (but don't close to form a cycle)\n// also set face and k properties for edge\nvoid set_next_chain( std::list<Edge> list, Face f, double k) {\n    typename std::list<Edge>::iterator it,nxt,end;\n    it= list.begin();\n    faces[f].edge = *it;\n    //set_next_chain(list);\n    //begin = it;    \n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n            \n        g[*it].face = f;\n        g[*it].k = k;\n    }\n}\n\n/// set next-pointers for the list\nvoid set_next_chain( std::list<Edge> list ) {\n    typename std::list<Edge>::iterator it,nxt,end;\n    it= list.begin();\n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n    }\n}\n\n/// on a face, search and return the left/right edge from endp\nstd::pair<Edge,Edge> find_next_prev(Face f, Vertex endp) {\n    Edge current = faces[f].edge;\n    Edge start_edge = current;\n    Edge next_edge = current; // this causes unintialized warning: Edge next_edge = Edge();\n    Edge prev_edge = current; // uninitialized warning on ubuntu 11.04 ?\n    do {\n        Vertex src = source(current);\n        Vertex trg = target(current);\n        if (src==endp)\n            next_edge = current;\n        if (trg==endp)\n            prev_edge = current;\n        current = g[current].next;\n    } while (current!=start_edge);\n    assert( next_edge != Edge() );\n    assert( prev_edge != Edge() );\n    //if (debug) {\n    //    std::cout << \" find_next_prev() next_edge = \"; g.print_edge(next_edge); \n    //    std::cout << \" find_next_prev() prev_edge = \"; g.print_edge(prev_edge);\n    //}\n    return std::make_pair(next_edge, prev_edge);\n}\n\n/// print all faces of graph\nvoid print_faces() {\n    for( Face f=0;f<g.num_faces();f++) {\n        print_face(f);\n    }\n}\n\n/// print out vertices on given Face\nvoid print_face(Face f) {\n    std::cout << \" Face \" << f << \": \";\n    Edge current = faces[f].edge;\n    Edge start=current;\n    int num_e=0;\n    do {\n        Vertex v = source(current);\n        std::cout << g[v].index  << \"(\" << g[v].status  << \")-f\"<< g[current].face << \"-\";\n        num_e++;\n        assert(num_e<300);\n        current = g[current].next;\n    } while ( current!=start );\n    std::cout << \"\\n\";\n}\n\n/// print given edges\nvoid print_edges(EdgeVector& q) {\n    BOOST_FOREACH( Edge e, q ) {\n        Vertex src = source(e);\n        Vertex trg = target(e);\n        std::cout << g[src].index << \"-\" << g[trg].index << \"\\n\";\n    }\n}\n\n/// print edge\nvoid print_edge(Edge e) {\n    Vertex src = source(e);\n    Vertex trg = target(e);\n    std::cout << g[src].index << \"-f\" << g[e].face << \"-\" << g[trg].index << \"\\n\";\n}\n\n/// print given vertices\nvoid print_vertices(VertexVector& q) {\n    BOOST_FOREACH( Vertex v, q) {\n        std::cout << g[v].index << \"[\"<< g[v].type << \"]\" << \" \";\n    }\n    std::cout << std::endl;\n}\n\n}; // end HEDIGraph class definition\n\n\n} // end hedi namespace\n// end halfedgediagram.hpp\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last, RandomNumberGenerator& rand);\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b);\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_first_of(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *_VSTD::min_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *_VSTD::max_element(__t.begin(), __t.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                                   _VSTD::minmax_element(__t.begin(), __t.end());\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    pair<const _Tp*, const _Tp*> __p =\n                           _VSTD::minmax_element(__t.begin(), __t.end(), __comp);\n    return pair<_Tp, _Tp>(*__p.first, *__p.second);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_front(_RandomAccessIterator __first, _RandomAccessIterator, _Compare __comp,\n                  typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        difference_type __p = 0;\n        _RandomAccessIterator __pp = __first;\n        difference_type __c = 2;\n        _RandomAccessIterator __cp = __first + __c;\n        if (__c == __len || __comp(*__cp, *(__cp - 1)))\n        {\n            --__c;\n            --__cp;\n        }\n        if (__comp(*__pp, *__cp))\n        {\n            value_type __t(_VSTD::move(*__pp));\n            do\n            {\n                *__pp = _VSTD::move(*__cp);\n                __pp = __cp;\n                __p = __c;\n                __c = (__p + 1) * 2;\n                if (__c > __len)\n                    break;\n                __cp = __first + __c;\n                if (__c == __len || __comp(*__cp, *(__cp - 1)))\n                {\n                    --__c;\n                    --__cp;\n                }\n            } while (__comp(__t, *__cp));\n            *__pp = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__push_heap_back(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n                 typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __push_heap_back<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __push_heap_back<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __push_heap_front<_Compare>(__first, __last, __comp, __len-1);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        __last = __first;\n        ++__last;\n        for (difference_type __i = 1; __i < __n;)\n            __push_heap_back<_Compare>(__first, ++__last, __comp, ++__i);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __push_heap_front<_Compare>(__first, __middle, __comp, __len);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = 0;\n        for (; __first != __last && __r != __result_last; ++__first, ++__r, ++__len)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __push_heap_front<_Compare>(__result_first, __r, __comp, __len);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","/*  \n *  Copyright 2010-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <queue>\n#include <set>\n#include <boost/tuple/tuple.hpp>\n\n#include \"common/point.hpp\"\n#include \"graph.hpp\"\n#include \"vertex_positioner.hpp\"\n#include \"filter.hpp\"\n#include \"kdtree.hpp\"\n\n/*! \\mainpage OpenVoronoi\n *\n * \\author Anders E. Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \\section intro_sec Introduction\n *\n * OpenVoronoi is a c++ library with python bindings (using boost::python) for calculating 2D voronoi-diagrams of point, \n * line-segment, and circular-arc(not implement yet!) sites.\n * An incremental topology-oriented algorithm is used.\n * \n * See github for build/install instructions https://github.com/aewallin/openvoronoi\n * \n * DEB packages for Ubuntu are available at https://launchpad.net/~anders-e-e-wallin/+archive/cam\n * \n * Output gallery: https://picasaweb.google.com/106188605401091280402/OpenVoronoiExamples\n * \n * \\section Utilities\n * - Offset\n * - Medial-Axis\n * - SVG output\n * \n * \\section Tests\n * Tests are written for CTest.\n * - \"ctest -R cpp\" runs only the c++ tests (these are fast)\n * - \"ctest\" runs all tests (some may be slow)\n * Some tests use truetype-tracer (font geometry source), and some use CGAL_RPG (random polygon generator). \n * \n * \\section coverage Code Coverage Testing\n * - compile using CMAKE_BUILD_TYPE=Coverage  (uses \"-fprofile-arcs -ftest-coverage\" )\n * - install the library \"sudo make install\"\n * - Run the custom target coverage-report with \"make coverage-report\". It will do the following:\n *  - reset lcov counters \"lcov --directory ./ --zerocounters\"\n *  - run CTest c++ tests with \"ctest -R cpptest\"\n *  - generate an info-file with \"lcov --directory ./ --capture --output-file app.info\"\n *  - generate html output with \"genhtml --output-directory coverage --title OpenVoronoi Test Coverage app.info\"\n * - point your browser to build/doc/index.html to see the output\n * \n * \\section debian Debian source package\n * - See the files in src/deb for more information. \n * - A debian source package in build/Debian is built with the spackage target, run with \"make spackage\"\n *  - remember to set the \"Release\" build-type in CMakeLists.txt\n *  - disable building of tests (these require truetypetracer(ttt) and randompolygon(rpg) which pbuilder/PPA does not find\n * - The source-package can be tested with pbuilder\n *  - To test-build the package (assuming you are on a precise distribution). This will take a long time.\n *   - \"sudo pbuilder build openvoronoi_12.02.257-ubuntu1~precise1.dsc\" \n *  - To test-build for other distributions:\n *   - \"sudo pbuilder build --distribution lucid openvoronoi_12.02.257-ubuntu1~lucid1.dsc\"\n * - The source-package(s) can be uploaded to the Launchpad PPA with dput (this requires that you have write-access to the PPA)\n *  - \"dput ppa:anders-e-e-wallin/cam *.changes\"\n */\n \n\nnamespace ovd\n{\n/*! \n * \\namespace ovd \n * \\brief OpenVoronoi classes and functions\n */\n \n \nclass VoronoiDiagramChecker;\n\n/// \\brief KD-tree for 2D point location\n///\n/// a kd-tree is used for nearest-neighbor search when inserting point sites\nstruct kd_point {\n    /// default ctor\n    kd_point() : p(0,0), face(0) { }\n    /// kd-point with given position and HEFace\n    kd_point(Point pt, HEFace f) : p(pt), face(f) { }\n    /// kd-point at given position\n    kd_point(Point pt) : p(pt), face(0) { }\n    /// distance (suared) to given point\n    double dist(const kd_point& pt) const {\n        return (p.x-pt.p.x)*(p.x-pt.p.x) + (p.y-pt.p.y)*(p.y-pt.p.y); \n    }\n    /// return x or y coordinate of Point\n    double operator[](unsigned int i) const {\n        return i == 0 ? p.x : p.y; \n    }\n    /// return x or y coordinate of Point\n    double& operator[](unsigned int i) { \n        return i == 0 ? p.x : p.y; \n    }\n    Point p; ///< position of 2D PointSite\n    HEFace face; ///< the HEFace correspoinding to the PointSite\n};\n\n/// type of the KD-tree used for nearest-neighbor search\ntypedef kdtree::KDTree<kd_point> kd_type; \n\n/// \\brief Voronoi diagram.\n///\n/// see http://en.wikipedia.org/wiki/Voronoi_diagram\n/// \n/// the dual of a voronoi diagram is the delaunay diagram(triangulation).\n///  voronoi-faces are dual to delaunay-vertices.\n///  vornoi-vertices are dual to delaunay-faces \n///  voronoi-edges are dual to delaunay-edges\nclass VoronoiDiagram {\npublic:\n    VoronoiDiagram(double far, unsigned int n_bins);\n    virtual ~VoronoiDiagram();\n    int insert_point_site(const Point& p, int step=0);\n    bool insert_line_site(int idx1, int idx2, int step=99); // default step should make algorithm run until the end!\n    void insert_arc_site(int idx1, int idx2, const Point& c, bool cw, int step=99);\n    \n    /// return the far radius\n    double get_far_radius() const {return far_radius;}\n    /// return number of point sites in diagram\n    int num_point_sites() const {return num_psites-3;} // the three initial vertices don't count\n    /// return number of line-segments sites in diagram\n    int num_line_sites() const {return num_lsites;}\n    /// return number of arc-sites in diagram\n    int num_arc_sites() const {return num_asites;}\n    /// return number of voronoi-vertices\n    int num_vertices() const { return g.num_vertices()-num_point_sites(); }\n    /// return number of faces in graph\n    int num_faces() const { return g.num_faces(); }\n    int num_split_vertices() const;\n    /// return reference to graph \\todo not elegant. only used by vd2svg ?\n    HEGraph& get_graph_reference() {return g;}\n    \n    std::string print() const;\n    /// reset vertex index count \\todo not very elegant...\n    static void reset_vertex_count() { VoronoiVertex::reset_count(); }\n    /// turn on debug output\n    void debug_on() {debug=true;} \n    /// set silent mode on/off\n    void set_silent(bool b) {\n        silent=b;\n        vpos->set_silent(silent);\n    } \n    bool check(); \n    void filter( Filter* flt);\n    void filter_reset();\nprotected:\n    /// type for item in VertexQueue. pair of vertex-desxriptor and in_circle predicate\n    typedef std::pair<HEVertex, double> VertexDetPair;\n    /// \\brief comparison-predicate for VertexQueue\n    ///\n    /// in augment_vertex_set() we grow the delete-tree by processing vertices\n    /// one-by-one from a priority_queue. This is the priority_queue sort predicate.\n    /// We handle vertices with a large fabs( in_circle() ) first, since we \n    /// believe their predicate to be more reliable.\n    class abs_comparison {\n    public:\n      /// return true if absolute-value of lhs.second is smaller than rhs.second\n      bool operator() (const VertexDetPair& lhs, const VertexDetPair&rhs) const {\n        return ( fabs(lhs.second) < fabs(rhs.second) );\n      }\n    };\n\n    /// priority_queue for vertex for processing \n    // sorted by decreasing fabs() of in_circle-predicate, so that the vertices whose IN/OUT status we are 'most certain' about are processed first\n    typedef std::priority_queue< VertexDetPair , std::vector<VertexDetPair>, abs_comparison > VertexQueue;\n    \n    /// \\brief data required for adding a new edge\n    ///\n    /// used in add_edge() for storing information related to\n    /// the new edge.\n    struct EdgeData {\n        HEEdge v1_prv; ///< edge prior to v1\n        HEVertex v1;   ///< NEW edge source \n        HEEdge v1_nxt; ///< edge following v1 \n        HEEdge v2_prv; ///< edge prior to v2 \n        HEVertex v2;   ///< NEW edge target \n        HEEdge v2_nxt; ///< edge following v2 \n        HEFace f;      ///< face of v1 and v2 \n    };\n\n    void initialize();\n    HEVertex   find_seed_vertex(HEFace f, Site* site);\n    EdgeVector find_in_out_edges(); \n    EdgeData   find_edge_data(HEFace f, VertexVector startverts, std::pair<HEVertex,HEVertex> segment);\n    EdgeVector find_split_edges(HEFace f, Point pt1, Point pt2);\n    bool       find_split_vertex(HEFace f, HEVertex& v);\n    std::pair<HEVertex,HEVertex> find_endpoints(int idx1, int idx2);\n    bool null_vertex_target( HEVertex v , HEVertex& trg);\n    void augment_vertex_set( Site* site);        \n    bool predicate_c4(HEVertex v);\n    bool predicate_c5(HEVertex v);\n    void mark_adjacent_faces(HEVertex v, Site* site);\n    void mark_adjacent_faces_p( HEVertex v );\n    void mark_vertex(HEVertex& v,  Site* site); \n    void   add_vertices( Site* site );\n    HEFace add_face(Site* site);\n    void   add_edges(HEFace new_f1, HEFace f);        \n    void   add_edges(HEFace new_f1, HEFace f, HEFace new_f2, std::pair<HEVertex,HEVertex> seg);\n    void   add_edge(EdgeData ed, HEFace new1, HEFace new2=0);\n    void   add_separator(HEFace f, HEFace nf, boost::tuple<HEEdge, HEVertex, HEEdge,bool> target, HEVertex endp, Site* s1, Site* s2);\n    void   add_split_vertex(HEFace f, Site* s);\n    boost::tuple<HEVertex,HEFace,HEVertex,HEVertex,HEFace> find_null_face(HEVertex start, HEVertex other, Point l, Point dir, Site* new_site);\n    boost::tuple<HEEdge,HEVertex,HEEdge,bool> find_separator_target(HEFace f, HEVertex endp);\n    std::pair<HEVertex,HEFace> process_null_edge(Point dir, HEEdge next_edge , bool k3, bool next_prev);\n    HEVertex add_separator_vertex(HEVertex endp, HEEdge edge, Point sep_dir);\n    void repair_face( HEFace f );\n    void repair_face( HEFace f , std::pair<HEVertex,HEVertex> segs,\n                                 std::pair<HEFace,HEFace> nulled_faces,\n                                 std::pair<HEFace,HEFace> null_faces );\n    void remove_vertex_set();\n    void remove_split_vertex(HEFace f);\n    void reset_status();\n    int num_new_vertices(HEFace f);\n// HELPER-CLASSES\n    VoronoiDiagramChecker* vd_checker; ///< sanity-checks on the diagram are done by this helper class\n    kd_type* kd_tree; ///< kd-tree for nearest neighbor search during point Site insertion\n    VertexPositioner* vpos; ///< an algorithm for positioning vertices\n// DATA\n    typedef std::map<int,HEVertex> VertexMap; ///< type for vertex-index to vertex-descriptor map\n    typedef std::pair<int,HEVertex> VertexMapPair; ///< associate vertex index with vertex descriptor\n    \n    VertexMap vertex_map; ///< map from int handles to vertex-descriptors, used in insert_line_site()\n    VertexQueue vertexQueue; ///< queue of vertices to be processed\n    HEGraph g; ///< the half-edge diagram of the vd\n    double far_radius; ///< sites must fall within a circle with radius far_radius\n    int num_psites; ///< the number of point sites\n    int num_lsites; ///< the number of line-segment sites\n    int num_asites; ///< the number of arc-sites\n    FaceVector incident_faces; ///< temporary variable for ::INCIDENT faces, will be reset to ::NONINCIDENT after a site has been inserted\n    std::set<HEVertex> modified_vertices; ///< temporary variable for in-vertices, out-vertices that need to be reset after a site has been inserted\n    VertexVector v0; ///< IN-vertices, i.e. to-be-deleted\n    bool debug; ///< turn debug output on/off\n    bool silent; ///< no warnings emitted when silent==true\nprivate:\n    VoronoiDiagram(); // don't use.\n};\n\n/// \\brief error-functor to locate ::SPLIT vertices\n///\n/// for passing to numerical boost::toms748 root-finding algorithm\nclass SplitPointError {\npublic:\n    /// \\param gi graph\n    /// \\param split_edge the edge on which we want to position a SPLIT vertex\n    /// \\param pt1 first point of split-line\n    /// \\param pt2 second point of split-line\n    SplitPointError(HEGraph& gi, HEEdge split_edge, Point pt1, Point pt2) :\n    g(gi),  edge(split_edge), p1(pt1), p2(pt2)\n    {}\n    \n    /// \\return signed distance to the pt1-pt2 line from edge-point at given offset \\a t\n    double operator()(const double t) {\n        Point p = g[edge].point(t);\n        // line: pt1 + u*(pt2-pt1) = p\n        //   (p-pt1) dot (pt2-pt1) = u* (pt2-pt1) dot (pt2-pt1)\n        \n        double u = (p-p1).dot(p2-p1) / ( (p2-p1).dot(p2-p1) );\n        Point proj = p1 + u*(p2-p1);\n        double dist = (proj-p).norm();\n        double sign;\n        if ( p.is_right(p1,p2) )\n            sign = +1;\n        else\n            sign = -1;\n            \n        return sign*dist;\n    }\nprivate:\n    HEGraph& g;      ///< reference to vd-graph\n    HEEdge edge;     ///< the HEEdge on which we position the new SPLIT vertex\n    Point p1;     ///< first point of the split-line\n    Point p2;    ///< second point of the split-line\n};\n\n} // end ovd namespace\n\n// end voronoidiagram.hpp\n","///////////////////////////////////////////////////////////////////////////////\n// foreach.hpp header file\n//\n// Copyright 2004 Eric Niebler.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n// See http://www.boost.org/libs/foreach for documentation\n//\n// Credits:\n//  Anson Tsao        - for the initial inspiration and several good suggestions.\n//  Thorsten Ottosen  - for Boost.Range, and for suggesting a way to detect\n//                      const-qualified rvalues at compile time on VC7.1+\n//  Russell Hind      - For help porting to Borland\n//  Alisdair Meredith - For help porting to Borland\n//  Stefan Slapeta    - For help porting to Intel\n//  David Jenkins     - For help finding a Microsoft Code Analysis bug\n//  mimomorin@...     - For a patch to use rvalue refs on supporting compilers\n\n#ifndef BOOST_FOREACH\n\n// MS compatible compilers support #pragma once\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n#include <cstddef>\n#include <utility>  // for std::pair\n\n#include <boost/config.hpp>\n#include <boost/detail/workaround.hpp>\n\n// Some compilers let us detect even const-qualified rvalues at compile-time\n#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)                                                   \\\n || BOOST_WORKAROUND(BOOST_MSVC, >= 1310) && !defined(_PREFAST_)                                 \\\n || (BOOST_WORKAROUND(__GNUC__, == 4) && (__GNUC_MINOR__ <= 5) && !defined(BOOST_INTEL) &&       \\\n                                                                  !defined(BOOST_CLANG))         \\\n || (BOOST_WORKAROUND(__GNUC__, == 3) && (__GNUC_MINOR__ >= 4) && !defined(BOOST_INTEL) &&       \\\n                                                                  !defined(BOOST_CLANG))\n# define BOOST_FOREACH_COMPILE_TIME_CONST_RVALUE_DETECTION\n#else\n// Some compilers allow temporaries to be bound to non-const references.\n// These compilers make it impossible to for BOOST_FOREACH to detect\n// temporaries and avoid reevaluation of the collection expression.\n# if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)                                                      \\\n  || BOOST_WORKAROUND(__BORLANDC__, < 0x593)                                                    \\\n  || (BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION, <= 700) && defined(_MSC_VER))                   \\\n  || BOOST_WORKAROUND(__SUNPRO_CC, < 0x5100)                                                    \\\n  || BOOST_WORKAROUND(__DECCXX_VER, <= 60590042)\n#  define BOOST_FOREACH_NO_RVALUE_DETECTION\n# endif\n// Some compilers do not correctly implement the lvalue/rvalue conversion\n// rules of the ternary conditional operator.\n# if defined(BOOST_FOREACH_NO_RVALUE_DETECTION)                                                 \\\n  || defined(BOOST_NO_SFINAE)                                                                   \\\n  || BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1400))                                        \\\n  || BOOST_WORKAROUND(BOOST_INTEL_WIN, BOOST_TESTED_AT(1400))                                   \\\n  || BOOST_WORKAROUND(__GNUC__, < 3)                                                            \\\n  || (BOOST_WORKAROUND(__GNUC__, == 3) && (__GNUC_MINOR__ <= 2))                                \\\n  || (BOOST_WORKAROUND(__GNUC__, == 3) && (__GNUC_MINOR__ <= 3) && defined(__APPLE_CC__))       \\\n  || BOOST_WORKAROUND(__IBMCPP__, BOOST_TESTED_AT(600))                                         \\\n  || BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3206))                                      \\\n  || BOOST_WORKAROUND(__SUNPRO_CC, >= 0x5100)                                                   \\\n  || BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x590))\n#  define BOOST_FOREACH_NO_CONST_RVALUE_DETECTION\n# else\n#  define BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\n# endif\n#endif\n\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/assert.hpp>\n#include <boost/mpl/logical.hpp>\n#include <boost/mpl/eval_if.hpp>\n#include <boost/noncopyable.hpp>\n#include <boost/range/end.hpp>\n#include <boost/range/begin.hpp>\n#include <boost/range/rend.hpp>\n#include <boost/range/rbegin.hpp>\n#include <boost/range/iterator.hpp>\n#include <boost/range/reverse_iterator.hpp>\n#include <boost/type_traits/is_array.hpp>\n#include <boost/type_traits/is_const.hpp>\n#include <boost/type_traits/is_abstract.hpp>\n#include <boost/type_traits/is_base_and_derived.hpp>\n#include <boost/type_traits/is_rvalue_reference.hpp>\n#include <boost/iterator/iterator_traits.hpp>\n#include <boost/utility/addressof.hpp>\n#include <boost/foreach_fwd.hpp>\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\n# include <new>\n# include <boost/aligned_storage.hpp>\n# include <boost/utility/enable_if.hpp>\n# include <boost/type_traits/remove_const.hpp>\n#endif\n\nnamespace boost\n{\n\n// forward declarations for iterator_range\ntemplate<typename T>\nclass iterator_range;\n\n// forward declarations for sub_range\ntemplate<typename T>\nclass sub_range;\n\nnamespace foreach\n{\n    ///////////////////////////////////////////////////////////////////////////////\n    // in_range\n    //\n    template<typename T>\n    inline std::pair<T, T> in_range(T begin, T end)\n    {\n        return std::make_pair(begin, end);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // boost::foreach::is_lightweight_proxy\n    //   Specialize this for user-defined collection types if they are inexpensive to copy.\n    //   This tells BOOST_FOREACH it can avoid the rvalue/lvalue detection stuff.\n    template<typename T>\n    struct is_lightweight_proxy\n      : boost::mpl::false_\n    {\n    };\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // boost::foreach::is_noncopyable\n    //   Specialize this for user-defined collection types if they cannot be copied.\n    //   This also tells BOOST_FOREACH to avoid the rvalue/lvalue detection stuff.\n    template<typename T>\n    struct is_noncopyable\n    #if !defined(BOOST_BROKEN_IS_BASE_AND_DERIVED) && !defined(BOOST_NO_IS_ABSTRACT)\n      : boost::mpl::or_<\n            boost::is_abstract<T>\n          , boost::is_base_and_derived<boost::noncopyable, T>\n        >\n    #elif !defined(BOOST_BROKEN_IS_BASE_AND_DERIVED)\n      : boost::is_base_and_derived<boost::noncopyable, T>\n    #elif !defined(BOOST_NO_IS_ABSTRACT)\n      : boost::is_abstract<T>\n    #else\n      : boost::mpl::false_\n    #endif\n    {\n    };\n\n} // namespace foreach\n\n} // namespace boost\n\n// vc6/7 needs help ordering the following overloads\n#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\n# define BOOST_FOREACH_TAG_DEFAULT ...\n#else\n# define BOOST_FOREACH_TAG_DEFAULT boost::foreach::tag\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// boost_foreach_is_lightweight_proxy\n//   Another customization point for the is_lightweight_proxy optimization,\n//   this one works on legacy compilers. Overload boost_foreach_is_lightweight_proxy\n//   at the global namespace for your type.\ntemplate<typename T>\ninline boost::foreach::is_lightweight_proxy<T> *\nboost_foreach_is_lightweight_proxy(T *&, BOOST_FOREACH_TAG_DEFAULT) { return 0; }\n\ntemplate<typename T>\ninline boost::mpl::true_ *\nboost_foreach_is_lightweight_proxy(std::pair<T, T> *&, boost::foreach::tag) { return 0; }\n\ntemplate<typename T>\ninline boost::mpl::true_ *\nboost_foreach_is_lightweight_proxy(boost::iterator_range<T> *&, boost::foreach::tag) { return 0; }\n\ntemplate<typename T>\ninline boost::mpl::true_ *\nboost_foreach_is_lightweight_proxy(boost::sub_range<T> *&, boost::foreach::tag) { return 0; }\n\ntemplate<typename T>\ninline boost::mpl::true_ *\nboost_foreach_is_lightweight_proxy(T **&, boost::foreach::tag) { return 0; }\n\n///////////////////////////////////////////////////////////////////////////////\n// boost_foreach_is_noncopyable\n//   Another customization point for the is_noncopyable trait,\n//   this one works on legacy compilers. Overload boost_foreach_is_noncopyable\n//   at the global namespace for your type.\ntemplate<typename T>\ninline boost::foreach::is_noncopyable<T> *\nboost_foreach_is_noncopyable(T *&, BOOST_FOREACH_TAG_DEFAULT) { return 0; }\n\nnamespace boost\n{\n\nnamespace foreach_detail_\n{\n\n///////////////////////////////////////////////////////////////////////////////\n// Define some utilities for assessing the properties of expressions\n//\ntemplate<typename Bool1, typename Bool2>\ninline boost::mpl::and_<Bool1, Bool2> *and_(Bool1 *, Bool2 *) { return 0; }\n\ntemplate<typename Bool1, typename Bool2, typename Bool3>\ninline boost::mpl::and_<Bool1, Bool2, Bool3> *and_(Bool1 *, Bool2 *, Bool3 *) { return 0; }\n\ntemplate<typename Bool1, typename Bool2>\ninline boost::mpl::or_<Bool1, Bool2> *or_(Bool1 *, Bool2 *) { return 0; }\n\ntemplate<typename Bool1, typename Bool2, typename Bool3>\ninline boost::mpl::or_<Bool1, Bool2, Bool3> *or_(Bool1 *, Bool2 *, Bool3 *) { return 0; }\n\ntemplate<typename Bool1>\ninline boost::mpl::not_<Bool1> *not_(Bool1 *) { return 0; }\n\ntemplate<typename T>\ninline boost::is_array<T> *is_array_(T const &) { return 0; }\n\ntemplate<typename T>\ninline boost::is_const<T> *is_const_(T &) { return 0; }\n\n#ifndef BOOST_FOREACH_NO_RVALUE_DETECTION\ntemplate<typename T>\ninline boost::mpl::true_ *is_const_(T const &) { return 0; }\n#endif\n\n#ifdef BOOST_NO_CXX11_RVALUE_REFERENCES\ntemplate<typename T>\ninline boost::mpl::false_ *is_rvalue_(T &, int) { return 0; }\n\ntemplate<typename T>\ninline boost::mpl::true_ *is_rvalue_(T const &, ...) { return 0; }\n#else\ntemplate<typename T>\ninline boost::is_rvalue_reference<T &&> *is_rvalue_(T &&, int) { return 0; }\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// auto_any_t/auto_any\n//  General utility for putting an object of any type into automatic storage\nstruct auto_any_base\n{\n    // auto_any_base must evaluate to false in boolean context so that\n    // they can be declared in if() statements.\n    operator bool() const\n    {\n        return false;\n    }\n};\n\ntemplate<typename T>\nstruct auto_any : auto_any_base\n{\n    explicit auto_any(T const &t)\n      : item(t)\n    {\n    }\n\n    // temporaries of type auto_any will be bound to const auto_any_base\n    // references, but we still want to be able to mutate the stored\n    // data, so declare it as mutable.\n    mutable T item;\n};\n\ntypedef auto_any_base const &auto_any_t;\n\ntemplate<typename T, typename C>\ninline BOOST_DEDUCED_TYPENAME boost::mpl::if_<C, T const, T>::type &auto_any_cast(auto_any_t a)\n{\n    return static_cast<auto_any<T> const &>(a).item;\n}\n\ntypedef boost::mpl::true_ const_;\n\n///////////////////////////////////////////////////////////////////////////////\n// type2type\n//\ntemplate<typename T, typename C = boost::mpl::false_>\nstruct type2type\n  : boost::mpl::if_<C, T const, T>\n{\n};\n\ntemplate<typename T>\nstruct wrap_cstr\n{\n    typedef T type;\n};\n\ntemplate<>\nstruct wrap_cstr<char *>\n{\n    typedef wrap_cstr<char *> type;\n    typedef char *iterator;\n    typedef char *const_iterator;\n};\n\ntemplate<>\nstruct wrap_cstr<char const *>\n{\n    typedef wrap_cstr<char const *> type;\n    typedef char const *iterator;\n    typedef char const *const_iterator;\n};\n\ntemplate<>\nstruct wrap_cstr<wchar_t *>\n{\n    typedef wrap_cstr<wchar_t *> type;\n    typedef wchar_t *iterator;\n    typedef wchar_t *const_iterator;\n};\n\ntemplate<>\nstruct wrap_cstr<wchar_t const *>\n{\n    typedef wrap_cstr<wchar_t const *> type;\n    typedef wchar_t const *iterator;\n    typedef wchar_t const *const_iterator;\n};\n\ntemplate<typename T>\nstruct is_char_array\n  : mpl::and_<\n        is_array<T>\n      , mpl::or_<\n            is_convertible<T, char const *>\n          , is_convertible<T, wchar_t const *>\n        >\n    >\n{};\n\ntemplate<typename T, typename C = boost::mpl::false_>\nstruct foreach_iterator\n{\n    // **** READ THIS IF YOUR COMPILE BREAKS HERE ****\n    //\n    // There is an ambiguity about how to iterate over arrays of char and wchar_t. \n    // Should the last array element be treated as a null terminator to be skipped, or\n    // is it just like any other element in the array? To fix the problem, you must\n    // say which behavior you want.\n    //\n    // To treat the container as a null-terminated string, merely cast it to a\n    // char const *, as in BOOST_FOREACH( char ch, (char const *)\"hello\" ) ...\n    //\n    // To treat the container as an array, use boost::as_array() in <boost/range/as_array.hpp>,\n    // as in BOOST_FOREACH( char ch, boost::as_array(\"hello\") ) ...\n    #if !defined(BOOST_MSVC) || BOOST_MSVC > 1300\n    BOOST_MPL_ASSERT_MSG( (!is_char_array<T>::value), IS_THIS_AN_ARRAY_OR_A_NULL_TERMINATED_STRING, (T&) );\n    #endif\n\n    // If the type is a pointer to a null terminated string (as opposed \n    // to an array type), there is no ambiguity.\n    typedef BOOST_DEDUCED_TYPENAME wrap_cstr<T>::type container;\n\n    typedef BOOST_DEDUCED_TYPENAME boost::mpl::eval_if<\n        C\n      , range_const_iterator<container>\n      , range_mutable_iterator<container>\n    >::type type;\n};\n\n\ntemplate<typename T, typename C = boost::mpl::false_>\nstruct foreach_reverse_iterator\n{\n    // **** READ THIS IF YOUR COMPILE BREAKS HERE ****\n    //\n    // There is an ambiguity about how to iterate over arrays of char and wchar_t. \n    // Should the last array element be treated as a null terminator to be skipped, or\n    // is it just like any other element in the array? To fix the problem, you must\n    // say which behavior you want.\n    //\n    // To treat the container as a null-terminated string, merely cast it to a\n    // char const *, as in BOOST_FOREACH( char ch, (char const *)\"hello\" ) ...\n    //\n    // To treat the container as an array, use boost::as_array() in <boost/range/as_array.hpp>,\n    // as in BOOST_FOREACH( char ch, boost::as_array(\"hello\") ) ...\n    #if !defined(BOOST_MSVC) || BOOST_MSVC > 1300\n    BOOST_MPL_ASSERT_MSG( (!is_char_array<T>::value), IS_THIS_AN_ARRAY_OR_A_NULL_TERMINATED_STRING, (T&) );\n    #endif\n\n    // If the type is a pointer to a null terminated string (as opposed \n    // to an array type), there is no ambiguity.\n    typedef BOOST_DEDUCED_TYPENAME wrap_cstr<T>::type container;\n\n    typedef BOOST_DEDUCED_TYPENAME boost::mpl::eval_if<\n        C\n      , range_reverse_iterator<container const>\n      , range_reverse_iterator<container>\n    >::type type;\n};\n\ntemplate<typename T, typename C = boost::mpl::false_>\nstruct foreach_reference\n  : iterator_reference<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>\n{\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// encode_type\n//\ntemplate<typename T>\ninline type2type<T> *encode_type(T &, boost::mpl::false_ *) { return 0; }\n\ntemplate<typename T>\ninline type2type<T, const_> *encode_type(T const &, boost::mpl::true_ *) { return 0; }\n\n///////////////////////////////////////////////////////////////////////////////\n// set_false\n//\ninline bool set_false(bool &b)\n{\n    b = false;\n    return false;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// to_ptr\n//\ntemplate<typename T>\ninline T *&to_ptr(T const &)\n{\n    static T *t = 0;\n    return t;\n}\n\n// Borland needs a little extra help with arrays\n#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\ntemplate<typename T,std::size_t N>\ninline T (*&to_ptr(T (&)[N]))[N]\n{\n    static T (*t)[N] = 0;\n    return t;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// derefof\n//\ntemplate<typename T>\ninline T &derefof(T *t)\n{\n    // This is a work-around for a compiler bug in Borland. If T* is a pointer to array type U(*)[N],\n    // then dereferencing it results in a U* instead of U(&)[N]. The cast forces the issue.\n    return reinterpret_cast<T &>(\n        *const_cast<char *>(\n            reinterpret_cast<char const volatile *>(t)\n        )\n    );\n}\n\n# define BOOST_FOREACH_DEREFOF(T) boost::foreach_detail_::derefof(*T)\n#else\n# define BOOST_FOREACH_DEREFOF(T) (*T)\n#endif\n\n#if defined(BOOST_FOREACH_COMPILE_TIME_CONST_RVALUE_DETECTION)                                  \\\n && !defined(BOOST_NO_CXX11_RVALUE_REFERENCES)\n///////////////////////////////////////////////////////////////////////////////\n// Rvalue references makes it drop-dead simple to detect at compile time\n// whether an expression is an rvalue.\n///////////////////////////////////////////////////////////////////////////////\n\n# define BOOST_FOREACH_IS_RVALUE(COL)                                                           \\\n    boost::foreach_detail_::is_rvalue_((COL), 0)\n\n#elif defined(BOOST_FOREACH_COMPILE_TIME_CONST_RVALUE_DETECTION)                                \\\n && defined(BOOST_NO_CXX11_RVALUE_REFERENCES)\n///////////////////////////////////////////////////////////////////////////////\n// Detect at compile-time whether an expression yields an rvalue or\n// an lvalue. This is rather non-standard, but some popular compilers\n// accept it.\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n// rvalue_probe\n//\ntemplate<typename T>\nstruct rvalue_probe\n{\n    struct private_type_ {};\n    // can't ever return an array by value\n    typedef BOOST_DEDUCED_TYPENAME boost::mpl::if_<\n        boost::mpl::or_<boost::is_abstract<T>, boost::is_array<T> >, private_type_, T\n    >::type value_type;\n    operator value_type() { return *reinterpret_cast<value_type *>(this); } // never called\n    operator T &() const { return *reinterpret_cast<T *>(const_cast<rvalue_probe *>(this)); } // never called\n};\n\ntemplate<typename T>\nrvalue_probe<T> const make_probe(T const &)\n{\n    return rvalue_probe<T>();\n}\n\n# define BOOST_FOREACH_IS_RVALUE(COL)                                                           \\\n    boost::foreach_detail_::and_(                                                               \\\n        boost::foreach_detail_::not_(boost::foreach_detail_::is_array_(COL))                    \\\n      , (true ? 0 : boost::foreach_detail_::is_rvalue_(                                         \\\n            (true ? boost::foreach_detail_::make_probe(COL) : (COL)), 0)))\n\n#elif defined(BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION)\n///////////////////////////////////////////////////////////////////////////////\n// Detect at run-time whether an expression yields an rvalue\n// or an lvalue. This is 100% standard C++, but not all compilers\n// accept it. Also, it causes FOREACH to break when used with non-\n// copyable collection types.\n///////////////////////////////////////////////////////////////////////////////\n\n///////////////////////////////////////////////////////////////////////////////\n// rvalue_probe\n//\ntemplate<typename T>\nstruct rvalue_probe\n{\n    rvalue_probe(T &t, bool &b)\n      : value(t)\n      , is_rvalue(b)\n    {\n    }\n\n    struct private_type_ {};\n    // can't ever return an array or an abstract type by value\n    #ifdef BOOST_NO_IS_ABSTRACT\n    typedef BOOST_DEDUCED_TYPENAME boost::mpl::if_<\n        boost::is_array<T>, private_type_, T\n    >::type value_type;\n    #else\n    typedef BOOST_DEDUCED_TYPENAME boost::mpl::if_<\n        boost::mpl::or_<boost::is_abstract<T>, boost::is_array<T> >, private_type_, T\n    >::type value_type;\n    #endif\n    \n    operator value_type()\n    {\n        this->is_rvalue = true;\n        return this->value;\n    }\n\n    operator T &() const\n    {\n        return this->value;\n    }\n\nprivate:\n    T &value;\n    bool &is_rvalue;\n};\n\ntemplate<typename T>\nrvalue_probe<T> make_probe(T &t, bool &b) { return rvalue_probe<T>(t, b); }\n\ntemplate<typename T>\nrvalue_probe<T const> make_probe(T const &t, bool &b)  { return rvalue_probe<T const>(t, b); }\n\n///////////////////////////////////////////////////////////////////////////////\n// simple_variant\n//  holds either a T or a T const*\ntemplate<typename T>\nstruct simple_variant\n{\n    simple_variant(T const *t)\n      : is_rvalue(false)\n    {\n        *static_cast<T const **>(this->data.address()) = t;\n    }\n\n    simple_variant(T const &t)\n      : is_rvalue(true)\n    {\n        ::new(this->data.address()) T(t);\n    }\n\n    simple_variant(simple_variant const &that)\n      : is_rvalue(that.is_rvalue)\n    {\n        if(this->is_rvalue)\n            ::new(this->data.address()) T(*that.get());\n        else\n            *static_cast<T const **>(this->data.address()) = that.get();\n    }\n\n    ~simple_variant()\n    {\n        if(this->is_rvalue)\n            this->get()->~T();\n    }\n\n    T const *get() const\n    {\n        if(this->is_rvalue)\n            return static_cast<T const *>(this->data.address());\n        else\n            return *static_cast<T const * const *>(this->data.address());\n    }\n\nprivate:\n    enum size_type { size = sizeof(T) > sizeof(T*) ? sizeof(T) : sizeof(T*) };\n    simple_variant &operator =(simple_variant const &); \n    bool const is_rvalue;\n    aligned_storage<size> data;\n};\n\n// If the collection is an array or is noncopyable, it must be an lvalue.\n// If the collection is a lightweight proxy, treat it as an rvalue\n// BUGBUG what about a noncopyable proxy?\ntemplate<typename LValue, typename IsProxy>\ninline BOOST_DEDUCED_TYPENAME boost::enable_if<boost::mpl::or_<LValue, IsProxy>, IsProxy>::type *\nshould_copy_impl(LValue *, IsProxy *, bool *)\n{\n    return 0;\n}\n\n// Otherwise, we must determine at runtime whether it's an lvalue or rvalue\ninline bool *\nshould_copy_impl(boost::mpl::false_ *, boost::mpl::false_ *, bool *is_rvalue)\n{\n    return is_rvalue;\n}\n\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// contain\n//\ntemplate<typename T>\ninline auto_any<T> contain(T const &t, boost::mpl::true_ *) // rvalue\n{\n    return auto_any<T>(t);\n}\n\ntemplate<typename T>\ninline auto_any<T *> contain(T &t, boost::mpl::false_ *) // lvalue\n{\n    // Cannot seem to get sunpro to handle addressof() with array types.\n    #if BOOST_WORKAROUND(__SUNPRO_CC, BOOST_TESTED_AT(0x570))\n    return auto_any<T *>(&t);\n    #else\n    return auto_any<T *>(boost::addressof(t));\n    #endif\n}\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\ntemplate<typename T>\ninline auto_any<simple_variant<T> >\ncontain(T const &t, bool *rvalue)\n{\n    return auto_any<simple_variant<T> >(*rvalue ? simple_variant<T>(t) : simple_variant<T>(&t));\n}\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// begin\n//\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>\nbegin(auto_any_t col, type2type<T, C> *, boost::mpl::true_ *) // rvalue\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>(\n        boost::begin(auto_any_cast<T, C>(col)));\n}\n\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>\nbegin(auto_any_t col, type2type<T, C> *, boost::mpl::false_ *) // lvalue\n{\n    typedef BOOST_DEDUCED_TYPENAME type2type<T, C>::type type;\n    typedef BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type iterator;\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>(\n        iterator(boost::begin(BOOST_FOREACH_DEREFOF((auto_any_cast<type *, boost::mpl::false_>(col))))));\n}\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\ntemplate<typename T>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, const_>::type>\nbegin(auto_any_t col, type2type<T, const_> *, bool *)\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, const_>::type>(\n        boost::begin(*auto_any_cast<simple_variant<T>, boost::mpl::false_>(col).get()));\n}\n#endif\n\n#ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\ntemplate<typename T, typename C>\ninline auto_any<T *>\nbegin(auto_any_t col, type2type<T *, C> *, boost::mpl::true_ *) // null-terminated C-style strings\n{\n    return auto_any<T *>(auto_any_cast<T *, boost::mpl::false_>(col));\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// end\n//\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>\nend(auto_any_t col, type2type<T, C> *, boost::mpl::true_ *) // rvalue\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>(\n        boost::end(auto_any_cast<T, C>(col)));\n}\n\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>\nend(auto_any_t col, type2type<T, C> *, boost::mpl::false_ *) // lvalue\n{\n    typedef BOOST_DEDUCED_TYPENAME type2type<T, C>::type type;\n    typedef BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type iterator;\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type>(\n        iterator(boost::end(BOOST_FOREACH_DEREFOF((auto_any_cast<type *, boost::mpl::false_>(col))))));\n}\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\ntemplate<typename T>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, const_>::type>\nend(auto_any_t col, type2type<T, const_> *, bool *)\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_iterator<T, const_>::type>(\n        boost::end(*auto_any_cast<simple_variant<T>, boost::mpl::false_>(col).get()));\n}\n#endif\n\n#ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\ntemplate<typename T, typename C>\ninline auto_any<int>\nend(auto_any_t, type2type<T *, C> *, boost::mpl::true_ *) // null-terminated C-style strings\n{\n    return auto_any<int>(0); // not used\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// done\n//\ntemplate<typename T, typename C>\ninline bool done(auto_any_t cur, auto_any_t end, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type iter_t;\n    return auto_any_cast<iter_t, boost::mpl::false_>(cur) == auto_any_cast<iter_t, boost::mpl::false_>(end);\n}\n\n#ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\ntemplate<typename T, typename C>\ninline bool done(auto_any_t cur, auto_any_t, type2type<T *, C> *) // null-terminated C-style strings\n{\n    return ! *auto_any_cast<T *, boost::mpl::false_>(cur);\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// next\n//\ntemplate<typename T, typename C>\ninline void next(auto_any_t cur, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type iter_t;\n    ++auto_any_cast<iter_t, boost::mpl::false_>(cur);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// deref\n//\ntemplate<typename T, typename C>\ninline BOOST_DEDUCED_TYPENAME foreach_reference<T, C>::type\nderef(auto_any_t cur, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_iterator<T, C>::type iter_t;\n    return *auto_any_cast<iter_t, boost::mpl::false_>(cur);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// rbegin\n//\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>\nrbegin(auto_any_t col, type2type<T, C> *, boost::mpl::true_ *) // rvalue\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>(\n        boost::rbegin(auto_any_cast<T, C>(col)));\n}\n\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>\nrbegin(auto_any_t col, type2type<T, C> *, boost::mpl::false_ *) // lvalue\n{\n    typedef BOOST_DEDUCED_TYPENAME type2type<T, C>::type type;\n    typedef BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type iterator;\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>(\n        iterator(boost::rbegin(BOOST_FOREACH_DEREFOF((auto_any_cast<type *, boost::mpl::false_>(col))))));\n}\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\ntemplate<typename T>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, const_>::type>\nrbegin(auto_any_t col, type2type<T, const_> *, bool *)\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, const_>::type>(\n        boost::rbegin(*auto_any_cast<simple_variant<T>, boost::mpl::false_>(col).get()));\n}\n#endif\n\n#ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\ntemplate<typename T, typename C>\ninline auto_any<reverse_iterator<T *> >\nrbegin(auto_any_t col, type2type<T *, C> *, boost::mpl::true_ *) // null-terminated C-style strings\n{\n    T *p = auto_any_cast<T *, boost::mpl::false_>(col);\n    while(0 != *p)\n        ++p;\n    return auto_any<reverse_iterator<T *> >(reverse_iterator<T *>(p));\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// rend\n//\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>\nrend(auto_any_t col, type2type<T, C> *, boost::mpl::true_ *) // rvalue\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>(\n        boost::rend(auto_any_cast<T, C>(col)));\n}\n\ntemplate<typename T, typename C>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>\nrend(auto_any_t col, type2type<T, C> *, boost::mpl::false_ *) // lvalue\n{\n    typedef BOOST_DEDUCED_TYPENAME type2type<T, C>::type type;\n    typedef BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type iterator;\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type>(\n        iterator(boost::rend(BOOST_FOREACH_DEREFOF((auto_any_cast<type *, boost::mpl::false_>(col))))));\n}\n\n#ifdef BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION\ntemplate<typename T>\ninline auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, const_>::type>\nrend(auto_any_t col, type2type<T, const_> *, bool *)\n{\n    return auto_any<BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, const_>::type>(\n        boost::rend(*auto_any_cast<simple_variant<T>, boost::mpl::false_>(col).get()));\n}\n#endif\n\n#ifndef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\ntemplate<typename T, typename C>\ninline auto_any<reverse_iterator<T *> >\nrend(auto_any_t col, type2type<T *, C> *, boost::mpl::true_ *) // null-terminated C-style strings\n{\n    return auto_any<reverse_iterator<T *> >(\n        reverse_iterator<T *>(auto_any_cast<T *, boost::mpl::false_>(col)));\n}\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// rdone\n//\ntemplate<typename T, typename C>\ninline bool rdone(auto_any_t cur, auto_any_t end, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type iter_t;\n    return auto_any_cast<iter_t, boost::mpl::false_>(cur) == auto_any_cast<iter_t, boost::mpl::false_>(end);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// rnext\n//\ntemplate<typename T, typename C>\ninline void rnext(auto_any_t cur, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type iter_t;\n    ++auto_any_cast<iter_t, boost::mpl::false_>(cur);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// rderef\n//\ntemplate<typename T, typename C>\ninline BOOST_DEDUCED_TYPENAME foreach_reference<T, C>::type\nrderef(auto_any_t cur, type2type<T, C> *)\n{\n    typedef BOOST_DEDUCED_TYPENAME foreach_reverse_iterator<T, C>::type iter_t;\n    return *auto_any_cast<iter_t, boost::mpl::false_>(cur);\n}\n\n} // namespace foreach_detail_\n} // namespace boost\n\n// Suppress a bogus code analysis warning on vc8+\n#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)\n# define BOOST_FOREACH_SUPPRESS_WARNINGS() __pragma(warning(suppress:6001))\n#else\n# define BOOST_FOREACH_SUPPRESS_WARNINGS()\n#endif\n\n///////////////////////////////////////////////////////////////////////////////\n// Define a macro for giving hidden variables a unique name. Not strictly\n// needed, but eliminates some warnings on some compilers.\n#if BOOST_WORKAROUND(BOOST_MSVC, BOOST_TESTED_AT(1500))\n// With some versions of MSVC, use of __LINE__ to create unique identifiers\n// can fail when the Edit-and-Continue debug flag is used.\n# define BOOST_FOREACH_ID(x) x\n#else\n# define BOOST_FOREACH_ID(x) BOOST_PP_CAT(x, __LINE__)\n#endif\n\n// A sneaky way to get the type of the collection without evaluating the expression\n#define BOOST_FOREACH_TYPEOF(COL)                                                               \\\n    (true ? 0 : boost::foreach_detail_::encode_type(COL, boost::foreach_detail_::is_const_(COL)))\n\n// returns true_* if the type is noncopyable\n#define BOOST_FOREACH_IS_NONCOPYABLE(COL)                                                       \\\n    boost_foreach_is_noncopyable(                                                               \\\n        boost::foreach_detail_::to_ptr(COL)                                                     \\\n      , boost_foreach_argument_dependent_lookup_hack_value)\n\n// returns true_* if the type is a lightweight proxy (and is not noncopyable)\n#define BOOST_FOREACH_IS_LIGHTWEIGHT_PROXY(COL)                                                 \\\n    boost::foreach_detail_::and_(                                                               \\\n        boost::foreach_detail_::not_(BOOST_FOREACH_IS_NONCOPYABLE(COL))                         \\\n      , boost_foreach_is_lightweight_proxy(                                                     \\\n            boost::foreach_detail_::to_ptr(COL)                                                 \\\n          , boost_foreach_argument_dependent_lookup_hack_value))\n\n#if defined(BOOST_FOREACH_COMPILE_TIME_CONST_RVALUE_DETECTION)\n///////////////////////////////////////////////////////////////////////////////\n// R-values and const R-values supported here with zero runtime overhead\n///////////////////////////////////////////////////////////////////////////////\n\n// No variable is needed to track the rvalue-ness of the collection expression\n# define BOOST_FOREACH_PREAMBLE()                                                               \\\n    BOOST_FOREACH_SUPPRESS_WARNINGS()\n\n// Evaluate the collection expression\n# define BOOST_FOREACH_EVALUATE(COL)                                                            \\\n    (COL)\n\n# define BOOST_FOREACH_SHOULD_COPY(COL)                                                         \\\n    (true ? 0 : boost::foreach_detail_::or_(                                                    \\\n        BOOST_FOREACH_IS_RVALUE(COL)                                                            \\\n      , BOOST_FOREACH_IS_LIGHTWEIGHT_PROXY(COL)))\n\n#elif defined(BOOST_FOREACH_RUN_TIME_CONST_RVALUE_DETECTION)\n///////////////////////////////////////////////////////////////////////////////\n// R-values and const R-values supported here\n///////////////////////////////////////////////////////////////////////////////\n\n// Declare a variable to track the rvalue-ness of the collection expression\n# define BOOST_FOREACH_PREAMBLE()                                                               \\\n    BOOST_FOREACH_SUPPRESS_WARNINGS()                                                           \\\n    if (bool BOOST_FOREACH_ID(_foreach_is_rvalue) = false) {} else\n\n// Evaluate the collection expression, and detect if it is an lvalue or and rvalue\n# define BOOST_FOREACH_EVALUATE(COL)                                                            \\\n    (true ? boost::foreach_detail_::make_probe((COL), BOOST_FOREACH_ID(_foreach_is_rvalue)) : (COL))\n\n// The rvalue/lvalue-ness of the collection expression is determined dynamically, unless\n// the type is an array or is noncopyable or is non-const, in which case we know it's an lvalue.\n// If the type happens to be a lightweight proxy, always make a copy.\n# define BOOST_FOREACH_SHOULD_COPY(COL)                                                         \\\n    (boost::foreach_detail_::should_copy_impl(                                                  \\\n        true ? 0 : boost::foreach_detail_::or_(                                                 \\\n            boost::foreach_detail_::is_array_(COL)                                              \\\n          , BOOST_FOREACH_IS_NONCOPYABLE(COL)                                                   \\\n          , boost::foreach_detail_::not_(boost::foreach_detail_::is_const_(COL)))               \\\n      , true ? 0 : BOOST_FOREACH_IS_LIGHTWEIGHT_PROXY(COL)                                      \\\n      , &BOOST_FOREACH_ID(_foreach_is_rvalue)))\n\n#elif !defined(BOOST_FOREACH_NO_RVALUE_DETECTION)\n///////////////////////////////////////////////////////////////////////////////\n// R-values supported here, const R-values NOT supported here\n///////////////////////////////////////////////////////////////////////////////\n\n// No variable is needed to track the rvalue-ness of the collection expression\n# define BOOST_FOREACH_PREAMBLE()                                                               \\\n    BOOST_FOREACH_SUPPRESS_WARNINGS()\n\n// Evaluate the collection expression\n# define BOOST_FOREACH_EVALUATE(COL)                                                            \\\n    (COL)\n\n// Determine whether the collection expression is an lvalue or an rvalue.\n// NOTE: this gets the answer wrong for const rvalues.\n# define BOOST_FOREACH_SHOULD_COPY(COL)                                                         \\\n    (true ? 0 : boost::foreach_detail_::or_(                                                    \\\n        boost::foreach_detail_::is_rvalue_((COL), 0)                                            \\\n      , BOOST_FOREACH_IS_LIGHTWEIGHT_PROXY(COL)))\n\n#else\n///////////////////////////////////////////////////////////////////////////////\n// R-values NOT supported here\n///////////////////////////////////////////////////////////////////////////////\n\n// No variable is needed to track the rvalue-ness of the collection expression\n# define BOOST_FOREACH_PREAMBLE()                                                               \\\n    BOOST_FOREACH_SUPPRESS_WARNINGS()\n\n// Evaluate the collection expression\n# define BOOST_FOREACH_EVALUATE(COL)                                                            \\\n    (COL)\n\n// Can't use rvalues with BOOST_FOREACH (unless they are lightweight proxies)\n# define BOOST_FOREACH_SHOULD_COPY(COL)                                                         \\\n    (true ? 0 : BOOST_FOREACH_IS_LIGHTWEIGHT_PROXY(COL))\n\n#endif\n\n#define BOOST_FOREACH_CONTAIN(COL)                                                              \\\n    boost::foreach_detail_::contain(                                                            \\\n        BOOST_FOREACH_EVALUATE(COL)                                                             \\\n      , BOOST_FOREACH_SHOULD_COPY(COL))\n\n#define BOOST_FOREACH_BEGIN(COL)                                                                \\\n    boost::foreach_detail_::begin(                                                              \\\n        BOOST_FOREACH_ID(_foreach_col)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL)                                                               \\\n      , BOOST_FOREACH_SHOULD_COPY(COL))\n\n#define BOOST_FOREACH_END(COL)                                                                  \\\n    boost::foreach_detail_::end(                                                                \\\n        BOOST_FOREACH_ID(_foreach_col)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL)                                                               \\\n      , BOOST_FOREACH_SHOULD_COPY(COL))\n\n#define BOOST_FOREACH_DONE(COL)                                                                 \\\n    boost::foreach_detail_::done(                                                               \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_ID(_foreach_end)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n#define BOOST_FOREACH_NEXT(COL)                                                                 \\\n    boost::foreach_detail_::next(                                                               \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n#define BOOST_FOREACH_DEREF(COL)                                                                \\\n    boost::foreach_detail_::deref(                                                              \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n#define BOOST_FOREACH_RBEGIN(COL)                                                               \\\n    boost::foreach_detail_::rbegin(                                                             \\\n        BOOST_FOREACH_ID(_foreach_col)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL)                                                               \\\n      , BOOST_FOREACH_SHOULD_COPY(COL))\n\n#define BOOST_FOREACH_REND(COL)                                                                 \\\n    boost::foreach_detail_::rend(                                                               \\\n        BOOST_FOREACH_ID(_foreach_col)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL)                                                               \\\n      , BOOST_FOREACH_SHOULD_COPY(COL))\n\n#define BOOST_FOREACH_RDONE(COL)                                                                \\\n    boost::foreach_detail_::rdone(                                                              \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_ID(_foreach_end)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n#define BOOST_FOREACH_RNEXT(COL)                                                                \\\n    boost::foreach_detail_::rnext(                                                              \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n#define BOOST_FOREACH_RDEREF(COL)                                                               \\\n    boost::foreach_detail_::rderef(                                                             \\\n        BOOST_FOREACH_ID(_foreach_cur)                                                          \\\n      , BOOST_FOREACH_TYPEOF(COL))\n\n///////////////////////////////////////////////////////////////////////////////\n// BOOST_FOREACH\n//\n//   For iterating over collections. Collections can be\n//   arrays, null-terminated strings, or STL containers.\n//   The loop variable can be a value or reference. For\n//   example:\n//\n//   std::list<int> int_list(/*stuff*/);\n//   BOOST_FOREACH(int &i, int_list)\n//   {\n//       /* \n//        * loop body goes here.\n//        * i is a reference to the int in int_list.\n//        */\n//   }\n//\n//   Alternately, you can declare the loop variable first,\n//   so you can access it after the loop finishes. Obviously,\n//   if you do it this way, then the loop variable cannot be\n//   a reference.\n//\n//   int i;\n//   BOOST_FOREACH(i, int_list)\n//       { ... }\n//\n#define BOOST_FOREACH(VAR, COL)                                                                                   \\\n    BOOST_FOREACH_PREAMBLE()                                                                                      \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_col) = BOOST_FOREACH_CONTAIN(COL)) {} else   \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_cur) = BOOST_FOREACH_BEGIN(COL)) {} else     \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_end) = BOOST_FOREACH_END(COL)) {} else       \\\n    for (bool BOOST_FOREACH_ID(_foreach_continue) = true;                                                         \\\n              BOOST_FOREACH_ID(_foreach_continue) && !BOOST_FOREACH_DONE(COL);                                    \\\n              BOOST_FOREACH_ID(_foreach_continue) ? BOOST_FOREACH_NEXT(COL) : (void)0)                            \\\n        if  (boost::foreach_detail_::set_false(BOOST_FOREACH_ID(_foreach_continue))) {} else                      \\\n        for (VAR = BOOST_FOREACH_DEREF(COL); !BOOST_FOREACH_ID(_foreach_continue); BOOST_FOREACH_ID(_foreach_continue) = true)\n\n///////////////////////////////////////////////////////////////////////////////\n// BOOST_REVERSE_FOREACH\n//\n//   For iterating over collections in reverse order. In\n//   all other respects, BOOST_REVERSE_FOREACH is like\n//   BOOST_FOREACH.\n//\n#define BOOST_REVERSE_FOREACH(VAR, COL)                                                                           \\\n    BOOST_FOREACH_PREAMBLE()                                                                                      \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_col) = BOOST_FOREACH_CONTAIN(COL)) {} else   \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_cur) = BOOST_FOREACH_RBEGIN(COL)) {} else    \\\n    if (boost::foreach_detail_::auto_any_t BOOST_FOREACH_ID(_foreach_end) = BOOST_FOREACH_REND(COL)) {} else      \\\n    for (bool BOOST_FOREACH_ID(_foreach_continue) = true;                                                         \\\n              BOOST_FOREACH_ID(_foreach_continue) && !BOOST_FOREACH_RDONE(COL);                                   \\\n              BOOST_FOREACH_ID(_foreach_continue) ? BOOST_FOREACH_RNEXT(COL) : (void)0)                           \\\n        if  (boost::foreach_detail_::set_false(BOOST_FOREACH_ID(_foreach_continue))) {} else                      \\\n        for (VAR = BOOST_FOREACH_RDEREF(COL); !BOOST_FOREACH_ID(_foreach_continue); BOOST_FOREACH_ID(_foreach_continue) = true)\n\n#endif\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        __base::clear();\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __move_construct_at_end(pointer __first, pointer __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __base::__destruct_at_end(__new_last);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_construct_at_end(pointer __first, pointer __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__first));\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __base::__move_assign_alloc(__c);\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __move_range(__p, __old_last, __p + __old_n);\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __move_range(__p, __old_last, __p + __old_n);\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~(__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __move_assign_alloc(__c);\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// Copyright (c) 2013 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/// @file hello_tutorial.cc\n/// This example demonstrates loading, running and scripting a very simple NaCl\n/// module.  To load the NaCl module, the browser first looks for the\n/// CreateModule() factory method (at the end of this file).  It calls\n/// CreateModule() once to load the module code.  After the code is loaded,\n/// CreateModule() is not called again.\n///\n/// Once the code is loaded, the browser calls the CreateInstance()\n/// method on the object returned by CreateModule().  It calls CreateInstance()\n/// each time it encounters an <embed> tag that references your NaCl module.\n///\n/// The browser can talk to your NaCl module via the postMessage() Javascript\n/// function.  When you call postMessage() on your NaCl module from the browser,\n/// this becomes a call to the HandleMessage() method of your pp::Instance\n/// subclass.  You can send messages back to the browser by calling the\n/// PostMessage() method on your pp::Instance.  Note that these two methods\n/// (postMessage() in Javascript and PostMessage() in C++) are asynchronous.\n/// This means they return immediately - there is no waiting for the message\n/// to be handled.  This has implications in your program design, particularly\n/// when mutating property values that are exposed to both the browser and the\n/// NaCl module.\n\n#include \"ppapi/cpp/instance.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/var.h\"\n#include \"clipper.hpp\"\n\n#include \"src/voronoidiagram.hpp\"\n#include \"src/offset.hpp\"\n#include \"src/utility/vd2svg.hpp\"\n\nnamespace {\n    // The expected string sent by the browser.\n    const char* const kHelloString = \"hello\";\n    // The string sent back to the browser upon receipt of a message\n    // containing \"hello\".\n   // const char* const kReplyString = \"hello from NaCl\";\n} // namespace\n\n\n/// The Instance class.  One of these exists for each instance of your NaCl\n/// module on the web page.  The browser will ask the Module object to create\n/// a new Instance for each occurrence of the <embed> tag that has these\n/// attributes:\n///     src=\"hello_tutorial.nmf\"\n///     type=\"application/x-pnacl\"\n/// To communicate with the browser, you must override HandleMessage() to\n/// receive messages from the browser, and use PostMessage() to send messages\n/// back to the browser.  Note that this interface is asynchronous.\nclass HelloTutorialInstance : public pp::Instance {\n public:\n  /// The constructor creates the plugin-side instance.\n  /// @param[in] instance the handle to the browser-side plugin instance.\n  explicit HelloTutorialInstance(PP_Instance instance) : pp::Instance(instance)\n  {}\n  virtual ~HelloTutorialInstance() {}\n\n  /// Handler for messages coming in from the browser via postMessage().  The\n  /// @a var_message can contain be any pp:Var type; for example int, string\n  /// Array or Dictinary. Please see the pp:Var documentation for more details.\n  /// @param[in] var_message The message posted by the browser.\n  virtual void HandleMessage(const pp::Var& var_message) {\n      ClipperLib::Clipper clipper;\n      if (!var_message.is_string())\n        return;\n      std::string message = var_message.AsString();\n\n\n      ovd::VoronoiDiagram* vd = new ovd::VoronoiDiagram(1,100); // (r, bins)\n      ovd::Point p0(-0.1,-0.2);\n      ovd::Point p1(0.2,0.1);\n      ovd::Point p2(0.4,0.2);\n      ovd::Point p3(0.6,0.6);\n      ovd::Point p4(-0.6,0.3);\n\n      int id0 = vd->insert_point_site(p0);\n      int id1 = vd->insert_point_site(p1);\n      int id2 = vd->insert_point_site(p2);\n      int id3 = vd->insert_point_site(p3);\n      int id4 = vd->insert_point_site(p4);\n\n      vd->insert_line_site(id0, id1);\n      vd->insert_line_site(id1, id2);\n      vd->insert_line_site(id2, id3);\n      vd->insert_line_site(id3, id4);\n      vd->insert_line_site(id4, id0);\n      vd->check();\n\n      ovd::HEGraph& g = vd->get_graph_reference();\n\n      // save drawing to svg file.\n      svg::Dimensions dimensions(1024, 1024);\n      svg::Document doc(\"basic_offset.svg\", svg::Layout(dimensions, svg::Layout::BottomLeft));\n      BOOST_FOREACH( ovd::HEEdge e, g.edges() ) {\n                      write_edge_to_svg(g,doc,e);\n                  }\n\n      // draw four offsets.\n      svg::Color line_color( svg::Color::Lime );\n      svg::Color arc_color( svg::Color::Green );\n      ovd::Offset offset(g);\n      for (int i=1; i<5; i++) {\n          ovd::OffsetLoops offset_list = offset.offset(i*0.008);\n          BOOST_FOREACH( ovd::OffsetLoop loop, offset_list ) { // loop through each loop\n                          bool first = true;\n                          ovd::Point previous;\n                          BOOST_FOREACH( ovd::OffsetVertex lpt, loop.vertices ) { // loop through each line/arc\n                                          if (first) {\n                                              first = false;\n                                              previous = lpt.p;\n                                          } else {\n                                              if (lpt.r == -1.) {\n                                                  write_line_to_svg(g,doc,previous,lpt.p,line_color);\n                                              } else {\n                                                  write_arc_to_svg(g,doc,previous,lpt.p,lpt.r,lpt.c,lpt.cw,arc_color);\n                                              }\n                                              previous = lpt.p;                                          }\n                                      }\n                      }\n      }\n\n\n\n\n      pp::Var var_reply;\n      if (message == kHelloString) {\n          var_reply = pp::Var(doc.toString());\n          PostMessage(var_reply);\n      }\n  }\n};\n\n/// The Module class.  The browser calls the CreateInstance() method to create\n/// an instance of your NaCl module on the web page.  The browser creates a new\n/// instance for each <embed> tag with type=\"application/x-pnacl\".\nclass HelloTutorialModule : public pp::Module {\n public:\n  HelloTutorialModule() : pp::Module() {}\n  virtual ~HelloTutorialModule() {}\n\n  /// Create and return a HelloTutorialInstance object.\n  /// @param[in] instance The browser-side instance.\n  /// @return the plugin-side instance.\n  virtual pp::Instance* CreateInstance(PP_Instance instance) {\n    return new HelloTutorialInstance(instance);\n  }\n};\n\nnamespace pp {\n/// Factory function called by the browser when the module is first loaded.\n/// The browser keeps a singleton of this module.  It calls the\n/// CreateInstance() method on the object you return to make instances.  There\n/// is one instance per <embed> tag on the page.  This is the main binding\n/// point for your NaCl module with the browser.\nModule* CreateModule() {\n  return new HelloTutorialModule();\n}\n}  // namespace pp\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct ____iterator_traits {};\n\ntemplate <class _Iter>\nstruct ____iterator_traits<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  ____iterator_traits\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {__t = current; return *--__t;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(&__x) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(&__x), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// Boost.Range library\n//\n//  Copyright Thorsten Ottosen 2003-2004. Use, modification and\n//  distribution is subject to the Boost Software License, Version\n//  1.0. (See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n// For more information, see http://www.boost.org/libs/range/\n//\n\n#ifndef BOOST_RANGE_END_HPP\n#define BOOST_RANGE_END_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include <boost/range/config.hpp>\n\n#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\n#include <boost/range/detail/end.hpp>\n#else\n\n#include <boost/range/detail/implementation_help.hpp>\n#include <boost/range/iterator.hpp>\n#include <boost/range/const_iterator.hpp>\n\nnamespace boost\n{\n\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\nnamespace range_detail\n{\n#endif\n\n        //////////////////////////////////////////////////////////////////////\n        // primary template\n        //////////////////////////////////////////////////////////////////////\n        template< typename C >\n        inline BOOST_DEDUCED_TYPENAME range_iterator<C>::type\n        range_end( C& c )\n        {\n            //\n            // If you get a compile-error here, it is most likely because\n            // you have not implemented range_begin() properly in\n            // the namespace of C\n            //\n            return c.end();\n        }\n\n        //////////////////////////////////////////////////////////////////////\n        // pair\n        //////////////////////////////////////////////////////////////////////\n\n        template< typename Iterator >\n        inline Iterator range_end( const std::pair<Iterator,Iterator>& p )\n        {\n            return p.second;\n        }\n\n        template< typename Iterator >\n        inline Iterator range_end( std::pair<Iterator,Iterator>& p )\n        {\n            return p.second;\n        }\n\n        //////////////////////////////////////////////////////////////////////\n        // array\n        //////////////////////////////////////////////////////////////////////\n\n        template< typename T, std::size_t sz >\n        inline const T* range_end( const T (&a)[sz] )\n        {\n            return range_detail::array_end<T,sz>( a );\n        }\n\n        template< typename T, std::size_t sz >\n        inline T* range_end( T (&a)[sz] )\n        {\n            return range_detail::array_end<T,sz>( a );\n        }\n\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n} // namespace 'range_detail'\n#endif\n\nnamespace range_adl_barrier\n{\n\ntemplate< class T >\ninline BOOST_DEDUCED_TYPENAME range_iterator<T>::type end( T& r )\n{\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n    using namespace range_detail;\n#endif\n    return range_end( r );\n}\n\ntemplate< class T >\ninline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type end( const T& r )\n{\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n    using namespace range_detail;\n#endif\n    return range_end( r );\n}\n\n    } // namespace range_adl_barrier\n} // namespace 'boost'\n\n#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING\n\nnamespace boost\n{\n    namespace range_adl_barrier\n    {\n        template< class T >\n        inline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type\n        const_end( const T& r )\n        {\n            return boost::range_adl_barrier::end( r );\n        }\n    } // namespace range_adl_barrier\n    using namespace range_adl_barrier;\n} // namespace boost\n\n#endif\n\n","//-----------------------------------------------------------------------------\n// boost aligned_storage.hpp header file\n// See http://www.boost.org for updates, documentation, and revision history.\n//-----------------------------------------------------------------------------\n//\n// Copyright (c) 2002-2003\n// Eric Friedman, Itay Maman\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_ALIGNED_STORAGE_HPP\n#define BOOST_ALIGNED_STORAGE_HPP\n\n#include <cstddef> // for std::size_t\n\n#include \"boost/config.hpp\"\n#include \"boost/detail/workaround.hpp\"\n#include \"boost/type_traits/alignment_of.hpp\"\n#include \"boost/type_traits/type_with_alignment.hpp\"\n#include \"boost/type_traits/is_pod.hpp\"\n\n#include \"boost/mpl/eval_if.hpp\"\n#include \"boost/mpl/identity.hpp\"\n\n#include \"boost/type_traits/detail/bool_trait_def.hpp\"\n\nnamespace boost {\n\nnamespace detail { namespace aligned_storage {\n\nBOOST_STATIC_CONSTANT(\n      std::size_t\n    , alignment_of_max_align = ::boost::alignment_of<max_align>::value\n    );\n\n//\n// To be TR1 conforming this must be a POD type:\n//\ntemplate <\n      std::size_t size_\n    , std::size_t alignment_\n>\nstruct aligned_storage_imp\n{\n    union data_t\n    {\n        char buf[size_];\n\n        typename mpl::eval_if_c<\n              alignment_ == std::size_t(-1)\n            , mpl::identity<detail::max_align>\n            , type_with_alignment<alignment_>\n            >::type align_;\n    } data_;\n    void* address() const { return const_cast<aligned_storage_imp*>(this); }\n};\n\ntemplate< std::size_t alignment_ >\nstruct aligned_storage_imp<0u,alignment_>\n{\n    /* intentionally empty */\n    void* address() const { return 0; }\n};\n\n}} // namespace detail::aligned_storage\n\ntemplate <\n      std::size_t size_\n    , std::size_t alignment_ = std::size_t(-1)\n>\nclass aligned_storage : \n#ifndef __BORLANDC__\n   private \n#else\n   public\n#endif\n   detail::aligned_storage::aligned_storage_imp<size_, alignment_> \n{\n \npublic: // constants\n\n    typedef detail::aligned_storage::aligned_storage_imp<size_, alignment_> type;\n\n    BOOST_STATIC_CONSTANT(\n          std::size_t\n        , size = size_\n        );\n    BOOST_STATIC_CONSTANT(\n          std::size_t\n        , alignment = (\n              alignment_ == std::size_t(-1)\n            ? ::boost::detail::aligned_storage::alignment_of_max_align\n            : alignment_\n            )\n        );\n\n#if defined(__GNUC__) &&\\\n    (__GNUC__ >  3) ||\\\n    (__GNUC__ == 3 && (__GNUC_MINOR__ >  2 ||\\\n                      (__GNUC_MINOR__ == 2 && __GNUC_PATCHLEVEL__ >=3)))\n\nprivate: // noncopyable\n\n    aligned_storage(const aligned_storage&);\n    aligned_storage& operator=(const aligned_storage&);\n\n#else // gcc less than 3.2.3\n\npublic: // _should_ be noncopyable, but GCC compiler emits error\n\n    aligned_storage(const aligned_storage&);\n    aligned_storage& operator=(const aligned_storage&);\n\n#endif // gcc < 3.2.3 workaround\n\npublic: // structors\n\n    aligned_storage()\n    {\n    }\n\n    ~aligned_storage()\n    {\n    }\n\npublic: // accessors\n\n    void* address()\n    {\n        return static_cast<type*>(this)->address();\n    }\n\n#if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n\n    const void* address() const\n    {\n        return static_cast<const type*>(this)->address();\n    }\n\n#else // MSVC6\n\n    const void* address() const;\n\n#endif // MSVC6 workaround\n\n};\n\n#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n\n// MSVC6 seems not to like inline functions with const void* returns, so we\n// declare the following here:\n\ntemplate <std::size_t S, std::size_t A>\nconst void* aligned_storage<S,A>::address() const\n{\n    return const_cast< aligned_storage<S,A>* >(this)->address();\n}\n\n#endif // MSVC6 workaround\n\n#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n//\n// Make sure that is_pod recognises aligned_storage<>::type\n// as a POD (Note that aligned_storage<> itself is not a POD):\n//\ntemplate <std::size_t size_, std::size_t alignment_>\nstruct is_pod<boost::detail::aligned_storage::aligned_storage_imp<size_,alignment_> >\n   BOOST_TT_AUX_BOOL_C_BASE(true)\n{ \n    BOOST_TT_AUX_BOOL_TRAIT_VALUE_DECL(true)\n}; \n#endif\n\n\n} // namespace boost\n\n#include \"boost/type_traits/detail/bool_trait_undef.hpp\"\n\n#endif // BOOST_ALIGNED_STORAGE_HPP\n","// Boost.Range library\n//\n//  Copyright Thorsten Ottosen 2003-2004. Use, modification and\n//  distribution is subject to the Boost Software License, Version\n//  1.0. (See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n// For more information, see http://www.boost.org/libs/range/\n//\n\n#ifndef BOOST_RANGE_BEGIN_HPP\n#define BOOST_RANGE_BEGIN_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1200)\n# pragma once\n#endif\n\n#include <boost/range/config.hpp>\n\n#ifdef BOOST_NO_FUNCTION_TEMPLATE_ORDERING\n#include <boost/range/detail/begin.hpp>\n#else\n\n#include <boost/range/iterator.hpp>\n\nnamespace boost\n{\n\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\nnamespace range_detail\n{\n#endif\n\n    //////////////////////////////////////////////////////////////////////\n    // primary template\n    //////////////////////////////////////////////////////////////////////\n\n    template< typename C >\n    inline BOOST_DEDUCED_TYPENAME range_iterator<C>::type\n    range_begin( C& c )\n    {\n        //\n        // If you get a compile-error here, it is most likely because\n        // you have not implemented range_begin() properly in\n        // the namespace of C\n        //\n        return c.begin();\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // pair\n    //////////////////////////////////////////////////////////////////////\n\n    template< typename Iterator >\n    inline Iterator range_begin( const std::pair<Iterator,Iterator>& p )\n    {\n        return p.first;\n    }\n\n    template< typename Iterator >\n    inline Iterator range_begin( std::pair<Iterator,Iterator>& p )\n    {\n        return p.first;\n    }\n\n    //////////////////////////////////////////////////////////////////////\n    // array\n    //////////////////////////////////////////////////////////////////////\n\n    //\n    // May this be discarded? Or is it needed for bad compilers?\n    //\n    template< typename T, std::size_t sz >\n    inline const T* range_begin( const T (&a)[sz] )\n    {\n        return a;\n    }\n\n    template< typename T, std::size_t sz >\n    inline T* range_begin( T (&a)[sz] )\n    {\n        return a;\n    }\n\n\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n} // namespace 'range_detail'\n#endif\n\n// Use a ADL namespace barrier to avoid ambiguity with other unqualified\n// calls. This is particularly important with C++0x encouraging\n// unqualified calls to begin/end.\nnamespace range_adl_barrier\n{\n\ntemplate< class T >\ninline BOOST_DEDUCED_TYPENAME range_iterator<T>::type begin( T& r )\n{\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n    using namespace range_detail;\n#endif\n    return range_begin( r );\n}\n\ntemplate< class T >\ninline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type begin( const T& r )\n{\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564)) && \\\n    !BOOST_WORKAROUND(__GNUC__, < 3) \\\n    /**/\n    using namespace range_detail;\n#endif\n    return range_begin( r );\n}\n\n    } // namespace range_adl_barrier\n} // namespace boost\n\n#endif // BOOST_NO_FUNCTION_TEMPLATE_ORDERING\n\nnamespace boost\n{\n    namespace range_adl_barrier\n    {\n        template< class T >\n        inline BOOST_DEDUCED_TYPENAME range_iterator<const T>::type\n        const_begin( const T& r )\n        {\n            return boost::range_adl_barrier::begin( r );\n        }\n    } // namespace range_adl_barrier\n\n    using namespace range_adl_barrier;\n} // namespace boost\n\n#endif\n\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(::operator new(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {::operator delete((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T1>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_scalar<_Ptr1>::value &&\n                                         !is_pointer<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, true>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value>::type\n             >\n    _LIBCPP_INLINE_VISIBILITY void reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        explicit shared_ptr(_Yp* __p);\n    template<class _Yp, class _Dp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a);\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp>&& __r);\n#else\n    template<class _Yp,\n             class = typename enable_if\n                     <\n                        is_convertible<_Yp*, element_type*>::value\n                     >::type\n            >\n        shared_ptr(auto_ptr<_Yp> __r);\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>&&,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             > shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n    template <class _Yp, class _Dp,\n                 class = typename enable_if\n                 <\n                    !is_array<_Yp>::value &&\n                    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value\n                 >::type\n             >\n       shared_ptr(unique_ptr<_Yp, _Dp>,\n       typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc, class>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r)\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r)\n#endif\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<!is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp, class>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n           typename enable_if<is_lvalue_reference<_Dp>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===--------------------------- cstddef ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CSTDDEF\n#define _LIBCPP_CSTDDEF\n\n/*\n    cstddef synopsis\n\nMacros:\n\n    offsetof(type,member-designator)\n    NULL\n\nnamespace std\n{\n\nTypes:\n\n    ptrdiff_t\n    size_t\n    max_align_t\n    nullptr_t\n\n}  // std\n\n*/\n\n#include <__config>\n\n#ifdef __GLIBC__\n#define __need_NULL\n#define __need_ptrdiff_t\n#define __need_size_t\n#endif  // __GLIBC__\n\n#include <stddef.h>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::ptrdiff_t;\nusing ::size_t;\n\ntypedef long double max_align_t;\n\n#ifdef _LIBCPP_HAS_NO_NULLPTR\n\nstruct _LIBCPP_TYPE_VIS_ONLY nullptr_t\n{\n    void* __lx;\n\n    struct __nat {int __for_bool_;};\n\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t() : __lx(0) {}\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t(int __nat::*) : __lx(0) {}\n\n    _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR operator int __nat::*() const {return 0;}\n\n    template <class _Tp>\n        _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR\n        operator _Tp* () const {return 0;}\n\n    template <class _Tp, class _Up>\n        _LIBCPP_ALWAYS_INLINE\n        operator _Tp _Up::* () const {return 0;}\n\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator==(nullptr_t, nullptr_t) {return true;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator!=(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator<(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator<=(nullptr_t, nullptr_t) {return true;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator>(nullptr_t, nullptr_t) {return false;}\n    friend _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR bool operator>=(nullptr_t, nullptr_t) {return true;}\n};\n\ninline _LIBCPP_ALWAYS_INLINE _LIBCPP_CONSTEXPR nullptr_t __get_nullptr_t() {return nullptr_t(0);}\n\n#define nullptr _VSTD::__get_nullptr_t()\n\n#endif  // _LIBCPP_HAS_NO_NULLPTR\n\n_LIBCPP_END_NAMESPACE_STD\n\n#ifndef _LIBCPP_HAS_NO_NULLPTR\n\nnamespace std\n{\n    typedef decltype(nullptr) nullptr_t;\n}\n\n#endif  // _LIBCPP_HAS_NO_NULLPTR\n\n#endif  // _LIBCPP_CSTDDEF\n","// -*- C++ -*-\n//===---------------------------- limits ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIMITS\n#define _LIBCPP_LIMITS\n\n/*\n    limits synopsis\n\nnamespace std\n{\n\ntemplate<class T>\nclass numeric_limits\n{\npublic:\n    static constexpr bool is_specialized = false;\n    static constexpr T min() noexcept;\n    static constexpr T max() noexcept;\n    static constexpr T lowest() noexcept;\n\n    static constexpr int  digits = 0;\n    static constexpr int  digits10 = 0;\n    static constexpr int  max_digits10 = 0;\n    static constexpr bool is_signed = false;\n    static constexpr bool is_integer = false;\n    static constexpr bool is_exact = false;\n    static constexpr int  radix = 0;\n    static constexpr T epsilon() noexcept;\n    static constexpr T round_error() noexcept;\n\n    static constexpr int  min_exponent = 0;\n    static constexpr int  min_exponent10 = 0;\n    static constexpr int  max_exponent = 0;\n    static constexpr int  max_exponent10 = 0;\n\n    static constexpr bool has_infinity = false;\n    static constexpr bool has_quiet_NaN = false;\n    static constexpr bool has_signaling_NaN = false;\n    static constexpr float_denorm_style has_denorm = denorm_absent;\n    static constexpr bool has_denorm_loss = false;\n    static constexpr T infinity() noexcept;\n    static constexpr T quiet_NaN() noexcept;\n    static constexpr T signaling_NaN() noexcept;\n    static constexpr T denorm_min() noexcept;\n\n    static constexpr bool is_iec559 = false;\n    static constexpr bool is_bounded = false;\n    static constexpr bool is_modulo = false;\n\n    static constexpr bool traps = false;\n    static constexpr bool tinyness_before = false;\n    static constexpr float_round_style round_style = round_toward_zero;\n};\n\nenum float_round_style\n{\n    round_indeterminate       = -1,\n    round_toward_zero         =  0,\n    round_to_nearest          =  1,\n    round_toward_infinity     =  2,\n    round_toward_neg_infinity =  3\n};\n\nenum float_denorm_style\n{\n    denorm_indeterminate = -1,\n    denorm_absent = 0,\n    denorm_present = 1\n};\n\ntemplate<> class numeric_limits<cv bool>;\n\ntemplate<> class numeric_limits<cv char>;\ntemplate<> class numeric_limits<cv signed char>;\ntemplate<> class numeric_limits<cv unsigned char>;\ntemplate<> class numeric_limits<cv wchar_t>;\ntemplate<> class numeric_limits<cv char16_t>;\ntemplate<> class numeric_limits<cv char32_t>;\n\ntemplate<> class numeric_limits<cv short>;\ntemplate<> class numeric_limits<cv int>;\ntemplate<> class numeric_limits<cv long>;\ntemplate<> class numeric_limits<cv long long>;\ntemplate<> class numeric_limits<cv unsigned short>;\ntemplate<> class numeric_limits<cv unsigned int>;\ntemplate<> class numeric_limits<cv unsigned long>;\ntemplate<> class numeric_limits<cv unsigned long long>;\n\ntemplate<> class numeric_limits<cv float>;\ntemplate<> class numeric_limits<cv double>;\ntemplate<> class numeric_limits<cv long double>;\n\n}  // std\n\n*/\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include <__config>\n#include <type_traits>\n\n#include <__undef_min_max>\n\n#if defined(_LIBCPP_MSVCRT)\n#include \"support/win32/limits_win32.h\"\n#endif // _LIBCPP_MSVCRT\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/limits.h\"\n#endif // __IBMCPP__\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nenum float_round_style\n{\n    round_indeterminate       = -1,\n    round_toward_zero         =  0,\n    round_to_nearest          =  1,\n    round_toward_infinity     =  2,\n    round_toward_neg_infinity =  3\n};\n\nenum float_denorm_style\n{\n    denorm_indeterminate = -1,\n    denorm_absent = 0,\n    denorm_present = 1\n};\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nclass __libcpp_numeric_limits\n{\nprotected:\n    typedef _Tp type;\n\n    static _LIBCPP_CONSTEXPR const  bool is_specialized = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = 0;\n    static _LIBCPP_CONSTEXPR const int  digits10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const bool is_signed = false;\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = 0;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = false;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <class _Tp, int digits, bool is_signed>\nstruct __libcpp_compute_min\n{\n    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(_Tp(1) << digits);\n};\n\ntemplate <class _Tp, int digits>\nstruct __libcpp_compute_min<_Tp, digits, false>\n{\n    static _LIBCPP_CONSTEXPR const _Tp value = _Tp(0);\n};\n\ntemplate <class _Tp>\nclass __libcpp_numeric_limits<_Tp, true>\n{\nprotected:\n    typedef _Tp type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = type(-1) < type(0);\n    static _LIBCPP_CONSTEXPR const int  digits = static_cast<int>(sizeof(type) * __CHAR_BIT__ - is_signed);\n    static _LIBCPP_CONSTEXPR const int  digits10 = digits * 3 / 10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const type __min = __libcpp_compute_min<type, digits, is_signed>::value;\n    static _LIBCPP_CONSTEXPR const type __max = is_signed ? type(type(~0) ^ __min) : type(~0);\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = true;\n    static _LIBCPP_CONSTEXPR const bool is_exact = true;\n    static _LIBCPP_CONSTEXPR const int  radix = 2;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = true;\n\n#if __i386__ || __x86_64__\n    static _LIBCPP_CONSTEXPR const bool traps = true;\n#else\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n#endif\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<bool, true>\n{\nprotected:\n    typedef bool type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = false;\n    static _LIBCPP_CONSTEXPR const int  digits = 1;\n    static _LIBCPP_CONSTEXPR const int  digits10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 0;\n    static _LIBCPP_CONSTEXPR const type __min = false;\n    static _LIBCPP_CONSTEXPR const type __max = true;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __min;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __max;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = true;\n    static _LIBCPP_CONSTEXPR const bool is_exact = true;\n    static _LIBCPP_CONSTEXPR const int  radix = 2;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = 0;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = 0;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = false;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = false;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = false;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_absent;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return type(0);}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return type(0);}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_toward_zero;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<float, true>\n{\nprotected:\n    typedef float type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __FLT_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __FLT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __FLT_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __FLT_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __FLT_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5F;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __FLT_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __FLT_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __FLT_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __FLT_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_valf();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanf(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansf(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __FLT_DENORM_MIN__;}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<double, true>\n{\nprotected:\n    typedef double type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __DBL_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __DBL_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __DBL_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __DBL_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __DBL_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __DBL_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __DBL_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __DBL_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __DBL_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_val();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nan(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nans(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __DBL_DENORM_MIN__;}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <>\nclass __libcpp_numeric_limits<long double, true>\n{\nprotected:\n    typedef long double type;\n\n    static _LIBCPP_CONSTEXPR const bool is_specialized = true;\n\n    static _LIBCPP_CONSTEXPR const bool is_signed = true;\n    static _LIBCPP_CONSTEXPR const int  digits = __LDBL_MANT_DIG__;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __LDBL_DIG__;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = 2+(digits * 30103)/100000;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __LDBL_MIN__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __LDBL_MAX__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return -max();}\n\n    static _LIBCPP_CONSTEXPR const bool is_integer = false;\n    static _LIBCPP_CONSTEXPR const bool is_exact = false;\n    static _LIBCPP_CONSTEXPR const int  radix = __FLT_RADIX__;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __LDBL_EPSILON__;}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return 0.5;}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __LDBL_MIN_EXP__;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __LDBL_MIN_10_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __LDBL_MAX_EXP__;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __LDBL_MAX_10_EXP__;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = true;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = true;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = true;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = denorm_present;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = false;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __builtin_huge_vall();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __builtin_nanl(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __builtin_nansl(\"\");}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __LDBL_DENORM_MIN__;}\n\n#if (defined(__ppc__) || defined(__ppc64__))\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = false;\n#else\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = true;\n#endif\n    static _LIBCPP_CONSTEXPR const bool is_bounded = true;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = false;\n\n    static _LIBCPP_CONSTEXPR const bool traps = false;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = false;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = round_to_nearest;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits\n    : private __libcpp_numeric_limits<typename remove_cv<_Tp>::type>\n{\n    typedef __libcpp_numeric_limits<typename remove_cv<_Tp>::type> __base;\n    typedef typename __base::type type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<_Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<_Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<_Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<_Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<const _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const _Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<volatile _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<volatile _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<volatile _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<volatile _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<volatile _Tp>::round_style;\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY numeric_limits<const volatile _Tp>\n    : private numeric_limits<_Tp>\n{\n    typedef numeric_limits<_Tp> __base;\n    typedef _Tp type;\npublic:\n    static _LIBCPP_CONSTEXPR const bool is_specialized = __base::is_specialized;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type min() _NOEXCEPT {return __base::min();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type max() _NOEXCEPT {return __base::max();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type lowest() _NOEXCEPT {return __base::lowest();}\n\n    static _LIBCPP_CONSTEXPR const int  digits = __base::digits;\n    static _LIBCPP_CONSTEXPR const int  digits10 = __base::digits10;\n    static _LIBCPP_CONSTEXPR const int  max_digits10 = __base::max_digits10;\n    static _LIBCPP_CONSTEXPR const bool is_signed = __base::is_signed;\n    static _LIBCPP_CONSTEXPR const bool is_integer = __base::is_integer;\n    static _LIBCPP_CONSTEXPR const bool is_exact = __base::is_exact;\n    static _LIBCPP_CONSTEXPR const int  radix = __base::radix;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type epsilon() _NOEXCEPT {return __base::epsilon();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type round_error() _NOEXCEPT {return __base::round_error();}\n\n    static _LIBCPP_CONSTEXPR const int  min_exponent = __base::min_exponent;\n    static _LIBCPP_CONSTEXPR const int  min_exponent10 = __base::min_exponent10;\n    static _LIBCPP_CONSTEXPR const int  max_exponent = __base::max_exponent;\n    static _LIBCPP_CONSTEXPR const int  max_exponent10 = __base::max_exponent10;\n\n    static _LIBCPP_CONSTEXPR const bool has_infinity = __base::has_infinity;\n    static _LIBCPP_CONSTEXPR const bool has_quiet_NaN = __base::has_quiet_NaN;\n    static _LIBCPP_CONSTEXPR const bool has_signaling_NaN = __base::has_signaling_NaN;\n    static _LIBCPP_CONSTEXPR const float_denorm_style has_denorm = __base::has_denorm;\n    static _LIBCPP_CONSTEXPR const bool has_denorm_loss = __base::has_denorm_loss;\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type infinity() _NOEXCEPT {return __base::infinity();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type quiet_NaN() _NOEXCEPT {return __base::quiet_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type signaling_NaN() _NOEXCEPT {return __base::signaling_NaN();}\n    _LIBCPP_INLINE_VISIBILITY static _LIBCPP_CONSTEXPR type denorm_min() _NOEXCEPT {return __base::denorm_min();}\n\n    static _LIBCPP_CONSTEXPR const bool is_iec559 = __base::is_iec559;\n    static _LIBCPP_CONSTEXPR const bool is_bounded = __base::is_bounded;\n    static _LIBCPP_CONSTEXPR const bool is_modulo = __base::is_modulo;\n\n    static _LIBCPP_CONSTEXPR const bool traps = __base::traps;\n    static _LIBCPP_CONSTEXPR const bool tinyness_before = __base::tinyness_before;\n    static _LIBCPP_CONSTEXPR const float_round_style round_style = __base::round_style;\n};\n\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_specialized;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::digits10;\ntemplate <class _Tp>\n    const int numeric_limits<const volatile _Tp>::max_digits10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_signed;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_integer;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_exact;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::radix;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::min_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const int numeric_limits<const volatile _Tp>::max_exponent10;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_infinity;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_quiet_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_signaling_NaN;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_denorm_style numeric_limits<const volatile _Tp>::has_denorm;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::has_denorm_loss;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_iec559;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_bounded;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::is_modulo;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::traps;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const bool numeric_limits<const volatile _Tp>::tinyness_before;\ntemplate <class _Tp>\n    _LIBCPP_CONSTEXPR const float_round_style numeric_limits<const volatile _Tp>::round_style;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIMITS\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __is_void       : public false_type {};\ntemplate <>          struct __is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct ____is_nullptr_t       : public false_type {};\ntemplate <>          struct ____is_nullptr_t<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public ____is_nullptr_t<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __is_integral                     : public false_type {};\ntemplate <>          struct __is_integral<bool>               : public true_type {};\ntemplate <>          struct __is_integral<char>               : public true_type {};\ntemplate <>          struct __is_integral<signed char>        : public true_type {};\ntemplate <>          struct __is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __is_integral<short>              : public true_type {};\ntemplate <>          struct __is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __is_integral<int>                : public true_type {};\ntemplate <>          struct __is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __is_integral<long>               : public true_type {};\ntemplate <>          struct __is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __is_integral<long long>          : public true_type {};\ntemplate <>          struct __is_integral<unsigned long long> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __is_floating_point              : public false_type {};\ntemplate <>          struct __is_floating_point<float>       : public true_type {};\ntemplate <>          struct __is_floating_point<double>      : public true_type {};\ntemplate <>          struct __is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __is_pointer       : public false_type {};\ntemplate <class _Tp> struct __is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n#if defined(__clang__) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n#define _LIBCPP_HAS_TYPE_TRAITS\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __is_function_imp\n{\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source();\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __is_function\n    : public integral_constant<bool, sizeof(__is_function_imp::__test<_Tp>(__is_function_imp::__source<_Tp>())) == 1>\n    {};\ntemplate <class _Tp> struct __is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __is_function<_Tp> {};\n\n// is_member_function_pointer\n\ntemplate <class _Tp> struct            __is_member_function_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct ___is_signed : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct ___is_signed<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __is_signed : public ___is_signed<_Tp> {};\n\ntemplate <class _Tp> struct __is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct ___is_unsigned : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct ___is_unsigned<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __is_unsigned : public ___is_unsigned<_Tp> {};\n\ntemplate <class _Tp> struct __is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // __has_feature(is_base_of)\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // __has_feature(is_base_of)\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = (is_arithmetic<_A1>::value || is_void<_A1>::value) &&\n                 (is_arithmetic<_A2>::value || is_void<_A2>::value) &&\n                 (is_arithmetic<_A3>::value || is_void<_A3>::value)>\nclass __promote {};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename conditional<is_arithmetic<_A1>::value,\n                     typename conditional<is_integral<_A1>::value, double, _A1>::type,\n                     void\n            >::type type;\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n    __nat\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n    __nat\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef _Tp type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_lvalue_reference<_Tp>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\ntemplate <class _Tp>\nstruct __destructible_test\n{\n    _Tp __t;\n};\n\ntemplate <class _Tp>\ndecltype((_VSTD::declval<__destructible_test<_Tp> >().~__destructible_test<_Tp>(), true_type()))\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_destructible_test(_Tp&&);\n#else\n__is_destructible_test(_Tp&);\n#endif\n\nfalse_type\n__is_destructible_test(__any);\n\ntemplate <class _Tp, bool = is_void<_Tp>::value || is_abstract<_Tp>::value\n                                                || is_function<_Tp>::value>\nstruct __destructible_imp\n    : public common_type\n        <\n            decltype(__is_destructible_test(declval<_Tp>()))\n        >::type {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_imp<_Tp> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\nnamespace __is_construct\n{\n\nstruct __nat {};\n\n}\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                               const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, __has_trivial_destructor(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// is_nothrow_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp, class... _Args> struct __is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp, const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp, class _Arg> struct __is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                               const typename add_lvalue_reference<_Tp>::type>\n    {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp> struct __is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else  // _LIBCPP_HAS_TYPE_TRAITS\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_TYPE_TRAITS\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#if __has_feature(is_literal)\n    : public integral_constant<bool, __is_literal(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCXX_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCXX_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCXX_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCXX_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===---------------------------- list ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LIST\n#define _LIBCPP_LIST\n\n/*\n    list synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Alloc = allocator<T> >\nclass list\n{\npublic:\n\n    // types:\n    typedef T value_type;\n    typedef Alloc allocator_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef implementation-defined size_type;\n    typedef implementation-defined difference_type;\n    typedef reverse_iterator<iterator> reverse_iterator;\n    typedef reverse_iterator<const_iterator> const_reverse_iterator;\n\n    list()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit list(const allocator_type& a);\n    explicit list(size_type n);\n    explicit list(size_type n, const allocator_type& a); // C++14\n    list(size_type n, const value_type& value);\n    list(size_type n, const value_type& value, const allocator_type& a);\n    template <class Iter>\n        list(Iter first, Iter last);\n    template <class Iter>\n        list(Iter first, Iter last, const allocator_type& a);\n    list(const list& x);\n    list(const list&, const allocator_type& a);\n    list(list&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    list(list&&, const allocator_type& a);\n    list(initializer_list<value_type>);\n    list(initializer_list<value_type>, const allocator_type& a);\n\n    ~list();\n\n    list& operator=(const list& x);\n    list& operator=(list&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    list& operator=(initializer_list<value_type>);\n    template <class Iter>\n        void assign(Iter first, Iter last);\n    void assign(size_type n, const value_type& t);\n    void assign(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator end() noexcept;\n    const_iterator end() const noexcept;\n    reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    bool empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    template <class... Args>\n        void emplace_front(Args&&... args);\n    void pop_front();\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n    void push_front(const value_type& x);\n    void push_front(value_type&& x);\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class Iter>\n        iterator insert(const_iterator position, Iter first, Iter last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator position, const_iterator last);\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(list&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n\n    void splice(const_iterator position, list& x);\n    void splice(const_iterator position, list&& x);\n    void splice(const_iterator position, list& x, const_iterator i);\n    void splice(const_iterator position, list&& x, const_iterator i);\n    void splice(const_iterator position, list& x, const_iterator first,\n                                                  const_iterator last);\n    void splice(const_iterator position, list&& x, const_iterator first,\n                                                  const_iterator last);\n\n    void remove(const value_type& value);\n    template <class Pred> void remove_if(Pred pred);\n    void unique();\n    template <class BinaryPredicate>\n        void unique(BinaryPredicate binary_pred);\n    void merge(list& x);\n    void merge(list&& x);\n    template <class Compare>\n        void merge(list& x, Compare comp);\n    template <class Compare>\n        void merge(list&& x, Compare comp);\n    void sort();\n    template <class Compare>\n        void sort(Compare comp);\n    void reverse() noexcept;\n};\n\ntemplate <class T, class Alloc>\n    bool operator==(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator< (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator!=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator> (const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator>=(const list<T,Alloc>& x, const list<T,Alloc>& y);\ntemplate <class T, class Alloc>\n    bool operator<=(const list<T,Alloc>& x, const list<T,Alloc>& y);\n\ntemplate <class T, class Alloc>\n    void swap(list<T,Alloc>& x, list<T,Alloc>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n\n#include <memory>\n#include <limits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#ifdef _LIBCPP_DEBUG\n#   include <__debug>\n#else\n#   define _LIBCPP_ASSERT(x, m) ((void)0)\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _VoidPtr> struct __list_node;\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node_base\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other pointer;\n#endif\n\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node_base> __base_pointer;\n#else\n        rebind<__list_node_base>::other __base_pointer;\n#endif\n\n    pointer __prev_;\n    pointer __next_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_node_base()\n        : __prev_(static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this))),\n          __next_(static_cast<pointer>(pointer_traits<__base_pointer>::pointer_to(*this)))\n          {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __list_node\n    : public __list_node_base<_Tp, _VoidPtr>\n{\n    _Tp __value_;\n};\n\ntemplate <class _Tp, class _Alloc> class _LIBCPP_TYPE_VIS_ONLY list;\ntemplate <class _Tp, class _Alloc> class __list_imp;\ntemplate <class _Tp, class _VoidPtr> class _LIBCPP_TYPE_VIS_ONLY __list_const_iterator;\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\n    template<class, class> friend class __list_const_iterator;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef value_type&                      reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator(const __list_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator=(const __list_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_iterator& __x, const __list_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass _LIBCPP_TYPE_VIS_ONLY __list_const_iterator\n{\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n        rebind<__list_node<_Tp, _VoidPtr> > __node_pointer;\n#else\n        rebind<__list_node<_Tp, _VoidPtr> >::other __node_pointer;\n#endif\n\n    __node_pointer __ptr_;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p, const void* __c) _NOEXCEPT\n        : __ptr_(__p)\n    {\n        __get_db()->__insert_ic(this, __c);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __list_const_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n#endif\n\n    template<class, class> friend class list;\n    template<class, class> friend class __list_imp;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                             pointer;\n    typedef typename pointer_traits<pointer>::difference_type difference_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator() _NOEXCEPT : __ptr_(nullptr)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__p);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator(const __list_const_iterator& __p)\n        : __ptr_(__p.__ptr_)\n    {\n        __get_db()->__iterator_copy(this, &__p);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__list_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator=(const __list_const_iterator& __p)\n    {\n        if (this != &__p)\n        {\n            __get_db()->__iterator_copy(this, &__p);\n            __ptr_ = __p.__ptr_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::const_iterator\");\n#endif\n        return __ptr_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable list::iterator\");\n#endif\n        return pointer_traits<pointer>::pointer_to(__ptr_->__value_);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__next_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator& operator--()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable list::const_iterator\");\n#endif\n        __ptr_ = __ptr_->__prev_;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)\n    {\n        return __x.__ptr_ == __y.__ptr_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _Alloc>\nclass __list_imp\n{\n    __list_imp(const __list_imp&);\n    __list_imp& operator=(const __list_imp&);\nprotected:\n    typedef _Tp                                                     value_type;\n    typedef _Alloc                                                  allocator_type;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n    typedef typename __alloc_traits::size_type                      size_type;\n    typedef typename __alloc_traits::void_pointer                   __void_pointer;\n    typedef __list_iterator<value_type, __void_pointer>             iterator;\n    typedef __list_const_iterator<value_type, __void_pointer>       const_iterator;\n    typedef __list_node_base<value_type, __void_pointer>            __node_base;\n    typedef __list_node<value_type, __void_pointer>                 __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node>\n#else\n                rebind_alloc<__node>::other\n#endif\n                                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>                       __node_alloc_traits;\n    typedef typename __node_alloc_traits::pointer                    __node_pointer;\n    typedef typename __node_alloc_traits::pointer                    __node_const_pointer;\n    typedef typename __alloc_traits::pointer                         pointer;\n    typedef typename __alloc_traits::const_pointer                   const_pointer;\n    typedef typename __alloc_traits::difference_type                 difference_type;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__node_base>\n#else\n                rebind_alloc<__node_base>::other\n#endif\n                                                                     __node_base_allocator;\n    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;\n\n    __node_base __end_;\n    __compressed_pair<size_type, __node_allocator> __size_alloc_;\n\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& __sz() _NOEXCEPT {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __sz() const _NOEXCEPT\n        {return __size_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT\n          {return __size_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __size_alloc_.second();}\n\n    static void __unlink_nodes(__node_pointer __f, __node_pointer __l) _NOEXCEPT;\n\n    __list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value);\n    __list_imp(const allocator_type& __a);\n    ~__list_imp();\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __sz() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__end_.__next_, this);\n#else\n        return iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const  _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(__end_.__next_, this);\n#else\n        return const_iterator(__end_.__next_);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(static_cast<__node_pointer>(\n                pointer_traits<__node_base_pointer>::pointer_to(__end_)), this);\n#else\n        return iterator(static_cast<__node_pointer>(\n                      pointer_traits<__node_base_pointer>::pointer_to(__end_)));\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))), this);\n#else\n        return const_iterator(static_cast<__node_const_pointer>(\n        pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(__end_))));\n#endif\n    }\n\n    void swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c)\n        _NOEXCEPT_(\n            !__node_alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_alloc_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, true_type)\n        {\n            if (__node_alloc() != __c.__node_alloc())\n                clear();\n            __node_alloc() = __c.__node_alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __list_imp& __c, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {\n            __node_alloc() = _VSTD::move(__c.__node_alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__list_imp& __c, false_type)\n        _NOEXCEPT\n        {}\n};\n\n// Unlink nodes [__f, __l]\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__list_imp<_Tp, _Alloc>::__unlink_nodes(__node_pointer __f, __node_pointer __l)\n    _NOEXCEPT\n{\n    __f->__prev_->__next_ = __l->__next_;\n    __l->__next_->__prev_ = __f->__prev_;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    : __size_alloc_(0)\n{\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)\n    : __size_alloc_(0, __node_allocator(__a))\n{\n}\n\ntemplate <class _Tp, class _Alloc>\n__list_imp<_Tp, _Alloc>::~__list_imp()\n{\n    clear();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::clear() _NOEXCEPT\n{\n    if (!empty())\n    {\n        __node_allocator& __na = __node_alloc();\n        __node_pointer __f = __end_.__next_;\n        __node_pointer __l = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n        __unlink_nodes(__f, __l->__prev_);\n        __sz() = 0;\n        while (__f != __l)\n        {\n            __node_pointer __n = __f;\n            __f = __f->__next_;\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != __l)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__node_alloc() == __c.__node_alloc(),\n                   \"list::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    using _VSTD::swap;\n    __swap_alloc(__node_alloc(), __c.__node_alloc());\n    swap(__sz(), __c.__sz());\n    swap(__end_, __c.__end_);\n    if (__sz() == 0)\n        __end_.__next_ = __end_.__prev_ = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n    else\n        __end_.__prev_->__next_ = __end_.__next_->__prev_\n                                = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_));\n    if (__c.__sz() == 0)\n        __c.__end_.__next_ = __c.__end_.__prev_\n                           = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_));\n    else\n        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_\n                                    = static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __libcpp_db* __db = __get_db();\n    __c_node* __cn1 = __db->__find_c_and_lock(this);\n    __c_node* __cn2 = __db->__find_c(&__c);\n    std::swap(__cn1->beg_, __cn2->beg_);\n    std::swap(__cn1->end_, __cn2->end_);\n    std::swap(__cn1->cap_, __cn2->cap_);\n    for (__i_node** __p = __cn1->end_; __p != __cn1->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n        {\n            __cn2->__add(*__p);\n            if (--__cn1->end_ != __p)\n                memmove(__p, __p+1, (__cn1->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn1;\n    }\n    for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n    {\n        --__p;\n        const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__end_)))\n        {\n            __cn1->__add(*__p);\n            if (--__cn2->end_ != __p)\n                memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n        }\n        else\n            (*__p)->__c_ = __cn2;\n    }\n    __db->unlock();\n#endif\n}\n\ntemplate <class _Tp, class _Alloc = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY list\n    : private __list_imp<_Tp, _Alloc>\n{\n    typedef __list_imp<_Tp, _Alloc> base;\n    typedef typename base::__node              __node;\n    typedef typename base::__node_allocator    __node_allocator;\n    typedef typename base::__node_pointer      __node_pointer;\n    typedef typename base::__node_alloc_traits __node_alloc_traits;\n    typedef typename base::__node_base         __node_base;\n    typedef typename base::__node_base_pointer __node_base_pointer;\n\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Alloc                                   allocator_type;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename base::pointer                   pointer;\n    typedef typename base::const_pointer             const_pointer;\n    typedef typename base::size_type                 size_type;\n    typedef typename base::difference_type           difference_type;\n    typedef typename base::iterator                  iterator;\n    typedef typename base::const_iterator            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    list()\n        _NOEXCEPT_(is_nothrow_default_constructible<__node_allocator>::value)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    explicit list(const allocator_type& __a) : base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit list(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit list(size_type __n, const allocator_type& __a);\n#endif\n    list(size_type __n, const value_type& __x);\n    list(size_type __n, const value_type& __x, const allocator_type& __a);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    template <class _InpIter>\n        list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n\n    list(const list& __c);\n    list(const list& __c, const allocator_type& __a);\n    list& operator=(const list& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    list(initializer_list<value_type> __il);\n    list(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    list(list&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value);\n    list(list&& __c, const allocator_type& __a);\n    list& operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    list& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InpIter>\n        void assign(_InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT     {return base::__sz();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT         {return base::empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return numeric_limits<difference_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT        {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT          {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::front called on empty list\");\n        return base::__end_.__next_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    reference back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"list::back called on empty list\");\n        return base::__end_.__prev_->__value_;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n       void emplace_front(_Args&&... __args);\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n    template <class... _Args>\n        iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    iterator insert(const_iterator __p, value_type&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void push_front(const value_type& __x);\n    void push_back(const value_type& __x);\n\n    iterator insert(const_iterator __p, const value_type& __x);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __x);\n    template <class _InpIter>\n        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(list& __c)\n        _NOEXCEPT_(!__node_alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<__node_allocator>::value)\n        {base::swap(__c);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {base::clear();}\n\n    void pop_front();\n    void pop_back();\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __x);\n\n    void splice(const_iterator __p, list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}\n#endif\n    void splice(const_iterator __p, list& __c, const_iterator __i);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __i)\n        {splice(__p, __c, __i);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)\n        {splice(__p, __c, __f, __l);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void remove(const value_type& __x);\n    template <class _Pred> void remove_if(_Pred __pred);\n    void unique();\n    template <class _BinaryPred>\n        void unique(_BinaryPred __binary_pred);\n    void merge(list& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void merge(list&& __c) {merge(__c);}\n#endif\n    template <class _Comp>\n        void merge(list& __c, _Comp __comp);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Comp>\n    _LIBCPP_INLINE_VISIBILITY\n        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void sort();\n    template <class _Comp>\n        void sort(_Comp __comp);\n\n    void reverse() _NOEXCEPT;\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    static void __link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l);\n    iterator __iterator(size_type __n);\n    template <class _Comp>\n        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);\n\n    void __move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value);\n    void __move_assign(list& __c, false_type);\n};\n\n// Link in nodes [__f, __l] just prior to __p\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::__link_nodes(__node_pointer __p, __node_pointer __f, __node_pointer __l)\n{\n    __p->__prev_->__next_ = __f;\n    __f->__prev_ = __p->__prev_;\n    __p->__prev_ = __l;\n    __l->__next_ = __p;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__iterator(size_type __n)\n{\n    return __n <= base::__sz() / 2 ? _VSTD::next(begin(), __n)\n                                   : _VSTD::prev(end(), base::__sz() - __n);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        emplace_back();\n#else\n        push_back(value_type());\n#endif\n}\n#endif\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __n > 0; --__n)\n        push_back(__x);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nlist<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,\n                        typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c)\n    : base(allocator_type(\n           __node_alloc_traits::select_on_container_copy_construction(\n                __c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(const list& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\ntemplate <class _Tp, class _Alloc>\nlist<_Tp, _Alloc>::list(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),\n            __e = __il.end(); __i != __e; ++__i)\n        push_back(*__i);\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(const list& __c)\n{\n    if (this != &__c)\n    {\n        base::__copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__node_allocator>::value)\n    : base(allocator_type(_VSTD::move(__c.__node_alloc())))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    splice(end(), __c);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>::list(list&& __c, const allocator_type& __a)\n    : base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __c.get_allocator())\n        splice(end(), __c);\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nlist<_Tp, _Alloc>&\nlist<_Tp, _Alloc>::operator=(list&& __c)\n        _NOEXCEPT_(\n            __node_alloc_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __node_alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, false_type)\n{\n    if (base::__node_alloc() != __c.__node_alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::__move_assign(list& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n{\n    clear();\n    base::__move_assign_alloc(__c);\n    splice(end(), __c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\nvoid\nlist<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,\n                          typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__i == __e)\n        insert(__e, __f, __l);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)\n{\n    iterator __i = begin();\n    iterator __e = end();\n    for (; __n > 0 && __i != __e; --__n, ++__i)\n        *__i = __x;\n    if (__i == __e)\n        insert(__e, __n, __x);\n    else\n        erase(__i, __e);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n_Alloc\nlist<_Tp, _Alloc>::get_allocator() const _NOEXCEPT\n{\n    return allocator_type(base::__node_alloc());\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__n > 0)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _InpIter>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,\n             typename enable_if<__is_input_iterator<_InpIter>::value>::type*)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, range) called with an iterator not\"\n        \" referring to this list\");\n    iterator __r(__p.__ptr_, this);\n#else\n    iterator __r(__p.__ptr_);\n#endif\n    if (__f != __l)\n    {\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __r = iterator(__hold.get(), this);\n#else\n        __r = iterator(__hold.get());\n#endif\n        __hold.release();\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (++__f; __f != __l; ++__f, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), *__f);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(const value_type& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_front(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::push_back(value_type&& __x)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_front(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(base::__end_.__next_, __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\nvoid\nlist<_Tp, _Alloc>::emplace_back(_Args&&... __args)\n{\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __hold.get(), __hold.get());\n    ++base::__sz();\n    __hold.release();\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class... _Args>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::emplace(iterator, args...) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::forward<_Args>(__args)...);\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::insert(iterator, x) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    __node_allocator& __na = base::__node_alloc();\n    typedef __allocator_destructor<__node_allocator> _Dp;\n    unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n    __hold->__prev_ = 0;\n    __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), _VSTD::move(__x));\n    __link_nodes(__p.__ptr_, __hold.get(), __hold.get());\n    ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__hold.release(), this);\n#else\n    return iterator(__hold.release());\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_front()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_front() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"list::pop_back() called with empty list\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = base::__end_.__prev_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __p)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::erase(iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    _LIBCPP_ASSERT(__p != end(),\n        \"list::erase(iterator) called with a non-dereferenceable iterator\");\n    __node_allocator& __na = base::__node_alloc();\n    __node_pointer __n = __p.__ptr_;\n    __node_pointer __r = __n->__next_;\n    base::__unlink_nodes(__n, __n);\n    --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__ptr_ == __n)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n    __node_alloc_traits::deallocate(__na, __n, 1);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__r, this);\n#else\n    return iterator(__r);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == this,\n        \"list::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (__f != __l)\n    {\n        __node_allocator& __na = base::__node_alloc();\n        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);\n        while (__f != __l)\n        {\n            __node_pointer __n = __f.__ptr_;\n            ++__f;\n            --base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __c_node* __c = __get_db()->__find_c_and_lock(this);\n            for (__i_node** __p = __c->end_; __p != __c->beg_; )\n            {\n                --__p;\n                iterator* __i = static_cast<iterator*>((*__p)->__i_);\n                if (__i->__ptr_ == __n)\n                {\n                    (*__p)->__c_ = nullptr;\n                    if (--__c->end_ != __p)\n                        memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n            __get_db()->unlock();\n#endif\n            __node_alloc_traits::destroy(__na, _VSTD::addressof(__n->__value_));\n            __node_alloc_traits::deallocate(__na, __n, 1);\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__l.__ptr_, this);\n#else\n    return iterator(__l.__ptr_);\n#endif\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_));\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)\n{\n    if (__n < base::__sz())\n        erase(__iterator(__n), end());\n    else if (__n > base::__sz())\n    {\n        __n -= base::__sz();\n        size_type __ds = 0;\n        __node_allocator& __na = base::__node_alloc();\n        typedef __allocator_destructor<__node_allocator> _Dp;\n        unique_ptr<__node, _Dp> __hold(__node_alloc_traits::allocate(__na, 1), _Dp(__na, 1));\n        __hold->__prev_ = 0;\n        __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n        ++__ds;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator __r = iterator(__hold.release(), this);\n#else\n        iterator __r = iterator(__hold.release());\n#endif\n        iterator __e = __r;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (--__n; __n != 0; --__n, ++__e, ++__ds)\n            {\n                __hold.reset(__node_alloc_traits::allocate(__na, 1));\n                __node_alloc_traits::construct(__na, _VSTD::addressof(__hold->__value_), __x);\n                __e.__ptr_->__next_ = __hold.get();\n                __hold->__prev_ = __e.__ptr_;\n                __hold.release();\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (true)\n            {\n                __node_alloc_traits::destroy(__na, _VSTD::addressof(*__e));\n                __node_pointer __prev = __e.__ptr_->__prev_;\n                __node_alloc_traits::deallocate(__na, __e.__ptr_, 1);\n                if (__prev == 0)\n                    break;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                __e = iterator(__prev, this);\n#else\n                __e = iterator(__prev);\n#endif\n            }\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __link_nodes(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::\n                         pointer_to(base::__end_)), __r.__ptr_, __e.__ptr_);\n        base::__sz() += __ds;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c)\n{\n    _LIBCPP_ASSERT(this != &__c,\n                   \"list::splice(iterator, list) called with this == &list\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list) called with an iterator not\"\n        \" referring to this list\");\n#endif\n    if (!__c.empty())\n    {\n        __node_pointer __f = __c.__end_.__next_;\n        __node_pointer __l = __c.__end_.__prev_;\n        base::__unlink_nodes(__f, __l);\n        __link_nodes(__p.__ptr_, __f, __l);\n        base::__sz() += __c.__sz();\n        __c.__sz() = 0;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__i) == &__c,\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(&__i),\n        \"list::splice(iterator, list, iterator) called with second iterator not\"\n        \" derefereceable\");\n#endif\n    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)\n    {\n        __node_pointer __f = __i.__ptr_;\n        base::__unlink_nodes(__f, __f);\n        __link_nodes(__p.__ptr_, __f, __f);\n        --__c.__sz();\n        ++base::__sz();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            if (__j->__ptr_ == __f)\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"list::splice(iterator, list, iterator, iterator) called with first iterator not\"\n        \" referring to this list\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__f) == &__c,\n        \"list::splice(iterator, list, iterator, iterator) called with second iterator not\"\n        \" referring to list argument\");\n    if (this == &__c)\n    {\n        for (const_iterator __i = __f; __i != __l; ++__i)\n            _LIBCPP_ASSERT(__i != __p,\n                           \"list::splice(iterator, list, iterator, iterator)\"\n                           \" called with the first iterator within the range\"\n                           \" of the second and third iterators\");\n    }\n#endif\n    if (__f != __l)\n    {\n        if (this != &__c)\n        {\n            size_type __s = _VSTD::distance(__f, __l);\n            __c.__sz() -= __s;\n            base::__sz() += __s;\n        }\n        __node_pointer __first = __f.__ptr_;\n        --__l;\n        __node_pointer __last = __l.__ptr_;\n        base::__unlink_nodes(__first, __last);\n        __link_nodes(__p.__ptr_, __first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __j = static_cast<iterator*>((*__p)->__i_);\n            for (__node_pointer __k = __f.__ptr_;\n                                          __k != __l.__ptr_; __k = __k->__next_)\n            {\n                if (__j->__ptr_ == __k)\n                {\n                    __cn1->__add(*__p);\n                    (*__p)->__c_ = __cn1;\n                    if (--__cn2->end_ != __p)\n                        memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n                }\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::remove(const value_type& __x)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (*__i == __x)\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && *__j == __x; ++__j)\n                ;\n            __i = erase(__i, __j);\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Pred>\nvoid\nlist<_Tp, _Alloc>::remove_if(_Pred __pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        if (__pred(*__i))\n        {\n            iterator __j = _VSTD::next(__i);\n            for (; __j != __e && __pred(*__j); ++__j)\n                ;\n            __i = erase(__i, __j);\n        }\n        else\n            ++__i;\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::unique()\n{\n    unique(__equal_to<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _BinaryPred>\nvoid\nlist<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)\n{\n    for (iterator __i = begin(), __e = end(); __i != __e;)\n    {\n        iterator __j = _VSTD::next(__i);\n        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)\n            ;\n        if (++__i != __j)\n            __i = erase(__i, __j);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::merge(list& __c)\n{\n    merge(__c, __less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\nvoid\nlist<_Tp, _Alloc>::merge(list& __c, _Comp __comp)\n{\n    if (this != &__c)\n    {\n        iterator __f1 = begin();\n        iterator __e1 = end();\n        iterator __f2 = __c.begin();\n        iterator __e2 = __c.end();\n        while (__f1 != __e1 && __f2 != __e2)\n        {\n            if (__comp(*__f2, *__f1))\n            {\n                size_type __ds = 1;\n                iterator __m2 = _VSTD::next(__f2);\n                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)\n                    ;\n                base::__sz() += __ds;\n                __c.__sz() -= __ds;\n                __node_pointer __f = __f2.__ptr_;\n                __node_pointer __l = __m2.__ptr_->__prev_;\n                __f2 = __m2;\n                base::__unlink_nodes(__f, __l);\n                __m2 = _VSTD::next(__f1);\n                __link_nodes(__f1.__ptr_, __f, __l);\n                __f1 = __m2;\n            }\n            else\n                ++__f1;\n        }\n        splice(__e1, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __libcpp_db* __db = __get_db();\n        __c_node* __cn1 = __db->__find_c_and_lock(this);\n        __c_node* __cn2 = __db->__find_c(&__c);\n        for (__i_node** __p = __cn2->end_; __p != __cn2->beg_;)\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(__c.__end_)))\n            {\n                __cn1->__add(*__p);\n                (*__p)->__c_ = __cn1;\n                if (--__cn2->end_ != __p)\n                    memmove(__p, __p+1, (__cn2->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __db->unlock();\n#endif\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort()\n{\n    sort(__less<value_type>());\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nlist<_Tp, _Alloc>::sort(_Comp __comp)\n{\n    __sort(begin(), end(), base::__sz(), __comp);\n}\n\ntemplate <class _Tp, class _Alloc>\ntemplate <class _Comp>\ntypename list<_Tp, _Alloc>::iterator\nlist<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)\n{\n    switch (__n)\n    {\n    case 0:\n    case 1:\n        return __f1;\n    case 2:\n        if (__comp(*--__e2, *__f1))\n        {\n            __node_pointer __f = __e2.__ptr_;\n            base::__unlink_nodes(__f, __f);\n            __link_nodes(__f1.__ptr_, __f, __f);\n            return __e2;\n        }\n        return __f1;\n    }\n    size_type __n2 = __n / 2;\n    iterator __e1 = _VSTD::next(__f1, __n2);\n    iterator  __r = __f1 = __sort(__f1, __e1, __n2, __comp);\n    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);\n    if (__comp(*__f2, *__f1))\n    {\n        iterator __m2 = _VSTD::next(__f2);\n        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n            ;\n        __node_pointer __f = __f2.__ptr_;\n        __node_pointer __l = __m2.__ptr_->__prev_;\n        __r = __f2;\n        __e1 = __f2 = __m2;\n        base::__unlink_nodes(__f, __l);\n        __m2 = _VSTD::next(__f1);\n        __link_nodes(__f1.__ptr_, __f, __l);\n        __f1 = __m2;\n    }\n    else\n        ++__f1;\n    while (__f1 != __e1 && __f2 != __e2)\n    {\n        if (__comp(*__f2, *__f1))\n        {\n            iterator __m2 = _VSTD::next(__f2);\n            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)\n                ;\n            __node_pointer __f = __f2.__ptr_;\n            __node_pointer __l = __m2.__ptr_->__prev_;\n            if (__e1 == __f2)\n                __e1 = __m2;\n            __f2 = __m2;\n            base::__unlink_nodes(__f, __l);\n            __m2 = _VSTD::next(__f1);\n            __link_nodes(__f1.__ptr_, __f, __l);\n            __f1 = __m2;\n        }\n        else\n            ++__f1;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\nlist<_Tp, _Alloc>::reverse() _NOEXCEPT\n{\n    if (base::__sz() > 1)\n    {\n        iterator __e = end();\n        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)\n        {\n            _VSTD::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);\n            __i.__ptr_ = __i.__ptr_->__prev_;\n        }\n        _VSTD::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);\n    }\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__invariants() const\n{\n    return size() == _VSTD::distance(begin(), end());\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__ptr_ != static_cast<__node_pointer>(\n                       pointer_traits<__node_base_pointer>::pointer_to(const_cast<__node_base&>(this->__end_)));\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__decrementable(const const_iterator* __i) const\n{\n    return !empty() &&  __i->__ptr_ != base::__end_.__next_;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Alloc>\nbool\nlist<_Tp, _Alloc>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LIST\n","//  tuple_basic.hpp -----------------------------------------------------\n\n// Copyright (C) 1999, 2000 Jaakko Jarvi (jaakko.jarvi@cs.utu.fi)\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n// For more information, see http://www.boost.org\n\n// Outside help:\n// This and that, Gary Powell.\n// Fixed return types for get_head/get_tail\n// ( and other bugs ) per suggestion of Jens Maurer\n// simplified element type accessors + bug fix  (Jeremy Siek)\n// Several changes/additions according to suggestions by Douglas Gregor,\n// William Kempf, Vesa Karvonen, John Max Skaller, Ed Brey, Beman Dawes,\n// David Abrahams.\n\n// Revision history:\n// 2002 05 01 Hugo Duncan: Fix for Borland after Jaakko's previous changes\n// 2002 04 18 Jaakko: tuple element types can be void or plain function\n//                    types, as long as no object is created.\n//                    Tuple objects can no hold even noncopyable types\n//                    such as arrays.\n// 2001 10 22 John Maddock\n//      Fixes for Borland C++\n// 2001 08 30 David Abrahams\n//      Added default constructor for cons<>.\n// -----------------------------------------------------------------\n\n#ifndef BOOST_TUPLE_BASIC_HPP\n#define BOOST_TUPLE_BASIC_HPP\n\n\n#include <utility> // needed for the assignment from pair to tuple\n\n#include \"boost/type_traits/cv_traits.hpp\"\n#include \"boost/type_traits/function_traits.hpp\"\n#include \"boost/utility/swap.hpp\"\n\n#include \"boost/detail/workaround.hpp\" // needed for BOOST_WORKAROUND\n\nnamespace boost {\nnamespace tuples {\n\n// -- null_type --------------------------------------------------------\nstruct null_type {};\n\n// a helper function to provide a const null_type type temporary\nnamespace detail {\n  inline const null_type cnull() { return null_type(); }\n\n\n// -- if construct ------------------------------------------------\n// Proposed by Krzysztof Czarnecki and Ulrich Eisenecker\n\ntemplate <bool If, class Then, class Else> struct IF { typedef Then RET; };\n\ntemplate <class Then, class Else> struct IF<false, Then, Else> {\n  typedef Else RET;\n};\n\n} // end detail\n\n// - cons forward declaration -----------------------------------------------\ntemplate <class HT, class TT> struct cons;\n\n\n// - tuple forward declaration -----------------------------------------------\ntemplate <\n  class T0 = null_type, class T1 = null_type, class T2 = null_type,\n  class T3 = null_type, class T4 = null_type, class T5 = null_type,\n  class T6 = null_type, class T7 = null_type, class T8 = null_type,\n  class T9 = null_type>\nclass tuple;\n\n// tuple_length forward declaration\ntemplate<class T> struct length;\n\n\n\nnamespace detail {\n\n// -- generate error template, referencing to non-existing members of this\n// template is used to produce compilation errors intentionally\ntemplate<class T>\nclass generate_error;\n\ntemplate<int N>\nstruct drop_front {\n    template<class Tuple>\n    struct apply {\n        typedef BOOST_DEDUCED_TYPENAME drop_front<N-1>::BOOST_NESTED_TEMPLATE\n            apply<Tuple> next;\n        typedef BOOST_DEDUCED_TYPENAME next::type::tail_type type;\n        static const type& call(const Tuple& tup) {\n            return next::call(tup).tail;\n        }\n    };\n};\n\ntemplate<>\nstruct drop_front<0> {\n    template<class Tuple>\n    struct apply {\n        typedef Tuple type;\n        static const type& call(const Tuple& tup) {\n            return tup;\n        }\n    };\n};\n\n} // end of namespace detail\n\n\n// -cons type accessors ----------------------------------------\n// typename tuples::element<N,T>::type gets the type of the\n// Nth element ot T, first element is at index 0\n// -------------------------------------------------------\n\n#ifndef BOOST_NO_CV_SPECIALIZATIONS\n\ntemplate<int N, class T>\nstruct element\n{\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<T>::type::head_type type;\n};\n\ntemplate<int N, class T>\nstruct element<N, const T>\n{\nprivate:\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<T>::type::head_type unqualified_type;\npublic:\n#if BOOST_WORKAROUND(__BORLANDC__,<0x600)\n  typedef const unqualified_type type;\n#else\n  typedef BOOST_DEDUCED_TYPENAME boost::add_const<unqualified_type>::type type;\n#endif\n};\n#else // def BOOST_NO_CV_SPECIALIZATIONS\n\nnamespace detail {\n\ntemplate<int N, class T, bool IsConst>\nstruct element_impl\n{\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<T>::type::head_type type;\n};\n\ntemplate<int N, class T>\nstruct element_impl<N, T, true /* IsConst */>\n{\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<T>::type::head_type unqualified_type;\n  typedef const unqualified_type type;\n};\n\n} // end of namespace detail\n\n\ntemplate<int N, class T>\nstruct element:\n  public detail::element_impl<N, T, ::boost::is_const<T>::value>\n{\n};\n\n#endif\n\n\n// -get function templates -----------------------------------------------\n// Usage: get<N>(aTuple)\n\n// -- some traits classes for get functions\n\n// access traits lifted from detail namespace to be part of the interface,\n// (Joel de Guzman's suggestion). Rationale: get functions are part of the\n// interface, so should the way to express their return types be.\n\ntemplate <class T> struct access_traits {\n  typedef const T& const_type;\n  typedef T& non_const_type;\n\n  typedef const typename boost::remove_cv<T>::type& parameter_type;\n\n// used as the tuple constructors parameter types\n// Rationale: non-reference tuple element types can be cv-qualified.\n// It should be possible to initialize such types with temporaries,\n// and when binding temporaries to references, the reference must\n// be non-volatile and const. 8.5.3. (5)\n};\n\ntemplate <class T> struct access_traits<T&> {\n\n  typedef T& const_type;\n  typedef T& non_const_type;\n\n  typedef T& parameter_type;\n};\n\n// get function for non-const cons-lists, returns a reference to the element\n\ntemplate<int N, class HT, class TT>\ninline typename access_traits<\n                  typename element<N, cons<HT, TT> >::type\n                >::non_const_type\nget(cons<HT, TT>& c BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(int, N)) {\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<cons<HT, TT> > impl;\n  typedef BOOST_DEDUCED_TYPENAME impl::type cons_element;\n  return const_cast<cons_element&>(impl::call(c)).head;\n}\n\n// get function for const cons-lists, returns a const reference to\n// the element. If the element is a reference, returns the reference\n// as such (that is, can return a non-const reference)\ntemplate<int N, class HT, class TT>\ninline typename access_traits<\n                  typename element<N, cons<HT, TT> >::type\n                >::const_type\nget(const cons<HT, TT>& c BOOST_APPEND_EXPLICIT_TEMPLATE_NON_TYPE(int, N)) {\n  typedef BOOST_DEDUCED_TYPENAME detail::drop_front<N>::BOOST_NESTED_TEMPLATE\n      apply<cons<HT, TT> > impl;\n  typedef BOOST_DEDUCED_TYPENAME impl::type cons_element;\n  return impl::call(c).head;\n}\n\n// -- the cons template  --------------------------------------------------\nnamespace detail {\n\n//  These helper templates wrap void types and plain function types.\n//  The reationale is to allow one to write tuple types with those types\n//  as elements, even though it is not possible to instantiate such object.\n//  E.g: typedef tuple<void> some_type; // ok\n//  but: some_type x; // fails\n\ntemplate <class T> class non_storeable_type {\n  non_storeable_type();\n};\n\ntemplate <class T> struct wrap_non_storeable_type {\n  typedef typename IF<\n    ::boost::is_function<T>::value, non_storeable_type<T>, T\n  >::RET type;\n};\ntemplate <> struct wrap_non_storeable_type<void> {\n  typedef non_storeable_type<void> type;\n};\n\n} // detail\n\ntemplate <class HT, class TT>\nstruct cons {\n\n  typedef HT head_type;\n  typedef TT tail_type;\n\n  typedef typename\n    detail::wrap_non_storeable_type<head_type>::type stored_head_type;\n\n  stored_head_type head;\n  tail_type tail;\n\n  typename access_traits<stored_head_type>::non_const_type\n  get_head() { return head; }\n\n  typename access_traits<tail_type>::non_const_type\n  get_tail() { return tail; }\n\n  typename access_traits<stored_head_type>::const_type\n  get_head() const { return head; }\n\n  typename access_traits<tail_type>::const_type\n  get_tail() const { return tail; }\n\n  cons() : head(), tail() {}\n  //  cons() : head(detail::default_arg<HT>::f()), tail() {}\n\n  // the argument for head is not strictly needed, but it prevents\n  // array type elements. This is good, since array type elements\n  // cannot be supported properly in any case (no assignment,\n  // copy works only if the tails are exactly the same type, ...)\n\n  cons(typename access_traits<stored_head_type>::parameter_type h,\n       const tail_type& t)\n    : head (h), tail(t) {}\n\n  template <class T1, class T2, class T3, class T4, class T5,\n            class T6, class T7, class T8, class T9, class T10>\n  cons( T1& t1, T2& t2, T3& t3, T4& t4, T5& t5,\n        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )\n    : head (t1),\n      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())\n      {}\n\n  template <class T2, class T3, class T4, class T5,\n            class T6, class T7, class T8, class T9, class T10>\n  cons( const null_type& /*t1*/, T2& t2, T3& t3, T4& t4, T5& t5,\n        T6& t6, T7& t7, T8& t8, T9& t9, T10& t10 )\n    : head (),\n      tail (t2, t3, t4, t5, t6, t7, t8, t9, t10, detail::cnull())\n      {}\n\n\n  template <class HT2, class TT2>\n  cons( const cons<HT2, TT2>& u ) : head(u.head), tail(u.tail) {}\n\n  template <class HT2, class TT2>\n  cons& operator=( const cons<HT2, TT2>& u ) {\n    head=u.head; tail=u.tail; return *this;\n  }\n\n  // must define assignment operator explicitly, implicit version is\n  // illformed if HT is a reference (12.8. (12))\n  cons& operator=(const cons& u) {\n    head = u.head; tail = u.tail;  return *this;\n  }\n\n  template <class T1, class T2>\n  cons& operator=( const std::pair<T1, T2>& u ) {\n    BOOST_STATIC_ASSERT(length<cons>::value == 2); // check length = 2\n    head = u.first; tail.head = u.second; return *this;\n  }\n\n  // get member functions (non-const and const)\n  template <int N>\n  typename access_traits<\n             typename element<N, cons<HT, TT> >::type\n           >::non_const_type\n  get() {\n    return boost::tuples::get<N>(*this); // delegate to non-member get\n  }\n\n  template <int N>\n  typename access_traits<\n             typename element<N, cons<HT, TT> >::type\n           >::const_type\n  get() const {\n    return boost::tuples::get<N>(*this); // delegate to non-member get\n  }\n};\n\ntemplate <class HT>\nstruct cons<HT, null_type> {\n\n  typedef HT head_type;\n  typedef null_type tail_type;\n  typedef cons<HT, null_type> self_type;\n\n  typedef typename\n    detail::wrap_non_storeable_type<head_type>::type stored_head_type;\n  stored_head_type head;\n\n  typename access_traits<stored_head_type>::non_const_type\n  get_head() { return head; }\n\n  null_type get_tail() { return null_type(); }\n\n  typename access_traits<stored_head_type>::const_type\n  get_head() const { return head; }\n\n  const null_type get_tail() const { return null_type(); }\n\n  //  cons() : head(detail::default_arg<HT>::f()) {}\n  cons() : head() {}\n\n  cons(typename access_traits<stored_head_type>::parameter_type h,\n       const null_type& = null_type())\n    : head (h) {}\n\n  template<class T1>\n  cons(T1& t1, const null_type&, const null_type&, const null_type&,\n       const null_type&, const null_type&, const null_type&,\n       const null_type&, const null_type&, const null_type&)\n  : head (t1) {}\n\n  cons(const null_type&,\n       const null_type&, const null_type&, const null_type&,\n       const null_type&, const null_type&, const null_type&,\n       const null_type&, const null_type&, const null_type&)\n  : head () {}\n\n  template <class HT2>\n  cons( const cons<HT2, null_type>& u ) : head(u.head) {}\n\n  template <class HT2>\n  cons& operator=(const cons<HT2, null_type>& u )\n  { head = u.head; return *this; }\n\n  // must define assignment operator explicitely, implicit version\n  // is illformed if HT is a reference\n  cons& operator=(const cons& u) { head = u.head; return *this; }\n\n  template <int N>\n  typename access_traits<\n             typename element<N, self_type>::type\n            >::non_const_type\n  get(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, N)) {\n    return boost::tuples::get<N>(*this);\n  }\n\n  template <int N>\n  typename access_traits<\n             typename element<N, self_type>::type\n           >::const_type\n  get(BOOST_EXPLICIT_TEMPLATE_NON_TYPE(int, N)) const {\n    return boost::tuples::get<N>(*this);\n  }\n\n};\n\n// templates for finding out the length of the tuple -------------------\n\ntemplate<class T>\nstruct length  {\n  BOOST_STATIC_CONSTANT(int, value = 1 + length<typename T::tail_type>::value);\n};\n\ntemplate<>\nstruct length<tuple<> > {\n  BOOST_STATIC_CONSTANT(int, value = 0);\n};\n\ntemplate<>\nstruct length<tuple<> const> {\n  BOOST_STATIC_CONSTANT(int, value = 0);\n};\n\ntemplate<>\nstruct length<null_type> {\n  BOOST_STATIC_CONSTANT(int, value = 0);\n};\n\ntemplate<>\nstruct length<null_type const> {\n  BOOST_STATIC_CONSTANT(int, value = 0);\n};\n\nnamespace detail {\n\n// Tuple to cons mapper --------------------------------------------------\ntemplate <class T0, class T1, class T2, class T3, class T4,\n          class T5, class T6, class T7, class T8, class T9>\nstruct map_tuple_to_cons\n{\n  typedef cons<T0,\n               typename map_tuple_to_cons<T1, T2, T3, T4, T5,\n                                          T6, T7, T8, T9, null_type>::type\n              > type;\n};\n\n// The empty tuple is a null_type\ntemplate <>\nstruct map_tuple_to_cons<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>\n{\n  typedef null_type type;\n};\n\n} // end detail\n\n// -------------------------------------------------------------------\n// -- tuple ------------------------------------------------------\ntemplate <class T0, class T1, class T2, class T3, class T4,\n          class T5, class T6, class T7, class T8, class T9>\n\nclass tuple :\n  public detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type\n{\npublic:\n  typedef typename\n    detail::map_tuple_to_cons<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type inherited;\n  typedef typename inherited::head_type head_type;\n  typedef typename inherited::tail_type tail_type;\n\n\n// access_traits<T>::parameter_type takes non-reference types as const T&\n  tuple() {}\n\n  tuple(typename access_traits<T0>::parameter_type t0)\n    : inherited(t0, detail::cnull(), detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1)\n    : inherited(t0, t1, detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2)\n    : inherited(t0, t1, t2, detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3)\n    : inherited(t0, t1, t2, t3, detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull(),\n                detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4)\n    : inherited(t0, t1, t2, t3, t4, detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4,\n        typename access_traits<T5>::parameter_type t5)\n    : inherited(t0, t1, t2, t3, t4, t5, detail::cnull(), detail::cnull(),\n                detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4,\n        typename access_traits<T5>::parameter_type t5,\n        typename access_traits<T6>::parameter_type t6)\n    : inherited(t0, t1, t2, t3, t4, t5, t6, detail::cnull(),\n                detail::cnull(), detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4,\n        typename access_traits<T5>::parameter_type t5,\n        typename access_traits<T6>::parameter_type t6,\n        typename access_traits<T7>::parameter_type t7)\n    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, detail::cnull(),\n                detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4,\n        typename access_traits<T5>::parameter_type t5,\n        typename access_traits<T6>::parameter_type t6,\n        typename access_traits<T7>::parameter_type t7,\n        typename access_traits<T8>::parameter_type t8)\n    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, detail::cnull()) {}\n\n  tuple(typename access_traits<T0>::parameter_type t0,\n        typename access_traits<T1>::parameter_type t1,\n        typename access_traits<T2>::parameter_type t2,\n        typename access_traits<T3>::parameter_type t3,\n        typename access_traits<T4>::parameter_type t4,\n        typename access_traits<T5>::parameter_type t5,\n        typename access_traits<T6>::parameter_type t6,\n        typename access_traits<T7>::parameter_type t7,\n        typename access_traits<T8>::parameter_type t8,\n        typename access_traits<T9>::parameter_type t9)\n    : inherited(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}\n\n\n  template<class U1, class U2>\n  tuple(const cons<U1, U2>& p) : inherited(p) {}\n\n  template <class U1, class U2>\n  tuple& operator=(const cons<U1, U2>& k) {\n    inherited::operator=(k);\n    return *this;\n  }\n\n  template <class U1, class U2>\n  tuple& operator=(const std::pair<U1, U2>& k) {\n    BOOST_STATIC_ASSERT(length<tuple>::value == 2);// check_length = 2\n    this->head = k.first;\n    this->tail.head = k.second;\n    return *this;\n  }\n\n};\n\n// The empty tuple\ntemplate <>\nclass tuple<null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type, null_type>  :\n  public null_type\n{\npublic:\n  typedef null_type inherited;\n};\n\n\n// Swallows any assignment   (by Doug Gregor)\nnamespace detail {\n\nstruct swallow_assign;\ntypedef void (detail::swallow_assign::*ignore_t)();\nstruct swallow_assign {\n  swallow_assign(ignore_t(*)(ignore_t)) {}\n  template<typename T>\n  swallow_assign const& operator=(const T&) const {\n    return *this;\n  }\n};\n\n\n} // namespace detail\n\n// \"ignore\" allows tuple positions to be ignored when using \"tie\".\ninline detail::ignore_t ignore(detail::ignore_t) { return 0; }\n\n// ---------------------------------------------------------------------------\n// The call_traits for make_tuple\n// Honours the reference_wrapper class.\n\n// Must be instantiated with plain or const plain types (not with references)\n\n// from template<class T> foo(const T& t) : make_tuple_traits<const T>::type\n// from template<class T> foo(T& t) : make_tuple_traits<T>::type\n\n// Conversions:\n// T -> T,\n// references -> compile_time_error\n// reference_wrapper<T> -> T&\n// const reference_wrapper<T> -> T&\n// array -> const ref array\n\n\ntemplate<class T>\nstruct make_tuple_traits {\n  typedef T type;\n\n  // commented away, see below  (JJ)\n  //  typedef typename IF<\n  //  boost::is_function<T>::value,\n  //  T&,\n  //  T>::RET type;\n\n};\n\n// The is_function test was there originally for plain function types,\n// which can't be stored as such (we must either store them as references or\n// pointers). Such a type could be formed if make_tuple was called with a\n// reference to a function.\n// But this would mean that a const qualified function type was formed in\n// the make_tuple function and hence make_tuple can't take a function\n// reference as a parameter, and thus T can't be a function type.\n// So is_function test was removed.\n// (14.8.3. says that type deduction fails if a cv-qualified function type\n// is created. (It only applies for the case of explicitly specifying template\n// args, though?)) (JJ)\n\ntemplate<class T>\nstruct make_tuple_traits<T&> {\n  typedef typename\n     detail::generate_error<T&>::\n       do_not_use_with_reference_type error;\n};\n\n// Arrays can't be stored as plain types; convert them to references.\n// All arrays are converted to const. This is because make_tuple takes its\n// parameters as const T& and thus the knowledge of the potential\n// non-constness of actual argument is lost.\ntemplate<class T, int n>  struct make_tuple_traits <T[n]> {\n  typedef const T (&type)[n];\n};\n\ntemplate<class T, int n>\nstruct make_tuple_traits<const T[n]> {\n  typedef const T (&type)[n];\n};\n\ntemplate<class T, int n>  struct make_tuple_traits<volatile T[n]> {\n  typedef const volatile T (&type)[n];\n};\n\ntemplate<class T, int n>\nstruct make_tuple_traits<const volatile T[n]> {\n  typedef const volatile T (&type)[n];\n};\n\ntemplate<class T>\nstruct make_tuple_traits<reference_wrapper<T> >{\n  typedef T& type;\n};\n\ntemplate<class T>\nstruct make_tuple_traits<const reference_wrapper<T> >{\n  typedef T& type;\n};\n\ntemplate<>\nstruct make_tuple_traits<detail::ignore_t(detail::ignore_t)> {\n  typedef detail::swallow_assign type;\n};\n\n\n\nnamespace detail {\n\n// a helper traits to make the make_tuple functions shorter (Vesa Karvonen's\n// suggestion)\ntemplate <\n  class T0 = null_type, class T1 = null_type, class T2 = null_type,\n  class T3 = null_type, class T4 = null_type, class T5 = null_type,\n  class T6 = null_type, class T7 = null_type, class T8 = null_type,\n  class T9 = null_type\n>\nstruct make_tuple_mapper {\n  typedef\n    tuple<typename make_tuple_traits<T0>::type,\n          typename make_tuple_traits<T1>::type,\n          typename make_tuple_traits<T2>::type,\n          typename make_tuple_traits<T3>::type,\n          typename make_tuple_traits<T4>::type,\n          typename make_tuple_traits<T5>::type,\n          typename make_tuple_traits<T6>::type,\n          typename make_tuple_traits<T7>::type,\n          typename make_tuple_traits<T8>::type,\n          typename make_tuple_traits<T9>::type> type;\n};\n\n} // end detail\n\n// -make_tuple function templates -----------------------------------\ninline tuple<> make_tuple() {\n  return tuple<>();\n}\n\ntemplate<class T0>\ninline typename detail::make_tuple_mapper<T0>::type\nmake_tuple(const T0& t0) {\n  typedef typename detail::make_tuple_mapper<T0>::type t;\n  return t(t0);\n}\n\ntemplate<class T0, class T1>\ninline typename detail::make_tuple_mapper<T0, T1>::type\nmake_tuple(const T0& t0, const T1& t1) {\n  typedef typename detail::make_tuple_mapper<T0, T1>::type t;\n  return t(t0, t1);\n}\n\ntemplate<class T0, class T1, class T2>\ninline typename detail::make_tuple_mapper<T0, T1, T2>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2) {\n  typedef typename detail::make_tuple_mapper<T0, T1, T2>::type t;\n  return t(t0, t1, t2);\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline typename detail::make_tuple_mapper<T0, T1, T2, T3>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3) {\n  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3>::type t;\n  return t(t0, t1, t2, t3);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4>\ninline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4) {\n  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4>::type t;\n  return t(t0, t1, t2, t3, t4);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5>\ninline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4, const T5& t5) {\n  typedef typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5>::type t;\n  return t(t0, t1, t2, t3, t4, t5);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4, const T5& t5, const T6& t6) {\n  typedef typename detail::make_tuple_mapper\n           <T0, T1, T2, T3, T4, T5, T6>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7>\ninline typename detail::make_tuple_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4, const T5& t5, const T6& t6, const T7& t7) {\n  typedef typename detail::make_tuple_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7, class T8>\ninline typename detail::make_tuple_mapper\n  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,\n                  const T8& t8) {\n  typedef typename detail::make_tuple_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7, class T8, class T9>\ninline typename detail::make_tuple_mapper\n  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type\nmake_tuple(const T0& t0, const T1& t1, const T2& t2, const T3& t3,\n                  const T4& t4, const T5& t5, const T6& t6, const T7& t7,\n                  const T8& t8, const T9& t9) {\n  typedef typename detail::make_tuple_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);\n}\n\nnamespace detail {\n\ntemplate<class T>\nstruct tie_traits {\n  typedef T& type;\n};\n\ntemplate<>\nstruct tie_traits<ignore_t(ignore_t)> {\n  typedef swallow_assign type;\n};\n\ntemplate<>\nstruct tie_traits<void> {\n  typedef null_type type;\n};\n\ntemplate <\n  class T0 = void, class T1 = void, class T2 = void,\n  class T3 = void, class T4 = void, class T5 = void,\n  class T6 = void, class T7 = void, class T8 = void,\n  class T9 = void\n>\nstruct tie_mapper {\n  typedef\n    tuple<typename tie_traits<T0>::type,\n          typename tie_traits<T1>::type,\n          typename tie_traits<T2>::type,\n          typename tie_traits<T3>::type,\n          typename tie_traits<T4>::type,\n          typename tie_traits<T5>::type,\n          typename tie_traits<T6>::type,\n          typename tie_traits<T7>::type,\n          typename tie_traits<T8>::type,\n          typename tie_traits<T9>::type> type;\n};\n\n}\n\n// Tie function templates -------------------------------------------------\ntemplate<class T0>\ninline typename detail::tie_mapper<T0>::type\ntie(T0& t0) {\n  typedef typename detail::tie_mapper<T0>::type t;\n  return t(t0);\n}\n\ntemplate<class T0, class T1>\ninline typename detail::tie_mapper<T0, T1>::type\ntie(T0& t0, T1& t1) {\n  typedef typename detail::tie_mapper<T0, T1>::type t;\n  return t(t0, t1);\n}\n\ntemplate<class T0, class T1, class T2>\ninline typename detail::tie_mapper<T0, T1, T2>::type\ntie(T0& t0, T1& t1, T2& t2) {\n  typedef typename detail::tie_mapper<T0, T1, T2>::type t;\n  return t(t0, t1, t2);\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline typename detail::tie_mapper<T0, T1, T2, T3>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3) {\n  typedef typename detail::tie_mapper<T0, T1, T2, T3>::type t;\n  return t(t0, t1, t2, t3);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4>\ninline typename detail::tie_mapper<T0, T1, T2, T3, T4>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4) {\n  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4>::type t;\n  return t(t0, t1, t2, t3, t4);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5>\ninline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4, T5& t5) {\n  typedef typename detail::tie_mapper<T0, T1, T2, T3, T4, T5>::type t;\n  return t(t0, t1, t2, t3, t4, t5);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6>\ninline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4, T5& t5, T6& t6) {\n  typedef typename detail::tie_mapper\n           <T0, T1, T2, T3, T4, T5, T6>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7>\ninline typename detail::tie_mapper<T0, T1, T2, T3, T4, T5, T6, T7>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4, T5& t5, T6& t6, T7& t7) {\n  typedef typename detail::tie_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7, class T8>\ninline typename detail::tie_mapper\n  <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4, T5& t5, T6& t6, T7& t7,\n                  T8& t8) {\n  typedef typename detail::tie_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7, T8>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8);\n}\n\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6,\n         class T7, class T8, class T9>\ninline typename detail::tie_mapper\n  <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type\ntie(T0& t0, T1& t1, T2& t2, T3& t3,\n                  T4& t4, T5& t5, T6& t6, T7& t7,\n                  T8& t8, T9& t9) {\n  typedef typename detail::tie_mapper\n           <T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>::type t;\n  return t(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9);\n}\n\ntemplate <class T0, class T1, class T2, class T3, class T4,\n          class T5, class T6, class T7, class T8, class T9>\nvoid swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,\n          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs);\ninline void swap(null_type&, null_type&) {}\ntemplate<class HH>\ninline void swap(cons<HH, null_type>& lhs, cons<HH, null_type>& rhs) {\n  ::boost::swap(lhs.head, rhs.head);\n}\ntemplate<class HH, class TT>\ninline void swap(cons<HH, TT>& lhs, cons<HH, TT>& rhs) {\n  ::boost::swap(lhs.head, rhs.head);\n  ::boost::tuples::swap(lhs.tail, rhs.tail);\n}\ntemplate <class T0, class T1, class T2, class T3, class T4,\n          class T5, class T6, class T7, class T8, class T9>\ninline void swap(tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& lhs,\n          tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9>& rhs) {\n  typedef tuple<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9> tuple_type;\n  typedef typename tuple_type::inherited base;\n  ::boost::tuples::swap(static_cast<base&>(lhs), static_cast<base&>(rhs));\n}\n\n} // end of namespace tuples\n} // end of namespace boost\n\n\n#endif // BOOST_TUPLE_BASIC_HPP\n\n\n","// -*- c++ -*-\n//=======================================================================\n// Copyright 1997, 1998, 1999, 2000 University of Notre Dame.\n// Copyright 2010 Thomas Claveirole\n// Authors: Andrew Lumsdaine, Lie-Quan Lee, Jeremy G. Siek, Thomas Claveirole\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//=======================================================================\n\n#ifndef BOOST_GRAPH_DETAIL_ADJACENCY_LIST_HPP\n#define BOOST_GRAPH_DETAIL_ADJACENCY_LIST_HPP\n\n#include <map> // for vertex_map in copy_impl\n#include <boost/config.hpp>\n#include <boost/detail/workaround.hpp>\n#include <boost/operators.hpp>\n#include <boost/property_map/property_map.hpp>\n#include <boost/pending/container_traits.hpp>\n#include <boost/range/irange.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <memory>\n#include <algorithm>\n#include <boost/limits.hpp>\n\n#include <boost/iterator/iterator_adaptor.hpp>\n\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/and.hpp>\n#include <boost/graph/graph_concepts.hpp>\n#include <boost/pending/container_traits.hpp>\n#include <boost/graph/detail/adj_list_edge_iterator.hpp>\n#include <boost/graph/properties.hpp>\n#include <boost/pending/property.hpp>\n#include <boost/graph/adjacency_iterator.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/assert.hpp>\n\n/*\n  Outline for this file:\n\n  out_edge_iterator and in_edge_iterator implementation\n  edge_iterator for undirected graph\n  stored edge types (these object live in the out-edge/in-edge lists)\n  directed edges helper class\n  directed graph helper class\n  undirected graph helper class\n  bidirectional graph helper class\n  bidirectional graph helper class (without edge properties)\n  bidirectional graph helper class (with edge properties)\n  adjacency_list helper class\n  adj_list_impl class\n  vec_adj_list_impl class\n  adj_list_gen class\n  vertex property map\n  edge property map\n\n\n  Note: it would be nice to merge some of the undirected and\n  bidirectional code... it is awful similar.\n */\n\n\nnamespace boost {\n\n  namespace detail {\n\n    template <typename DirectedS>\n    struct directed_category_traits {\n      typedef directed_tag directed_category;\n    };\n\n    template <>\n    struct directed_category_traits<directedS> {\n      typedef directed_tag directed_category;\n    };\n    template <>\n    struct directed_category_traits<undirectedS> {\n      typedef undirected_tag directed_category;\n    };\n    template <>\n    struct directed_category_traits<bidirectionalS> {\n      typedef bidirectional_tag directed_category;\n    };\n\n    template <class Vertex>\n    struct target_is {\n      target_is(const Vertex& v) : m_target(v) { }\n      template <class StoredEdge>\n      bool operator()(const StoredEdge& e) const {\n        return e.get_target() == m_target;\n      }\n      Vertex m_target;\n    };\n\n    // O(E/V)\n    template <class EdgeList, class vertex_descriptor>\n    void erase_from_incidence_list(EdgeList& el, vertex_descriptor v,\n                                   allow_parallel_edge_tag)\n    {\n      boost::graph_detail::erase_if(el, detail::target_is<vertex_descriptor>(v));\n    }\n    // O(log(E/V))\n    template <class EdgeList, class vertex_descriptor>\n    void erase_from_incidence_list(EdgeList& el, vertex_descriptor v,\n                                   disallow_parallel_edge_tag)\n    {\n      typedef typename EdgeList::value_type StoredEdge;\n      el.erase(StoredEdge(v));\n    }\n\n    //=========================================================================\n    // Out-Edge and In-Edge Iterator Implementation\n\n    template <class BaseIter, class VertexDescriptor, class EdgeDescriptor, class Difference>\n    struct out_edge_iter\n      : iterator_adaptor<\n            out_edge_iter<BaseIter, VertexDescriptor, EdgeDescriptor, Difference>\n          , BaseIter\n          , EdgeDescriptor\n          , use_default\n          , EdgeDescriptor\n          , Difference\n        >\n    {\n      typedef iterator_adaptor<\n          out_edge_iter<BaseIter, VertexDescriptor, EdgeDescriptor, Difference>\n        , BaseIter\n        , EdgeDescriptor\n        , use_default\n        , EdgeDescriptor\n        , Difference\n      > super_t;\n\n      inline out_edge_iter() { }\n        inline out_edge_iter(const BaseIter& i, const VertexDescriptor& src)\n          : super_t(i), m_src(src) { }\n\n      inline EdgeDescriptor\n      dereference() const\n      {\n        return EdgeDescriptor(m_src, (*this->base()).get_target(),\n                              &(*this->base()).get_property());\n      }\n      VertexDescriptor m_src;\n    };\n\n    template <class BaseIter, class VertexDescriptor, class EdgeDescriptor, class Difference>\n    struct in_edge_iter\n      : iterator_adaptor<\n            in_edge_iter<BaseIter, VertexDescriptor, EdgeDescriptor, Difference>\n          , BaseIter\n          , EdgeDescriptor\n          , use_default\n          , EdgeDescriptor\n          , Difference\n        >\n    {\n      typedef iterator_adaptor<\n          in_edge_iter<BaseIter, VertexDescriptor, EdgeDescriptor, Difference>\n        , BaseIter\n        , EdgeDescriptor\n        , use_default\n        , EdgeDescriptor\n        , Difference\n      > super_t;\n\n      inline in_edge_iter() { }\n      inline in_edge_iter(const BaseIter& i, const VertexDescriptor& src)\n        : super_t(i), m_src(src) { }\n\n      inline EdgeDescriptor\n      dereference() const\n      {\n        return EdgeDescriptor((*this->base()).get_target(), m_src,\n                              &this->base()->get_property());\n      }\n      VertexDescriptor m_src;\n    };\n\n    //=========================================================================\n    // Undirected Edge Iterator Implementation\n\n    template <class EdgeIter, class EdgeDescriptor, class Difference>\n    struct undirected_edge_iter\n      : iterator_adaptor<\n            undirected_edge_iter<EdgeIter, EdgeDescriptor, Difference>\n          , EdgeIter\n          , EdgeDescriptor\n          , use_default\n          , EdgeDescriptor\n          , Difference\n        >\n    {\n      typedef iterator_adaptor<\n          undirected_edge_iter<EdgeIter, EdgeDescriptor, Difference>\n        , EdgeIter\n        , EdgeDescriptor\n        , use_default\n        , EdgeDescriptor\n        , Difference\n      > super_t;\n\n      undirected_edge_iter() {}\n\n      explicit undirected_edge_iter(EdgeIter i)\n          : super_t(i) {}\n\n      inline EdgeDescriptor\n      dereference() const {\n        return EdgeDescriptor(\n            (*this->base()).m_source\n          , (*this->base()).m_target\n          , &this->base()->get_property());\n      }\n    };\n\n    //=========================================================================\n    // Edge Storage Types (stored in the out-edge/in-edge lists)\n\n    template <class Vertex>\n    class stored_edge\n      : public boost::equality_comparable1< stored_edge<Vertex>,\n        boost::less_than_comparable1< stored_edge<Vertex> > >\n    {\n    public:\n      typedef no_property property_type;\n      inline stored_edge() { }\n      inline stored_edge(Vertex target, const no_property& = no_property())\n        : m_target(target) { }\n      // Need to write this explicitly so stored_edge_property can\n      // invoke Base::operator= (at least, for SGI MIPSPro compiler)\n      inline stored_edge& operator=(const stored_edge& x) {\n        m_target = x.m_target;\n        return *this;\n      }\n      inline Vertex& get_target() const { return m_target; }\n      inline const no_property& get_property() const { return s_prop; }\n      inline bool operator==(const stored_edge& x) const\n        { return m_target == x.get_target(); }\n      inline bool operator<(const stored_edge& x) const\n        { return m_target < x.get_target(); }\n      //protected: need to add hash<> as a friend\n      static no_property s_prop;\n      // Sometimes target not used as key in the set, and in that case\n      // it is ok to change the target.\n      mutable Vertex m_target;\n    };\n    template <class Vertex>\n    no_property stored_edge<Vertex>::s_prop;\n\n    template <class Vertex, class Property>\n    class stored_edge_property : public stored_edge<Vertex> {\n      typedef stored_edge_property self;\n      typedef stored_edge<Vertex> Base;\n    public:\n      typedef Property property_type;\n      inline stored_edge_property() { }\n      inline stored_edge_property(Vertex target,\n                                  const Property& p = Property())\n        : stored_edge<Vertex>(target), m_property(new Property(p)) { }\n      stored_edge_property(const self& x)\n        : Base(x), m_property(const_cast<self&>(x).m_property) { }\n      self& operator=(const self& x) {\n        Base::operator=(x);\n        m_property = const_cast<self&>(x).m_property;\n        return *this;\n      }\n      inline Property& get_property() { return *m_property; }\n      inline const Property& get_property() const { return *m_property; }\n    protected:\n      // Holding the property by-value causes edge-descriptor\n      // invalidation for add_edge() with EdgeList=vecS. Instead we\n      // hold a pointer to the property. std::auto_ptr is not\n      // a perfect fit for the job, but it is darn close.\n      std::auto_ptr<Property> m_property;\n    };\n\n\n    template <class Vertex, class Iter, class Property>\n    class stored_edge_iter\n      : public stored_edge<Vertex>\n    {\n    public:\n      typedef Property property_type;\n      inline stored_edge_iter() { }\n      inline stored_edge_iter(Vertex v)\n        : stored_edge<Vertex>(v) { }\n      inline stored_edge_iter(Vertex v, Iter i, void* = 0)\n        : stored_edge<Vertex>(v), m_iter(i) { }\n      inline Property& get_property() { return m_iter->get_property(); }\n      inline const Property& get_property() const {\n        return m_iter->get_property();\n      }\n      inline Iter get_iter() const { return m_iter; }\n    protected:\n      Iter m_iter;\n    };\n\n    // For when the EdgeList is a std::vector.\n    // Want to make the iterator stable, so use an offset\n    // instead of an iterator into a std::vector\n    template <class Vertex, class EdgeVec, class Property>\n    class stored_ra_edge_iter\n      : public stored_edge<Vertex>\n    {\n      typedef typename EdgeVec::iterator Iter;\n    public:\n      typedef Property property_type;\n      inline stored_ra_edge_iter() { }\n      inline explicit stored_ra_edge_iter(Vertex v) // Only used for comparisons\n        : stored_edge<Vertex>(v), m_i(0), m_vec(0){ }\n      inline stored_ra_edge_iter(Vertex v, Iter i, EdgeVec* edge_vec)\n        : stored_edge<Vertex>(v), m_i(i - edge_vec->begin()), m_vec(edge_vec){ }\n      inline Property& get_property() { BOOST_ASSERT ((m_vec != 0)); return (*m_vec)[m_i].get_property(); }\n      inline const Property& get_property() const {\n        BOOST_ASSERT ((m_vec != 0));\n        return (*m_vec)[m_i].get_property();\n      }\n      inline Iter get_iter() const { BOOST_ASSERT ((m_vec != 0)); return m_vec->begin() + m_i; }\n    protected:\n      std::size_t m_i;\n      EdgeVec* m_vec;\n    };\n\n  } // namespace detail\n\n  template <class Tag, class Vertex, class Property>\n  const typename property_value<Property,Tag>::type&\n  get(Tag property_tag,\n      const detail::stored_edge_property<Vertex, Property>& e)\n  {\n    return get_property_value(e.get_property(), property_tag);\n  }\n\n  template <class Tag, class Vertex, class Iter, class Property>\n  const typename property_value<Property,Tag>::type&\n  get(Tag property_tag,\n      const detail::stored_edge_iter<Vertex, Iter, Property>& e)\n  {\n    return get_property_value(e.get_property(), property_tag);\n  }\n\n  template <class Tag, class Vertex, class EdgeVec, class Property>\n  const typename property_value<Property,Tag>::type&\n  get(Tag property_tag,\n      const detail::stored_ra_edge_iter<Vertex, EdgeVec, Property>& e)\n  {\n    return get_property_value(e.get_property(), property_tag);\n  }\n\n    //=========================================================================\n    // Directed Edges Helper Class\n\n    namespace detail {\n\n      // O(E/V)\n      template <class edge_descriptor, class EdgeList, class StoredProperty>\n      inline void\n      remove_directed_edge_dispatch(edge_descriptor, EdgeList& el,\n                                    StoredProperty& p)\n      {\n        for (typename EdgeList::iterator i = el.begin();\n             i != el.end(); ++i)\n          if (&(*i).get_property() == &p) {\n            el.erase(i);\n            return;\n          }\n      }\n\n      template <class incidence_iterator, class EdgeList, class Predicate>\n      inline void\n      remove_directed_edge_if_dispatch(incidence_iterator first,\n                                       incidence_iterator last,\n                                       EdgeList& el, Predicate pred,\n                                       boost::allow_parallel_edge_tag)\n      {\n        // remove_if\n        while (first != last && !pred(*first))\n          ++first;\n        incidence_iterator i = first;\n        if (first != last)\n          for (++i; i != last; ++i)\n            if (!pred(*i)) {\n              *first.base() = *i.base();\n              ++first;\n            }\n        el.erase(first.base(), el.end());\n      }\n      template <class incidence_iterator, class EdgeList, class Predicate>\n      inline void\n      remove_directed_edge_if_dispatch(incidence_iterator first,\n                                       incidence_iterator last,\n                                       EdgeList& el,\n                                       Predicate pred,\n                                       boost::disallow_parallel_edge_tag)\n      {\n        for (incidence_iterator next = first;\n             first != last; first = next) {\n          ++next;\n          if (pred(*first))\n            el.erase( first.base() );\n        }\n      }\n\n      template <class PropT, class Graph, class incidence_iterator,\n                class EdgeList, class Predicate>\n      inline void\n      undirected_remove_out_edge_if_dispatch(Graph& g,\n                                             incidence_iterator first,\n                                             incidence_iterator last,\n                                             EdgeList& el, Predicate pred,\n                                             boost::allow_parallel_edge_tag)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        // remove_if\n        while (first != last && !pred(*first))\n          ++first;\n        incidence_iterator i = first;\n        bool self_loop_removed = false;\n        if (first != last)\n          for (; i != last; ++i) {\n            if (self_loop_removed) {\n              /* With self loops, the descriptor will show up\n               * twice. The first time it will be removed, and now it\n               * will be skipped.\n               */\n              self_loop_removed = false;\n            }\n            else if (!pred(*i)) {\n              *first.base() = *i.base();\n              ++first;\n            } else {\n              if (source(*i, g) == target(*i, g)) self_loop_removed = true;\n              else {\n                // Remove the edge from the target\n                detail::remove_directed_edge_dispatch\n                  (*i,\n                   g.out_edge_list(target(*i, g)),\n                   *(PropT*)(*i).get_property());\n              }\n\n              // Erase the edge property\n              g.m_edges.erase( (*i.base()).get_iter() );\n            }\n          }\n        el.erase(first.base(), el.end());\n      }\n      template <class PropT, class Graph, class incidence_iterator,\n                class EdgeList, class Predicate>\n      inline void\n      undirected_remove_out_edge_if_dispatch(Graph& g,\n                                             incidence_iterator first,\n                                             incidence_iterator last,\n                                             EdgeList& el,\n                                             Predicate pred,\n                                             boost::disallow_parallel_edge_tag)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        for (incidence_iterator next = first;\n             first != last; first = next) {\n          ++next;\n          if (pred(*first)) {\n            if (source(*first, g) != target(*first, g)) {\n              // Remove the edge from the target\n              detail::remove_directed_edge_dispatch\n                (*first,\n                 g.out_edge_list(target(*first, g)),\n                 *(PropT*)(*first).get_property());\n            }\n\n            // Erase the edge property\n            g.m_edges.erase( (*first.base()).get_iter() );\n\n            // Erase the edge in the source\n            el.erase( first.base() );\n          }\n        }\n      }\n\n      // O(E/V)\n      template <class edge_descriptor, class EdgeList, class StoredProperty>\n      inline void\n      remove_directed_edge_dispatch(edge_descriptor e, EdgeList& el,\n                                    no_property&)\n      {\n        for (typename EdgeList::iterator i = el.begin();\n             i != el.end(); ++i)\n          if ((*i).get_target() == e.m_target) {\n            el.erase(i);\n            return;\n          }\n      }\n\n    } // namespace detail\n\n    template <class Config>\n    struct directed_edges_helper {\n\n      // Placement of these overloaded remove_edge() functions\n      // inside the class avoids a VC++ bug.\n\n      // O(E/V)\n      inline void\n      remove_edge(typename Config::edge_descriptor e)\n      {\n        typedef typename Config::graph_type graph_type;\n        graph_type& g = static_cast<graph_type&>(*this);\n        typename Config::OutEdgeList& el = g.out_edge_list(source(e, g));\n        typedef typename Config::OutEdgeList::value_type::property_type PType;\n        detail::remove_directed_edge_dispatch(e, el,\n                                              *(PType*)e.get_property());\n      }\n\n      // O(1)\n      inline void\n      remove_edge(typename Config::out_edge_iterator iter)\n      {\n        typedef typename Config::graph_type graph_type;\n        graph_type& g = static_cast<graph_type&>(*this);\n        typename Config::edge_descriptor e = *iter;\n        typename Config::OutEdgeList& el = g.out_edge_list(source(e, g));\n        el.erase(iter.base());\n      }\n\n    };\n\n    // O(1)\n    template <class Config>\n    inline std::pair<typename Config::edge_iterator,\n                     typename Config::edge_iterator>\n    edges(const directed_edges_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_iterator edge_iterator;\n      const graph_type& cg = static_cast<const graph_type&>(g_);\n      graph_type& g = const_cast<graph_type&>(cg);\n      return std::make_pair( edge_iterator(g.vertex_set().begin(),\n                                           g.vertex_set().begin(),\n                                           g.vertex_set().end(), g),\n                             edge_iterator(g.vertex_set().begin(),\n                                           g.vertex_set().end(),\n                                           g.vertex_set().end(), g) );\n    }\n\n    //=========================================================================\n    // Directed Graph Helper Class\n\n    struct adj_list_dir_traversal_tag :\n      public virtual vertex_list_graph_tag,\n      public virtual incidence_graph_tag,\n      public virtual adjacency_graph_tag,\n      public virtual edge_list_graph_tag { };\n\n    template <class Config>\n    struct directed_graph_helper\n      : public directed_edges_helper<Config> {\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef adj_list_dir_traversal_tag traversal_category;\n    };\n\n    // O(E/V)\n    template <class Config>\n    inline void\n    remove_edge(typename Config::vertex_descriptor u,\n                typename Config::vertex_descriptor v,\n                directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_parallel_category Cat;\n      graph_type& g = static_cast<graph_type&>(g_);\n      detail::erase_from_incidence_list(g.out_edge_list(u), v, Cat());\n    }\n\n    template <class Config, class Predicate>\n    inline void\n    remove_out_edge_if(typename Config::vertex_descriptor u, Predicate pred,\n                       directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::out_edge_iterator first, last;\n      boost::tie(first, last) = out_edges(u, g);\n      typedef typename Config::edge_parallel_category edge_parallel_category;\n      detail::remove_directed_edge_if_dispatch\n        (first, last, g.out_edge_list(u), pred, edge_parallel_category());\n    }\n\n    template <class Config, class Predicate>\n    inline void\n    remove_edge_if(Predicate pred, directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n\n      typename Config::vertex_iterator vi, vi_end;\n      for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)\n        remove_out_edge_if(*vi, pred, g);\n    }\n\n    template <class EdgeOrIter, class Config>\n    inline void\n    remove_edge(EdgeOrIter e_or_iter, directed_graph_helper<Config>& g_)\n    {\n      g_.remove_edge(e_or_iter);\n    }\n\n    // O(V + E) for allow_parallel_edges\n    // O(V * log(E/V)) for disallow_parallel_edges\n    template <class Config>\n    inline void\n    clear_vertex(typename Config::vertex_descriptor u,\n                 directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_parallel_category Cat;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::vertex_iterator vi, viend;\n      for (boost::tie(vi, viend) = vertices(g); vi != viend; ++vi)\n        detail::erase_from_incidence_list(g.out_edge_list(*vi), u, Cat());\n      g.out_edge_list(u).clear();\n      // clear() should be a req of Sequence and AssociativeContainer,\n      // or maybe just Container\n    }\n\n    template <class Config>\n    inline void\n    clear_out_edges(typename Config::vertex_descriptor u,\n                    directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      g.out_edge_list(u).clear();\n      // clear() should be a req of Sequence and AssociativeContainer,\n      // or maybe just Container\n    }\n\n    // O(V), could do better...\n    template <class Config>\n    inline typename Config::edges_size_type\n    num_edges(const directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      const graph_type& g = static_cast<const graph_type&>(g_);\n      typename Config::edges_size_type num_e = 0;\n      typename Config::vertex_iterator vi, vi_end;\n      for (boost::tie(vi, vi_end) = vertices(g); vi != vi_end; ++vi)\n        num_e += out_degree(*vi, g);\n      return num_e;\n    }\n    // O(1) for allow_parallel_edge_tag\n    // O(log(E/V)) for disallow_parallel_edge_tag\n    template <class Config>\n    inline std::pair<typename directed_graph_helper<Config>::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             const typename Config::edge_property_type& p,\n             directed_graph_helper<Config>& g_)\n    {\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::StoredEdge StoredEdge;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::OutEdgeList::iterator i;\n      bool inserted;\n      boost::tie(i, inserted) = boost::graph_detail::push(g.out_edge_list(u),\n                                            StoredEdge(v, p));\n      return std::make_pair(edge_descriptor(u, v, &(*i).get_property()),\n                            inserted);\n    }\n    // Did not use default argument here because that\n    // causes Visual C++ to get confused.\n    template <class Config>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             directed_graph_helper<Config>& g_)\n    {\n      typename Config::edge_property_type p;\n      return add_edge(u, v, p, g_);\n    }\n    //=========================================================================\n    // Undirected Graph Helper Class\n\n    template <class Config>\n    struct undirected_graph_helper;\n\n    struct undir_adj_list_traversal_tag :\n      public virtual vertex_list_graph_tag,\n      public virtual incidence_graph_tag,\n      public virtual adjacency_graph_tag,\n      public virtual edge_list_graph_tag,\n      public virtual bidirectional_graph_tag { };\n\n    namespace detail {\n\n      // using class with specialization for dispatch is a VC++ workaround.\n      template <class StoredProperty>\n      struct remove_undirected_edge_dispatch {\n\n        // O(E/V)\n        template <class edge_descriptor, class Config>\n        static void\n        apply(edge_descriptor e,\n              undirected_graph_helper<Config>& g_,\n              StoredProperty& p)\n        {\n          typedef typename Config::global_edgelist_selector EdgeListS;\n          BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n          typedef typename Config::graph_type graph_type;\n          graph_type& g = static_cast<graph_type&>(g_);\n\n          typename Config::OutEdgeList& out_el = g.out_edge_list(source(e, g));\n          typename Config::OutEdgeList::iterator out_i = out_el.begin();\n          typename Config::EdgeIter edge_iter_to_erase;\n          for (; out_i != out_el.end(); ++out_i)\n            if (&(*out_i).get_property() == &p) {\n              edge_iter_to_erase = (*out_i).get_iter();\n              out_el.erase(out_i);\n              break;\n            }\n          typename Config::OutEdgeList& in_el = g.out_edge_list(target(e, g));\n          typename Config::OutEdgeList::iterator in_i = in_el.begin();\n          for (; in_i != in_el.end(); ++in_i)\n            if (&(*in_i).get_property() == &p) {\n              in_el.erase(in_i);\n              break;\n            }\n          g.m_edges.erase(edge_iter_to_erase);\n        }\n      };\n\n      template <>\n      struct remove_undirected_edge_dispatch<no_property> {\n        // O(E/V)\n        template <class edge_descriptor, class Config>\n        static void\n        apply(edge_descriptor e,\n              undirected_graph_helper<Config>& g_,\n              no_property&)\n        {\n          typedef typename Config::global_edgelist_selector EdgeListS;\n          BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n          typedef typename Config::graph_type graph_type;\n          graph_type& g = static_cast<graph_type&>(g_);\n          no_property* p = (no_property*)e.get_property();\n          typename Config::OutEdgeList& out_el = g.out_edge_list(source(e, g));\n          typename Config::OutEdgeList::iterator out_i = out_el.begin();\n          typename Config::EdgeIter edge_iter_to_erase;\n          for (; out_i != out_el.end(); ++out_i)\n            if (&(*out_i).get_property() == p) {\n              edge_iter_to_erase = (*out_i).get_iter();\n              out_el.erase(out_i);\n              break;\n            }\n          typename Config::OutEdgeList& in_el = g.out_edge_list(target(e, g));\n          typename Config::OutEdgeList::iterator in_i = in_el.begin();\n          for (; in_i != in_el.end(); ++in_i)\n            if (&(*in_i).get_property() == p) {\n              in_el.erase(in_i);\n              break;\n            }\n          g.m_edges.erase(edge_iter_to_erase);\n        }\n      };\n\n      // O(E/V)\n      template <class Graph, class EdgeList, class Vertex>\n      inline void\n      remove_edge_and_property(Graph& g, EdgeList& el, Vertex v,\n                               boost::allow_parallel_edge_tag cat)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typename EdgeList::iterator i = el.begin(), end = el.end();\n        for (; i != end; ++i) {\n          if ((*i).get_target() == v) {\n            // NOTE: Wihtout this skip, this loop will double-delete properties\n            // of loop edges. This solution is based on the observation that\n            // the incidence edges of a vertex with a loop are adjacent in the\n            // out edge list. This *may* actually hold for multisets also.\n            bool skip = (boost::next(i) != end && i->get_iter() == boost::next(i)->get_iter());\n            g.m_edges.erase((*i).get_iter());\n            if (skip) ++i;\n          }\n        }\n        detail::erase_from_incidence_list(el, v, cat);\n      }\n      // O(log(E/V))\n      template <class Graph, class EdgeList, class Vertex>\n      inline void\n      remove_edge_and_property(Graph& g, EdgeList& el, Vertex v,\n                               boost::disallow_parallel_edge_tag)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typedef typename EdgeList::value_type StoredEdge;\n        typename EdgeList::iterator i = el.find(StoredEdge(v)), end = el.end();\n        if (i != end) {\n          g.m_edges.erase((*i).get_iter());\n          el.erase(i);\n        }\n      }\n\n    } // namespace detail\n\n    template <class Vertex, class EdgeProperty>\n    struct list_edge // short name due to VC++ truncation and linker problems\n      : public boost::detail::edge_base<boost::undirected_tag, Vertex>\n    {\n      typedef EdgeProperty property_type;\n      typedef boost::detail::edge_base<boost::undirected_tag, Vertex> Base;\n      list_edge(Vertex u, Vertex v, const EdgeProperty& p = EdgeProperty())\n        : Base(u, v), m_property(p) { }\n      EdgeProperty& get_property() { return m_property; }\n      const EdgeProperty& get_property() const { return m_property; }\n      // the following methods should never be used, but are needed\n      // to make SGI MIPSpro C++ happy\n      list_edge() { }\n      bool operator==(const list_edge&) const { return false; }\n      bool operator<(const list_edge&) const { return false; }\n      EdgeProperty m_property;\n    };\n\n    template <class Config>\n    struct undirected_graph_helper {\n\n      typedef undir_adj_list_traversal_tag traversal_category;\n\n      // Placement of these overloaded remove_edge() functions\n      // inside the class avoids a VC++ bug.\n\n      // O(E/V)\n      inline void\n      remove_edge(typename Config::edge_descriptor e)\n      {\n        typedef typename Config::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typedef typename Config::OutEdgeList::value_type::property_type PType;\n        detail::remove_undirected_edge_dispatch<PType>::apply\n          (e, *this, *(PType*)e.get_property());\n      }\n      // O(E/V)\n      inline void\n      remove_edge(typename Config::out_edge_iterator iter)\n      {\n        this->remove_edge(*iter);\n      }\n    };\n\n    // Had to make these non-members to avoid accidental instantiation\n    // on SGI MIPSpro C++\n    template <class C>\n    inline typename C::InEdgeList&\n    in_edge_list(undirected_graph_helper<C>&,\n                 typename C::vertex_descriptor v)\n    {\n      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;\n      return sv->m_out_edges;\n    }\n    template <class C>\n    inline const typename C::InEdgeList&\n    in_edge_list(const undirected_graph_helper<C>&,\n                 typename C::vertex_descriptor v) {\n      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;\n      return sv->m_out_edges;\n    }\n\n    // O(E/V)\n    template <class EdgeOrIter, class Config>\n    inline void\n    remove_edge(EdgeOrIter e, undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      g_.remove_edge(e);\n    }\n\n    // O(E/V) or O(log(E/V))\n    template <class Config>\n    void\n    remove_edge(typename Config::vertex_descriptor u,\n                typename Config::vertex_descriptor v,\n                undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typedef typename Config::edge_parallel_category Cat;\n      detail::remove_edge_and_property(g, g.out_edge_list(u), v, Cat());\n      detail::erase_from_incidence_list(g.out_edge_list(v), u, Cat());\n    }\n\n    template <class Config, class Predicate>\n    void\n    remove_out_edge_if(typename Config::vertex_descriptor u, Predicate pred,\n                       undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::OutEdgeList::value_type::property_type PropT;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::out_edge_iterator first, last;\n      boost::tie(first, last) = out_edges(u, g);\n      typedef typename Config::edge_parallel_category Cat;\n      detail::undirected_remove_out_edge_if_dispatch<PropT>\n        (g, first, last, g.out_edge_list(u), pred, Cat());\n    }\n    template <class Config, class Predicate>\n    void\n    remove_in_edge_if(typename Config::vertex_descriptor u, Predicate pred,\n                      undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      remove_out_edge_if(u, pred, g_);\n    }\n\n    // O(E/V * E) or O(log(E/V) * E)\n    template <class Predicate, class Config>\n    void\n    remove_edge_if(Predicate pred, undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::edge_iterator ei, ei_end, next;\n      boost::tie(ei, ei_end) = edges(g);\n      for (next = ei; ei != ei_end; ei = next) {\n        ++next;\n        if (pred(*ei))\n          remove_edge(*ei, g);\n      }\n    }\n\n    // O(1)\n    template <class Config>\n    inline std::pair<typename Config::edge_iterator,\n                     typename Config::edge_iterator>\n    edges(const undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_iterator edge_iterator;\n      const graph_type& cg = static_cast<const graph_type&>(g_);\n      graph_type& g = const_cast<graph_type&>(cg);\n      return std::make_pair( edge_iterator(g.m_edges.begin()),\n                             edge_iterator(g.m_edges.end()) );\n    }\n    // O(1)\n    template <class Config>\n    inline typename Config::edges_size_type\n    num_edges(const undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      const graph_type& g = static_cast<const graph_type&>(g_);\n      return g.m_edges.size();\n    }\n    // O(E/V * E/V)\n    template <class Config>\n    inline void\n    clear_vertex(typename Config::vertex_descriptor u,\n                 undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      while (true) {\n        typename Config::out_edge_iterator ei, ei_end;\n        boost::tie(ei, ei_end) = out_edges(u, g);\n        if (ei == ei_end) break;\n        remove_edge(*ei, g);\n      }\n    }\n    // O(1) for allow_parallel_edge_tag\n    // O(log(E/V)) for disallow_parallel_edge_tag\n    template <class Config>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             const typename Config::edge_property_type& p,\n             undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::StoredEdge StoredEdge;\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n\n      bool inserted;\n      typename Config::EdgeContainer::value_type e(u, v, p);\n      typename Config::EdgeContainer::iterator p_iter\n        = graph_detail::push(g.m_edges, e).first;\n\n      typename Config::OutEdgeList::iterator i;\n      boost::tie(i, inserted) = boost::graph_detail::push(g.out_edge_list(u),\n                                    StoredEdge(v, p_iter, &g.m_edges));\n      if (inserted) {\n        boost::graph_detail::push(g.out_edge_list(v), StoredEdge(u, p_iter, &g.m_edges));\n        return std::make_pair(edge_descriptor(u, v, &p_iter->get_property()),\n                              true);\n      } else {\n        g.m_edges.erase(p_iter);\n        return std::make_pair\n          (edge_descriptor(u, v, &i->get_iter()->get_property()), false);\n      }\n    }\n    template <class Config>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             undirected_graph_helper<Config>& g_)\n    {\n      typename Config::edge_property_type p;\n      return add_edge(u, v, p, g_);\n    }\n\n    // O(1)\n    template <class Config>\n    inline typename Config::degree_size_type\n    degree(typename Config::vertex_descriptor u,\n           const undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type Graph;\n      const Graph& g = static_cast<const Graph&>(g_);\n      return out_degree(u, g);\n    }\n\n    template <class Config>\n    inline std::pair<typename Config::in_edge_iterator,\n                     typename Config::in_edge_iterator>\n    in_edges(typename Config::vertex_descriptor u,\n             const undirected_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type Graph;\n      const Graph& cg = static_cast<const Graph&>(g_);\n      Graph& g = const_cast<Graph&>(cg);\n      typedef typename Config::in_edge_iterator in_edge_iterator;\n      return\n        std::make_pair(in_edge_iterator(g.out_edge_list(u).begin(), u),\n                       in_edge_iterator(g.out_edge_list(u).end(), u));\n    }\n\n    template <class Config>\n    inline typename Config::degree_size_type\n    in_degree(typename Config::vertex_descriptor u,\n              const undirected_graph_helper<Config>& g_)\n    { return degree(u, g_); }\n\n    //=========================================================================\n    // Bidirectional Graph Helper Class\n\n    struct bidir_adj_list_traversal_tag :\n      public virtual vertex_list_graph_tag,\n      public virtual incidence_graph_tag,\n      public virtual adjacency_graph_tag,\n      public virtual edge_list_graph_tag,\n      public virtual bidirectional_graph_tag { };\n\n    template <class Config>\n    struct bidirectional_graph_helper\n      : public directed_edges_helper<Config> {\n      typedef bidir_adj_list_traversal_tag traversal_category;\n    };\n\n    // Had to make these non-members to avoid accidental instantiation\n    // on SGI MIPSpro C++\n    template <class C>\n    inline typename C::InEdgeList&\n    in_edge_list(bidirectional_graph_helper<C>&,\n                 typename C::vertex_descriptor v)\n    {\n      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;\n      return sv->m_in_edges;\n    }\n    template <class C>\n    inline const typename C::InEdgeList&\n    in_edge_list(const bidirectional_graph_helper<C>&,\n                 typename C::vertex_descriptor v) {\n      typename C::stored_vertex* sv = (typename C::stored_vertex*)v;\n      return sv->m_in_edges;\n    }\n\n    template <class Predicate, class Config>\n    inline void\n    remove_edge_if(Predicate pred, bidirectional_graph_helper<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::edge_iterator ei, ei_end, next;\n      boost::tie(ei, ei_end) = edges(g);\n      for (next = ei; ei != ei_end; ei = next) {\n        ++next;\n        if (pred(*ei))\n          remove_edge(*ei, g);\n      }\n    }\n\n    template <class Config>\n    inline std::pair<typename Config::in_edge_iterator,\n                     typename Config::in_edge_iterator>\n    in_edges(typename Config::vertex_descriptor u,\n             const bidirectional_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      const graph_type& cg = static_cast<const graph_type&>(g_);\n      graph_type& g = const_cast<graph_type&>(cg);\n      typedef typename Config::in_edge_iterator in_edge_iterator;\n      return\n        std::make_pair(in_edge_iterator(in_edge_list(g, u).begin(), u),\n                       in_edge_iterator(in_edge_list(g, u).end(), u));\n    }\n\n    // O(1)\n    template <class Config>\n    inline std::pair<typename Config::edge_iterator,\n                     typename Config::edge_iterator>\n    edges(const bidirectional_graph_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_iterator edge_iterator;\n      const graph_type& cg = static_cast<const graph_type&>(g_);\n      graph_type& g = const_cast<graph_type&>(cg);\n      return std::make_pair( edge_iterator(g.m_edges.begin()),\n                             edge_iterator(g.m_edges.end()) );\n    }\n\n    //=========================================================================\n    // Bidirectional Graph Helper Class (with edge properties)\n\n\n    template <class Config>\n    struct bidirectional_graph_helper_with_property\n      : public bidirectional_graph_helper<Config>\n    {\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::out_edge_iterator out_edge_iterator;\n\n      std::pair<out_edge_iterator, out_edge_iterator>\n      get_parallel_edge_sublist(typename Config::edge_descriptor e,\n                                const graph_type& g,\n                                void*)\n      { return out_edges(source(e, g), g); }\n\n      std::pair<out_edge_iterator, out_edge_iterator>\n      get_parallel_edge_sublist(typename Config::edge_descriptor e,\n                                const graph_type& g,\n                                setS*)\n      { return edge_range(source(e, g), target(e, g), g); }\n\n      std::pair<out_edge_iterator, out_edge_iterator>\n      get_parallel_edge_sublist(typename Config::edge_descriptor e,\n                                const graph_type& g,\n                                multisetS*)\n      { return edge_range(source(e, g), target(e, g), g); }\n\n      std::pair<out_edge_iterator, out_edge_iterator>\n      get_parallel_edge_sublist(typename Config::edge_descriptor e,\n                                const graph_type& g,\n                                hash_setS*)\n      { return edge_range(source(e, g), target(e, g), g); }\n\n      // Placement of these overloaded remove_edge() functions\n      // inside the class avoids a VC++ bug.\n\n      // O(E/V) or O(log(E/V))\n      void\n      remove_edge(typename Config::edge_descriptor e)\n      {\n        typedef typename Config::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        graph_type& g = static_cast<graph_type&>(*this);\n\n        typedef typename Config::edgelist_selector OutEdgeListS;\n\n        std::pair<out_edge_iterator, out_edge_iterator> rng =\n          get_parallel_edge_sublist(e, g, (OutEdgeListS*)(0));\n        rng.first = std::find(rng.first, rng.second, e);\n        BOOST_ASSERT(rng.first != rng.second);\n        remove_edge(rng.first);\n      }\n\n      inline void\n      remove_edge(typename Config::out_edge_iterator iter)\n      {\n        typedef typename Config::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typedef typename Config::graph_type graph_type;\n        graph_type& g = static_cast<graph_type&>(*this);\n        typename Config::edge_descriptor e = *iter;\n        typename Config::OutEdgeList& oel = g.out_edge_list(source(e, g));\n        typename Config::InEdgeList& iel = in_edge_list(g, target(e, g));\n        typedef typename Config::OutEdgeList::value_type::property_type PType;\n        PType& p = *(PType*)e.get_property();\n        detail::remove_directed_edge_dispatch(*iter, iel, p);\n        g.m_edges.erase(iter.base()->get_iter());\n        oel.erase(iter.base());\n      }\n    };\n\n    // O(E/V) for allow_parallel_edge_tag\n    // O(log(E/V)) for disallow_parallel_edge_tag\n    template <class Config>\n    inline void\n    remove_edge(typename Config::vertex_descriptor u,\n                typename Config::vertex_descriptor v,\n                bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typedef typename Config::edge_parallel_category Cat;\n      detail::remove_edge_and_property(g, g.out_edge_list(u), v, Cat());\n      detail::erase_from_incidence_list(in_edge_list(g, v), u, Cat());\n    }\n\n    // O(E/V) or O(log(E/V))\n    template <class EdgeOrIter, class Config>\n    inline void\n    remove_edge(EdgeOrIter e,\n                bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      g_.remove_edge(e);\n    }\n\n    template <class Config, class Predicate>\n    inline void\n    remove_out_edge_if(typename Config::vertex_descriptor u, Predicate pred,\n                       bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::OutEdgeList::value_type::property_type PropT;\n      graph_type& g = static_cast<graph_type&>(g_);\n\n      typedef typename Config::EdgeIter EdgeIter;\n      typedef std::vector<EdgeIter> Garbage;\n      Garbage garbage;\n\n      // First remove the edges from the targets' in-edge lists and\n      // from the graph's edge set list.\n      typename Config::out_edge_iterator out_i, out_end;\n      for (boost::tie(out_i, out_end) = out_edges(u, g); out_i != out_end; ++out_i)\n        if (pred(*out_i)) {\n          detail::remove_directed_edge_dispatch\n            (*out_i, in_edge_list(g, target(*out_i, g)),\n             *(PropT*)(*out_i).get_property());\n          // Put in garbage to delete later. Will need the properties\n          // for the remove_if of the out-edges.\n          garbage.push_back((*out_i.base()).get_iter());\n        }\n\n      // Now remove the edges from this out-edge list.\n      typename Config::out_edge_iterator first, last;\n      boost::tie(first, last) = out_edges(u, g);\n      typedef typename Config::edge_parallel_category Cat;\n      detail::remove_directed_edge_if_dispatch\n        (first, last, g.out_edge_list(u), pred, Cat());\n\n      // Now delete the edge properties from the g.m_edges list\n      for (typename Garbage::iterator i = garbage.begin();\n           i != garbage.end(); ++i)\n        g.m_edges.erase(*i);\n    }\n    template <class Config, class Predicate>\n    inline void\n    remove_in_edge_if(typename Config::vertex_descriptor v, Predicate pred,\n                      bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::OutEdgeList::value_type::property_type PropT;\n      graph_type& g = static_cast<graph_type&>(g_);\n\n      typedef typename Config::EdgeIter EdgeIter;\n      typedef std::vector<EdgeIter> Garbage;\n      Garbage garbage;\n\n      // First remove the edges from the sources' out-edge lists and\n      // from the graph's edge set list.\n      typename Config::in_edge_iterator in_i, in_end;\n      for (boost::tie(in_i, in_end) = in_edges(v, g); in_i != in_end; ++in_i)\n        if (pred(*in_i)) {\n          typename Config::vertex_descriptor u = source(*in_i, g);\n          detail::remove_directed_edge_dispatch\n            (*in_i, g.out_edge_list(u), *(PropT*)(*in_i).get_property());\n          // Put in garbage to delete later. Will need the properties\n          // for the remove_if of the out-edges.\n          garbage.push_back((*in_i.base()).get_iter());\n        }\n      // Now remove the edges from this in-edge list.\n      typename Config::in_edge_iterator first, last;\n      boost::tie(first, last) = in_edges(v, g);\n      typedef typename Config::edge_parallel_category Cat;\n      detail::remove_directed_edge_if_dispatch\n        (first, last, in_edge_list(g, v), pred, Cat());\n\n      // Now delete the edge properties from the g.m_edges list\n      for (typename Garbage::iterator i = garbage.begin();\n           i != garbage.end(); ++i)\n        g.m_edges.erase(*i);\n    }\n\n    // O(1)\n    template <class Config>\n    inline typename Config::edges_size_type\n    num_edges(const bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      const graph_type& g = static_cast<const graph_type&>(g_);\n      return g.m_edges.size();\n    }\n    // O(E/V * E/V) for allow_parallel_edge_tag\n    // O(E/V * log(E/V)) for disallow_parallel_edge_tag\n    template <class Config>\n    inline void\n    clear_vertex(typename Config::vertex_descriptor u,\n                 bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_parallel_category Cat;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::OutEdgeList& el = g.out_edge_list(u);\n      typename Config::OutEdgeList::iterator\n        ei = el.begin(), ei_end = el.end();\n      for (; ei != ei_end; ++ei) {\n        detail::erase_from_incidence_list\n          (in_edge_list(g, (*ei).get_target()), u, Cat());\n        g.m_edges.erase((*ei).get_iter());\n      }\n      typename Config::InEdgeList& in_el = in_edge_list(g, u);\n      typename Config::InEdgeList::iterator\n        in_ei = in_el.begin(), in_ei_end = in_el.end();\n      for (; in_ei != in_ei_end; ++in_ei) {\n        detail::erase_from_incidence_list\n          (g.out_edge_list((*in_ei).get_target()), u, Cat());\n        g.m_edges.erase((*in_ei).get_iter());\n      }\n      g.out_edge_list(u).clear();\n      in_edge_list(g, u).clear();\n    }\n\n    template <class Config>\n    inline void\n    clear_out_edges(typename Config::vertex_descriptor u,\n                    bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_parallel_category Cat;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::OutEdgeList& el = g.out_edge_list(u);\n      typename Config::OutEdgeList::iterator\n        ei = el.begin(), ei_end = el.end();\n      for (; ei != ei_end; ++ei) {\n        detail::erase_from_incidence_list\n          (in_edge_list(g, (*ei).get_target()), u, Cat());\n        g.m_edges.erase((*ei).get_iter());\n      }\n      g.out_edge_list(u).clear();\n    }\n\n    template <class Config>\n    inline void\n    clear_in_edges(typename Config::vertex_descriptor u,\n                   bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::global_edgelist_selector EdgeListS;\n      BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n      typedef typename Config::graph_type graph_type;\n      typedef typename Config::edge_parallel_category Cat;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typename Config::InEdgeList& in_el = in_edge_list(g, u);\n      typename Config::InEdgeList::iterator\n        in_ei = in_el.begin(), in_ei_end = in_el.end();\n      for (; in_ei != in_ei_end; ++in_ei) {\n        detail::erase_from_incidence_list\n          (g.out_edge_list((*in_ei).get_target()), u, Cat());\n        g.m_edges.erase((*in_ei).get_iter());\n      }\n      in_edge_list(g, u).clear();\n    }\n\n    // O(1) for allow_parallel_edge_tag\n    // O(log(E/V)) for disallow_parallel_edge_tag\n    template <class Config>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             const typename Config::edge_property_type& p,\n             bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      graph_type& g = static_cast<graph_type&>(g_);\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::StoredEdge StoredEdge;\n      bool inserted;\n      typename Config::EdgeContainer::value_type e(u, v, p);\n      typename Config::EdgeContainer::iterator p_iter\n        = graph_detail::push(g.m_edges, e).first;\n      typename Config::OutEdgeList::iterator i;\n      boost::tie(i, inserted) = boost::graph_detail::push(g.out_edge_list(u),\n                                        StoredEdge(v, p_iter, &g.m_edges));\n      if (inserted) {\n        boost::graph_detail::push(in_edge_list(g, v), StoredEdge(u, p_iter, &g.m_edges));\n        return std::make_pair(edge_descriptor(u, v, &p_iter->m_property),\n                              true);\n      } else {\n        g.m_edges.erase(p_iter);\n        return std::make_pair(edge_descriptor(u, v,\n                                     &i->get_iter()->get_property()),\n                              false);\n      }\n    }\n\n    template <class Config>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typename Config::edge_property_type p;\n      return add_edge(u, v, p, g_);\n    }\n    // O(1)\n    template <class Config>\n    inline typename Config::degree_size_type\n    degree(typename Config::vertex_descriptor u,\n           const bidirectional_graph_helper_with_property<Config>& g_)\n    {\n      typedef typename Config::graph_type graph_type;\n      const graph_type& g = static_cast<const graph_type&>(g_);\n      return in_degree(u, g) + out_degree(u, g);\n    }\n\n    //=========================================================================\n    // Adjacency List Helper Class\n\n    template <class Config, class Base>\n    struct adj_list_helper : public Base\n    {\n      typedef typename Config::graph_type AdjList;\n      typedef typename Config::vertex_descriptor vertex_descriptor;\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::out_edge_iterator out_edge_iterator;\n      typedef typename Config::in_edge_iterator in_edge_iterator;\n      typedef typename Config::adjacency_iterator adjacency_iterator;\n      typedef typename Config::inv_adjacency_iterator inv_adjacency_iterator;\n      typedef typename Config::vertex_iterator vertex_iterator;\n      typedef typename Config::edge_iterator edge_iterator;\n      typedef typename Config::directed_category directed_category;\n      typedef typename Config::edge_parallel_category edge_parallel_category;\n      typedef typename Config::vertices_size_type vertices_size_type;\n      typedef typename Config::edges_size_type edges_size_type;\n      typedef typename Config::degree_size_type degree_size_type;\n      typedef typename Config::StoredEdge StoredEdge;\n      typedef typename Config::vertex_property_type vertex_property_type;\n      typedef typename Config::edge_property_type edge_property_type;\n      typedef typename Config::graph_property_type graph_property_type;\n\n      typedef typename Config::global_edgelist_selector\n        global_edgelist_selector;\n\n      typedef typename lookup_one_property<vertex_property_type, vertex_bundle_t>::type vertex_bundled;\n      typedef typename lookup_one_property<edge_property_type, edge_bundle_t>::type edge_bundled;\n      typedef typename lookup_one_property<graph_property_type, graph_bundle_t>::type graph_bundled;\n    };\n\n    template <class Config, class Base>\n    inline std::pair<typename Config::adjacency_iterator,\n                     typename Config::adjacency_iterator>\n    adjacent_vertices(typename Config::vertex_descriptor u,\n                      const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      const AdjList& cg = static_cast<const AdjList&>(g_);\n      AdjList& g = const_cast<AdjList&>(cg);\n      typedef typename Config::adjacency_iterator adjacency_iterator;\n      typename Config::out_edge_iterator first, last;\n      boost::tie(first, last) = out_edges(u, g);\n      return std::make_pair(adjacency_iterator(first, &g),\n                            adjacency_iterator(last, &g));\n    }\n    template <class Config, class Base>\n    inline std::pair<typename Config::inv_adjacency_iterator,\n                     typename Config::inv_adjacency_iterator>\n    inv_adjacent_vertices(typename Config::vertex_descriptor u,\n                          const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      const AdjList& cg = static_cast<const AdjList&>(g_);\n      AdjList& g = const_cast<AdjList&>(cg);\n      typedef typename Config::inv_adjacency_iterator inv_adjacency_iterator;\n      typename Config::in_edge_iterator first, last;\n      boost::tie(first, last) = in_edges(u, g);\n      return std::make_pair(inv_adjacency_iterator(first, &g),\n                            inv_adjacency_iterator(last, &g));\n    }\n    template <class Config, class Base>\n    inline std::pair<typename Config::out_edge_iterator,\n                     typename Config::out_edge_iterator>\n    out_edges(typename Config::vertex_descriptor u,\n              const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      typedef typename Config::out_edge_iterator out_edge_iterator;\n      const AdjList& cg = static_cast<const AdjList&>(g_);\n      AdjList& g = const_cast<AdjList&>(cg);\n      return\n        std::make_pair(out_edge_iterator(g.out_edge_list(u).begin(), u),\n                       out_edge_iterator(g.out_edge_list(u).end(), u));\n    }\n    template <class Config, class Base>\n    inline std::pair<typename Config::vertex_iterator,\n                     typename Config::vertex_iterator>\n    vertices(const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      const AdjList& cg = static_cast<const AdjList&>(g_);\n      AdjList& g = const_cast<AdjList&>(cg);\n      return std::make_pair( g.vertex_set().begin(), g.vertex_set().end() );\n    }\n    template <class Config, class Base>\n    inline typename Config::vertices_size_type\n    num_vertices(const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      const AdjList& g = static_cast<const AdjList&>(g_);\n      return g.vertex_set().size();\n    }\n    template <class Config, class Base>\n    inline typename Config::degree_size_type\n    out_degree(typename Config::vertex_descriptor u,\n               const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type AdjList;\n      const AdjList& g = static_cast<const AdjList&>(g_);\n      return g.out_edge_list(u).size();\n    }\n    template <class Config, class Base>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    edge(typename Config::vertex_descriptor u,\n         typename Config::vertex_descriptor v,\n         const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type Graph;\n      typedef typename Config::StoredEdge StoredEdge;\n      const Graph& cg = static_cast<const Graph&>(g_);\n      const typename Config::OutEdgeList& el = cg.out_edge_list(u);\n      typename Config::OutEdgeList::const_iterator it = graph_detail::\n        find(el, StoredEdge(v));\n      return std::make_pair(\n               typename Config::edge_descriptor\n                     (u, v, (it == el.end() ? 0 : &(*it).get_property())),\n               (it != el.end()));\n    }\n\n    template <class Config, class Base>\n    inline std::pair<typename Config::out_edge_iterator,\n                     typename Config::out_edge_iterator>\n    edge_range(typename Config::vertex_descriptor u,\n               typename Config::vertex_descriptor v,\n               const adj_list_helper<Config, Base>& g_)\n    {\n      typedef typename Config::graph_type Graph;\n      typedef typename Config::StoredEdge StoredEdge;\n      const Graph& cg = static_cast<const Graph&>(g_);\n      Graph& g = const_cast<Graph&>(cg);\n      typedef typename Config::out_edge_iterator out_edge_iterator;\n      typename Config::OutEdgeList& el = g.out_edge_list(u);\n      typename Config::OutEdgeList::iterator first, last;\n      typename Config::EdgeContainer fake_edge_container;\n      boost::tie(first, last) = graph_detail::\n        equal_range(el, StoredEdge(v, fake_edge_container.end(),\n                                   &fake_edge_container));\n      return std::make_pair(out_edge_iterator(first, u),\n                            out_edge_iterator(last, u));\n    }\n\n    template <class Config>\n    inline typename Config::degree_size_type\n    in_degree(typename Config::vertex_descriptor u,\n              const directed_edges_helper<Config>& g_)\n    {\n      typedef typename Config::graph_type Graph;\n      const Graph& cg = static_cast<const Graph&>(g_);\n      Graph& g = const_cast<Graph&>(cg);\n      return in_edge_list(g, u).size();\n    }\n\n    namespace detail {\n      template <class Config, class Base, class Property>\n      inline\n      typename boost::property_map<typename Config::graph_type,\n        Property>::type\n      get_dispatch(adj_list_helper<Config,Base>&, Property p,\n                   boost::edge_property_tag) {\n        typedef typename Config::graph_type Graph;\n        typedef typename boost::property_map<Graph, Property>::type PA;\n        return PA(p);\n      }\n      template <class Config, class Base, class Property>\n      inline\n      typename boost::property_map<typename Config::graph_type,\n        Property>::const_type\n      get_dispatch(const adj_list_helper<Config,Base>&, Property p,\n                   boost::edge_property_tag) {\n        typedef typename Config::graph_type Graph;\n        typedef typename boost::property_map<Graph, Property>::const_type PA;\n        return PA(p);\n      }\n\n      template <class Config, class Base, class Property>\n      inline\n      typename boost::property_map<typename Config::graph_type,\n        Property>::type\n      get_dispatch(adj_list_helper<Config,Base>& g, Property p,\n                   boost::vertex_property_tag) {\n        typedef typename Config::graph_type Graph;\n        typedef typename boost::property_map<Graph, Property>::type PA;\n        return PA(&static_cast<Graph&>(g), p);\n      }\n      template <class Config, class Base, class Property>\n      inline\n      typename boost::property_map<typename Config::graph_type,\n        Property>::const_type\n      get_dispatch(const adj_list_helper<Config, Base>& g, Property p,\n                   boost::vertex_property_tag) {\n        typedef typename Config::graph_type Graph;\n        typedef typename boost::property_map<Graph, Property>::const_type PA;\n        const Graph& cg = static_cast<const Graph&>(g);\n        return PA(&cg, p);\n      }\n\n    } // namespace detail\n\n    // Implementation of the PropertyGraph interface\n    template <class Config, class Base, class Property>\n    inline\n    typename boost::property_map<typename Config::graph_type, Property>::type\n    get(Property p, adj_list_helper<Config, Base>& g) {\n      typedef typename detail::property_kind_from_graph<adj_list_helper<Config, Base>, Property>::type Kind;\n      return detail::get_dispatch(g, p, Kind());\n    }\n    template <class Config, class Base, class Property>\n    inline\n    typename boost::property_map<typename Config::graph_type,\n      Property>::const_type\n    get(Property p, const adj_list_helper<Config, Base>& g) {\n      typedef typename detail::property_kind_from_graph<adj_list_helper<Config, Base>, Property>::type Kind;\n      return detail::get_dispatch(g, p, Kind());\n    }\n\n    template <class Config, class Base, class Property, class Key>\n    inline\n    typename boost::property_traits<\n      typename boost::property_map<typename Config::graph_type,\n        Property>::type\n    >::reference\n    get(Property p, adj_list_helper<Config, Base>& g, const Key& key) {\n      return get(get(p, g), key);\n    }\n\n    template <class Config, class Base, class Property, class Key>\n    inline\n    typename boost::property_traits<\n      typename boost::property_map<typename Config::graph_type,\n        Property>::const_type\n    >::reference\n    get(Property p, const adj_list_helper<Config, Base>& g, const Key& key) {\n      return get(get(p, g), key);\n    }\n\n    template <class Config, class Base, class Property, class Key,class Value>\n    inline void\n    put(Property p, adj_list_helper<Config, Base>& g,\n        const Key& key, const Value& value)\n    {\n      typedef typename Config::graph_type Graph;\n      typedef typename boost::property_map<Graph, Property>::type Map;\n      Map pmap = get(p, static_cast<Graph&>(g));\n      put(pmap, key, value);\n    }\n\n\n    //=========================================================================\n    // Generalize Adjacency List Implementation\n\n    struct adj_list_tag { };\n\n    template <class Derived, class Config, class Base>\n    class adj_list_impl\n      : public adj_list_helper<Config, Base>\n    {\n      typedef typename Config::OutEdgeList OutEdgeList;\n      typedef typename Config::InEdgeList InEdgeList;\n      typedef typename Config::StoredVertexList StoredVertexList;\n    public:\n      typedef typename Config::stored_vertex stored_vertex;\n      typedef typename Config::EdgeContainer EdgeContainer;\n      typedef typename Config::vertex_descriptor vertex_descriptor;\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::vertex_iterator vertex_iterator;\n      typedef typename Config::edge_iterator edge_iterator;\n      typedef typename Config::edge_parallel_category edge_parallel_category;\n      typedef typename Config::vertices_size_type vertices_size_type;\n      typedef typename Config::edges_size_type edges_size_type;\n      typedef typename Config::degree_size_type degree_size_type;\n      typedef typename Config::edge_property_type edge_property_type;\n      typedef adj_list_tag graph_tag;\n\n      static vertex_descriptor null_vertex()\n      {\n        return 0;\n      }\n\n      inline adj_list_impl() { }\n\n      inline adj_list_impl(const adj_list_impl& x) {\n        copy_impl(x);\n      }\n      inline adj_list_impl& operator=(const adj_list_impl& x) {\n        this->clear();\n        copy_impl(x);\n        return *this;\n      }\n      inline void clear() {\n        for (typename StoredVertexList::iterator i = m_vertices.begin();\n             i != m_vertices.end(); ++i)\n          delete (stored_vertex*)*i;\n        m_vertices.clear();\n        m_edges.clear();\n      }\n      inline adj_list_impl(vertices_size_type num_vertices) {\n        for (vertices_size_type i = 0; i < num_vertices; ++i)\n          add_vertex(static_cast<Derived&>(*this));\n      }\n      template <class EdgeIterator>\n      inline adj_list_impl(vertices_size_type num_vertices,\n                           EdgeIterator first, EdgeIterator last)\n      {\n        vertex_descriptor* v = new vertex_descriptor[num_vertices];\n        for (vertices_size_type i = 0; i < num_vertices; ++i)\n          v[i] = add_vertex(static_cast<Derived&>(*this));\n\n        while (first != last) {\n          add_edge(v[(*first).first], v[(*first).second], *this);\n          ++first;\n        }\n        delete [] v;\n      }\n      template <class EdgeIterator, class EdgePropertyIterator>\n      inline adj_list_impl(vertices_size_type num_vertices,\n                           EdgeIterator first, EdgeIterator last,\n                           EdgePropertyIterator ep_iter)\n      {\n        vertex_descriptor* v = new vertex_descriptor[num_vertices];\n        for (vertices_size_type i = 0; i < num_vertices; ++i)\n          v[i] = add_vertex(static_cast<Derived&>(*this));\n\n        while (first != last) {\n          add_edge(v[(*first).first], v[(*first).second], *ep_iter, *this);\n          ++first;\n          ++ep_iter;\n        }\n        delete [] v;\n      }\n      ~adj_list_impl() {\n        for (typename StoredVertexList::iterator i = m_vertices.begin();\n             i != m_vertices.end(); ++i)\n          delete (stored_vertex*)*i;\n      }\n      //    protected:\n      inline OutEdgeList& out_edge_list(vertex_descriptor v) {\n        stored_vertex* sv = (stored_vertex*)v;\n        return sv->m_out_edges;\n      }\n      inline const OutEdgeList& out_edge_list(vertex_descriptor v) const {\n        stored_vertex* sv = (stored_vertex*)v;\n        return sv->m_out_edges;\n      }\n      inline StoredVertexList& vertex_set() { return m_vertices; }\n      inline const StoredVertexList& vertex_set() const { return m_vertices; }\n\n      inline void copy_impl(const adj_list_impl& x_)\n      {\n        const Derived& x = static_cast<const Derived&>(x_);\n\n        // Would be better to have a constant time way to get from\n        // vertices in x to the corresponding vertices in *this.\n        std::map<stored_vertex*,stored_vertex*> vertex_map;\n\n        // Copy the stored vertex objects by adding each vertex\n        // and copying its property object.\n        vertex_iterator vi, vi_end;\n        for (boost::tie(vi, vi_end) = vertices(x); vi != vi_end; ++vi) {\n          stored_vertex* v = (stored_vertex*)add_vertex(*this);\n          v->m_property = ((stored_vertex*)*vi)->m_property;\n          vertex_map[(stored_vertex*)*vi] = v;\n        }\n        // Copy the edges by adding each edge and copying its\n        // property object.\n        edge_iterator ei, ei_end;\n        for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei) {\n          edge_descriptor e;\n          bool inserted;\n          vertex_descriptor s = source(*ei,x), t = target(*ei,x);\n          boost::tie(e, inserted) = add_edge(vertex_map[(stored_vertex*)s],\n                                             vertex_map[(stored_vertex*)t], *this);\n          *((edge_property_type*)e.m_eproperty)\n            = *((edge_property_type*)(*ei).m_eproperty);\n        }\n      }\n\n\n      typename Config::EdgeContainer m_edges;\n      StoredVertexList m_vertices;\n    };\n\n    // O(1)\n    template <class Derived, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    add_vertex(adj_list_impl<Derived, Config, Base>& g_)\n    {\n      Derived& g = static_cast<Derived&>(g_);\n      typedef typename Config::stored_vertex stored_vertex;\n      stored_vertex* v = new stored_vertex;\n      typename Config::StoredVertexList::iterator pos;\n      bool inserted;\n      boost::tie(pos,inserted) = boost::graph_detail::push(g.m_vertices, v);\n      v->m_position = pos;\n      g.added_vertex(v);\n      return v;\n    }\n    // O(1)\n    template <class Derived, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    add_vertex(const typename Config::vertex_property_type& p,\n               adj_list_impl<Derived, Config, Base>& g_)\n    {\n      typedef typename Config::vertex_descriptor vertex_descriptor;\n      Derived& g = static_cast<Derived&>(g_);\n      if (optional<vertex_descriptor> v\n            = g.vertex_by_property(get_property_value(p, vertex_bundle)))\n        return *v;\n\n      typedef typename Config::stored_vertex stored_vertex;\n      stored_vertex* v = new stored_vertex(p);\n      typename Config::StoredVertexList::iterator pos;\n      bool inserted;\n      boost::tie(pos,inserted) = boost::graph_detail::push(g.m_vertices, v);\n      v->m_position = pos;\n      g.added_vertex(v);\n      return v;\n    }\n    // O(1)\n    template <class Derived, class Config, class Base>\n    inline void remove_vertex(typename Config::vertex_descriptor u,\n                              adj_list_impl<Derived, Config, Base>& g_)\n    {\n      typedef typename Config::stored_vertex stored_vertex;\n      Derived& g = static_cast<Derived&>(g_);\n      g.removing_vertex(u, boost::graph_detail::iterator_stability(g_.m_vertices));\n      stored_vertex* su = (stored_vertex*)u;\n      g.m_vertices.erase(su->m_position);\n      delete su;\n    }\n    // O(V)\n    template <class Derived, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    vertex(typename Config::vertices_size_type n,\n           const adj_list_impl<Derived, Config, Base>& g_)\n    {\n      const Derived& g = static_cast<const Derived&>(g_);\n      typename Config::vertex_iterator i = vertices(g).first;\n      while (n--) ++i; // std::advance(i, n); (not VC++ portable)\n      return *i;\n    }\n\n    //=========================================================================\n    // Vector-Backbone Adjacency List Implementation\n\n    namespace detail {\n\n      template <class Graph, class vertex_descriptor>\n      inline void\n      remove_vertex_dispatch(Graph& g, vertex_descriptor u,\n                             boost::directed_tag)\n      {\n        typedef typename Graph::edge_parallel_category edge_parallel_category;\n        g.m_vertices.erase(g.m_vertices.begin() + u);\n        vertex_descriptor V = num_vertices(g);\n        if (u != V) {\n          for (vertex_descriptor v = 0; v < V; ++v)\n            reindex_edge_list(g.out_edge_list(v), u, edge_parallel_category());\n        }\n      }\n\n      template <class Graph, class vertex_descriptor>\n      inline void\n      remove_vertex_dispatch(Graph& g, vertex_descriptor u,\n                             boost::undirected_tag)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typedef typename Graph::edge_parallel_category edge_parallel_category;\n        g.m_vertices.erase(g.m_vertices.begin() + u);\n        vertex_descriptor V = num_vertices(g);\n        for (vertex_descriptor v = 0; v < V; ++v)\n          reindex_edge_list(g.out_edge_list(v), u,\n                            edge_parallel_category());\n        typedef typename Graph::EdgeContainer Container;\n        typedef typename Container::iterator Iter;\n        Iter ei = g.m_edges.begin(), ei_end = g.m_edges.end();\n        for (; ei != ei_end; ++ei) {\n          if (ei->m_source > u)\n            --ei->m_source;\n          if (ei->m_target > u)\n            --ei->m_target;\n        }\n      }\n      template <class Graph, class vertex_descriptor>\n      inline void\n      remove_vertex_dispatch(Graph& g, vertex_descriptor u,\n                             boost::bidirectional_tag)\n      {\n        typedef typename Graph::global_edgelist_selector EdgeListS;\n        BOOST_STATIC_ASSERT((!is_same<EdgeListS, vecS>::value));\n\n        typedef typename Graph::edge_parallel_category edge_parallel_category;\n        g.m_vertices.erase(g.m_vertices.begin() + u);\n        vertex_descriptor V = num_vertices(g);\n        vertex_descriptor v;\n        if (u != V) {\n          for (v = 0; v < V; ++v)\n            reindex_edge_list(g.out_edge_list(v), u,\n                              edge_parallel_category());\n          for (v = 0; v < V; ++v)\n            reindex_edge_list(in_edge_list(g, v), u,\n                              edge_parallel_category());\n\n          typedef typename Graph::EdgeContainer Container;\n          typedef typename Container::iterator Iter;\n          Iter ei = g.m_edges.begin(), ei_end = g.m_edges.end();\n          for (; ei != ei_end; ++ei) {\n            if (ei->m_source > u)\n              --ei->m_source;\n            if (ei->m_target > u)\n              --ei->m_target;\n          }\n        }\n      }\n\n      template <class EdgeList, class vertex_descriptor>\n      inline void\n      reindex_edge_list(EdgeList& el, vertex_descriptor u,\n                        boost::allow_parallel_edge_tag)\n      {\n        typename EdgeList::iterator ei = el.begin(), e_end = el.end();\n        for (; ei != e_end; ++ei)\n          if ((*ei).get_target() > u)\n            --(*ei).get_target();\n      }\n      template <class EdgeList, class vertex_descriptor>\n      inline void\n      reindex_edge_list(EdgeList& el, vertex_descriptor u,\n                        boost::disallow_parallel_edge_tag)\n      {\n        typename EdgeList::iterator ei = el.begin(), e_end = el.end();\n        while (ei != e_end) {\n          typename EdgeList::value_type ce = *ei;\n          ++ei;\n          if (ce.get_target() > u) {\n            el.erase(ce);\n            --ce.get_target();\n            el.insert(ce);\n          }\n        }\n      }\n    } // namespace detail\n\n    struct vec_adj_list_tag { };\n\n    template <class Graph, class Config, class Base>\n    class vec_adj_list_impl\n      : public adj_list_helper<Config, Base>\n    {\n      typedef typename Config::OutEdgeList OutEdgeList;\n      typedef typename Config::InEdgeList InEdgeList;\n      typedef typename Config::StoredVertexList StoredVertexList;\n    public:\n      typedef typename Config::vertex_descriptor vertex_descriptor;\n      typedef typename Config::edge_descriptor edge_descriptor;\n      typedef typename Config::out_edge_iterator out_edge_iterator;\n      typedef typename Config::edge_iterator edge_iterator;\n      typedef typename Config::directed_category directed_category;\n      typedef typename Config::vertices_size_type vertices_size_type;\n      typedef typename Config::edges_size_type edges_size_type;\n      typedef typename Config::degree_size_type degree_size_type;\n      typedef typename Config::StoredEdge StoredEdge;\n      typedef typename Config::stored_vertex stored_vertex;\n      typedef typename Config::EdgeContainer EdgeContainer;\n      typedef typename Config::edge_property_type edge_property_type;\n      typedef vec_adj_list_tag graph_tag;\n\n      static vertex_descriptor null_vertex()\n      {\n        return (std::numeric_limits<vertex_descriptor>::max)();\n      }\n\n      inline vec_adj_list_impl() { }\n\n      inline vec_adj_list_impl(const vec_adj_list_impl& x) {\n        copy_impl(x);\n      }\n      inline vec_adj_list_impl& operator=(const vec_adj_list_impl& x) {\n        this->clear();\n        copy_impl(x);\n        return *this;\n      }\n      inline void clear() {\n        m_vertices.clear();\n        m_edges.clear();\n      }\n\n      inline vec_adj_list_impl(vertices_size_type _num_vertices)\n        : m_vertices(_num_vertices) { }\n\n      template <class EdgeIterator>\n      inline vec_adj_list_impl(vertices_size_type num_vertices,\n                               EdgeIterator first, EdgeIterator last)\n        : m_vertices(num_vertices)\n      {\n        while (first != last) {\n          add_edge((*first).first, (*first).second,\n                   static_cast<Graph&>(*this));\n          ++first;\n        }\n      }\n      template <class EdgeIterator, class EdgePropertyIterator>\n      inline vec_adj_list_impl(vertices_size_type num_vertices,\n                               EdgeIterator first, EdgeIterator last,\n                               EdgePropertyIterator ep_iter)\n        : m_vertices(num_vertices)\n      {\n        while (first != last) {\n          add_edge((*first).first, (*first).second, *ep_iter,\n                   static_cast<Graph&>(*this));\n          ++first;\n          ++ep_iter;\n        }\n      }\n\n      //    protected:\n      inline boost::integer_range<vertex_descriptor> vertex_set() const {\n        return boost::integer_range<vertex_descriptor>(0, m_vertices.size());\n      }\n      inline OutEdgeList& out_edge_list(vertex_descriptor v) {\n        return m_vertices[v].m_out_edges;\n      }\n      inline const OutEdgeList& out_edge_list(vertex_descriptor v) const {\n        return m_vertices[v].m_out_edges;\n      }\n      inline void copy_impl(const vec_adj_list_impl& x_)\n      {\n        const Graph& x = static_cast<const Graph&>(x_);\n        // Copy the stored vertex objects by adding each vertex\n        // and copying its property object.\n        for (vertices_size_type i = 0; i < num_vertices(x); ++i) {\n          vertex_descriptor v = add_vertex(*this);\n          m_vertices[v].m_property = x.m_vertices[i].m_property;\n        }\n        // Copy the edges by adding each edge and copying its\n        // property object.\n        edge_iterator ei, ei_end;\n        for (boost::tie(ei, ei_end) = edges(x); ei != ei_end; ++ei) {\n          edge_descriptor e;\n          bool inserted;\n          boost::tie(e, inserted) = add_edge(source(*ei,x), target(*ei,x) , *this);\n          *((edge_property_type*)e.m_eproperty)\n            = *((edge_property_type*)(*ei).m_eproperty);\n        }\n      }\n      typename Config::EdgeContainer m_edges;\n      StoredVertexList m_vertices;\n    };\n    // Had to make these non-members to avoid accidental instantiation\n    // on SGI MIPSpro C++\n    template <class G, class C, class B>\n    inline typename C::InEdgeList&\n    in_edge_list(vec_adj_list_impl<G,C,B>& g,\n                 typename C::vertex_descriptor v) {\n      return g.m_vertices[v].m_in_edges;\n    }\n    template <class G, class C, class B>\n    inline const typename C::InEdgeList&\n    in_edge_list(const vec_adj_list_impl<G,C,B>& g,\n                 typename C::vertex_descriptor v) {\n      return g.m_vertices[v].m_in_edges;\n    }\n\n      // O(1)\n    template <class Graph, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    add_vertex(vec_adj_list_impl<Graph, Config, Base>& g_) {\n      Graph& g = static_cast<Graph&>(g_);\n      g.m_vertices.resize(g.m_vertices.size() + 1);\n      g.added_vertex(g.m_vertices.size() - 1);\n      return g.m_vertices.size() - 1;\n    }\n\n    template <class Graph, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    add_vertex(const typename Config::vertex_property_type& p,\n               vec_adj_list_impl<Graph, Config, Base>& g_) {\n      typedef typename Config::vertex_descriptor vertex_descriptor;\n      Graph& g = static_cast<Graph&>(g_);\n      if (optional<vertex_descriptor> v\n            = g.vertex_by_property(get_property_value(p, vertex_bundle)))\n        return *v;\n      typedef typename Config::stored_vertex stored_vertex;\n      g.m_vertices.push_back(stored_vertex(p));\n      g.added_vertex(g.m_vertices.size() - 1);\n      return g.m_vertices.size() - 1;\n    }\n\n    // Here we override the directed_graph_helper add_edge() function\n    // so that the number of vertices is automatically changed if\n    // either u or v is greater than the number of vertices.\n    template <class Graph, class Config, class Base>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             const typename Config::edge_property_type& p,\n             vec_adj_list_impl<Graph, Config, Base>& g_)\n    {\n      BOOST_USING_STD_MAX();\n      typename Config::vertex_descriptor x = max BOOST_PREVENT_MACRO_SUBSTITUTION(u, v);\n      if (x >= num_vertices(g_))\n        g_.m_vertices.resize(x + 1);\n      adj_list_helper<Config, Base>& g = g_;\n      return add_edge(u, v, p, g);\n    }\n    template <class Graph, class Config, class Base>\n    inline std::pair<typename Config::edge_descriptor, bool>\n    add_edge(typename Config::vertex_descriptor u,\n             typename Config::vertex_descriptor v,\n             vec_adj_list_impl<Graph, Config, Base>& g_)\n    {\n      typename Config::edge_property_type p;\n      return add_edge(u, v, p, g_);\n    }\n\n\n    // O(V + E)\n    template <class Graph, class Config, class Base>\n    inline void remove_vertex(typename Config::vertex_descriptor v,\n                              vec_adj_list_impl<Graph, Config, Base>& g_)\n    {\n      typedef typename Config::directed_category Cat;\n      Graph& g = static_cast<Graph&>(g_);\n      g.removing_vertex(v, boost::graph_detail::iterator_stability(g_.m_vertices));\n      detail::remove_vertex_dispatch(g, v, Cat());\n    }\n    // O(1)\n    template <class Graph, class Config, class Base>\n    inline typename Config::vertex_descriptor\n    vertex(typename Config::vertices_size_type n,\n           const vec_adj_list_impl<Graph, Config, Base>&)\n    {\n      return n;\n    }\n\n\n  namespace detail {\n\n    //=========================================================================\n    // Adjacency List Generator\n\n    template <class Graph, class VertexListS, class OutEdgeListS,\n              class DirectedS, class VertexProperty, class EdgeProperty,\n              class GraphProperty, class EdgeListS>\n    struct adj_list_gen\n    {\n      typedef typename detail::is_random_access<VertexListS>::type\n        is_rand_access;\n      typedef typename has_property<EdgeProperty>::type has_edge_property;\n      typedef typename DirectedS::is_directed_t DirectedT;\n      typedef typename DirectedS::is_bidir_t BidirectionalT;\n\n      struct config\n      {\n        typedef OutEdgeListS edgelist_selector;\n        typedef EdgeListS global_edgelist_selector;\n\n        typedef Graph graph_type;\n        typedef EdgeProperty edge_property_type;\n        typedef VertexProperty vertex_property_type;\n        typedef GraphProperty graph_property_type;\n        typedef std::size_t vertices_size_type;\n\n        typedef adjacency_list_traits<OutEdgeListS, VertexListS, DirectedS>\n           Traits;\n\n        typedef typename Traits::directed_category directed_category;\n        typedef typename Traits::edge_parallel_category edge_parallel_category;\n        typedef typename Traits::vertex_descriptor vertex_descriptor;\n        typedef typename Traits::edge_descriptor edge_descriptor;\n\n        typedef void* vertex_ptr;\n\n        // need to reorganize this to avoid instantiating stuff\n        // that doesn't get used -JGS\n\n        // VertexList and vertex_iterator\n        typedef typename container_gen<VertexListS,\n          vertex_ptr>::type SeqVertexList;\n        typedef boost::integer_range<vertex_descriptor> RandVertexList;\n        typedef typename mpl::if_<is_rand_access,\n          RandVertexList, SeqVertexList>::type VertexList;\n\n        typedef typename VertexList::iterator vertex_iterator;\n\n        // EdgeContainer and StoredEdge\n\n        typedef typename container_gen<EdgeListS,\n          list_edge<vertex_descriptor, EdgeProperty> >::type EdgeContainer;\n\n        typedef typename mpl::and_<DirectedT,\n             typename mpl::not_<BidirectionalT>::type >::type on_edge_storage;\n\n        typedef typename mpl::if_<on_edge_storage,\n          std::size_t, typename EdgeContainer::size_type\n        >::type edges_size_type;\n\n        typedef typename EdgeContainer::iterator EdgeIter;\n\n        typedef typename detail::is_random_access<EdgeListS>::type is_edge_ra;\n\n        typedef typename mpl::if_<on_edge_storage,\n          stored_edge_property<vertex_descriptor, EdgeProperty>,\n          typename mpl::if_<is_edge_ra,\n            stored_ra_edge_iter<vertex_descriptor, EdgeContainer, EdgeProperty>,\n            stored_edge_iter<vertex_descriptor, EdgeIter, EdgeProperty>\n          >::type\n        >::type StoredEdge;\n\n        // Adjacency Types\n\n        typedef typename container_gen<OutEdgeListS, StoredEdge>::type\n          OutEdgeList;\n        typedef typename OutEdgeList::size_type degree_size_type;\n        typedef typename OutEdgeList::iterator OutEdgeIter;\n\n        typedef boost::detail::iterator_traits<OutEdgeIter> OutEdgeIterTraits;\n        typedef typename OutEdgeIterTraits::iterator_category OutEdgeIterCat;\n        typedef typename OutEdgeIterTraits::difference_type OutEdgeIterDiff;\n\n        typedef out_edge_iter<\n            OutEdgeIter, vertex_descriptor, edge_descriptor, OutEdgeIterDiff\n        > out_edge_iterator;\n\n        typedef typename adjacency_iterator_generator<graph_type,\n           vertex_descriptor, out_edge_iterator>::type adjacency_iterator;\n\n        typedef OutEdgeList InEdgeList;\n        typedef OutEdgeIter InEdgeIter;\n        typedef OutEdgeIterCat InEdgeIterCat;\n        typedef OutEdgeIterDiff InEdgeIterDiff;\n\n        typedef in_edge_iter<\n            InEdgeIter, vertex_descriptor, edge_descriptor, InEdgeIterDiff\n        > in_edge_iterator;\n\n        typedef typename inv_adjacency_iterator_generator<graph_type,\n           vertex_descriptor, in_edge_iterator>::type inv_adjacency_iterator;\n\n        // Edge Iterator\n\n        typedef boost::detail::iterator_traits<EdgeIter> EdgeIterTraits;\n        typedef typename EdgeIterTraits::iterator_category EdgeIterCat;\n        typedef typename EdgeIterTraits::difference_type EdgeIterDiff;\n\n        typedef undirected_edge_iter<\n            EdgeIter\n          , edge_descriptor\n          , EdgeIterDiff\n        > UndirectedEdgeIter; // also used for bidirectional\n\n        typedef adj_list_edge_iterator<vertex_iterator, out_edge_iterator,\n           graph_type> DirectedEdgeIter;\n\n        typedef typename mpl::if_<on_edge_storage,\n          DirectedEdgeIter, UndirectedEdgeIter>::type edge_iterator;\n\n        // stored_vertex and StoredVertexList\n        typedef typename container_gen<VertexListS, vertex_ptr>::type\n          SeqStoredVertexList;\n        struct seq_stored_vertex {\n          seq_stored_vertex() { }\n          seq_stored_vertex(const VertexProperty& p) : m_property(p) { }\n          OutEdgeList m_out_edges;\n          VertexProperty m_property;\n          typename SeqStoredVertexList::iterator m_position;\n        };\n        struct bidir_seq_stored_vertex {\n          bidir_seq_stored_vertex() { }\n          bidir_seq_stored_vertex(const VertexProperty& p) : m_property(p) { }\n          OutEdgeList m_out_edges;\n          InEdgeList m_in_edges;\n          VertexProperty m_property;\n          typename SeqStoredVertexList::iterator m_position;\n        };\n        struct rand_stored_vertex {\n          rand_stored_vertex() { }\n          rand_stored_vertex(const VertexProperty& p) : m_property(p) { }\n          OutEdgeList m_out_edges;\n          VertexProperty m_property;\n        };\n        struct bidir_rand_stored_vertex {\n          bidir_rand_stored_vertex() { }\n          bidir_rand_stored_vertex(const VertexProperty& p) : m_property(p) { }\n          OutEdgeList m_out_edges;\n          InEdgeList m_in_edges;\n          VertexProperty m_property;\n        };\n        typedef typename mpl::if_<is_rand_access,\n          typename mpl::if_<BidirectionalT,\n            bidir_rand_stored_vertex, rand_stored_vertex>::type,\n          typename mpl::if_<BidirectionalT,\n            bidir_seq_stored_vertex, seq_stored_vertex>::type\n        >::type StoredVertex;\n        struct stored_vertex : public StoredVertex {\n          stored_vertex() { }\n          stored_vertex(const VertexProperty& p) : StoredVertex(p) { }\n        };\n\n        typedef typename container_gen<VertexListS, stored_vertex>::type\n          RandStoredVertexList;\n        typedef typename mpl::if_< is_rand_access,\n          RandStoredVertexList, SeqStoredVertexList>::type StoredVertexList;\n      }; // end of config\n\n\n      typedef typename mpl::if_<BidirectionalT,\n        bidirectional_graph_helper_with_property<config>,\n        typename mpl::if_<DirectedT,\n          directed_graph_helper<config>,\n          undirected_graph_helper<config>\n        >::type\n      >::type DirectedHelper;\n\n      typedef typename mpl::if_<is_rand_access,\n        vec_adj_list_impl<Graph, config, DirectedHelper>,\n        adj_list_impl<Graph, config, DirectedHelper>\n      >::type type;\n\n    };\n\n  } // namespace detail\n\n    //=========================================================================\n    // Vertex Property Maps\n\n    template <class Graph, class ValueType, class Reference, class Tag>\n    struct adj_list_vertex_property_map\n      : public boost::put_get_helper<\n          Reference,\n          adj_list_vertex_property_map<Graph, ValueType, Reference, Tag>\n        >\n    {\n      typedef typename Graph::stored_vertex StoredVertex;\n      typedef ValueType value_type;\n      typedef Reference reference;\n      typedef typename Graph::vertex_descriptor key_type;\n      typedef boost::lvalue_property_map_tag category;\n      inline adj_list_vertex_property_map(const Graph* = 0, Tag tag = Tag()): m_tag(tag) { }\n      inline Reference operator[](key_type v) const {\n        StoredVertex* sv = (StoredVertex*)v;\n        return get_property_value(sv->m_property, m_tag);\n      }\n      inline Reference operator()(key_type v) const {\n        return this->operator[](v);\n      }\n      Tag m_tag;\n    };\n\n    template <class Graph, class Property, class PropRef>\n    struct adj_list_vertex_all_properties_map\n      : public boost::put_get_helper<PropRef,\n          adj_list_vertex_all_properties_map<Graph, Property, PropRef>\n        >\n    {\n      typedef typename Graph::stored_vertex StoredVertex;\n      typedef Property value_type;\n      typedef PropRef reference;\n      typedef typename Graph::vertex_descriptor key_type;\n      typedef boost::lvalue_property_map_tag category;\n      inline adj_list_vertex_all_properties_map(const Graph* = 0, vertex_all_t = vertex_all_t()) { }\n      inline PropRef operator[](key_type v) const {\n        StoredVertex* sv = (StoredVertex*)v;\n        return sv->m_property;\n      }\n      inline PropRef operator()(key_type v) const {\n        return this->operator[](v);\n      }\n    };\n\n    template <class Graph, class GraphPtr, class ValueType, class Reference,\n              class Tag>\n    struct vec_adj_list_vertex_property_map\n      : public boost::put_get_helper<\n          Reference,\n          vec_adj_list_vertex_property_map<Graph,GraphPtr,ValueType,Reference,\n             Tag>\n        >\n    {\n      typedef ValueType value_type;\n      typedef Reference reference;\n      typedef typename boost::graph_traits<Graph>::vertex_descriptor key_type;\n      typedef boost::lvalue_property_map_tag category;\n      vec_adj_list_vertex_property_map(GraphPtr g = 0, Tag tag = Tag()) : m_g(g), m_tag(tag) { }\n      inline Reference operator[](key_type v) const {\n        return get_property_value(m_g->m_vertices[v].m_property, m_tag);\n      }\n      inline Reference operator()(key_type v) const {\n        return this->operator[](v);\n      }\n      GraphPtr m_g;\n      Tag m_tag;\n    };\n\n    template <class Graph, class GraphPtr, class Property, class PropertyRef>\n    struct vec_adj_list_vertex_all_properties_map\n      : public boost::put_get_helper<PropertyRef,\n          vec_adj_list_vertex_all_properties_map<Graph,GraphPtr,Property,\n            PropertyRef>\n        >\n    {\n      typedef Property value_type;\n      typedef PropertyRef reference;\n      typedef typename boost::graph_traits<Graph>::vertex_descriptor key_type;\n      typedef boost::lvalue_property_map_tag category;\n      vec_adj_list_vertex_all_properties_map(GraphPtr g = 0, vertex_all_t = vertex_all_t()) : m_g(g) { }\n      inline PropertyRef operator[](key_type v) const {\n        return m_g->m_vertices[v].m_property;\n      }\n      inline PropertyRef operator()(key_type v) const {\n        return this->operator[](v);\n      }\n      GraphPtr m_g;\n    };\n\n    struct adj_list_any_vertex_pa {\n      template <class Tag, class Graph, class Property>\n      struct bind_ {\n        typedef typename property_value<Property, Tag>::type value_type;\n        typedef value_type& reference;\n        typedef const value_type& const_reference;\n\n        typedef adj_list_vertex_property_map\n          <Graph, value_type, reference, Tag> type;\n        typedef adj_list_vertex_property_map\n          <Graph, value_type, const_reference, Tag> const_type;\n      };\n    };\n    struct adj_list_all_vertex_pa {\n      template <class Tag, class Graph, class Property>\n      struct bind_ {\n        typedef typename Graph::vertex_descriptor Vertex;\n        typedef adj_list_vertex_all_properties_map<Graph,Property,\n          Property&> type;\n        typedef adj_list_vertex_all_properties_map<Graph,Property,\n          const Property&> const_type;\n      };\n    };\n\n    template <class Property, class Vertex>\n    struct vec_adj_list_vertex_id_map\n      : public boost::put_get_helper<\n          Vertex, vec_adj_list_vertex_id_map<Property, Vertex>\n        >\n    {\n      typedef Vertex value_type;\n      typedef Vertex key_type;\n      typedef Vertex reference;\n      typedef boost::readable_property_map_tag category;\n      inline vec_adj_list_vertex_id_map() { }\n      template <class Graph>\n      inline vec_adj_list_vertex_id_map(const Graph&, vertex_index_t) { }\n      inline value_type operator[](key_type v) const { return v; }\n      inline value_type operator()(key_type v) const { return v; }\n    };\n\n    struct vec_adj_list_any_vertex_pa {\n      template <class Tag, class Graph, class Property>\n      struct bind_ {\n        typedef typename property_value<Property, Tag>::type value_type;\n        typedef value_type& reference;\n        typedef const value_type& const_reference;\n\n        typedef vec_adj_list_vertex_property_map\n          <Graph, Graph*, value_type, reference, Tag> type;\n        typedef vec_adj_list_vertex_property_map\n          <Graph, const Graph*, value_type, const_reference, Tag> const_type;\n      };\n    };\n    struct vec_adj_list_id_vertex_pa {\n      template <class Tag, class Graph, class Property>\n      struct bind_ {\n        typedef typename Graph::vertex_descriptor Vertex;\n        typedef vec_adj_list_vertex_id_map<Property, Vertex> type;\n        typedef vec_adj_list_vertex_id_map<Property, Vertex> const_type;\n      };\n    };\n    struct vec_adj_list_all_vertex_pa {\n      template <class Tag, class Graph, class Property>\n      struct bind_ {\n        typedef typename Graph::vertex_descriptor Vertex;\n        typedef vec_adj_list_vertex_all_properties_map\n          <Graph, Graph*, Property, Property&> type;\n        typedef vec_adj_list_vertex_all_properties_map\n          <Graph, const Graph*, Property, const Property&> const_type;\n      };\n    };\n  namespace detail {\n    template <class Tag, class Graph, class Property>\n    struct adj_list_choose_vertex_pa\n      : boost::mpl::if_<\n          boost::is_same<Tag, vertex_all_t>,\n          adj_list_all_vertex_pa,\n          adj_list_any_vertex_pa>::type\n        ::template bind_<Tag, Graph, Property>\n    {};\n\n\n    template <class Tag>\n    struct vec_adj_list_choose_vertex_pa_helper {\n      typedef vec_adj_list_any_vertex_pa type;\n    };\n    template <>\n    struct vec_adj_list_choose_vertex_pa_helper<vertex_index_t> {\n      typedef vec_adj_list_id_vertex_pa type;\n    };\n    template <>\n    struct vec_adj_list_choose_vertex_pa_helper<vertex_all_t> {\n      typedef vec_adj_list_all_vertex_pa type;\n    };\n    template <class Tag, class Graph, class Property>\n    struct vec_adj_list_choose_vertex_pa\n      : vec_adj_list_choose_vertex_pa_helper<Tag>::type::template bind_<Tag,Graph,Property>\n    {};\n  } // namespace detail\n\n    //=========================================================================\n    // Edge Property Map\n\n    template <class Directed, class Value, class Ref, class Vertex,\n              class Property, class Tag>\n    struct adj_list_edge_property_map\n      : public put_get_helper<\n          Ref,\n          adj_list_edge_property_map<Directed, Value, Ref, Vertex, Property,\n            Tag>\n        >\n    {\n      Tag tag;\n      explicit adj_list_edge_property_map(Tag tag = Tag()): tag(tag) {}\n\n      typedef Value value_type;\n      typedef Ref reference;\n      typedef detail::edge_desc_impl<Directed, Vertex> key_type;\n      typedef boost::lvalue_property_map_tag category;\n      inline Ref operator[](key_type e) const {\n        Property& p = *(Property*)e.get_property();\n        return get_property_value(p, tag);\n      }\n      inline Ref operator()(key_type e) const {\n        return this->operator[](e);\n      }\n    };\n\n    template <class Directed, class Property, class PropRef, class PropPtr,\n      class Vertex>\n    struct adj_list_edge_all_properties_map\n      : public put_get_helper<PropRef,\n          adj_list_edge_all_properties_map<Directed, Property, PropRef,\n            PropPtr, Vertex>\n        >\n    {\n      explicit adj_list_edge_all_properties_map(edge_all_t = edge_all_t()) {}\n      typedef Property value_type;\n      typedef PropRef reference;\n      typedef detail::edge_desc_impl<Directed, Vertex> key_type;\n      typedef boost::lvalue_property_map_tag category;\n      inline PropRef operator[](key_type e) const {\n        return *(PropPtr)e.get_property();\n      }\n      inline PropRef operator()(key_type e) const {\n        return this->operator[](e);\n      }\n    };\n\n  // Edge Property Maps\n\n  namespace detail {\n    struct adj_list_any_edge_pmap {\n      template <class Graph, class Property, class Tag>\n      struct bind_ {\n        typedef typename property_value<Property,Tag>::type value_type;\n        typedef value_type& reference;\n        typedef const value_type& const_reference;\n\n        typedef adj_list_edge_property_map\n           <typename Graph::directed_category, value_type, reference,\n            typename Graph::vertex_descriptor,Property,Tag> type;\n        typedef adj_list_edge_property_map\n           <typename Graph::directed_category, value_type, const_reference,\n            typename Graph::vertex_descriptor,const Property, Tag> const_type;\n      };\n    };\n    struct adj_list_all_edge_pmap {\n      template <class Graph, class Property, class Tag>\n      struct bind_ {\n        typedef adj_list_edge_all_properties_map\n        <typename Graph::directed_category, Property, Property&, Property*,\n            typename Graph::vertex_descriptor> type;\n        typedef adj_list_edge_all_properties_map\n        <typename Graph::directed_category, Property, const Property&,\n            const Property*, typename Graph::vertex_descriptor> const_type;\n      };\n    };\n\n    template <class Tag>\n    struct adj_list_choose_edge_pmap_helper {\n      typedef adj_list_any_edge_pmap type;\n    };\n    template <>\n    struct adj_list_choose_edge_pmap_helper<edge_all_t> {\n      typedef adj_list_all_edge_pmap type;\n    };\n    template <class Tag, class Graph, class Property>\n    struct adj_list_choose_edge_pmap\n      : adj_list_choose_edge_pmap_helper<Tag>::type::template bind_<Graph, Property, Tag>\n      {};\n    struct adj_list_edge_property_selector {\n      template <class Graph, class Property, class Tag>\n      struct bind_: adj_list_choose_edge_pmap<Tag, Graph, Property> {};\n    };\n  } // namespace detail\n\n  template <>\n  struct edge_property_selector<adj_list_tag> {\n    typedef detail::adj_list_edge_property_selector type;\n  };\n  template <>\n  struct edge_property_selector<vec_adj_list_tag> {\n    typedef detail::adj_list_edge_property_selector type;\n  };\n\n  // Vertex Property Maps\n\n  struct adj_list_vertex_property_selector {\n    template <class Graph, class Property, class Tag>\n    struct bind_\n      : detail::adj_list_choose_vertex_pa<Tag,Graph,Property>\n    {};\n  };\n  template <>\n  struct vertex_property_selector<adj_list_tag> {\n    typedef adj_list_vertex_property_selector type;\n  };\n\n  struct vec_adj_list_vertex_property_selector {\n    template <class Graph, class Property, class Tag>\n    struct bind_: detail::vec_adj_list_choose_vertex_pa<Tag,Graph,Property> {};\n  };\n  template <>\n  struct vertex_property_selector<vec_adj_list_tag> {\n    typedef vec_adj_list_vertex_property_selector type;\n  };\n\n} // namespace boost\n\n#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)\nnamespace boost {\n\n  template <typename V>\n  struct hash< boost::detail::stored_edge<V> >\n  {\n    std::size_t\n    operator()(const boost::detail::stored_edge<V>& e) const\n    {\n      return hash<V>()(e.m_target);\n    }\n  };\n\n  template <typename V, typename P>\n  struct hash< boost::detail::stored_edge_property <V,P> >\n  {\n    std::size_t\n    operator()(const boost::detail::stored_edge_property<V,P>& e) const\n    {\n      return hash<V>()(e.m_target);\n    }\n  };\n\n  template <typename V, typename I, typename P>\n  struct hash< boost::detail::stored_edge_iter<V,I, P> >\n  {\n    std::size_t\n    operator()(const boost::detail::stored_edge_iter<V,I,P>& e) const\n    {\n      return hash<V>()(e.m_target);\n    }\n  };\n\n}\n#endif\n\n\n#endif // BOOST_GRAPH_DETAIL_DETAIL_ADJACENCY_LIST_CCT\n\n/*\n  Implementation Notes:\n\n  Many of the public interface functions in this file would have been\n  more conveniently implemented as inline friend functions.\n  However there are a few compiler bugs that make that approach\n  non-portable.\n\n  1. g++ inline friend in namespace bug\n  2. g++ using clause doesn't work with inline friends\n  3. VC++ doesn't have Koenig lookup\n\n  For these reasons, the functions were all written as non-inline free\n  functions, and static cast was used to convert from the helper\n  class to the adjacency_list derived class.\n\n  Looking back, it might have been better to write out all functions\n  in terms of the adjacency_list, and then use a tag to dispatch\n  to the various helpers instead of using inheritance.\n\n */\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, std::pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, std::pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&\n    get(std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, std::pair<T1, T2> >::type&\n    get(const std::pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, std::pair<T1, T2> >::type&&\n    get(std::pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(std::pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(std::pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(std::pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct ___make_pair_return\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct ___make_pair_return<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename ___make_pair_return<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct ____is_reference_wrapper : public false_type {};\ntemplate <class _Tp> struct ____is_reference_wrapper<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public ____is_reference_wrapper<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// (C) Copyright David Abrahams 2002.\n// (C) Copyright Jeremy Siek    2002.\n// (C) Copyright Thomas Witt    2002.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n#ifndef BOOST_ITERATOR_FACADE_23022003THW_HPP\n#define BOOST_ITERATOR_FACADE_23022003THW_HPP\n\n#include <boost/iterator.hpp>\n#include <boost/iterator/interoperable.hpp>\n#include <boost/iterator/iterator_traits.hpp>\n\n#include <boost/iterator/detail/facade_iterator_category.hpp>\n#include <boost/iterator/detail/enable_if.hpp>\n\n#include <boost/static_assert.hpp>\n#include <boost/utility/addressof.hpp>\n\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/add_const.hpp>\n#include <boost/type_traits/add_pointer.hpp>\n#include <boost/type_traits/remove_const.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/type_traits/is_convertible.hpp>\n#include <boost/type_traits/is_pod.hpp>\n\n#include <boost/mpl/eval_if.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/or.hpp>\n#include <boost/mpl/and.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/always.hpp>\n#include <boost/mpl/apply.hpp>\n#include <boost/mpl/identity.hpp>\n\n#include <boost/iterator/detail/config_def.hpp> // this goes last\n\nnamespace boost\n{\n  // This forward declaration is required for the friend declaration\n  // in iterator_core_access\n  template <class I, class V, class TC, class R, class D> class iterator_facade;\n\n  namespace detail\n  {\n    // A binary metafunction class that always returns bool.  VC6\n    // ICEs on mpl::always<bool>, probably because of the default\n    // parameters.\n    struct always_bool2\n    {\n        template <class T, class U>\n        struct apply\n        {\n            typedef bool type;\n        };\n    };\n\n    //\n    // enable if for use in operator implementation.\n    //\n    template <\n        class Facade1\n      , class Facade2\n      , class Return\n    >\n    struct enable_if_interoperable\n#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)\n    {\n        typedef typename mpl::if_<\n            mpl::or_<\n                is_convertible<Facade1, Facade2>\n              , is_convertible<Facade2, Facade1>\n            >\n          , Return\n          , int[3]\n        >::type type;\n    };        \n#else\n      : ::boost::iterators::enable_if<\n           mpl::or_<\n               is_convertible<Facade1, Facade2>\n             , is_convertible<Facade2, Facade1>\n           >\n         , Return\n        >\n    {};\n#endif \n\n    //\n    // Generates associated types for an iterator_facade with the\n    // given parameters.\n    //\n    template <\n        class ValueParam\n      , class CategoryOrTraversal\n      , class Reference \n      , class Difference\n    >\n    struct iterator_facade_types\n    {\n        typedef typename facade_iterator_category<\n            CategoryOrTraversal, ValueParam, Reference\n        >::type iterator_category;\n        \n        typedef typename remove_const<ValueParam>::type value_type;\n        \n        // Not the real associated pointer type\n        typedef typename mpl::eval_if<\n            boost::detail::iterator_writability_disabled<ValueParam,Reference>\n          , add_pointer<const value_type>\n          , add_pointer<value_type>\n        >::type pointer;\n      \n# if defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)                          \\\n    && (BOOST_WORKAROUND(_STLPORT_VERSION, BOOST_TESTED_AT(0x452))              \\\n        || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, BOOST_TESTED_AT(310)))     \\\n    || BOOST_WORKAROUND(BOOST_RWSTD_VER, BOOST_TESTED_AT(0x20101))              \\\n    || BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, <= 310)\n\n        // To interoperate with some broken library/compiler\n        // combinations, user-defined iterators must be derived from\n        // std::iterator.  It is possible to implement a standard\n        // library for broken compilers without this limitation.\n#  define BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE 1\n\n        typedef\n           iterator<iterator_category, value_type, Difference, pointer, Reference>\n        base;\n# endif\n    };\n\n    // iterators whose dereference operators reference the same value\n    // for all iterators into the same sequence (like many input\n    // iterators) need help with their postfix ++: the referenced\n    // value must be read and stored away before the increment occurs\n    // so that *a++ yields the originally referenced element and not\n    // the next one.\n    template <class Iterator>\n    class postfix_increment_proxy\n    {\n        typedef typename iterator_value<Iterator>::type value_type;\n     public:\n        explicit postfix_increment_proxy(Iterator const& x)\n          : stored_value(*x)\n        {}\n\n        // Returning a mutable reference allows nonsense like\n        // (*r++).mutate(), but it imposes fewer assumptions about the\n        // behavior of the value_type.  In particular, recall that\n        // (*r).mutate() is legal if operator* returns by value.\n        value_type&\n        operator*() const\n        {\n            return this->stored_value;\n        }\n     private:\n        mutable value_type stored_value;\n    };\n    \n    //\n    // In general, we can't determine that such an iterator isn't\n    // writable -- we also need to store a copy of the old iterator so\n    // that it can be written into.\n    template <class Iterator>\n    class writable_postfix_increment_proxy\n    {\n        typedef typename iterator_value<Iterator>::type value_type;\n     public:\n        explicit writable_postfix_increment_proxy(Iterator const& x)\n          : stored_value(*x)\n          , stored_iterator(x)\n        {}\n\n        // Dereferencing must return a proxy so that both *r++ = o and\n        // value_type(*r++) can work.  In this case, *r is the same as\n        // *r++, and the conversion operator below is used to ensure\n        // readability.\n        writable_postfix_increment_proxy const&\n        operator*() const\n        {\n            return *this;\n        }\n\n        // Provides readability of *r++\n        operator value_type&() const\n        {\n            return stored_value;\n        }\n\n        // Provides writability of *r++\n        template <class T>\n        T const& operator=(T const& x) const\n        {\n            *this->stored_iterator = x;\n            return x;\n        }\n\n        // This overload just in case only non-const objects are writable\n        template <class T>\n        T& operator=(T& x) const\n        {\n            *this->stored_iterator = x;\n            return x;\n        }\n\n        // Provides X(r++)\n        operator Iterator const&() const\n        {\n            return stored_iterator;\n        }\n        \n     private:\n        mutable value_type stored_value;\n        Iterator stored_iterator;\n    };\n\n# ifdef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n\n    template <class Reference, class Value>\n    struct is_non_proxy_reference_impl\n    {\n        static Reference r;\n        \n        template <class R>\n        static typename mpl::if_<\n            is_convertible<\n                R const volatile*\n              , Value const volatile*\n            >\n          , char[1]\n          , char[2]\n        >::type& helper(R const&);\n        \n        BOOST_STATIC_CONSTANT(bool, value = sizeof(helper(r)) == 1);\n    };\n        \n    template <class Reference, class Value>\n    struct is_non_proxy_reference\n      : mpl::bool_<\n            is_non_proxy_reference_impl<Reference, Value>::value\n        >\n    {};\n# else \n    template <class Reference, class Value>\n    struct is_non_proxy_reference\n      : is_convertible<\n            typename remove_reference<Reference>::type\n            const volatile*\n          , Value const volatile*\n        >\n    {};\n# endif \n        \n    // A metafunction to choose the result type of postfix ++\n    //\n    // Because the C++98 input iterator requirements say that *r++ has\n    // type T (value_type), implementations of some standard\n    // algorithms like lexicographical_compare may use constructions\n    // like:\n    //\n    //          *r++ < *s++\n    //\n    // If *r++ returns a proxy (as required if r is writable but not\n    // multipass), this sort of expression will fail unless the proxy\n    // supports the operator<.  Since there are any number of such\n    // operations, we're not going to try to support them.  Therefore,\n    // even if r++ returns a proxy, *r++ will only return a proxy if\n    // *r also returns a proxy.\n    template <class Iterator, class Value, class Reference, class CategoryOrTraversal>\n    struct postfix_increment_result\n      : mpl::eval_if<\n            mpl::and_<\n                // A proxy is only needed for readable iterators\n                is_convertible<Reference,Value const&>\n                \n                // No multipass iterator can have values that disappear\n                // before positions can be re-visited\n              , mpl::not_<\n                    is_convertible<\n                        typename iterator_category_to_traversal<CategoryOrTraversal>::type\n                      , forward_traversal_tag\n                    >\n                >\n            >\n          , mpl::if_<\n                is_non_proxy_reference<Reference,Value>\n              , postfix_increment_proxy<Iterator>\n              , writable_postfix_increment_proxy<Iterator>\n            >\n          , mpl::identity<Iterator>\n        >\n    {};\n\n    // operator->() needs special support for input iterators to strictly meet the\n    // standard's requirements. If *i is not a reference type, we must still\n    // produce an lvalue to which a pointer can be formed.  We do that by\n    // returning a proxy object containing an instance of the reference object.\n    template <class Reference, class Pointer>\n    struct operator_arrow_dispatch // proxy references\n    {\n        struct proxy\n        {\n            explicit proxy(Reference const & x) : m_ref(x) {}\n            Reference* operator->() { return boost::addressof(m_ref); }\n            // This function is needed for MWCW and BCC, which won't call\n            // operator-> again automatically per 13.3.1.2 para 8\n            operator Reference*() { return boost::addressof(m_ref); }\n            Reference m_ref;\n        };\n        typedef proxy result_type;\n        static result_type apply(Reference const & x)\n        {\n            return result_type(x);\n        }\n    };\n\n    template <class T, class Pointer>\n    struct operator_arrow_dispatch<T&, Pointer> // \"real\" references\n    {\n        typedef Pointer result_type;\n        static result_type apply(T& x)\n        {\n            return boost::addressof(x);\n        }\n    };\n\n# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n    // Deal with ETI\n    template<>\n    struct operator_arrow_dispatch<int, int>\n    {\n        typedef int result_type;\n    };\n# endif\n\n    // A proxy return type for operator[], needed to deal with\n    // iterators that may invalidate referents upon destruction.\n    // Consider the temporary iterator in *(a + n)\n    template <class Iterator>\n    class operator_brackets_proxy\n    {\n        // Iterator is actually an iterator_facade, so we do not have to\n        // go through iterator_traits to access the traits.\n        typedef typename Iterator::reference  reference;\n        typedef typename Iterator::value_type value_type;\n\n     public:\n        operator_brackets_proxy(Iterator const& iter)\n          : m_iter(iter)\n        {}\n\n        operator reference() const\n        {\n            return *m_iter;\n        }\n\n        operator_brackets_proxy& operator=(value_type const& val)\n        {\n            *m_iter = val;\n            return *this;\n        }\n\n     private:\n        Iterator m_iter;\n    };\n\n    // A metafunction that determines whether operator[] must return a\n    // proxy, or whether it can simply return a copy of the value_type.\n    template <class ValueType, class Reference>\n    struct use_operator_brackets_proxy\n      : mpl::not_<\n            mpl::and_<\n                // Really we want an is_copy_constructible trait here,\n                // but is_POD will have to suffice in the meantime.\n                boost::is_POD<ValueType>\n              , iterator_writability_disabled<ValueType,Reference>\n            >\n        >\n    {};\n        \n    template <class Iterator, class Value, class Reference>\n    struct operator_brackets_result\n    {\n        typedef typename mpl::if_<\n            use_operator_brackets_proxy<Value,Reference>\n          , operator_brackets_proxy<Iterator>\n          , Value\n        >::type type;\n    };\n\n    template <class Iterator>\n    operator_brackets_proxy<Iterator> make_operator_brackets_result(Iterator const& iter, mpl::true_)\n    {\n        return operator_brackets_proxy<Iterator>(iter);\n    }\n\n    template <class Iterator>\n    typename Iterator::value_type make_operator_brackets_result(Iterator const& iter, mpl::false_)\n    {\n      return *iter;\n    }\n\n    struct choose_difference_type\n    {\n        template <class I1, class I2>\n        struct apply\n          :\n# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP\n          iterator_difference<I1>\n# elif BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n          mpl::if_<\n              is_convertible<I2,I1>\n            , typename I1::difference_type\n            , typename I2::difference_type\n          >\n# else \n          mpl::eval_if<\n              is_convertible<I2,I1>\n            , iterator_difference<I1>\n            , iterator_difference<I2>\n          >\n# endif \n        {};\n\n    };\n  } // namespace detail\n\n\n  // Macros which describe the declarations of binary operators\n# ifdef BOOST_NO_STRICT_ITERATOR_INTEROPERABILITY\n#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD(prefix, op, result_type)       \\\n    template <                                                              \\\n        class Derived1, class V1, class TC1, class Reference1, class Difference1 \\\n      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \\\n    >                                                                       \\\n    prefix typename mpl::apply2<result_type,Derived1,Derived2>::type \\\n    operator op(                                                            \\\n        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \\\n      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)\n# else \n#  define BOOST_ITERATOR_FACADE_INTEROP_HEAD(prefix, op, result_type)   \\\n    template <                                                          \\\n        class Derived1, class V1, class TC1, class Reference1, class Difference1 \\\n      , class Derived2, class V2, class TC2, class Reference2, class Difference2 \\\n    >                                                                   \\\n    prefix typename boost::detail::enable_if_interoperable<             \\\n        Derived1, Derived2                                              \\\n      , typename mpl::apply2<result_type,Derived1,Derived2>::type       \\\n    >::type                                                             \\\n    operator op(                                                        \\\n        iterator_facade<Derived1, V1, TC1, Reference1, Difference1> const& lhs   \\\n      , iterator_facade<Derived2, V2, TC2, Reference2, Difference2> const& rhs)\n# endif \n\n#  define BOOST_ITERATOR_FACADE_PLUS_HEAD(prefix,args)              \\\n    template <class Derived, class V, class TC, class R, class D>   \\\n    prefix Derived operator+ args\n\n  //\n  // Helper class for granting access to the iterator core interface.\n  //\n  // The simple core interface is used by iterator_facade. The core\n  // interface of a user/library defined iterator type should not be made public\n  // so that it does not clutter the public interface. Instead iterator_core_access\n  // should be made friend so that iterator_facade can access the core\n  // interface through iterator_core_access.\n  //\n  class iterator_core_access\n  {\n# if defined(BOOST_NO_MEMBER_TEMPLATE_FRIENDS)                  \n      // Tasteless as this may seem, making all members public allows member templates\n      // to work in the absence of member template friends.\n   public:\n# else\n      \n      template <class I, class V, class TC, class R, class D> friend class iterator_facade;\n\n#  define BOOST_ITERATOR_FACADE_RELATION(op)                                \\\n      BOOST_ITERATOR_FACADE_INTEROP_HEAD(friend,op, boost::detail::always_bool2);\n\n      BOOST_ITERATOR_FACADE_RELATION(==)\n      BOOST_ITERATOR_FACADE_RELATION(!=)\n\n      BOOST_ITERATOR_FACADE_RELATION(<)\n      BOOST_ITERATOR_FACADE_RELATION(>)\n      BOOST_ITERATOR_FACADE_RELATION(<=)\n      BOOST_ITERATOR_FACADE_RELATION(>=)\n#  undef BOOST_ITERATOR_FACADE_RELATION\n\n      BOOST_ITERATOR_FACADE_INTEROP_HEAD(\n          friend, -, boost::detail::choose_difference_type)\n      ;\n\n      BOOST_ITERATOR_FACADE_PLUS_HEAD(\n          friend inline\n          , (iterator_facade<Derived, V, TC, R, D> const&\n           , typename Derived::difference_type)\n      )\n      ;\n\n      BOOST_ITERATOR_FACADE_PLUS_HEAD(\n          friend inline\n        , (typename Derived::difference_type\n           , iterator_facade<Derived, V, TC, R, D> const&)\n      )\n      ;\n\n# endif\n\n      template <class Facade>\n      static typename Facade::reference dereference(Facade const& f)\n      {\n          return f.dereference();\n      }\n\n      template <class Facade>\n      static void increment(Facade& f)\n      {\n          f.increment();\n      }\n\n      template <class Facade>\n      static void decrement(Facade& f)\n      {\n          f.decrement();\n      }\n\n      template <class Facade1, class Facade2>\n      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::true_)\n      {\n          return f1.equal(f2);\n      }\n\n      template <class Facade1, class Facade2>\n      static bool equal(Facade1 const& f1, Facade2 const& f2, mpl::false_)\n      {\n          return f2.equal(f1);\n      }\n\n      template <class Facade>\n      static void advance(Facade& f, typename Facade::difference_type n)\n      {\n          f.advance(n);\n      }\n\n      template <class Facade1, class Facade2>\n      static typename Facade1::difference_type distance_from(\n          Facade1 const& f1, Facade2 const& f2, mpl::true_)\n      {\n          return -f1.distance_to(f2);\n      }\n\n      template <class Facade1, class Facade2>\n      static typename Facade2::difference_type distance_from(\n          Facade1 const& f1, Facade2 const& f2, mpl::false_)\n      {\n          return f2.distance_to(f1);\n      }\n\n      //\n      // Curiously Recurring Template interface.\n      //\n      template <class I, class V, class TC, class R, class D>\n      static I& derived(iterator_facade<I,V,TC,R,D>& facade)\n      {\n          return *static_cast<I*>(&facade);\n      }\n\n      template <class I, class V, class TC, class R, class D>\n      static I const& derived(iterator_facade<I,V,TC,R,D> const& facade)\n      {\n          return *static_cast<I const*>(&facade);\n      }\n\n   private:\n      // objects of this class are useless\n      iterator_core_access(); //undefined\n  };\n\n  //\n  // iterator_facade - use as a public base class for defining new\n  // standard-conforming iterators.\n  //\n  template <\n      class Derived             // The derived iterator type being constructed\n    , class Value\n    , class CategoryOrTraversal\n    , class Reference   = Value&\n    , class Difference  = std::ptrdiff_t\n  >\n  class iterator_facade\n# ifdef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE\n    : public boost::detail::iterator_facade_types<\n         Value, CategoryOrTraversal, Reference, Difference\n      >::base\n#  undef BOOST_ITERATOR_FACADE_NEEDS_ITERATOR_BASE\n# endif\n  {\n   private:\n      //\n      // Curiously Recurring Template interface.\n      //\n      Derived& derived()\n      {\n          return *static_cast<Derived*>(this);\n      }\n\n      Derived const& derived() const\n      {\n          return *static_cast<Derived const*>(this);\n      }\n\n      typedef boost::detail::iterator_facade_types<\n         Value, CategoryOrTraversal, Reference, Difference\n      > associated_types;\n\n      typedef boost::detail::operator_arrow_dispatch<\n          Reference\n        , typename associated_types::pointer\n      > operator_arrow_dispatch_;\n\n   protected:\n      // For use by derived classes\n      typedef iterator_facade<Derived,Value,CategoryOrTraversal,Reference,Difference> iterator_facade_;\n      \n   public:\n\n      typedef typename associated_types::value_type value_type;\n      typedef Reference reference;\n      typedef Difference difference_type;\n\n      typedef typename operator_arrow_dispatch_::result_type pointer;\n\n      typedef typename associated_types::iterator_category iterator_category;\n\n      reference operator*() const\n      {\n          return iterator_core_access::dereference(this->derived());\n      }\n\n      pointer operator->() const\n      {\n          return operator_arrow_dispatch_::apply(*this->derived());\n      }\n        \n      typename boost::detail::operator_brackets_result<Derived,Value,reference>::type\n      operator[](difference_type n) const\n      {\n          typedef boost::detail::use_operator_brackets_proxy<Value,Reference> use_proxy;\n          \n          return boost::detail::make_operator_brackets_result<Derived>(\n              this->derived() + n\n            , use_proxy()\n          );\n      }\n\n      Derived& operator++()\n      {\n          iterator_core_access::increment(this->derived());\n          return this->derived();\n      }\n\n# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n      typename boost::detail::postfix_increment_result<Derived,Value,Reference,CategoryOrTraversal>::type\n      operator++(int)\n      {\n          typename boost::detail::postfix_increment_result<Derived,Value,Reference,CategoryOrTraversal>::type\n          tmp(this->derived());\n          ++*this;\n          return tmp;\n      }\n# endif\n      \n      Derived& operator--()\n      {\n          iterator_core_access::decrement(this->derived());\n          return this->derived();\n      }\n\n      Derived operator--(int)\n      {\n          Derived tmp(this->derived());\n          --*this;\n          return tmp;\n      }\n\n      Derived& operator+=(difference_type n)\n      {\n          iterator_core_access::advance(this->derived(), n);\n          return this->derived();\n      }\n\n      Derived& operator-=(difference_type n)\n      {\n          iterator_core_access::advance(this->derived(), -n);\n          return this->derived();\n      }\n\n      Derived operator-(difference_type x) const\n      {\n          Derived result(this->derived());\n          return result -= x;\n      }\n\n# if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n      // There appears to be a bug which trashes the data of classes\n      // derived from iterator_facade when they are assigned unless we\n      // define this assignment operator.  This bug is only revealed\n      // (so far) in STLPort debug mode, but it's clearly a codegen\n      // problem so we apply the workaround for all MSVC6.\n      iterator_facade& operator=(iterator_facade const&)\n      {\n          return *this;\n      }\n# endif\n  };\n\n# if !BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n  template <class I, class V, class TC, class R, class D>\n  inline typename boost::detail::postfix_increment_result<I,V,R,TC>::type\n  operator++(\n      iterator_facade<I,V,TC,R,D>& i\n    , int\n  )\n  {\n      typename boost::detail::postfix_increment_result<I,V,R,TC>::type\n          tmp(*static_cast<I*>(&i));\n      \n      ++i;\n      \n      return tmp;\n  }\n# endif \n\n  \n  //\n  // Comparison operator implementation. The library supplied operators\n  // enables the user to provide fully interoperable constant/mutable\n  // iterator types. I.e. the library provides all operators\n  // for all mutable/constant iterator combinations.\n  //\n  // Note though that this kind of interoperability for constant/mutable\n  // iterators is not required by the standard for container iterators.\n  // All the standard asks for is a conversion mutable -> constant.\n  // Most standard library implementations nowadays provide fully interoperable\n  // iterator implementations, but there are still heavily used implementations\n  // that do not provide them. (Actually it's even worse, they do not provide\n  // them for only a few iterators.)\n  //\n  // ?? Maybe a BOOST_ITERATOR_NO_FULL_INTEROPERABILITY macro should\n  //    enable the user to turn off mixed type operators\n  //\n  // The library takes care to provide only the right operator overloads.\n  // I.e.\n  //\n  // bool operator==(Iterator,      Iterator);\n  // bool operator==(ConstIterator, Iterator);\n  // bool operator==(Iterator,      ConstIterator);\n  // bool operator==(ConstIterator, ConstIterator);\n  //\n  //   ...\n  //\n  // In order to do so it uses c++ idioms that are not yet widely supported\n  // by current compiler releases. The library is designed to degrade gracefully\n  // in the face of compiler deficiencies. In general compiler\n  // deficiencies result in less strict error checking and more obscure\n  // error messages, functionality is not affected.\n  //\n  // For full operation compiler support for \"Substitution Failure Is Not An Error\"\n  // (aka. enable_if) and boost::is_convertible is required.\n  //\n  // The following problems occur if support is lacking.\n  //\n  // Pseudo code\n  //\n  // ---------------\n  // AdaptorA<Iterator1> a1;\n  // AdaptorA<Iterator2> a2;\n  //\n  // // This will result in a no such overload error in full operation\n  // // If enable_if or is_convertible is not supported\n  // // The instantiation will fail with an error hopefully indicating that\n  // // there is no operator== for Iterator1, Iterator2\n  // // The same will happen if no enable_if is used to remove\n  // // false overloads from the templated conversion constructor\n  // // of AdaptorA.\n  //\n  // a1 == a2;\n  // ----------------\n  //\n  // AdaptorA<Iterator> a;\n  // AdaptorB<Iterator> b;\n  //\n  // // This will result in a no such overload error in full operation\n  // // If enable_if is not supported the static assert used\n  // // in the operator implementation will fail.\n  // // This will accidently work if is_convertible is not supported.\n  //\n  // a == b;\n  // ----------------\n  //\n\n# ifdef BOOST_NO_ONE_WAY_ITERATOR_INTEROP\n#  define BOOST_ITERATOR_CONVERTIBLE(a,b) mpl::true_()\n# else\n#  define BOOST_ITERATOR_CONVERTIBLE(a,b) is_convertible<a,b>()\n# endif\n\n# define BOOST_ITERATOR_FACADE_INTEROP(op, result_type, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP_HEAD(inline, op, result_type)                   \\\n  {                                                                             \\\n      /* For those compilers that do not support enable_if */                   \\\n      BOOST_STATIC_ASSERT((                                                     \\\n          is_interoperable< Derived1, Derived2 >::value                         \\\n      ));                                                                       \\\n      return_prefix iterator_core_access::base_op(                              \\\n          *static_cast<Derived1 const*>(&lhs)                                   \\\n        , *static_cast<Derived2 const*>(&rhs)                                   \\\n        , BOOST_ITERATOR_CONVERTIBLE(Derived2,Derived1)                         \\\n      );                                                                        \\\n  }\n\n# define BOOST_ITERATOR_FACADE_RELATION(op, return_prefix, base_op) \\\n  BOOST_ITERATOR_FACADE_INTEROP(                                    \\\n      op                                                            \\\n    , boost::detail::always_bool2                                   \\\n    , return_prefix                                                 \\\n    , base_op                                                       \\\n  )\n\n  BOOST_ITERATOR_FACADE_RELATION(==, return, equal)\n  BOOST_ITERATOR_FACADE_RELATION(!=, return !, equal)\n\n  BOOST_ITERATOR_FACADE_RELATION(<, return 0 >, distance_from)\n  BOOST_ITERATOR_FACADE_RELATION(>, return 0 <, distance_from)\n  BOOST_ITERATOR_FACADE_RELATION(<=, return 0 >=, distance_from)\n  BOOST_ITERATOR_FACADE_RELATION(>=, return 0 <=, distance_from)\n# undef BOOST_ITERATOR_FACADE_RELATION\n\n  // operator- requires an additional part in the static assertion\n  BOOST_ITERATOR_FACADE_INTEROP(\n      -\n    , boost::detail::choose_difference_type\n    , return\n    , distance_from\n  )\n# undef BOOST_ITERATOR_FACADE_INTEROP\n# undef BOOST_ITERATOR_FACADE_INTEROP_HEAD\n\n# define BOOST_ITERATOR_FACADE_PLUS(args)           \\\n  BOOST_ITERATOR_FACADE_PLUS_HEAD(inline, args)     \\\n  {                                                 \\\n      Derived tmp(static_cast<Derived const&>(i));  \\\n      return tmp += n;                              \\\n  }\n\nBOOST_ITERATOR_FACADE_PLUS((\n  iterator_facade<Derived, V, TC, R, D> const& i\n  , typename Derived::difference_type n\n))\n\nBOOST_ITERATOR_FACADE_PLUS((\n    typename Derived::difference_type n\n    , iterator_facade<Derived, V, TC, R, D> const& i\n))\n# undef BOOST_ITERATOR_FACADE_PLUS\n# undef BOOST_ITERATOR_FACADE_PLUS_HEAD\n\n} // namespace boost\n\n#include <boost/iterator/detail/config_undef.hpp>\n\n#endif // BOOST_ITERATOR_FACADE_23022003THW_HPP\n","// (C) Copyright David Abrahams 2002.\n// (C) Copyright Jeremy Siek    2002.\n// (C) Copyright Thomas Witt    2002.\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n#ifndef BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n#define BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n\n#include <boost/static_assert.hpp>\n#include <boost/iterator.hpp>\n#include <boost/detail/iterator.hpp>\n\n#include <boost/iterator/iterator_categories.hpp>\n#include <boost/iterator/iterator_facade.hpp>\n#include <boost/iterator/detail/enable_if.hpp>\n\n#include <boost/mpl/and.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/or.hpp>\n\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/is_convertible.hpp>\n\n#ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY\n# include <boost/type_traits/remove_reference.hpp>\n#endif\n\n#include <boost/type_traits/add_reference.hpp>\n#include <boost/iterator/detail/config_def.hpp>\n\n#include <boost/iterator/iterator_traits.hpp>\n\nnamespace boost\n{\n  // Used as a default template argument internally, merely to\n  // indicate \"use the default\", this can also be passed by users\n  // explicitly in order to specify that the default should be used.\n  struct use_default;\n  \n# ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  // the incompleteness of use_default causes massive problems for\n  // is_convertible (naturally).  This workaround is fortunately not\n  // needed for vc6/vc7.\n  template<class To>\n  struct is_convertible<use_default,To>\n    : mpl::false_ {};\n# endif \n  \n  namespace detail\n  {\n\n    // \n    // Result type used in enable_if_convertible meta function.\n    // This can be an incomplete type, as only pointers to \n    // enable_if_convertible< ... >::type are used.\n    // We could have used void for this, but conversion to\n    // void* is just to easy.\n    //\n    struct enable_type;\n  }\n\n\n  //\n  // enable_if for use in adapted iterators constructors.\n  //\n  // In order to provide interoperability between adapted constant and\n  // mutable iterators, adapted iterators will usually provide templated\n  // conversion constructors of the following form\n  //\n  // template <class BaseIterator>\n  // class adapted_iterator :\n  //   public iterator_adaptor< adapted_iterator<Iterator>, Iterator >\n  // {\n  // public:\n  //   \n  //   ...\n  //\n  //   template <class OtherIterator>\n  //   adapted_iterator(\n  //       OtherIterator const& it\n  //     , typename enable_if_convertible<OtherIterator, Iterator>::type* = 0);\n  //\n  //   ...\n  // };\n  //\n  // enable_if_convertible is used to remove those overloads from the overload\n  // set that cannot be instantiated. For all practical purposes only overloads\n  // for constant/mutable interaction will remain. This has the advantage that\n  // meta functions like boost::is_convertible do not return false positives,\n  // as they can only look at the signature of the conversion constructor\n  // and not at the actual instantiation.\n  //\n  // enable_if_interoperable can be safely used in user code. It falls back to\n  // always enabled for compilers that don't support enable_if or is_convertible. \n  // There is no need for compiler specific workarounds in user code. \n  //\n  // The operators implementation relies on boost::is_convertible not returning\n  // false positives for user/library defined iterator types. See comments\n  // on operator implementation for consequences.\n  //\n#  if BOOST_WORKAROUND(BOOST_MSVC, <= 1300)\n  \n  template<typename From, typename To>\n  struct enable_if_convertible\n  {\n     typedef typename mpl::if_<\n         mpl::or_<\n             is_same<From,To>\n           , is_convertible<From, To>\n         >\n      , boost::detail::enable_type\n      , int&\n     >::type type;\n  };\n  \n#  elif defined(BOOST_NO_IS_CONVERTIBLE) || defined(BOOST_NO_SFINAE)\n  \n  template <class From, class To>\n  struct enable_if_convertible\n  {\n      typedef boost::detail::enable_type type;\n  };\n  \n#  elif BOOST_WORKAROUND(_MSC_FULL_VER, BOOST_TESTED_AT(13102292)) && BOOST_MSVC > 1300\n  \n  // For some reason vc7.1 needs us to \"cut off\" instantiation\n  // of is_convertible in a few cases.\n  template<typename From, typename To>\n  struct enable_if_convertible\n    : iterators::enable_if<\n        mpl::or_<\n            is_same<From,To>\n          , is_convertible<From, To>\n        >\n      , boost::detail::enable_type\n    >\n  {};\n  \n#  else \n  \n  template<typename From, typename To>\n  struct enable_if_convertible\n    : iterators::enable_if<\n          is_convertible<From, To>\n        , boost::detail::enable_type\n      >\n  {};\n      \n# endif\n  \n  //\n  // Default template argument handling for iterator_adaptor\n  //\n  namespace detail\n  {\n    // If T is use_default, return the result of invoking\n    // DefaultNullaryFn, otherwise return T.\n    template <class T, class DefaultNullaryFn>\n    struct ia_dflt_help\n      : mpl::eval_if<\n            is_same<T, use_default>\n          , DefaultNullaryFn\n          , mpl::identity<T>\n        >\n    {\n    };\n\n    // A metafunction which computes an iterator_adaptor's base class,\n    // a specialization of iterator_facade.\n    template <\n        class Derived\n      , class Base\n      , class Value\n      , class Traversal\n      , class Reference\n      , class Difference\n    >\n    struct iterator_adaptor_base\n    {\n        typedef iterator_facade<\n            Derived\n            \n# ifdef BOOST_ITERATOR_REF_CONSTNESS_KILLS_WRITABILITY\n          , typename boost::detail::ia_dflt_help<\n                Value\n              , mpl::eval_if<\n                    is_same<Reference,use_default>\n                  , iterator_value<Base>\n                  , remove_reference<Reference>\n                >\n            >::type\n# else\n          , typename boost::detail::ia_dflt_help<\n                Value, iterator_value<Base>\n            >::type\n# endif\n            \n          , typename boost::detail::ia_dflt_help<\n                Traversal\n              , iterator_traversal<Base>\n            >::type\n\n          , typename boost::detail::ia_dflt_help<\n                Reference\n              , mpl::eval_if<\n                    is_same<Value,use_default>\n                  , iterator_reference<Base>\n                  , add_reference<Value>\n                >\n            >::type\n\n          , typename boost::detail::ia_dflt_help<\n                Difference, iterator_difference<Base>\n            >::type\n        >\n        type;\n    };\n  \n    // workaround for aC++ CR JAGaf33512\n    template <class Tr1, class Tr2>\n    inline void iterator_adaptor_assert_traversal ()\n    {\n      BOOST_STATIC_ASSERT((is_convertible<Tr1, Tr2>::value));\n    }\n  }\n  \n  //\n  // Iterator Adaptor\n  //\n  // The parameter ordering changed slightly with respect to former\n  // versions of iterator_adaptor The idea is that when the user needs\n  // to fiddle with the reference type it is highly likely that the\n  // iterator category has to be adjusted as well.  Any of the\n  // following four template arguments may be ommitted or explicitly\n  // replaced by use_default.\n  //\n  //   Value - if supplied, the value_type of the resulting iterator, unless\n  //      const. If const, a conforming compiler strips constness for the\n  //      value_type. If not supplied, iterator_traits<Base>::value_type is used\n  //\n  //   Category - the traversal category of the resulting iterator. If not\n  //      supplied, iterator_traversal<Base>::type is used.\n  //\n  //   Reference - the reference type of the resulting iterator, and in\n  //      particular, the result type of operator*(). If not supplied but\n  //      Value is supplied, Value& is used. Otherwise\n  //      iterator_traits<Base>::reference is used.\n  //\n  //   Difference - the difference_type of the resulting iterator. If not\n  //      supplied, iterator_traits<Base>::difference_type is used.\n  //\n  template <\n      class Derived\n    , class Base\n    , class Value        = use_default\n    , class Traversal    = use_default\n    , class Reference    = use_default\n    , class Difference   = use_default\n  >\n  class iterator_adaptor\n    : public boost::detail::iterator_adaptor_base<\n        Derived, Base, Value, Traversal, Reference, Difference\n      >::type\n  {\n      friend class iterator_core_access;\n\n   protected:\n      typedef typename boost::detail::iterator_adaptor_base<\n          Derived, Base, Value, Traversal, Reference, Difference\n      >::type super_t;\n   public:\n      iterator_adaptor() {}\n\n      explicit iterator_adaptor(Base const &iter)\n          : m_iterator(iter)\n      {\n      }\n\n      typedef Base base_type;\n\n      Base const& base() const\n        { return m_iterator; }\n\n   protected:\n      // for convenience in derived classes\n      typedef iterator_adaptor<Derived,Base,Value,Traversal,Reference,Difference> iterator_adaptor_;\n      \n      //\n      // lvalue access to the Base object for Derived\n      //\n      Base const& base_reference() const\n        { return m_iterator; }\n\n      Base& base_reference()\n        { return m_iterator; }\n\n   private:\n      //\n      // Core iterator interface for iterator_facade.  This is private\n      // to prevent temptation for Derived classes to use it, which\n      // will often result in an error.  Derived classes should use\n      // base_reference(), above, to get direct access to m_iterator.\n      // \n      typename super_t::reference dereference() const\n        { return *m_iterator; }\n\n      template <\n      class OtherDerived, class OtherIterator, class V, class C, class R, class D\n      >   \n      bool equal(iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& x) const\n      {\n        // Maybe readd with same_distance\n        //           BOOST_STATIC_ASSERT(\n        //               (detail::same_category_and_difference<Derived,OtherDerived>::value)\n        //               );\n          return m_iterator == x.base();\n      }\n\n      typedef typename iterator_category_to_traversal<\n          typename super_t::iterator_category\n      >::type my_traversal;\n\n# define BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(cat) \\\n      boost::detail::iterator_adaptor_assert_traversal<my_traversal, cat>();\n\n      void advance(typename super_t::difference_type n)\n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)\n          m_iterator += n;\n      }\n  \n      void increment() { ++m_iterator; }\n\n      void decrement() \n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(bidirectional_traversal_tag)\n           --m_iterator;\n      }\n\n      template <\n          class OtherDerived, class OtherIterator, class V, class C, class R, class D\n      >   \n      typename super_t::difference_type distance_to(\n          iterator_adaptor<OtherDerived, OtherIterator, V, C, R, D> const& y) const\n      {\n          BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL(random_access_traversal_tag)\n          // Maybe readd with same_distance\n          //           BOOST_STATIC_ASSERT(\n          //               (detail::same_category_and_difference<Derived,OtherDerived>::value)\n          //               );\n          return y.base() - m_iterator;\n      }\n\n# undef BOOST_ITERATOR_ADAPTOR_ASSERT_TRAVERSAL\n      \n   private: // data members\n      Base m_iterator;\n  };\n\n} // namespace boost\n\n#include <boost/iterator/detail/config_undef.hpp>\n\n#endif // BOOST_ITERATOR_ADAPTOR_23022003THW_HPP\n","//\n//=======================================================================\n// Copyright 1997, 1998, 1999, 2000 University of Notre Dame.\n// Authors: Andrew Lumsdaine, Lie-Quan Lee, Jeremy G. Siek\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//=======================================================================\n\n#ifndef BOOST_GRAPH_DETAIL_EDGE_HPP\n#define BOOST_GRAPH_DETAIL_EDGE_HPP\n\n#if __GNUC__ < 3\n#include <iostream>\n#else\n#include <iosfwd>\n#endif\n\nnamespace boost {\n\n  namespace  detail {\n\n    template <typename Directed, typename Vertex>\n    struct edge_base\n    {\n      inline edge_base() {} \n      inline edge_base(Vertex s, Vertex d)\n        : m_source(s), m_target(d) { }\n      Vertex m_source;\n      Vertex m_target;\n    };\n\n    template <typename Directed, typename Vertex>\n    class edge_desc_impl  : public edge_base<Directed,Vertex> {\n      typedef edge_desc_impl                              self;\n      typedef edge_base<Directed,Vertex> Base;\n    public: \n      typedef void                              property_type;\n      \n      inline edge_desc_impl() : m_eproperty(0) {} \n      \n      inline edge_desc_impl(Vertex s, Vertex d, const property_type* eplug)\n        : Base(s,d), m_eproperty(const_cast<property_type*>(eplug)) { }\n      \n      property_type* get_property() { return m_eproperty; }\n      const property_type* get_property() const { return m_eproperty; }\n      \n      //  protected:\n      property_type* m_eproperty;\n    };\n\n    template <class D, class V>\n    inline bool\n    operator==(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return a.get_property() == b.get_property();\n    }\n    template <class D, class V>\n    inline bool\n    operator!=(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return ! (a.get_property() == b.get_property());\n    }\n\n    // Order edges according to the address of their property object\n    template <class D, class V>\n    inline bool\n    operator<(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return a.get_property() < b.get_property();\n    }\n    template <class D, class V>\n    inline bool\n    operator<=(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return a.get_property() <= b.get_property();\n    }\n    template <class D, class V>\n    inline bool\n    operator>(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return a.get_property() > b.get_property();\n    }\n    template <class D, class V>\n    inline bool\n    operator>=(const detail::edge_desc_impl<D,V>& a, \n               const detail::edge_desc_impl<D,V>& b)\n    {\n      return a.get_property() >= b.get_property();\n    }\n\n  } //namespace detail\n  \n} // namespace boost\n\nnamespace std {\n\n#if __GNUC__ < 3\n  template <class D, class V>\n  std::ostream& \n  operator<<(std::ostream& os, const boost::detail::edge_desc_impl<D,V>& e)\n  {\n    return os << \"(\" << e.m_source << \",\" << e.m_target << \")\";\n  }\n#else\n  template <class Char, class Traits, class D, class V>\n  std::basic_ostream<Char, Traits>& \n  operator<<(std::basic_ostream<Char, Traits>& os,\n             const boost::detail::edge_desc_impl<D,V>& e)\n  {\n    return os << \"(\" << e.m_source << \",\" << e.m_target << \")\";\n  }\n#endif\n\n}\n\n\n#endif // BOOST_GRAPH_DETAIL_DETAIL_EDGE_HPP\n","//=======================================================================\n// Copyright 1997, 1998, 1999, 2000 University of Notre Dame.\n// Copyright 2010 Thomas Claveirole\n// Authors: Andrew Lumsdaine, Lie-Quan Lee, Jeremy G. Siek, Thomas Claveirole\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//=======================================================================\n\n#ifndef BOOST_GRAPH_ADJACENCY_LIST_HPP\n#define BOOST_GRAPH_ADJACENCY_LIST_HPP\n\n\n#include <boost/config.hpp>\n\n#include <vector>\n#include <list>\n#include <set>\n\n#include <boost/unordered_set.hpp>\n\n#if !defined BOOST_NO_SLIST\n#  ifdef BOOST_SLIST_HEADER\n#    include BOOST_SLIST_HEADER\n#  else\n#    include <slist>\n#  endif\n#endif\n\n#include <boost/scoped_ptr.hpp>\n\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/graph_mutability_traits.hpp>\n#include <boost/graph/graph_selectors.hpp>\n#include <boost/property_map/property_map.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/and.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/mpl/bool.hpp>\n#include <boost/graph/detail/edge.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/detail/workaround.hpp>\n#include <boost/graph/properties.hpp>\n#include <boost/graph/named_graph.hpp>\n\nnamespace boost {\n\n  //===========================================================================\n  // Selectors for the VertexList and EdgeList template parameters of\n  // adjacency_list, and the container_gen traits class which is used\n  // to map the selectors to the container type used to implement the\n  // graph.\n\n#if !defined BOOST_NO_SLIST\n  struct slistS {};\n#endif\n\n  struct vecS  { };\n  struct listS { };\n  struct setS { };\n  struct mapS  { };\n  struct multisetS { };\n  struct multimapS { };\n  struct hash_setS { };\n  struct hash_mapS { };\n  struct hash_multisetS { };\n  struct hash_multimapS { };\n\n  template <class Selector, class ValueType>\n  struct container_gen { };\n\n  template <class ValueType>\n  struct container_gen<listS, ValueType> {\n    typedef std::list<ValueType> type;\n  };\n#if !defined BOOST_NO_SLIST\n  template <class ValueType>\n  struct container_gen<slistS, ValueType> {\n    typedef BOOST_STD_EXTENSION_NAMESPACE::slist<ValueType> type;\n  };\n#endif\n  template <class ValueType>\n  struct container_gen<vecS, ValueType> {\n    typedef std::vector<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<mapS, ValueType> {\n    typedef std::set<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<setS, ValueType> {\n    typedef std::set<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<multisetS, ValueType> {\n    typedef std::multiset<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<multimapS, ValueType> {\n    typedef std::multiset<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<hash_setS, ValueType> {\n    typedef boost::unordered_set<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<hash_mapS, ValueType> {\n    typedef boost::unordered_set<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<hash_multisetS, ValueType> {\n    typedef boost::unordered_multiset<ValueType> type;\n  };\n\n  template <class ValueType>\n  struct container_gen<hash_multimapS, ValueType> {\n    typedef boost::unordered_multiset<ValueType> type;\n  };\n\n  template <class StorageSelector>\n  struct parallel_edge_traits { };\n\n  template <>\n  struct parallel_edge_traits<vecS> {\n    typedef allow_parallel_edge_tag type; };\n\n  template <>\n  struct parallel_edge_traits<listS> {\n    typedef allow_parallel_edge_tag type; };\n\n#if !defined BOOST_NO_SLIST\n  template <>\n  struct parallel_edge_traits<slistS> {\n    typedef allow_parallel_edge_tag type; };\n#endif\n\n  template <>\n  struct parallel_edge_traits<setS> {\n    typedef disallow_parallel_edge_tag type; };\n\n  template <>\n  struct parallel_edge_traits<multisetS> {\n    typedef allow_parallel_edge_tag type; };\n\n  template <>\n  struct parallel_edge_traits<hash_setS> {\n    typedef disallow_parallel_edge_tag type;\n  };\n\n  // mapS is obsolete, replaced with setS\n  template <>\n  struct parallel_edge_traits<mapS> {\n    typedef disallow_parallel_edge_tag type; };\n\n  template <>\n  struct parallel_edge_traits<hash_mapS> {\n    typedef disallow_parallel_edge_tag type;\n  };\n\n  template <>\n  struct parallel_edge_traits<hash_multisetS> {\n    typedef allow_parallel_edge_tag type;\n  };\n\n  template <>\n  struct parallel_edge_traits<hash_multimapS> {\n    typedef allow_parallel_edge_tag type;\n  };\n\n  namespace detail {\n    template <class Directed> struct is_random_access {\n      enum { value = false};\n      typedef mpl::false_ type;\n    };\n    template <>\n    struct is_random_access<vecS> {\n      enum { value = true };\n      typedef mpl::true_ type;\n    };\n\n  } // namespace detail\n\n  template <typename Selector> struct is_distributed_selector: mpl::false_ {};\n\n\n  //===========================================================================\n  // The adjacency_list_traits class, which provides a way to access\n  // some of the associated types of an adjacency_list type without\n  // having to first create the adjacency_list type. This is useful\n  // when trying to create interior vertex or edge properties who's\n  // value type is a vertex or edge descriptor.\n\n  template <class OutEdgeListS = vecS,\n            class VertexListS = vecS,\n            class DirectedS = directedS,\n            class EdgeListS = listS>\n  struct adjacency_list_traits\n  {\n    typedef typename detail::is_random_access<VertexListS>::type\n      is_rand_access;\n    typedef typename DirectedS::is_bidir_t is_bidir;\n    typedef typename DirectedS::is_directed_t is_directed;\n\n    typedef typename mpl::if_<is_bidir,\n      bidirectional_tag,\n      typename mpl::if_<is_directed,\n        directed_tag, undirected_tag\n      >::type\n    >::type directed_category;\n\n    typedef typename parallel_edge_traits<OutEdgeListS>::type\n      edge_parallel_category;\n\n    typedef std::size_t vertices_size_type;\n    typedef void* vertex_ptr;\n    typedef typename mpl::if_<is_rand_access,\n      vertices_size_type, vertex_ptr>::type vertex_descriptor;\n    typedef detail::edge_desc_impl<directed_category, vertex_descriptor>\n      edge_descriptor;\n\n  private:\n    // Logic to figure out the edges_size_type\n    struct dummy {};\n    typedef typename container_gen<EdgeListS, dummy>::type EdgeContainer;\n    typedef typename DirectedS::is_bidir_t BidirectionalT;\n    typedef typename DirectedS::is_directed_t DirectedT;\n    typedef typename mpl::and_<DirectedT,\n      typename mpl::not_<BidirectionalT>::type >::type on_edge_storage;\n  public:\n    typedef typename mpl::if_<on_edge_storage,\n       std::size_t, typename EdgeContainer::size_type\n    >::type edges_size_type;\n\n  };\n\n} // namespace boost\n\n#include <boost/graph/detail/adjacency_list.hpp>\n\nnamespace boost {\n\n  //===========================================================================\n  // The adjacency_list class.\n  //\n\n  template <class OutEdgeListS = vecS, // a Sequence or an AssociativeContainer\n            class VertexListS = vecS, // a Sequence or a RandomAccessContainer\n            class DirectedS = directedS,\n            class VertexProperty = no_property,\n            class EdgeProperty = no_property,\n            class GraphProperty = no_property,\n            class EdgeListS = listS>\n  class adjacency_list\n    : public detail::adj_list_gen<\n      adjacency_list<OutEdgeListS,VertexListS,DirectedS,\n                     VertexProperty,EdgeProperty,GraphProperty,EdgeListS>,\n      VertexListS, OutEdgeListS, DirectedS,\n      VertexProperty, EdgeProperty,\n      GraphProperty, EdgeListS>::type,\n      // Support for named vertices\n      public graph::maybe_named_graph<\n        adjacency_list<OutEdgeListS,VertexListS,DirectedS,\n                       VertexProperty,EdgeProperty,GraphProperty,EdgeListS>,\n        typename adjacency_list_traits<OutEdgeListS, VertexListS, DirectedS,\n                                       EdgeListS>::vertex_descriptor,\n        VertexProperty>\n  {\n      public:\n    typedef GraphProperty graph_property_type;\n    typedef typename lookup_one_property<GraphProperty, graph_bundle_t>::type graph_bundled;\n\n    typedef VertexProperty vertex_property_type;\n    typedef typename lookup_one_property<VertexProperty, vertex_bundle_t>::type vertex_bundled;\n\n    typedef EdgeProperty edge_property_type;\n    typedef typename lookup_one_property<EdgeProperty, edge_bundle_t>::type edge_bundled;\n\n  private:\n    typedef adjacency_list self;\n    typedef typename detail::adj_list_gen<\n      self, VertexListS, OutEdgeListS, DirectedS,\n      vertex_property_type, edge_property_type, GraphProperty, EdgeListS\n    >::type Base;\n\n  public:\n    typedef typename Base::stored_vertex stored_vertex;\n    typedef typename Base::vertices_size_type vertices_size_type;\n    typedef typename Base::edges_size_type edges_size_type;\n    typedef typename Base::degree_size_type degree_size_type;\n    typedef typename Base::vertex_descriptor vertex_descriptor;\n    typedef typename Base::edge_descriptor edge_descriptor;\n    typedef OutEdgeListS out_edge_list_selector;\n    typedef VertexListS vertex_list_selector;\n    typedef DirectedS directed_selector;\n    typedef EdgeListS edge_list_selector;\n\n\n    adjacency_list(const GraphProperty& p = GraphProperty())\n      : m_property(new graph_property_type(p))\n    { }\n\n    adjacency_list(const adjacency_list& x)\n      : Base(x), m_property(new graph_property_type(*x.m_property))\n    { }\n\n    adjacency_list& operator=(const adjacency_list& x) {\n      // TBD: probably should give the strong guarantee\n      if (&x != this) {\n        Base::operator=(x);\n\n        // Copy/swap the ptr since we can't just assign it...\n        property_ptr p(new graph_property_type(*x.m_property));\n        m_property.swap(p);\n      }\n      return *this;\n    }\n\n    // Required by Mutable Graph\n    adjacency_list(vertices_size_type num_vertices,\n                          const GraphProperty& p = GraphProperty())\n      : Base(num_vertices), m_property(new graph_property_type(p))\n    { }\n\n#if !defined(BOOST_MSVC) || BOOST_MSVC >= 1300\n    // Required by Iterator Constructible Graph\n    template <class EdgeIterator>\n    adjacency_list(EdgeIterator first, EdgeIterator last,\n                          vertices_size_type n,\n                          edges_size_type = 0,\n                          const GraphProperty& p = GraphProperty())\n      : Base(n, first, last), m_property(new graph_property_type(p))\n    { }\n\n    template <class EdgeIterator, class EdgePropertyIterator>\n    adjacency_list(EdgeIterator first, EdgeIterator last,\n                          EdgePropertyIterator ep_iter,\n                          vertices_size_type n,\n                          edges_size_type = 0,\n                          const GraphProperty& p = GraphProperty())\n      : Base(n, first, last, ep_iter), m_property(new graph_property_type(p))\n    { }\n#endif\n\n    void swap(adjacency_list& x) {\n      // Is there a more efficient way to do this?\n      adjacency_list tmp(x);\n      x = *this;\n      *this = tmp;\n    }\n\n    void clear()\n    {\n      this->clearing_graph();\n      Base::clear();\n    }\n\n#ifndef BOOST_GRAPH_NO_BUNDLED_PROPERTIES\n    // Directly access a vertex or edge bundle\n    vertex_bundled& operator[](vertex_descriptor v)\n    { return get(vertex_bundle, *this)[v]; }\n\n    const vertex_bundled& operator[](vertex_descriptor v) const\n    { return get(vertex_bundle, *this)[v]; }\n\n    edge_bundled& operator[](edge_descriptor e)\n    { return get(edge_bundle, *this)[e]; }\n\n    const edge_bundled& operator[](edge_descriptor e) const\n    { return get(edge_bundle, *this)[e]; }\n\n    graph_bundled& operator[](graph_bundle_t)\n    { return get_property(*this); }\n\n    graph_bundled const& operator[](graph_bundle_t) const\n    { return get_property(*this); }\n#endif\n\n    //  protected:  (would be protected if friends were more portable)\n    typedef scoped_ptr<graph_property_type> property_ptr;\n    property_ptr  m_property;\n  };\n\n#define ADJLIST_PARAMS \\\n    typename OEL, typename VL, typename D, typename VP, typename EP, \\\n    typename GP, typename EL\n#define ADJLIST adjacency_list<OEL,VL,D,VP,EP,GP,EL>\n\n  template<ADJLIST_PARAMS, typename Tag, typename Value>\n  inline void set_property(ADJLIST& g, Tag tag, Value const& value) {\n    get_property_value(*g.m_property, tag) = value;\n  }\n\n  template<ADJLIST_PARAMS, typename Tag>\n  inline typename graph_property<ADJLIST, Tag>::type&\n  get_property(ADJLIST& g, Tag tag) {\n    return get_property_value(*g.m_property, tag);\n  }\n\n  template<ADJLIST_PARAMS, typename Tag>\n  inline typename graph_property<ADJLIST, Tag>::type const&\n  get_property(ADJLIST const& g, Tag tag) {\n    return get_property_value(*g.m_property, tag);\n  }\n\n  // dwa 09/25/00 - needed to be more explicit so reverse_graph would work.\n  template <class Directed, class Vertex,\n      class OutEdgeListS,\n      class VertexListS,\n      class DirectedS,\n      class VertexProperty,\n      class EdgeProperty,\n      class GraphProperty, class EdgeListS>\n  inline Vertex\n  source(const detail::edge_base<Directed,Vertex>& e,\n         const adjacency_list<OutEdgeListS, VertexListS, DirectedS,\n                 VertexProperty, EdgeProperty, GraphProperty, EdgeListS>&)\n  {\n    return e.m_source;\n  }\n\n  template <class Directed, class Vertex, class OutEdgeListS,\n      class VertexListS, class DirectedS, class VertexProperty,\n      class EdgeProperty, class GraphProperty, class EdgeListS>\n  inline Vertex\n  target(const detail::edge_base<Directed,Vertex>& e,\n         const adjacency_list<OutEdgeListS, VertexListS, DirectedS,\n              VertexProperty, EdgeProperty, GraphProperty, EdgeListS>&)\n  {\n    return e.m_target;\n  }\n\n// Mutability Traits\ntemplate <ADJLIST_PARAMS>\nstruct graph_mutability_traits<ADJLIST> {\n    typedef mutable_property_graph_tag category;\n};\n\n// Can't remove vertices from adjacency lists with VL==vecS\ntemplate <typename OEL, typename D, typename VP, typename EP, typename GP, typename EL>\nstruct graph_mutability_traits< adjacency_list<OEL,vecS,D,VP,EP,GP,EL> > {\n    typedef add_only_property_graph_tag category;\n};\n#undef ADJLIST_PARAMS\n#undef ADJLIST\n\n\n} // namespace boost\n\n\n#endif // BOOST_GRAPH_ADJACENCY_LIST_HPP\n","//  (C) Copyright Jeremy Siek 2004\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_PROPERTY_HPP\n#define BOOST_PROPERTY_HPP\n\n#include <boost/mpl/bool.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/has_xxx.hpp>\n#include <boost/utility/enable_if.hpp>\n#include <boost/type_traits.hpp>\n#include <boost/static_assert.hpp>\n\nnamespace boost {\n\n  struct no_property {};\n\n  template <class Tag, class T, class Base = no_property>\n  struct property {\n    typedef Base next_type;\n    typedef Tag tag_type;\n    typedef T value_type;\n    property(const T& v = T()) : m_value(v) { }\n    property(const T& v, const Base& b) : m_value(v), m_base(b) { }\n    // copy constructor and assignment operator will be generated by compiler\n\n    T m_value;\n    Base m_base;\n  };\n\n  // Kinds of properties\n  namespace graph_introspect_detail {\n    BOOST_MPL_HAS_XXX_TRAIT_DEF(kind)\n    template <typename T, bool Cond> struct get_kind {typedef void type;};\n    template <typename T> struct get_kind<T, true> {typedef typename T::kind type;};\n  }\n\n  // Having a default is to make this trait work for any type, not just valid\n  // properties, to work around VC++ <= 10 bugs related to SFINAE in\n  // compressed_sparse_row_graph's get functions and similar\n  template <class PropertyTag>\n  struct property_kind:\n    graph_introspect_detail::get_kind<PropertyTag, graph_introspect_detail::has_kind<PropertyTag>::value>\n  {};\n\n  // Some standard properties defined independently of Boost.Graph:\n  enum vertex_all_t {vertex_all};\n  enum edge_all_t {edge_all};\n  enum graph_all_t {graph_all};\n  enum vertex_bundle_t {vertex_bundle};\n  enum edge_bundle_t {edge_bundle};\n  enum graph_bundle_t {graph_bundle};\n\n  // Code to look up one property in a property list:\n  template <typename PList, typename PropName, typename Enable = void>\n  struct lookup_one_property_internal {BOOST_STATIC_CONSTANT(bool, found = false); typedef void type;};\n\n  // Special-case properties (vertex_all, edge_all, graph_all)\n#define BGL_ALL_PROP(tag) \\\n  template <typename T> \\\n  struct lookup_one_property_internal<T, tag> { \\\n    BOOST_STATIC_CONSTANT(bool, found = true); \\\n    typedef T type; \\\n    static T& lookup(T& x, tag) {return x;} \\\n    static const T& lookup(const T& x, tag) {return x;} \\\n  }; \\\n  template <typename Tag, typename T, typename Base> \\\n  struct lookup_one_property_internal<property<Tag, T, Base>, tag> { /* Avoid ambiguity */ \\\n    BOOST_STATIC_CONSTANT(bool, found = true); \\\n    typedef property<Tag, T, Base> type; \\\n    static type& lookup(type& x, tag) {return x;} \\\n    static const type& lookup(const type& x, tag) {return x;} \\\n  };\n\n  BGL_ALL_PROP(vertex_all_t)\n  BGL_ALL_PROP(edge_all_t)\n  BGL_ALL_PROP(graph_all_t)\n#undef BGL_ALL_PROP\n\n  // *_bundled; these need to be macros rather than inheritance to resolve ambiguities\n  #define BGL_DO_ONE_BUNDLE_TYPE(kind) \\\n  template <typename T> \\\n  struct lookup_one_property_internal<T, BOOST_JOIN(kind, _bundle_t)> { \\\n    BOOST_STATIC_CONSTANT(bool, found = true); \\\n    typedef T type; \\\n    static T& lookup(T& x, BOOST_JOIN(kind, _bundle_t)) {return x;} \\\n    static const T& lookup(const T& x, BOOST_JOIN(kind, _bundle_t)) {return x;} \\\n  }; \\\n \\\n  template <typename Tag, typename T, typename Base> \\\n  struct lookup_one_property_internal<property<Tag, T, Base>, BOOST_JOIN(kind, _bundle_t)>: lookup_one_property_internal<Base, BOOST_JOIN(kind, _bundle_t)> { \\\n    private: \\\n    typedef lookup_one_property_internal<Base, BOOST_JOIN(kind, _bundle_t)> base_type; \\\n    public: \\\n    template <typename BundleTag> \\\n    static typename lazy_enable_if_c<(base_type::found && (is_same<BundleTag, BOOST_JOIN(kind, _bundle_t)>::value)), \\\n                                     add_reference<typename base_type::type> >::type \\\n    lookup(property<Tag, T, Base>& p, BundleTag) {return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)());} \\\n    template <typename BundleTag> \\\n    static typename lazy_enable_if_c<(base_type::found && (is_same<BundleTag, BOOST_JOIN(kind, _bundle_t)>::value)), \\\n                                     add_reference<const typename base_type::type> >::type \\\n    lookup(const property<Tag, T, Base>& p, BundleTag) {return base_type::lookup(p.m_base, BOOST_JOIN(kind, _bundle_t)());} \\\n  }; \\\n\n  BGL_DO_ONE_BUNDLE_TYPE(vertex)\n  BGL_DO_ONE_BUNDLE_TYPE(edge)\n  BGL_DO_ONE_BUNDLE_TYPE(graph)\n#undef BGL_DO_ONE_BUNDLE_TYPE\n\n  // Normal old-style properties; second case also handles chaining of bundled property accesses\n  template <typename Tag, typename T, typename Base>\n  struct lookup_one_property_internal<boost::property<Tag, T, Base>, Tag> {\n    BOOST_STATIC_CONSTANT(bool, found = true);\n    typedef property<Tag, T, Base> prop;\n    typedef T type;\n    template <typename U>\n    static typename enable_if<is_same<prop, U>, T&>::type\n    lookup(U& prop, const Tag&) {return prop.m_value;}\n    template <typename U>\n    static typename enable_if<is_same<prop, U>, const T&>::type\n    lookup(const U& prop, const Tag&) {return prop.m_value;}\n  };\n\n  template <typename Tag, typename T, typename Base, typename PropName>\n  struct lookup_one_property_internal<boost::property<Tag, T, Base>, PropName>: lookup_one_property_internal<Base, PropName> {\n    private:\n    typedef lookup_one_property_internal<Base, PropName> base_type;\n    public:\n    template <typename PL>\n    static typename lazy_enable_if<is_same<PL, boost::property<Tag, T, Base> >,\n                                   add_reference<typename base_type::type> >::type\n    lookup(PL& prop, const PropName& tag) {\n      return base_type::lookup(prop.m_base, tag);\n    }\n    template <typename PL>\n    static typename lazy_enable_if<is_same<PL, boost::property<Tag, T, Base> >,\n                                   add_reference<const typename base_type::type> >::type\n    lookup(const PL& prop, const PropName& tag) {\n      return base_type::lookup(prop.m_base, tag);\n    }\n  };\n\n  // Pointer-to-member access to bundled properties\n#ifndef BOOST_GRAPH_NO_BUNDLED_PROPERTIES\n  template <typename T, typename TMaybeBase, typename R>\n  struct lookup_one_property_internal<T, R TMaybeBase::*, typename enable_if<is_base_of<TMaybeBase, T> >::type> {\n    BOOST_STATIC_CONSTANT(bool, found = true);\n    typedef R type;\n    static R& lookup(T& x, R TMaybeBase::*ptr) {return x.*ptr;}\n    static const R& lookup(const T& x, R TMaybeBase::*ptr) {return x.*ptr;}\n  };\n#endif\n\n  // Version of above handling const property lists properly\n  template <typename T, typename Tag>\n  struct lookup_one_property: lookup_one_property_internal<T, Tag> {};\n\n  template <typename T, typename Tag>\n  struct lookup_one_property<const T, Tag> {\n    BOOST_STATIC_CONSTANT(bool, found = (lookup_one_property_internal<T, Tag>::found));\n    typedef const typename lookup_one_property_internal<T, Tag>::type type;\n    template <typename U>\n    static typename lazy_enable_if<is_same<T, U>,\n                                   add_reference<const typename lookup_one_property_internal<T, Tag>::type> >::type\n    lookup(const U& p, Tag tag) {\n      return lookup_one_property_internal<T, Tag>::lookup(p, tag);\n    }\n  };\n\n  // The BGL properties specialize property_kind and\n  // property_num, and use enum's for the Property type (see\n  // graph/properties.hpp), but the user may want to use a class\n  // instead with a nested kind type and num.  Also, we may want to\n  // switch BGL back to using class types for properties at some point.\n\n  template <class P>\n  struct has_property : boost::mpl::true_ {};\n  template <>\n  struct has_property<no_property> : boost::mpl::false_ {};\n\n} // namespace boost\n\n#include <boost/pending/detail/property.hpp>\n\nnamespace boost {\n\n  template <class PropertyList, class Tag>\n  struct property_value: lookup_one_property<PropertyList, Tag> {};\n\n  template <class PropertyList, class Tag>\n  inline typename lookup_one_property<PropertyList, Tag>::type&\n  get_property_value(PropertyList& p, Tag tag) {\n    return lookup_one_property<PropertyList, Tag>::lookup(p, tag);\n  }\n\n  template <class PropertyList, class Tag>\n  inline const typename lookup_one_property<PropertyList, Tag>::type&\n  get_property_value(const PropertyList& p, Tag tag) {\n    return lookup_one_property<PropertyList, Tag>::lookup(p, tag);\n  }\n\n namespace detail {\n\n     /** This trait returns true if T is no_property. */\n    template <typename T>\n    struct is_no_property\n        : mpl::bool_<is_same<T, no_property>::value>\n    { };\n\n    template <typename PList, typename Tag>\n    class lookup_one_property_f;\n\n    template <typename PList, typename Tag, typename F> struct lookup_one_property_f_result;\n\n    template <typename PList, typename Tag>\n    struct lookup_one_property_f_result<PList, Tag, const lookup_one_property_f<PList, Tag>(PList)> {\n      typedef typename lookup_one_property<PList, Tag>::type type;\n    };\n\n    template <typename PList, typename Tag>\n    struct lookup_one_property_f_result<PList, Tag, const lookup_one_property_f<PList, Tag>(PList&)> {\n      typedef typename lookup_one_property<PList, Tag>::type& type;\n    };\n\n    template <typename PList, typename Tag>\n    struct lookup_one_property_f_result<PList, Tag, const lookup_one_property_f<PList, Tag>(const PList&)> {\n      typedef const typename lookup_one_property<PList, Tag>::type& type;\n    };\n\n    template <typename PList, typename Tag>\n    class lookup_one_property_f {\n      Tag tag;\n      public:\n      lookup_one_property_f(Tag tag): tag(tag) {}\n      template <typename F> struct result: lookup_one_property_f_result<PList, Tag, F> {};\n\n      typename lookup_one_property_f_result<PList, Tag, const lookup_one_property_f(PList&)>::type\n      operator()(PList& pl) const {\n        return lookup_one_property<PList, Tag>::lookup(pl, tag);\n      }\n    };\n\n} // namespace detail\n\nnamespace detail {\n  // Stuff for directed_graph and undirected_graph to skip over their first\n  // vertex_index and edge_index properties when providing vertex_all and\n  // edge_all; make sure you know the exact structure of your properties if you\n  // use there.\n  struct remove_first_property {\n    template <typename F>\n    struct result {\n      typedef typename boost::function_traits<F>::arg1_type a1;\n      typedef typename boost::remove_reference<a1>::type non_ref;\n      typedef typename non_ref::next_type nx;\n      typedef typename boost::mpl::if_<boost::is_const<non_ref>, boost::add_const<nx>, nx>::type with_const;\n      typedef typename boost::add_reference<with_const>::type type;\n    };\n    template <typename Prop>\n    typename Prop::next_type& operator()(Prop& p) const {return p.m_base;}\n    template <typename Prop>\n    const typename Prop::next_type& operator()(const Prop& p) const {return p.m_base;}\n  };\n}\n\n} // namesapce boost\n\n#endif /* BOOST_PROPERTY_HPP */\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_VAR_H_\n#define PPAPI_CPP_VAR_H_\n\n#include <string>\n#include <vector>\n\n#include \"ppapi/c/pp_var.h\"\n#include \"ppapi/cpp/pass_ref.h\"\n#include \"ppapi/cpp/resource.h\"\n\n/// @file\n/// This file defines the API for handling the passing of data types between\n/// your module and the page.\nnamespace pp {\n\n/// A generic type used for passing data types between the module and the page.\nclass Var {\n public:\n  /// Special value passed to constructor to make <code>NULL</code>.\n  struct Null {};\n\n  /// Default constructor. Creates a <code>Var</code> of type\n  /// <code>Undefined</code>.\n  Var();\n\n  /// A constructor used to create a <code>Var</code> of type <code>Null</code>.\n  Var(Null);\n\n  /// A constructor used to create a <code>Var</code> of type <code>Bool</code>.\n  ///\n  /// @param[in] b A boolean value.\n  Var(bool b);\n\n  /// A constructor used to create a 32 bit integer <code>Var</code>.\n  ///\n  /// @param[in] i A 32 bit integer value.\n  Var(int32_t i);\n\n  /// A constructor used to create a double value <code>Var</code>.\n  ///\n  /// @param[in] d A double value.\n  Var(double d);\n\n  /// A constructor used to create a UTF-8 character <code>Var</code>.\n  Var(const char* utf8_str);  // Must be encoded in UTF-8.\n\n  /// A constructor used to create a UTF-8 character <code>Var</code>.\n  Var(const std::string& utf8_str);  // Must be encoded in UTF-8.\n\n  /// A constructor used to create a resource <code>Var</code>.\n  explicit Var(const pp::Resource& resource);\n\n  /// A constructor used when you have received a <code>Var</code> as a return\n  /// value that has had its reference count incremented for you.\n  ///\n  /// You will not normally need to use this constructor because\n  /// the reference count will not normally be incremented for you.\n  Var(PassRef, const PP_Var& var) {\n    var_ = var;\n    is_managed_ = true;\n  }\n\n  /// A constructor that increments the reference count.\n  explicit Var(const PP_Var& var);\n\n  struct DontManage {};\n\n  /// This constructor is used when we've given a <code>PP_Var</code> as an\n  /// input argument from somewhere and that reference is managing the\n  /// reference count for us. The object will not have its reference count\n  /// increased or decreased by this class instance.\n  ///\n  /// @param[in] var A <code>Var</code>.\n  Var(DontManage, const PP_Var& var) {\n    var_ = var;\n    is_managed_ = false;\n  }\n\n  /// A constructor for copying a <code>Var</code>.\n  Var(const Var& other);\n\n  /// Destructor.\n  virtual ~Var();\n\n  /// This function assigns one <code>Var</code> to another <code>Var</code>.\n  ///\n  /// @param[in] other The <code>Var</code> to be assigned.\n  ///\n  /// @return A resulting <code>Var</code>.\n  virtual Var& operator=(const Var& other);\n\n  /// This function compares object identity (rather than value identity) for\n  /// objects, dictionaries, and arrays\n  ///\n  /// @param[in] other The <code>Var</code> to be compared to this Var.\n  ///\n  /// @return true if the <code>other</code> <code>Var</code> is the same as\n  /// this <code>Var</code>, otherwise false.\n  bool operator==(const Var& other) const;\n\n  /// This function determines if this <code>Var</code> is an undefined value.\n  ///\n  /// @return true if this <code>Var</code> is undefined, otherwise false.\n  bool is_undefined() const { return var_.type == PP_VARTYPE_UNDEFINED; }\n\n  /// This function determines if this <code>Var</code> is a null value.\n  ///\n  /// @return true if this <code>Var</code> is null, otherwise false.\n  bool is_null() const { return var_.type == PP_VARTYPE_NULL; }\n\n  /// This function determines if this <code>Var</code> is a bool value.\n  ///\n  /// @return true if this <code>Var</code> is a bool, otherwise false.\n  bool is_bool() const { return var_.type == PP_VARTYPE_BOOL; }\n\n  /// This function determines if this <code>Var</code> is a string value.\n  ///\n  /// @return true if this <code>Var</code> is a string, otherwise false.\n  bool is_string() const { return var_.type == PP_VARTYPE_STRING; }\n\n  /// This function determines if this <code>Var</code> is an object.\n  ///\n  /// @return true if this <code>Var</code> is an object, otherwise false.\n  bool is_object() const { return var_.type == PP_VARTYPE_OBJECT; }\n\n  /// This function determines if this <code>Var</code> is an array.\n  ///\n  /// @return true if this <code>Var</code> is an array, otherwise false.\n  bool is_array() const { return var_.type == PP_VARTYPE_ARRAY; }\n\n  /// This function determines if this <code>Var</code> is a dictionary.\n  ///\n  /// @return true if this <code>Var</code> is a dictionary, otherwise false.\n  bool is_dictionary() const { return var_.type == PP_VARTYPE_DICTIONARY; }\n\n  /// This function determines if this <code>Var</code> is a resource.\n  ///\n  /// @return true if this <code>Var</code> is a resource, otherwise false.\n  bool is_resource() const { return var_.type == PP_VARTYPE_RESOURCE; }\n\n  /// This function determines if this <code>Var</code> is an integer value.\n  /// The <code>is_int</code> function returns the internal representation.\n  /// The JavaScript runtime may convert between the two as needed, so the\n  /// distinction may not be relevant in all cases (int is really an\n  /// optimization inside the runtime). So most of the time, you will want\n  /// to check is_number().\n  ///\n  /// @return true if this <code>Var</code> is an integer, otherwise false.\n  bool is_int() const { return var_.type == PP_VARTYPE_INT32; }\n\n  /// This function determines if this <code>Var</code> is a double value.\n  /// The <code>is_double</code> function returns the internal representation.\n  /// The JavaScript runtime may convert between the two as needed, so the\n  /// distinction may not be relevant in all cases (int is really an\n  /// optimization inside the runtime). So most of the time, you will want to\n  /// check is_number().\n  ///\n  /// @return true if this <code>Var</code> is a double, otherwise false.\n  bool is_double() const { return var_.type == PP_VARTYPE_DOUBLE; }\n\n  /// This function determines if this <code>Var</code> is a number.\n  ///\n  /// @return true if this <code>Var</code> is an int32 or double number,\n  /// otherwise false.\n  bool is_number() const {\n    return var_.type == PP_VARTYPE_INT32 ||\n           var_.type == PP_VARTYPE_DOUBLE;\n  }\n\n  /// This function determines if this <code>Var</code> is an ArrayBuffer.\n  bool is_array_buffer() const { return var_.type == PP_VARTYPE_ARRAY_BUFFER; }\n\n  /// AsBool() converts this <code>Var</code> to a bool. Assumes the\n  /// internal representation is_bool(). If it's not, it will assert in debug\n  /// mode, and return false.\n  ///\n  /// @return A bool version of this <code>Var</code>.\n  bool AsBool() const;\n\n  /// AsInt() converts this <code>Var</code> to an int32_t. This function\n  /// is required because JavaScript doesn't have a concept of ints and doubles,\n  /// only numbers. The distinction between the two is an optimization inside\n  /// the compiler. Since converting from a double to an int may be lossy, if\n  /// you care about the distinction, either always work in doubles, or check\n  /// !is_double() before calling AsInt().\n  ///\n  /// These functions will assert in debug mode and return 0 if the internal\n  /// representation is not is_number().\n  ///\n  /// @return An int32_t version of this <code>Var</code>.\n  int32_t AsInt() const;\n\n  /// AsDouble() converts this <code>Var</code> to a double. This function is\n  /// necessary because JavaScript doesn't have a concept of ints and doubles,\n  /// only numbers. The distinction between the two is an optimization inside\n  /// the compiler. Since converting from a double to an int may be lossy, if\n  /// you care about the distinction, either always work in doubles, or check\n  /// !is_double() before calling AsInt().\n  ///\n  /// These functions will assert in debug mode and return 0 if the internal\n  /// representation is not is_number().\n  ///\n  /// @return An double version of this <code>Var</code>.\n  double AsDouble() const;\n\n  /// AsString() converts this <code>Var</code> to a string. If this object is\n  /// not a string, it will assert in debug mode, and return an empty string.\n  ///\n  /// @return A string version of this <code>Var</code>.\n  std::string AsString() const;\n\n  /// Gets the resource contained in the var. If this object is not a resource,\n  /// it will assert in debug mode, and return a null resource.\n  ///\n  /// @return The <code>pp::Resource</code> that is contained in the var.\n  pp::Resource AsResource() const;\n\n  /// This function returns the internal <code>PP_Var</code>\n  /// managed by this <code>Var</code> object.\n  ///\n  /// @return A const reference to a <code>PP_Var</code>.\n  const PP_Var& pp_var() const {\n    return var_;\n  }\n\n  /// Detach() detaches from the internal <code>PP_Var</code> of this\n  /// object, keeping the reference count the same. This is used when returning\n  /// a <code>PP_Var</code> from an API function where the caller expects the\n  /// return value to have the reference count incremented for it.\n  ///\n  /// @return A detached version of this object without affecting the reference\n  /// count.\n  PP_Var Detach() {\n    PP_Var ret = var_;\n    var_ = PP_MakeUndefined();\n    is_managed_ = true;\n    return ret;\n  }\n\n  /// DebugString() returns a short description \"Var<X>\" that can be used for\n  /// logging, where \"X\" is the underlying scalar or \"UNDEFINED\" or \"OBJ\" as\n  /// it does not call into the browser to get the object description.\n  ///\n  /// @return A string displaying the value of this <code>Var</code>. This\n  /// function is used for debugging.\n  std::string DebugString() const;\n\n  /// This class is used when calling the raw C PPAPI when using the C++\n  /// <code>Var</code> as a possible NULL exception. This class will handle\n  /// getting the address of the internal value out if it's non-NULL and\n  /// fixing up the reference count.\n  ///\n  /// <strong>Warning:</strong> this will only work for things with exception\n  /// semantics, i.e. that the value will not be changed if it's a\n  /// non-undefined exception. Otherwise, this class will mess up the\n  /// refcounting.\n  ///\n  /// This is a bit subtle:\n  /// - If NULL is passed, we return NULL from get() and do nothing.\n  ///\n  /// - If a undefined value is passed, we return the address of a undefined\n  ///   var from get and have the output value take ownership of that var.\n  ///\n  /// - If a non-undefined value is passed, we return the address of that var\n  ///   from get, and nothing else should change.\n  ///\n  /// Example:\n  ///   void FooBar(a, b, Var* exception = NULL) {\n  ///     foo_interface->Bar(a, b, Var::OutException(exception).get());\n  ///   }\n  class OutException {\n   public:\n    /// A constructor.\n    OutException(Var* v)\n        : output_(v),\n          originally_had_exception_(v && !v->is_undefined()) {\n      if (output_) {\n        temp_ = output_->var_;\n      } else {\n        temp_.padding = 0;\n        temp_.type = PP_VARTYPE_UNDEFINED;\n      }\n    }\n\n    /// Destructor.\n    ~OutException() {\n      if (output_ && !originally_had_exception_)\n        *output_ = Var(PASS_REF, temp_);\n    }\n\n    PP_Var* get() {\n      if (output_)\n        return &temp_;\n      return NULL;\n    }\n\n   private:\n    Var* output_;\n    bool originally_had_exception_;\n    PP_Var temp_;\n  };\n\n protected:\n  PP_Var var_;\n\n  // |is_managed_| indicates if the instance manages |var_|.\n  // You need to check if |var_| is refcounted to call Release().\n  bool is_managed_;\n\n private:\n  // Prevent an arbitrary pointer argument from being implicitly converted to\n  // a bool at Var construction. If somebody makes such a mistake, (s)he will\n  // get a compilation error.\n  Var(void* non_scriptable_object_pointer);\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_VAR_H_\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <string>\n#include <iostream>\n\n#include \"graph.hpp\"\n#include \"site.hpp\"\n\nnamespace ovd\n{\n\n/// \\brief Line- or arc-vertex of an offset curve.\n///\n/// \\todo this duplicates the idea of the Ofs class. Remove this or Ofs!\nstruct OffsetVertex {\n    Point p;  ///< position (start)\n    double r; ///< arc radius (line-vertex is indicated by radius of -1)\n    Point c;  ///< arc center\n    bool cw;  ///< clockwise (or not)\n    HEFace f; ///< corresponding face in the vd-graph\n    /// ctor\n    OffsetVertex(Point pi, double ri, Point ci, bool cwi, HEFace fi): p(pi), r(ri), c(ci), cw(cwi), f(fi) {}\n    /// ctor\n    OffsetVertex(Point pi): p(pi), r(-1.), cw(false), f(0) {}\n};\n\n/// a single offset loop\nstruct OffsetLoop {\n    std::list<OffsetVertex> vertices;   ///< list of offsetvertices in this loop\n    double offset_distance;             ///< offset distance for this loop\n    /// add an offsetvertex to this loop\n    void push_back(OffsetVertex v) { vertices.push_back(v); }\n};\n\n/// multiple loops. the output of the algorithm\ntypedef std::vector<OffsetLoop> OffsetLoops;\n\n/// \\brief From a voronoi-diagram, generate offsets.\n///\n/// an offset is allways a closed loop.\n/// the loop consists of offset-elements from each face that the loop visits.\n/// each face is associated with a Site, and the offset element from\n/// - a point-site is a circular arc\n/// - a line-site is a line\n/// - an arc is a circular arc\n///\n/// This class produces offsets at the given offset-distance on the entire\n/// voronoi-diagram. To produce offsets only inside or outside a given geometry,\n/// use a filter first. The filter sets the valid-property of edges, so that offsets\n/// are not produced on faces with one or more invalid edge.\nclass Offset {\npublic:\n    /// \\param gi vd-graph\n    Offset(HEGraph& gi): g(gi) {\n        face_done.clear();\n        face_done.assign( g.num_faces(), 1 );\n    }\n    /// print stats\n    void print();\n    /// create offsets at offset distance \\a t\n    OffsetLoops offset(double t);\nprotected:\n    bool find_start_face(HEFace& start);\n    void offset_loop_walk(HEFace start, double t);\n    OffsetVertex offset_element_from_face(HEFace current_face, HEEdge current_edge, HEEdge next_edge, double t);\n    bool edge_mode(HEEdge e, double t);\n    bool find_cw(Point start, Point center, Point end);\n    HEEdge find_next_offset_edge(HEEdge e, double t, bool mode);\n    void set_flags(double t);\n    bool t_bracket(double a, double b, double t);\n    void print_status();\n    \n    OffsetLoops offset_list; ///< list of output offsets\nprivate:\n    Offset(); // don't use.\n    HEGraph& g; ///< vd-graph\n    /// hold a 0/1 flag for each face, indicating if an offset for this face has been produced or not.\n    std::vector<unsigned char> face_done;\n};\n\n\n} // end ovd namespace\n// end file offset.hpp\n","// -*- C++ -*-\n//===--------------------------- sstream ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SSTREAM\n#define _LIBCPP_SSTREAM\n\n/*\n    sstream synopsis\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringbuf\n    : public basic_streambuf<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode which = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const basic_string<char_type, traits_type, allocator_type>& str,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    basic_stringbuf(basic_stringbuf&& rhs);\n\n    // 27.8.1.2 Assign and swap:\n    basic_stringbuf& operator=(basic_stringbuf&& rhs);\n    void swap(basic_stringbuf& rhs);\n\n    // 27.8.1.3 Get and set:\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n    virtual int_type overflow (int_type c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type*, streamsize);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringbuf<charT, traits, Allocator>& x,\n            basic_stringbuf<charT, traits, Allocator>& y);\n\ntypedef basic_stringbuf<char>    stringbuf;\ntypedef basic_stringbuf<wchar_t> wstringbuf;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_istringstream\n    : public basic_istream<charT, traits>\n{\npublic:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode which = ios_base::in);\n    explicit basic_istringstream(const basic_string<char_type, traits_type,allocator_type>& str,\n                                 ios_base::openmode which = ios_base::in);\n    basic_istringstream(basic_istringstream&& rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& rhs);\n    void swap(basic_istringstream& rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_istringstream<charT, traits, Allocator>& x,\n            basic_istringstream<charT, traits, Allocator>& y);\n\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_istringstream<wchar_t> wistringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_ostringstream\n    : public basic_ostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // 27.8.3.1 Constructors/destructor:\n    explicit basic_ostringstream(ios_base::openmode which = ios_base::out);\n    explicit basic_ostringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                 ios_base::openmode which = ios_base::out);\n    basic_ostringstream(basic_ostringstream&& rhs);\n\n    // 27.8.3.2 Assign/swap:\n    basic_ostringstream& operator=(basic_ostringstream&& rhs);\n    void swap(basic_ostringstream& rhs);\n\n    // 27.8.3.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& s);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_ostringstream<charT, traits, Allocator>& x,\n            basic_ostringstream<charT, traits, Allocator>& y);\n\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_stringstream\n    : public basic_iostream<charT, traits>\n{\npublic:\n    // types:\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef Allocator                      allocator_type;\n\n    // constructors/destructor\n    explicit basic_stringstream(ios_base::openmode which = ios_base::out|ios_base::in);\n    explicit basic_stringstream(const basic_string<char_type, traits_type, allocator_type>& str,\n                                ios_base::openmode which = ios_base::out|ios_base::in);\n    basic_stringstream(basic_stringstream&& rhs);\n\n    // 27.8.5.1 Assign/swap:\n    basic_stringstream& operator=(basic_stringstream&& rhs);\n    void swap(basic_stringstream& rhs);\n\n    // Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    basic_string<char_type, traits_type, allocator_type> str() const;\n    void str(const basic_string<char_type, traits_type, allocator_type>& str);\n};\n\ntemplate <class charT, class traits, class Allocator>\n  void swap(basic_stringstream<charT, traits, Allocator>& x,\n            basic_stringstream<charT, traits, Allocator>& y);\n\ntypedef basic_stringstream<char>    stringstream;\ntypedef basic_stringstream<wchar_t> wstringstream;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ostream>\n#include <istream>\n#include <string>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// basic_stringbuf\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringbuf\n    : public basic_streambuf<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n\n    string_type __str_;\n    mutable char_type* __hm_;\n    ios_base::openmode __mode_;\n\npublic:\n    // 27.8.1.1 Constructors:\n    explicit basic_stringbuf(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf(basic_stringbuf&& __rhs);\n#endif\n\n    // 27.8.1.2 Assign and swap:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringbuf& operator=(basic_stringbuf&& __rhs);\n#endif\n    void swap(basic_stringbuf& __rhs);\n\n    // 27.8.1.3 Get and set:\n    string_type str() const;\n    void str(const string_type& __s);\n\nprotected:\n    // 27.8.1.4 Overridden virtual functions:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(string_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(const string_type& __s,\n                             ios_base::openmode __wch)\n    : __hm_(0),\n      __mode_(__wch)\n{\n    str(__s);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::basic_stringbuf(basic_stringbuf&& __rhs)\n    : __mode_(__rhs.__mode_)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>&\nbasic_stringbuf<_CharT, _Traits, _Allocator>::operator=(basic_stringbuf&& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __binp = -1;\n    ptrdiff_t __ninp = -1;\n    ptrdiff_t __einp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __binp = __rhs.eback() - __p;\n        __ninp = __rhs.gptr() - __p;\n        __einp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __bout = -1;\n    ptrdiff_t __nout = -1;\n    ptrdiff_t __eout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __bout = __rhs.pbase() - __p;\n        __nout = __rhs.pptr() - __p;\n        __eout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __hm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __str_ = _VSTD::move(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__binp != -1)\n        this->setg(__p + __binp, __p + __ninp, __p + __einp);\n    if (__bout != -1)\n    {\n        this->setp(__p + __bout, __p + __eout);\n        this->pbump(__nout);\n    }\n    __hm_ = __hm == -1 ? nullptr : __p + __hm;\n    __mode_ = __rhs.__mode_;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    __rhs.setg(__p, __p, __p);\n    __rhs.setp(__p, __p);\n    __rhs.__hm_ = __p;\n    this->pubimbue(__rhs.getloc());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::swap(basic_stringbuf& __rhs)\n{\n    char_type* __p = const_cast<char_type*>(__rhs.__str_.data());\n    ptrdiff_t __rbinp = -1;\n    ptrdiff_t __rninp = -1;\n    ptrdiff_t __reinp = -1;\n    if (__rhs.eback() != nullptr)\n    {\n        __rbinp = __rhs.eback() - __p;\n        __rninp = __rhs.gptr() - __p;\n        __reinp = __rhs.egptr() - __p;\n    }\n    ptrdiff_t __rbout = -1;\n    ptrdiff_t __rnout = -1;\n    ptrdiff_t __reout = -1;\n    if (__rhs.pbase() != nullptr)\n    {\n        __rbout = __rhs.pbase() - __p;\n        __rnout = __rhs.pptr() - __p;\n        __reout = __rhs.epptr() - __p;\n    }\n    ptrdiff_t __rhm = __rhs.__hm_ == nullptr ? -1 : __rhs.__hm_ - __p;\n    __p = const_cast<char_type*>(__str_.data());\n    ptrdiff_t __lbinp = -1;\n    ptrdiff_t __lninp = -1;\n    ptrdiff_t __leinp = -1;\n    if (this->eback() != nullptr)\n    {\n        __lbinp = this->eback() - __p;\n        __lninp = this->gptr() - __p;\n        __leinp = this->egptr() - __p;\n    }\n    ptrdiff_t __lbout = -1;\n    ptrdiff_t __lnout = -1;\n    ptrdiff_t __leout = -1;\n    if (this->pbase() != nullptr)\n    {\n        __lbout = this->pbase() - __p;\n        __lnout = this->pptr() - __p;\n        __leout = this->epptr() - __p;\n    }\n    ptrdiff_t __lhm = __hm_ == nullptr ? -1 : __hm_ - __p;\n    _VSTD::swap(__mode_, __rhs.__mode_);\n    __str_.swap(__rhs.__str_);\n    __p = const_cast<char_type*>(__str_.data());\n    if (__rbinp != -1)\n        this->setg(__p + __rbinp, __p + __rninp, __p + __reinp);\n    else\n        this->setg(nullptr, nullptr, nullptr);\n    if (__rbout != -1)\n    {\n        this->setp(__p + __rbout, __p + __reout);\n        this->pbump(__rnout);\n    }\n    else\n        this->setp(nullptr, nullptr);\n    __hm_ = __rhm == -1 ? nullptr : __p + __rhm;\n    __p = const_cast<char_type*>(__rhs.__str_.data());\n    if (__lbinp != -1)\n        __rhs.setg(__p + __lbinp, __p + __lninp, __p + __leinp);\n    else\n        __rhs.setg(nullptr, nullptr, nullptr);\n    if (__lbout != -1)\n    {\n        __rhs.setp(__p + __lbout, __p + __leout);\n        __rhs.pbump(__lnout);\n    }\n    else\n        __rhs.setp(nullptr, nullptr);\n    __rhs.__hm_ = __lhm == -1 ? nullptr : __p + __lhm;\n    locale __tl = __rhs.getloc();\n    __rhs.pubimbue(this->getloc());\n    this->pubimbue(__tl);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringbuf<_CharT, _Traits, _Allocator>& __x,\n     basic_stringbuf<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str() const\n{\n    if (__mode_ & ios_base::out)\n    {\n        if (__hm_ < this->pptr())\n            __hm_ = this->pptr();\n        return string_type(this->pbase(), __hm_, __str_.get_allocator());\n    }\n    else if (__mode_ & ios_base::in)\n        return string_type(this->eback(), this->egptr(), __str_.get_allocator());\n    return string_type(__str_.get_allocator());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_stringbuf<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __str_ = __s;\n    __hm_ = 0;\n    if (__mode_ & ios_base::in)\n    {\n        __hm_ = const_cast<char_type*>(__str_.data()) + __str_.size();\n        this->setg(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()),\n                   __hm_);\n    }\n    if (__mode_ & ios_base::out)\n    {\n        typename string_type::size_type __sz = __str_.size();\n        __hm_ = const_cast<char_type*>(__str_.data()) + __sz;\n        __str_.resize(__str_.capacity());\n        this->setp(const_cast<char_type*>(__str_.data()),\n                   const_cast<char_type*>(__str_.data()) + __str_.size());\n        if (__mode_ & (ios_base::app | ios_base::ate))\n            this->pbump(__sz);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::underflow()\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (__mode_ & ios_base::in)\n    {\n        if (this->egptr() < __hm_)\n            this->setg(this->eback(), this->gptr(), __hm_);\n        if (this->gptr() < this->egptr())\n            return traits_type::to_int_type(*this->gptr());\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::pbackfail(int_type __c)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if (this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            return traits_type::not_eof(__c);\n        }\n        if ((__mode_ & ios_base::out) ||\n            traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->setg(this->eback(), this->gptr()-1, __hm_);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::int_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::overflow(int_type __c)\n{\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        ptrdiff_t __ninp = this->gptr()  - this->eback();\n        if (this->pptr() == this->epptr())\n        {\n            if (!(__mode_ & ios_base::out))\n                return traits_type::eof();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                ptrdiff_t __nout = this->pptr()  - this->pbase();\n                ptrdiff_t __hm = __hm_ - this->pbase();\n                __str_.push_back(char_type());\n                __str_.resize(__str_.capacity());\n                char_type* __p = const_cast<char_type*>(__str_.data());\n                this->setp(__p, __p + __str_.size());\n                this->pbump(__nout);\n                __hm_ = this->pbase() + __hm;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                return traits_type::eof();\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        }\n        __hm_ = _VSTD::max(this->pptr() + 1, __hm_);\n        if (__mode_ & ios_base::in)\n        {\n            char_type* __p = const_cast<char_type*>(__str_.data());\n            this->setg(__p, __p + __ninp, __hm_);\n        }\n        return this->sputc(__c);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekoff(off_type __off,\n                                                      ios_base::seekdir __way,\n                                                      ios_base::openmode __wch)\n{\n    if (__hm_ < this->pptr())\n        __hm_ = this->pptr();\n    if ((__wch & (ios_base::in | ios_base::out)) == 0)\n        return pos_type(-1);\n    if ((__wch & (ios_base::in | ios_base::out)) == (ios_base::in | ios_base::out)\n        && __way == ios_base::cur)\n        return pos_type(-1);\n    off_type __noff;\n    switch (__way)\n    {\n    case ios_base::beg:\n        __noff = 0;\n        break;\n    case ios_base::cur:\n        if (__wch & ios_base::in)\n            __noff = this->gptr() - this->eback();\n        else\n            __noff = this->pptr() - this->pbase();\n        break;\n    case ios_base::end:\n        __noff = __hm_ - __str_.data();\n        break;\n    default:\n        return pos_type(-1);\n    }\n    __noff += __off;\n    if (__noff < 0 || __hm_ - __str_.data() < __noff)\n        return pos_type(-1);\n    if (__noff != 0)\n    {\n        if ((__wch & ios_base::in) && this->gptr() == 0)\n            return pos_type(-1);\n        if ((__wch & ios_base::out) && this->pptr() == 0)\n            return pos_type(-1);\n    }\n    if (__wch & ios_base::in)\n        this->setg(this->eback(), this->eback() + __noff, __hm_);\n    if (__wch & ios_base::out)\n    {\n        this->setp(this->pbase(), this->epptr());\n        this->pbump(__noff);\n    }\n    return pos_type(__noff);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_stringbuf<_CharT, _Traits, _Allocator>::pos_type\nbasic_stringbuf<_CharT, _Traits, _Allocator>::seekpos(pos_type __sp,\n                                                      ios_base::openmode __wch)\n{\n    return seekoff(__sp, ios_base::beg, __wch);\n}\n\n// basic_istringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_istringstream\n    : public basic_istream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_istringstream(ios_base::openmode __wch = ios_base::in);\n    explicit basic_istringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::in);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_istringstream(basic_istringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_istringstream& operator=(basic_istringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_istringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::in)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_istream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::in)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istringstream<_CharT, _Traits, _Allocator>::basic_istringstream(basic_istringstream&& __rhs)\n    : basic_istream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>&\nbasic_istringstream<_CharT, _Traits, _Allocator>::operator=(basic_istringstream&& __rhs)\n{\n    basic_istream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::swap(basic_istringstream& __rhs)\n{\n    basic_istream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_istringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_istringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_istringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_istringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_istringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_ostringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostringstream\n    : public basic_ostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_ostringstream(ios_base::openmode __wch = ios_base::out);\n    explicit basic_ostringstream(const string_type& __s,\n                                 ios_base::openmode __wch = ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_ostringstream(basic_ostringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_ostringstream& operator=(basic_ostringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_ostringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch | ios_base::out)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(const string_type& __s,\n                                                                      ios_base::openmode __wch)\n    : basic_ostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch | ios_base::out)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostringstream<_CharT, _Traits, _Allocator>::basic_ostringstream(basic_ostringstream&& __rhs)\n    : basic_ostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_ostream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>&\nbasic_ostringstream<_CharT, _Traits, _Allocator>::operator=(basic_ostringstream&& __rhs)\n{\n    basic_ostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::swap(basic_ostringstream& __rhs)\n{\n    basic_ostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_ostringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_ostringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_ostringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n// basic_stringstream\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_stringstream\n    : public basic_iostream<_CharT, _Traits>\n{\npublic:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef _Allocator                     allocator_type;\n\n    typedef basic_string<char_type, traits_type, allocator_type> string_type;\n\nprivate:\n    basic_stringbuf<char_type, traits_type, allocator_type> __sb_;\n\npublic:\n    // 27.8.2.1 Constructors:\n    explicit basic_stringstream(ios_base::openmode __wch = ios_base::in | ios_base::out);\n    explicit basic_stringstream(const string_type& __s,\n                                ios_base::openmode __wch = ios_base::in | ios_base::out);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    basic_stringstream(basic_stringstream&& __rhs);\n\n    // 27.8.2.2 Assign and swap:\n    basic_stringstream& operator=(basic_stringstream&& __rhs);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(basic_stringstream& __rhs);\n\n    // 27.8.2.3 Members:\n    basic_stringbuf<char_type, traits_type, allocator_type>* rdbuf() const;\n    string_type str() const;\n    void str(const string_type& __s);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__wch)\n{\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(const string_type& __s,\n                                                                    ios_base::openmode __wch)\n    : basic_iostream<_CharT, _Traits>(&__sb_),\n      __sb_(__s, __wch)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringstream<_CharT, _Traits, _Allocator>::basic_stringstream(basic_stringstream&& __rhs)\n    : basic_iostream<_CharT, _Traits>(_VSTD::move(__rhs)),\n      __sb_(_VSTD::move(__rhs.__sb_))\n{\n    basic_istream<_CharT, _Traits>::set_rdbuf(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>&\nbasic_stringstream<_CharT, _Traits, _Allocator>::operator=(basic_stringstream&& __rhs)\n{\n    basic_iostream<char_type, traits_type>::operator=(_VSTD::move(__rhs));\n    __sb_ = _VSTD::move(__rhs.__sb_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::swap(basic_stringstream& __rhs)\n{\n    basic_iostream<char_type, traits_type>::swap(__rhs);\n    __sb_.swap(__rhs.__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_stringstream<_CharT, _Traits, _Allocator>& __x,\n     basic_stringstream<_CharT, _Traits, _Allocator>& __y)\n{\n    __x.swap(__y);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_stringbuf<_CharT, _Traits, _Allocator>*\nbasic_stringstream<_CharT, _Traits, _Allocator>::rdbuf() const\n{\n    return const_cast<basic_stringbuf<char_type, traits_type, allocator_type>*>(&__sb_);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_stringstream<_CharT, _Traits, _Allocator>::str() const\n{\n    return __sb_.str();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_stringstream<_CharT, _Traits, _Allocator>::str(const string_type& __s)\n{\n    __sb_.str(__s);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SSTREAM\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#if _LIBCPP_STD_VER > 11\n    basic_ostream& operator=(const basic_ostream&) = delete;\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 (char*)&__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (char*)&__c + 1 :\n                                     (char*)&__c,\n                                 (char*)&__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length(__str);\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<char, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<char, _Traits> _Ip;\n            size_t __len = _Traits::length((const char*)__str);\n            if (__pad_and_output(_Ip(__os),\n                                 (const char*)__str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     (const char*)__str + __len :\n                                     (const char*)__str,\n                                 (const char*)__str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = __str.size();\n            if (__pad_and_output(_Ip(__os),\n                                 __str.data(),\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str.data() + __len :\n                                     __str.data(),\n                                 __str.data() + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===--------------------------- iosfwd -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOSFWD\n#define _LIBCPP_IOSFWD\n\n/*\n    iosfwd synopsis\n\nnamespace std\n{\n\ntemplate<class charT> struct char_traits;\ntemplate<class T>     class allocator;\n\nclass ios_base;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ios;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_streambuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_istream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ostream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_iostream;\n\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringbuf;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_istringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_ostringstream;\ntemplate <class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\n    class basic_stringstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class basic_filebuf;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ifstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_ofstream;\ntemplate <class charT, class traits = char_traits<charT> > class basic_fstream;\n\ntemplate <class charT, class traits = char_traits<charT> > class istreambuf_iterator;\ntemplate <class charT, class traits = char_traits<charT> > class ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class state> class fpos;\ntypedef fpos<char_traits<char>::state_type>    streampos;\ntypedef fpos<char_traits<wchar_t>::state_type> wstreampos;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <wchar.h>  // for mbstate_t\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS ios_base;\n\ntemplate<class _CharT>  struct _LIBCPP_TYPE_VIS_ONLY char_traits;\ntemplate<class _Tp>     class _LIBCPP_TYPE_VIS_ONLY allocator;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ios;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_streambuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_iostream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringbuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_istringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ostringstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_stringstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_filebuf;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ifstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_ofstream;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_fstream;\n\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator;\ntemplate <class _CharT, class _Traits = char_traits<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator;\n\ntypedef basic_ios<char>              ios;\ntypedef basic_ios<wchar_t>           wios;\n\ntypedef basic_streambuf<char>        streambuf;\ntypedef basic_istream<char>          istream;\ntypedef basic_ostream<char>          ostream;\ntypedef basic_iostream<char>         iostream;\n\ntypedef basic_stringbuf<char>        stringbuf;\ntypedef basic_istringstream<char>    istringstream;\ntypedef basic_ostringstream<char>    ostringstream;\ntypedef basic_stringstream<char>     stringstream;\n\ntypedef basic_filebuf<char>          filebuf;\ntypedef basic_ifstream<char>         ifstream;\ntypedef basic_ofstream<char>         ofstream;\ntypedef basic_fstream<char>          fstream;\n\ntypedef basic_streambuf<wchar_t>     wstreambuf;\ntypedef basic_istream<wchar_t>       wistream;\ntypedef basic_ostream<wchar_t>       wostream;\ntypedef basic_iostream<wchar_t>      wiostream;\n\ntypedef basic_stringbuf<wchar_t>     wstringbuf;\ntypedef basic_istringstream<wchar_t> wistringstream;\ntypedef basic_ostringstream<wchar_t> wostringstream;\ntypedef basic_stringstream<wchar_t>  wstringstream;\n\ntypedef basic_filebuf<wchar_t>       wfilebuf;\ntypedef basic_ifstream<wchar_t>      wifstream;\ntypedef basic_ofstream<wchar_t>      wofstream;\ntypedef basic_fstream<wchar_t>       wfstream;\n\ntemplate <class _State>             class _LIBCPP_TYPE_VIS_ONLY fpos;\ntypedef fpos<mbstate_t>    streampos;\ntypedef fpos<mbstate_t>    wstreampos;\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntypedef fpos<mbstate_t>    u16streampos;\ntypedef fpos<mbstate_t>    u32streampos;\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef long long streamoff;        // for char_traits in <string>\n\ntemplate <class _CharT,             // for <stdexcept>\n          class _Traits = char_traits<_CharT>,\n          class _Allocator = allocator<_CharT> >\n    class _LIBCPP_TYPE_VIS_ONLY basic_string;\ntypedef basic_string<char, char_traits<char>, allocator<char> > string;\ntypedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> > wstring;\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOSFWD\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if __has_feature(cxx_atomic)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n#if __has_feature(cxx_atomic) && !defined(__EMSCRIPTEN__)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif _AIX\n# include <support/ibm/xlocale.h>\n#elif (defined(__GLIBC__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__sun__)) || defined(__EMSCRIPTEN__) || defined(__IBMCPP__)\n# include <xlocale.h>\n#endif  // _WIN32 || __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n    static const mask xdigit = _CTYPE_X;\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#else // _LIBCPP_MSVCRT\n#include <nl_types.h>\n#endif  // !_LIBCPP_MSVCRT\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\ninline _LIBCPP_ALWAYS_INLINE\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\ninline _LIBCPP_ALWAYS_INLINE\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_senstive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end - __a == __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __a[sizeof(__a)-1] = 0;\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__a, _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__a, __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primatives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primatives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#ifdef _WIN32\n    return -1;\n#else // _WIN32\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#ifdef _WIN32\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS_ONLY wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS_ONLY wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// Copyright (C) 2002 Brad King (brad.king@kitware.com)\n//                    Douglas Gregor (gregod@cs.rpi.edu)\n//\n// Copyright (C) 2002, 2008 Peter Dimov\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n// For more information, see http://www.boost.org\n\n#ifndef BOOST_UTILITY_ADDRESSOF_HPP\n# define BOOST_UTILITY_ADDRESSOF_HPP\n\n# include <boost/config.hpp>\n# include <boost/detail/workaround.hpp>\n\nnamespace boost\n{\n\nnamespace detail\n{\n\ntemplate<class T> struct addr_impl_ref\n{\n    T & v_;\n\n    inline addr_impl_ref( T & v ): v_( v ) {}\n    inline operator T& () const { return v_; }\n\nprivate:\n    addr_impl_ref & operator=(const addr_impl_ref &);\n};\n\ntemplate<class T> struct addressof_impl\n{\n    static inline T * f( T & v, long )\n    {\n        return reinterpret_cast<T*>(\n            &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));\n    }\n\n    static inline T * f( T * v, int )\n    {\n        return v;\n    }\n};\n\n} // namespace detail\n\ntemplate<class T> T * addressof( T & v )\n{\n#if (defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT( 0x610 ) ) ) || defined( __SUNPRO_CC )\n\n    return boost::detail::addressof_impl<T>::f( v, 0 );\n\n#else\n\n    return boost::detail::addressof_impl<T>::f( boost::detail::addr_impl_ref<T>( v ), 0 );\n\n#endif\n}\n\n#if defined( __SUNPRO_CC ) && BOOST_WORKAROUND( __SUNPRO_CC, BOOST_TESTED_AT( 0x590 ) )\n\nnamespace detail\n{\n\ntemplate<class T> struct addressof_addp\n{\n    typedef T * type;\n};\n\n} // namespace detail\n\ntemplate< class T, std::size_t N >\ntypename detail::addressof_addp< T[N] >::type addressof( T (&t)[N] )\n{\n    return &t;\n}\n\n#endif\n\n// Borland doesn't like casting an array reference to a char reference\n// but these overloads work around the problem.\n#if defined( __BORLANDC__ ) && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\ntemplate<typename T,std::size_t N>\nT (*addressof(T (&t)[N]))[N]\n{\n   return reinterpret_cast<T(*)[N]>(&t);\n}\n\ntemplate<typename T,std::size_t N>\nconst T (*addressof(const T (&t)[N]))[N]\n{\n   return reinterpret_cast<const T(*)[N]>(&t);\n}\n#endif\n\n} // namespace boost\n\n#endif // BOOST_UTILITY_ADDRESSOF_HPP\n","/*******************************************************************************\r\n*                                                                              *\r\n* Author    :  Angus Johnson                                                   *\r\n* Version   :  6.0.0                                                           *\r\n* Date      :  30 October 2013                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2013                                         *\r\n*                                                                              *\r\n* License:                                                                     *\r\n* Use, modification & distribution is subject to Boost Software License Ver 1. *\r\n* http://www.boost.org/LICENSE_1_0.txt                                         *\r\n*                                                                              *\r\n* Attributions:                                                                *\r\n* The code in this library is an extension of Bala Vatti's clipping algorithm: *\r\n* \"A generic solution to polygon clipping\"                                     *\r\n* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\r\n* http://portal.acm.org/citation.cfm?id=129906                                 *\r\n*                                                                              *\r\n* Computer graphics and geometric modeling: implementation and algorithms      *\r\n* By Max K. Agoston                                                            *\r\n* Springer; 1 edition (January 4, 2005)                                        *\r\n* http://books.google.com/books?q=vatti+clipping+agoston                       *\r\n*                                                                              *\r\n* See also:                                                                    *\r\n* \"Polygon Offsetting by Computing Winding Numbers\"                            *\r\n* Paper no. DETC2005-85513 pp. 565-575                                         *\r\n* ASME 2005 International Design Engineering Technical Conferences             *\r\n* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\r\n* September 24-28, 2005 , Long Beach, California, USA                          *\r\n* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\r\n*                                                                              *\r\n*******************************************************************************/\r\n\r\n/*******************************************************************************\r\n*                                                                              *\r\n* This is a translation of the Delphi Clipper library and the naming style     *\r\n* used has retained a Delphi flavour.                                          *\r\n*                                                                              *\r\n*******************************************************************************/\r\n\r\n#include \"clipper.hpp\"\r\n#include <cmath>\r\n#include <vector>\r\n#include <algorithm>\r\n#include <stdexcept>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <ostream>\r\n#include <functional>\r\n\r\nnamespace ClipperLib {\r\n\r\n#ifdef use_int32\r\n  static cInt const loRange = 46340;\r\n  static cInt const hiRange = 46340;\r\n#else\r\n  static cInt const loRange = 0x3FFFFFFF;\r\n  static cInt const hiRange = 0x3FFFFFFFFFFFFFFFLL;\r\n  typedef unsigned long long ulong64;\r\n#endif\r\n\r\nstatic double const pi = 3.141592653589793238;\r\nenum Direction { dRightToLeft, dLeftToRight };\r\n\r\nstatic int const Unassigned = -1;  //edge not currently 'owning' a solution\r\nstatic int const Skip = -2;        //edge that would otherwise close a path\r\n\r\n#define HORIZONTAL (-1.0E+40)\r\n#define TOLERANCE (1.0e-20)\r\n#define NEAR_ZERO(val) (((val) > -TOLERANCE) && ((val) < TOLERANCE))\r\n\r\nstruct TEdge {\r\n  IntPoint Bot;\r\n  IntPoint Curr;\r\n  IntPoint Top;\r\n  IntPoint Delta;\r\n  double Dx;\r\n  PolyType PolyTyp;\r\n  EdgeSide Side;\r\n  int WindDelta; //1 or -1 depending on winding direction\r\n  int WindCnt;\r\n  int WindCnt2; //winding count of the opposite polytype\r\n  int OutIdx;\r\n  TEdge *Next;\r\n  TEdge *Prev;\r\n  TEdge *NextInLML;\r\n  TEdge *NextInAEL;\r\n  TEdge *PrevInAEL;\r\n  TEdge *NextInSEL;\r\n  TEdge *PrevInSEL;\r\n};\r\n\r\nstruct IntersectNode {\r\n  TEdge          *Edge1;\r\n  TEdge          *Edge2;\r\n  IntPoint        Pt;\r\n  IntersectNode  *Next;\r\n};\r\n\r\nstruct LocalMinima {\r\n  cInt          Y;\r\n  TEdge        *LeftBound;\r\n  TEdge        *RightBound;\r\n  LocalMinima  *Next;\r\n};\r\n\r\nstruct OutPt;\r\n\r\nstruct OutRec {\r\n  int       Idx;\r\n  bool      IsHole;\r\n  bool      IsOpen;\r\n  OutRec   *FirstLeft;  //see comments in clipper.pas\r\n  PolyNode *PolyNd;\r\n  OutPt    *Pts;\r\n  OutPt    *BottomPt;\r\n};\r\n\r\nstruct OutPt {\r\n  int       Idx;\r\n  IntPoint  Pt;\r\n  OutPt    *Next;\r\n  OutPt    *Prev;\r\n};\r\n\r\nstruct Join {\r\n  OutPt    *OutPt1;\r\n  OutPt    *OutPt2;\r\n  IntPoint  OffPt;\r\n};\r\n\r\n//------------------------------------------------------------------------------\r\n//------------------------------------------------------------------------------\r\n\r\ninline cInt Round(double val)\r\n{\r\n  if ((val < 0)) return static_cast<cInt>(val - 0.5); \r\n  else return static_cast<cInt>(val + 0.5);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline cInt Abs(cInt val)\r\n{\r\n  return val < 0 ? -val : val;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// PolyTree methods ...\r\n//------------------------------------------------------------------------------\r\n\r\nvoid PolyTree::Clear()\r\n{\r\n    for (PolyNodes::size_type i = 0; i < AllNodes.size(); ++i)\r\n      delete AllNodes[i];\r\n    AllNodes.resize(0); \r\n    Childs.resize(0);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nPolyNode* PolyTree::GetFirst() const\r\n{\r\n  if (!Childs.empty())\r\n      return Childs[0];\r\n  else\r\n      return 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nint PolyTree::Total() const\r\n{\r\n  return AllNodes.size();\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// PolyNode methods ...\r\n//------------------------------------------------------------------------------\r\n\r\nPolyNode::PolyNode(): Childs(), Parent(0), m_IsOpen(false), Index(0)\r\n{\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nint PolyNode::ChildCount() const\r\n{\r\n  return Childs.size();\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid PolyNode::AddChild(PolyNode& child)\r\n{\r\n  unsigned cnt = Childs.size();\r\n  Childs.push_back(&child);\r\n  child.Parent = this;\r\n  child.Index = cnt;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nPolyNode* PolyNode::GetNext() const\r\n{ \r\n  if (!Childs.empty()) \r\n      return Childs[0]; \r\n  else\r\n      return GetNextSiblingUp();    \r\n}  \r\n//------------------------------------------------------------------------------\r\n\r\nPolyNode* PolyNode::GetNextSiblingUp() const\r\n{ \r\n  if (!Parent) //protects against PolyTree.GetNextSiblingUp()\r\n      return 0;\r\n  else if (Index == Parent->Childs.size() - 1)\r\n      return Parent->GetNextSiblingUp();\r\n  else\r\n      return Parent->Childs[Index + 1];\r\n}  \r\n//------------------------------------------------------------------------------\r\n\r\nbool PolyNode::IsHole() const\r\n{ \r\n  bool result = true;\r\n  PolyNode* node = Parent;\r\n  while (node)\r\n  {\r\n      result = !result;\r\n      node = node->Parent;\r\n  }\r\n  return result;\r\n}  \r\n//------------------------------------------------------------------------------\r\n\r\nbool PolyNode::IsOpen() const\r\n{ \r\n  return m_IsOpen;\r\n}  \r\n//------------------------------------------------------------------------------\r\n\r\n#ifndef use_int32\r\n\r\n//------------------------------------------------------------------------------\r\n// Int128 class (enables safe math on signed 64bit integers)\r\n// eg Int128 val1((cInt)9223372036854775807); //ie 2^63 -1\r\n//    Int128 val2((cInt)9223372036854775807);\r\n//    Int128 val3 = val1 * val2;\r\n//    val3.AsString => \"85070591730234615847396907784232501249\" (8.5e+37)\r\n//------------------------------------------------------------------------------\r\n\r\nclass Int128\r\n{\r\n  public:\r\n\r\n    cUInt lo;\r\n    cInt hi;\r\n\r\n    Int128(cInt _lo = 0)\r\n    {\r\n      lo = (cUInt)_lo;   \r\n      if (_lo < 0)  hi = -1; else hi = 0; \r\n    }\r\n\r\n\r\n    Int128(const Int128 &val): lo(val.lo), hi(val.hi){}\r\n\r\n    Int128(const cInt& _hi, const ulong64& _lo): lo(_lo), hi(_hi){}\r\n    \r\n    Int128& operator = (const cInt &val)\r\n    {\r\n      lo = (ulong64)val;\r\n      if (val < 0) hi = -1; else hi = 0;\r\n      return *this;\r\n    }\r\n\r\n    bool operator == (const Int128 &val) const\r\n      {return (hi == val.hi && lo == val.lo);}\r\n\r\n    bool operator != (const Int128 &val) const\r\n      { return !(*this == val);}\r\n\r\n    bool operator > (const Int128 &val) const\r\n    {\r\n      if (hi != val.hi)\r\n        return hi > val.hi;\r\n      else\r\n        return lo > val.lo;\r\n    }\r\n\r\n    bool operator < (const Int128 &val) const\r\n    {\r\n      if (hi != val.hi)\r\n        return hi < val.hi;\r\n      else\r\n        return lo < val.lo;\r\n    }\r\n\r\n    bool operator >= (const Int128 &val) const\r\n      { return !(*this < val);}\r\n\r\n    bool operator <= (const Int128 &val) const\r\n      { return !(*this > val);}\r\n\r\n    Int128& operator += (const Int128 &rhs)\r\n    {\r\n      hi += rhs.hi;\r\n      lo += rhs.lo;\r\n      if (lo < rhs.lo) hi++;\r\n      return *this;\r\n    }\r\n\r\n    Int128 operator + (const Int128 &rhs) const\r\n    {\r\n      Int128 result(*this);\r\n      result+= rhs;\r\n      return result;\r\n    }\r\n\r\n    Int128& operator -= (const Int128 &rhs)\r\n    {\r\n      *this += -rhs;\r\n      return *this;\r\n    }\r\n\r\n    Int128 operator - (const Int128 &rhs) const\r\n    {\r\n      Int128 result(*this);\r\n      result -= rhs;\r\n      return result;\r\n    }\r\n\r\n    Int128 operator-() const //unary negation\r\n    {\r\n      if (lo == 0)\r\n        return Int128(-hi,0);\r\n      else \r\n        return Int128(~hi,~lo +1);\r\n    }\r\n\r\n    Int128 operator/ (const Int128 &rhs) const\r\n    {\r\n      if (rhs.lo == 0 && rhs.hi == 0)\r\n        throw \"Int128 operator/: divide by zero\";\r\n\r\n      bool negate = (rhs.hi < 0) != (hi < 0);\r\n      Int128 dividend = *this;\r\n      Int128 divisor = rhs;\r\n      if (dividend.hi < 0) dividend = -dividend;\r\n      if (divisor.hi < 0) divisor = -divisor;\r\n\r\n      if (divisor < dividend)\r\n      {\r\n          Int128 result = Int128(0);\r\n          Int128 cntr = Int128(1);\r\n          while (divisor.hi >= 0 && !(divisor > dividend))\r\n          {\r\n              divisor.hi <<= 1;\r\n              if ((cInt)divisor.lo < 0) divisor.hi++;\r\n              divisor.lo <<= 1;\r\n\r\n              cntr.hi <<= 1;\r\n              if ((cInt)cntr.lo < 0) cntr.hi++;\r\n              cntr.lo <<= 1;\r\n          }\r\n          divisor.lo >>= 1;\r\n          if ((divisor.hi & 1) == 1)\r\n              divisor.lo |= 0x8000000000000000LL; \r\n          divisor.hi = (ulong64)divisor.hi >> 1;\r\n\r\n          cntr.lo >>= 1;\r\n          if ((cntr.hi & 1) == 1)\r\n              cntr.lo |= 0x8000000000000000LL; \r\n          cntr.hi >>= 1;\r\n\r\n          while (cntr.hi != 0 || cntr.lo != 0)\r\n          {\r\n              if (!(dividend < divisor))\r\n              {\r\n                  dividend -= divisor;\r\n                  result.hi |= cntr.hi;\r\n                  result.lo |= cntr.lo;\r\n              }\r\n              divisor.lo >>= 1;\r\n              if ((divisor.hi & 1) == 1)\r\n                  divisor.lo |= 0x8000000000000000LL; \r\n              divisor.hi >>= 1;\r\n\r\n              cntr.lo >>= 1;\r\n              if ((cntr.hi & 1) == 1)\r\n                  cntr.lo |= 0x8000000000000000LL; \r\n              cntr.hi >>= 1;\r\n          }\r\n          if (negate) result = -result;\r\n          return result;\r\n      }\r\n      else if (rhs.hi == this->hi && rhs.lo == this->lo)\r\n          return Int128(1);\r\n      else\r\n          return Int128(0);\r\n    }\r\n\r\n    double AsDouble() const\r\n    {\r\n      const double shift64 = 18446744073709551616.0; //2^64\r\n      if (hi < 0)\r\n      {\r\n        if (lo == 0) return (double)hi * shift64;\r\n        else return -(double)(~lo + ~hi * shift64);\r\n      }\r\n      else\r\n        return (double)(lo + hi * shift64);\r\n    }\r\n\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\nInt128 Int128Mul (cInt lhs, cInt rhs)\r\n{\r\n  bool negate = (lhs < 0) != (rhs < 0);\r\n\r\n  if (lhs < 0) lhs = -lhs;\r\n  ulong64 int1Hi = ulong64(lhs) >> 32;\r\n  ulong64 int1Lo = ulong64(lhs & 0xFFFFFFFF);\r\n\r\n  if (rhs < 0) rhs = -rhs;\r\n  ulong64 int2Hi = ulong64(rhs) >> 32;\r\n  ulong64 int2Lo = ulong64(rhs & 0xFFFFFFFF);\r\n\r\n  //nb: see comments in clipper.pas\r\n  ulong64 a = int1Hi * int2Hi;\r\n  ulong64 b = int1Lo * int2Lo;\r\n  ulong64 c = int1Hi * int2Lo + int1Lo * int2Hi;\r\n\r\n  Int128 tmp;\r\n  tmp.hi = cInt(a + (c >> 32));\r\n  tmp.lo = cInt(c << 32);\r\n  tmp.lo += cInt(b);\r\n  if (tmp.lo < b) tmp.hi++;\r\n  if (negate) tmp = -tmp;\r\n  return tmp;\r\n};\r\n#endif\r\n\r\n//------------------------------------------------------------------------------\r\n// Miscellaneous global functions\r\n//------------------------------------------------------------------------------\r\n\r\nbool Orientation(const Path &poly)\r\n{\r\n    return Area(poly) >= 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ndouble Area(const Path &poly)\r\n{\r\n  int highI = (int)poly.size() -1;\r\n  if (highI < 2) return 0;\r\n\r\n  double a;\r\n  a = ((double)poly[highI].X + poly[0].X) * ((double)poly[0].Y - poly[highI].Y);\r\n  for (int i = 1; i <= highI; ++i)\r\n    a += ((double)poly[i - 1].X + poly[i].X) * ((double)poly[i].Y - poly[i - 1].Y);\r\n  return a / 2;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ndouble Area(const OutRec &outRec)\r\n{\r\n  OutPt *op = outRec.Pts;\r\n  if (!op) return 0;\r\n  double a = 0;\r\n  do {\r\n    a = a + (double)(op->Pt.X + op->Prev->Pt.X) * (double)(op->Prev->Pt.Y - op->Pt.Y);\r\n    op = op->Next;\r\n  } while (op != outRec.Pts);\r\n  return a / 2;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool PointIsVertex(const IntPoint &Pt, OutPt *pp)\r\n{\r\n  OutPt *pp2 = pp;\r\n  do\r\n  {\r\n    if (pp2->Pt == Pt) return true;\r\n    pp2 = pp2->Next;\r\n  }\r\n  while (pp2 != pp);\r\n  return false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool PointOnLineSegment(const IntPoint Pt, \r\n  const IntPoint linePt1, const IntPoint linePt2, bool UseFullInt64Range)\r\n{\r\n#ifndef use_int32\r\n  if (UseFullInt64Range)\r\n    return ((Pt.X == linePt1.X) && (Pt.Y == linePt1.Y)) ||\r\n      ((Pt.X == linePt2.X) && (Pt.Y == linePt2.Y)) ||\r\n      (((Pt.X > linePt1.X) == (Pt.X < linePt2.X)) &&\r\n      ((Pt.Y > linePt1.Y) == (Pt.Y < linePt2.Y)) &&\r\n      ((Int128Mul((Pt.X - linePt1.X), (linePt2.Y - linePt1.Y)) ==\r\n      Int128Mul((linePt2.X - linePt1.X), (Pt.Y - linePt1.Y)))));\r\n  else\r\n#endif\r\n    return ((Pt.X == linePt1.X) && (Pt.Y == linePt1.Y)) ||\r\n      ((Pt.X == linePt2.X) && (Pt.Y == linePt2.Y)) ||\r\n      (((Pt.X > linePt1.X) == (Pt.X < linePt2.X)) &&\r\n      ((Pt.Y > linePt1.Y) == (Pt.Y < linePt2.Y)) &&\r\n      ((Pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) ==\r\n        (linePt2.X - linePt1.X) * (Pt.Y - linePt1.Y)));\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool PointOnPolygon(const IntPoint Pt, OutPt *pp, bool UseFullInt64Range)\r\n{\r\n  OutPt *pp2 = pp;\r\n  while (true)\r\n  {\r\n    if (PointOnLineSegment(Pt, pp2->Pt, pp2->Next->Pt, UseFullInt64Range))\r\n      return true;\r\n    pp2 = pp2->Next;\r\n    if (pp2 == pp) break;\r\n  } \r\n  return false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool PointInPolygon(const IntPoint &Pt, OutPt *pp, bool UseFullInt64Range)\r\n{\r\n  OutPt *pp2 = pp;\r\n  bool result = false;\r\n#ifndef use_int32\r\n  if (UseFullInt64Range) {\r\n    do\r\n    {\r\n      if (((pp2->Pt.Y > Pt.Y) != (pp2->Prev->Pt.Y > Pt.Y)) &&                     \r\n        (Int128(Pt.X - pp2->Pt.X) < \r\n        Int128Mul(pp2->Prev->Pt.X - pp2->Pt.X, Pt.Y - pp2->Pt.Y) / \r\n        Int128(pp2->Prev->Pt.Y - pp2->Pt.Y))) result = !result;\r\n      pp2 = pp2->Next;\r\n    }\r\n    while (pp2 != pp);\r\n    return result;\r\n  }\r\n#endif\r\n  do\r\n  {\r\n    //http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\r\n    if (((pp2->Pt.Y > Pt.Y) != (pp2->Prev->Pt.Y > Pt.Y)) &&                     \r\n      ((Pt.X - pp2->Pt.X) < (pp2->Prev->Pt.X - pp2->Pt.X) * (Pt.Y - pp2->Pt.Y) / \r\n      (pp2->Prev->Pt.Y - pp2->Pt.Y))) result = !result;\r\n    pp2 = pp2->Next;\r\n  }\r\n  while (pp2 != pp);\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SlopesEqual(const TEdge &e1, const TEdge &e2, bool UseFullInt64Range)\r\n{\r\n#ifndef use_int32\r\n  if (UseFullInt64Range)\r\n    return Int128Mul(e1.Delta.Y, e2.Delta.X) == Int128Mul(e1.Delta.X, e2.Delta.Y);\r\n  else \r\n#endif\r\n    return e1.Delta.Y * e2.Delta.X == e1.Delta.X * e2.Delta.Y;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SlopesEqual(const IntPoint pt1, const IntPoint pt2,\r\n  const IntPoint pt3, bool UseFullInt64Range)\r\n{\r\n#ifndef use_int32\r\n  if (UseFullInt64Range)\r\n    return Int128Mul(pt1.Y-pt2.Y, pt2.X-pt3.X) == Int128Mul(pt1.X-pt2.X, pt2.Y-pt3.Y);\r\n  else \r\n#endif\r\n    return (pt1.Y-pt2.Y)*(pt2.X-pt3.X) == (pt1.X-pt2.X)*(pt2.Y-pt3.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SlopesEqual(const IntPoint pt1, const IntPoint pt2,\r\n  const IntPoint pt3, const IntPoint pt4, bool UseFullInt64Range)\r\n{\r\n#ifndef use_int32\r\n  if (UseFullInt64Range)\r\n    return Int128Mul(pt1.Y-pt2.Y, pt3.X-pt4.X) == Int128Mul(pt1.X-pt2.X, pt3.Y-pt4.Y);\r\n  else \r\n#endif\r\n    return (pt1.Y-pt2.Y)*(pt3.X-pt4.X) == (pt1.X-pt2.X)*(pt3.Y-pt4.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool IsHorizontal(TEdge &e)\r\n{\r\n  return e.Delta.Y == 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline double GetDx(const IntPoint pt1, const IntPoint pt2)\r\n{\r\n  return (pt1.Y == pt2.Y) ?\r\n    HORIZONTAL : (double)(pt2.X - pt1.X) / (pt2.Y - pt1.Y);\r\n}\r\n//---------------------------------------------------------------------------\r\n\r\ninline void SetDx(TEdge &e)\r\n{\r\n  e.Delta.X = (e.Top.X - e.Bot.X);\r\n  e.Delta.Y = (e.Top.Y - e.Bot.Y);\r\n\r\n  if (e.Delta.Y == 0) e.Dx = HORIZONTAL;\r\n  else e.Dx = (double)(e.Delta.X) / e.Delta.Y;\r\n}\r\n//---------------------------------------------------------------------------\r\n\r\ninline void SwapSides(TEdge &Edge1, TEdge &Edge2)\r\n{\r\n  EdgeSide Side =  Edge1.Side;\r\n  Edge1.Side = Edge2.Side;\r\n  Edge2.Side = Side;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline void SwapPolyIndexes(TEdge &Edge1, TEdge &Edge2)\r\n{\r\n  int OutIdx =  Edge1.OutIdx;\r\n  Edge1.OutIdx = Edge2.OutIdx;\r\n  Edge2.OutIdx = OutIdx;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline cInt TopX(TEdge &edge, const cInt currentY)\r\n{\r\n  return ( currentY == edge.Top.Y ) ?\r\n    edge.Top.X : edge.Bot.X + Round(edge.Dx *(currentY - edge.Bot.Y));\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool IntersectPoint(TEdge &Edge1, TEdge &Edge2,\r\n  IntPoint &ip, bool UseFullInt64Range)\r\n{\r\n#ifdef use_xyz  \r\n  ip.Z = 0;\r\n#endif\r\n  double b1, b2;\r\n  //nb: with very large coordinate values, it's possible for SlopesEqual() to \r\n  //return false but for the edge.Dx value be equal due to double precision rounding.\r\n  if (SlopesEqual(Edge1, Edge2, UseFullInt64Range) || Edge1.Dx == Edge2.Dx)\r\n  {\r\n    if (Edge2.Bot.Y > Edge1.Bot.Y) ip.Y = Edge2.Bot.Y;\r\n    else ip.Y = Edge1.Bot.Y;\r\n    return false;\r\n  }\r\n  else if (Edge1.Delta.X == 0)\r\n  {\r\n    ip.X = Edge1.Bot.X;\r\n    if (IsHorizontal(Edge2))\r\n      ip.Y = Edge2.Bot.Y;\r\n    else\r\n    {\r\n      b2 = Edge2.Bot.Y - (Edge2.Bot.X / Edge2.Dx);\r\n      ip.Y = Round(ip.X / Edge2.Dx + b2);\r\n    }\r\n  }\r\n  else if (Edge2.Delta.X == 0)\r\n  {\r\n    ip.X = Edge2.Bot.X;\r\n    if (IsHorizontal(Edge1))\r\n      ip.Y = Edge1.Bot.Y;\r\n    else\r\n    {\r\n      b1 = Edge1.Bot.Y - (Edge1.Bot.X / Edge1.Dx);\r\n      ip.Y = Round(ip.X / Edge1.Dx + b1);\r\n    }\r\n  } \r\n  else \r\n  {\r\n    b1 = Edge1.Bot.X - Edge1.Bot.Y * Edge1.Dx;\r\n    b2 = Edge2.Bot.X - Edge2.Bot.Y * Edge2.Dx;\r\n    double q = (b2-b1) / (Edge1.Dx - Edge2.Dx);\r\n    ip.Y = Round(q);\r\n    if (std::fabs(Edge1.Dx) < std::fabs(Edge2.Dx))\r\n      ip.X = Round(Edge1.Dx * q + b1);\r\n    else \r\n      ip.X = Round(Edge2.Dx * q + b2);\r\n  }\r\n\r\n  if (ip.Y < Edge1.Top.Y || ip.Y < Edge2.Top.Y) \r\n  {\r\n    if (Edge1.Top.Y > Edge2.Top.Y)\r\n    {\r\n      ip.Y = Edge1.Top.Y;\r\n      ip.X = TopX(Edge2, Edge1.Top.Y);\r\n      return ip.X < Edge1.Top.X;\r\n    } \r\n    else\r\n    {\r\n      ip.Y = Edge2.Top.Y;\r\n      ip.X = TopX(Edge1, Edge2.Top.Y);\r\n      return ip.X > Edge2.Top.X;\r\n    }\r\n  } \r\n  else \r\n    return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ReversePolyPtLinks(OutPt *pp)\r\n{\r\n  if (!pp) return;\r\n  OutPt *pp1, *pp2;\r\n  pp1 = pp;\r\n  do {\r\n  pp2 = pp1->Next;\r\n  pp1->Next = pp1->Prev;\r\n  pp1->Prev = pp2;\r\n  pp1 = pp2;\r\n  } while( pp1 != pp );\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid DisposeOutPts(OutPt*& pp)\r\n{\r\n  if (pp == 0) return;\r\n    pp->Prev->Next = 0;\r\n  while( pp )\r\n  {\r\n    OutPt *tmpPp = pp;\r\n    pp = pp->Next;\r\n    delete tmpPp;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline void InitEdge(TEdge* e, TEdge* eNext, TEdge* ePrev, const IntPoint& Pt)\r\n{\r\n  std::memset(e, 0, sizeof(TEdge));\r\n  e->Next = eNext;\r\n  e->Prev = ePrev;\r\n  e->Curr = Pt;\r\n  e->OutIdx = Unassigned;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid InitEdge2(TEdge& e, PolyType Pt)\r\n{\r\n  if (e.Curr.Y >= e.Next->Curr.Y)\r\n  {\r\n    e.Bot = e.Curr;\r\n    e.Top = e.Next->Curr;\r\n  } else\r\n  {\r\n    e.Top = e.Curr;\r\n    e.Bot = e.Next->Curr;\r\n  }\r\n  SetDx(e);\r\n  e.PolyTyp = Pt;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nTEdge* RemoveEdge(TEdge* e)\r\n{\r\n  //removes e from double_linked_list (but without removing from memory)\r\n  e->Prev->Next = e->Next;\r\n  e->Next->Prev = e->Prev;\r\n  TEdge* result = e->Next;\r\n  e->Prev = 0; //flag as removed (see ClipperBase.Clear)\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nTEdge* GetLastHorz(TEdge* Edge)\r\n{\r\n  TEdge* result = Edge;\r\n  while (result->OutIdx != Skip && result->Next != Edge && IsHorizontal(*result->Next))\r\n    result = result->Next;\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SharedVertWithPrevAtTop(TEdge* Edge)\r\n{\r\n  TEdge* E = Edge;\r\n  bool result = true;\r\n  while (E->Prev != Edge)\r\n  {\r\n    if (E->Top == E->Prev->Top)\r\n    {\r\n      if (E->Bot == E->Prev->Bot)\r\n      {E = E->Prev; continue;}\r\n      else result = true;\r\n    } \r\n    else result = false;\r\n    break;\r\n  }\r\n  while (E != Edge) \r\n  {\r\n    result = !result;\r\n    E = E->Next;\r\n  }\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SharedVertWithNextIsBot(TEdge* Edge)\r\n{\r\n  bool result = true;\r\n  TEdge* E = Edge;\r\n  while (E->Prev != Edge)\r\n  {\r\n    bool A = (E->Next->Bot == E->Bot);\r\n    bool B = (E->Prev->Bot == E->Bot);\r\n    if (A != B) \r\n    {\r\n      result = A;\r\n      break;\r\n    }\r\n    A = (E->Next->Top == E->Top);\r\n    B = (E->Prev->Top == E->Top);\r\n    if (A != B) \r\n    {\r\n      result = B;\r\n      break;\r\n    }\r\n    E = E->Prev;\r\n  }\r\n  while (E != Edge)\r\n  {\r\n    result = !result;\r\n    E = E->Next;\r\n  }\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool MoreBelow(TEdge* Edge) \r\n{\r\n  //Edge is Skip heading down.\r\n  TEdge* E = Edge;\r\n  if (IsHorizontal(*E)) \r\n  {\r\n    while (IsHorizontal(*E->Next)) E = E->Next;\r\n    return E->Next->Bot.Y > E->Bot.Y;\r\n  } else if (IsHorizontal(*E->Next))\r\n  {\r\n    while (IsHorizontal(*E->Next)) E = E->Next;\r\n    return E->Next->Bot.Y > E->Bot.Y;\r\n  } \r\n  else return (E->Bot == E->Next->Top);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool JustBeforeLocMin(TEdge* Edge)\r\n{\r\n  //Edge is Skip and was heading down.\r\n  TEdge*E = Edge;\r\n  if (IsHorizontal(*E))\r\n  {\r\n    while (IsHorizontal(*E->Next)) E = E->Next;\r\n    return E->Next->Top.Y < E->Bot.Y;\r\n  }\r\n  else return SharedVertWithNextIsBot(E);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool MoreAbove(TEdge* Edge)\r\n{\r\n  if (IsHorizontal(*Edge)) \r\n  {\r\n    Edge = GetLastHorz(Edge);\r\n    return (Edge->Next->Top.Y < Edge->Top.Y);\r\n  } else if (IsHorizontal(*Edge->Next)) \r\n  {\r\n    Edge = GetLastHorz(Edge->Next);\r\n    return (Edge->Next->Top.Y < Edge->Top.Y);\r\n  } \r\n  else\r\n    return (Edge->Next->Top.Y < Edge->Top.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool AllHorizontal(TEdge* Edge)\r\n{  \r\n  if (!IsHorizontal(*Edge)) return false;\r\n  TEdge* E = Edge->Next;\r\n  while (E != Edge)\r\n  {\r\n    if (!IsHorizontal(*E)) return false;\r\n    else E = E->Next;\r\n  }\r\n  return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline void ReverseHorizontal(TEdge &e)\r\n{\r\n  //swap horizontal edges' Top and Bottom x's so they follow the natural\r\n  //progression of the bounds - ie so their xbots will align with the\r\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\r\n  cInt tmp = e.Top.X;\r\n  e.Top.X = e.Bot.X;\r\n  e.Bot.X = tmp;\r\n#ifdef use_xyz  \r\n  tmp = e.Top.Z;\r\n  e.Top.Z = e.Bot.Z;\r\n  e.Bot.Z = tmp;\r\n#endif\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid SwapPoints(IntPoint &pt1, IntPoint &pt2)\r\n{\r\n  IntPoint tmp = pt1;\r\n  pt1 = pt2;\r\n  pt2 = tmp;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool GetOverlapSegment(IntPoint pt1a, IntPoint pt1b, IntPoint pt2a,\r\n  IntPoint pt2b, IntPoint &pt1, IntPoint &pt2)\r\n{\r\n  //precondition: segments are Collinear.\r\n  if (Abs(pt1a.X - pt1b.X) > Abs(pt1a.Y - pt1b.Y))\r\n  {\r\n    if (pt1a.X > pt1b.X) SwapPoints(pt1a, pt1b);\r\n    if (pt2a.X > pt2b.X) SwapPoints(pt2a, pt2b);\r\n    if (pt1a.X > pt2a.X) pt1 = pt1a; else pt1 = pt2a;\r\n    if (pt1b.X < pt2b.X) pt2 = pt1b; else pt2 = pt2b;\r\n    return pt1.X < pt2.X;\r\n  } else\r\n  {\r\n    if (pt1a.Y < pt1b.Y) SwapPoints(pt1a, pt1b);\r\n    if (pt2a.Y < pt2b.Y) SwapPoints(pt2a, pt2b);\r\n    if (pt1a.Y < pt2a.Y) pt1 = pt1a; else pt1 = pt2a;\r\n    if (pt1b.Y > pt2b.Y) pt2 = pt1b; else pt2 = pt2b;\r\n    return pt1.Y > pt2.Y;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool FirstIsBottomPt(const OutPt* btmPt1, const OutPt* btmPt2)\r\n{\r\n  OutPt *p = btmPt1->Prev;\r\n  while ((p->Pt == btmPt1->Pt) && (p != btmPt1)) p = p->Prev;\r\n  double dx1p = std::fabs(GetDx(btmPt1->Pt, p->Pt));\r\n  p = btmPt1->Next;\r\n  while ((p->Pt == btmPt1->Pt) && (p != btmPt1)) p = p->Next;\r\n  double dx1n = std::fabs(GetDx(btmPt1->Pt, p->Pt));\r\n\r\n  p = btmPt2->Prev;\r\n  while ((p->Pt == btmPt2->Pt) && (p != btmPt2)) p = p->Prev;\r\n  double dx2p = std::fabs(GetDx(btmPt2->Pt, p->Pt));\r\n  p = btmPt2->Next;\r\n  while ((p->Pt == btmPt2->Pt) && (p != btmPt2)) p = p->Next;\r\n  double dx2n = std::fabs(GetDx(btmPt2->Pt, p->Pt));\r\n  return (dx1p >= dx2p && dx1p >= dx2n) || (dx1n >= dx2p && dx1n >= dx2n);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutPt* GetBottomPt(OutPt *pp)\r\n{\r\n  OutPt* dups = 0;\r\n  OutPt* p = pp->Next;\r\n  while (p != pp)\r\n  {\r\n    if (p->Pt.Y > pp->Pt.Y)\r\n    {\r\n      pp = p;\r\n      dups = 0;\r\n    }\r\n    else if (p->Pt.Y == pp->Pt.Y && p->Pt.X <= pp->Pt.X)\r\n    {\r\n      if (p->Pt.X < pp->Pt.X)\r\n      {\r\n        dups = 0;\r\n        pp = p;\r\n      } else\r\n      {\r\n        if (p->Next != pp && p->Prev != pp) dups = p;\r\n      }\r\n    }\r\n    p = p->Next;\r\n  }\r\n  if (dups)\r\n  {\r\n    //there appears to be at least 2 vertices at BottomPt so ...\r\n    while (dups != p)\r\n    {\r\n      if (!FirstIsBottomPt(p, dups)) pp = dups;\r\n      dups = dups->Next;\r\n      while (dups->Pt != pp->Pt) dups = dups->Next;\r\n    }\r\n  }\r\n  return pp;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool FindSegment(OutPt* &pp, bool UseFullInt64Range, \r\n  IntPoint &pt1, IntPoint &pt2)\r\n{\r\n  //OutPt1 & OutPt2 => the overlap segment (if the function returns true)\r\n  if (!pp) return false;\r\n  OutPt* pp2 = pp;\r\n  IntPoint pt1a = pt1, pt2a = pt2;\r\n  do\r\n  {\r\n    if (SlopesEqual(pt1a, pt2a, pp->Pt, pp->Prev->Pt, UseFullInt64Range) &&\r\n      SlopesEqual(pt1a, pt2a, pp->Pt, UseFullInt64Range) &&\r\n      GetOverlapSegment(pt1a, pt2a, pp->Pt, pp->Prev->Pt, pt1, pt2))\r\n        return true;\r\n    pp = pp->Next;\r\n  }\r\n  while (pp != pp2);\r\n  return false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Pt2IsBetweenPt1AndPt3(const IntPoint pt1,\r\n  const IntPoint pt2, const IntPoint pt3)\r\n{\r\n  if ((pt1 == pt3) || (pt1 == pt2) || (pt3 == pt2))\r\n    return false;\r\n  else if (pt1.X != pt3.X)\r\n    return (pt2.X > pt1.X) == (pt2.X < pt3.X);\r\n  else\r\n    return (pt2.Y > pt1.Y) == (pt2.Y < pt3.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutPt* InsertPolyPtBetween(OutPt* p1, OutPt* p2, const IntPoint Pt)\r\n{\r\n  if (p1 == p2) throw \"JoinError\";\r\n  OutPt* result = new OutPt;\r\n  result->Pt = Pt;\r\n  if (p2 == p1->Next)\r\n  {\r\n    p1->Next = result;\r\n    p2->Prev = result;\r\n    result->Next = p2;\r\n    result->Prev = p1;\r\n  } else\r\n  {\r\n    p2->Next = result;\r\n    p1->Prev = result;\r\n    result->Next = p1;\r\n    result->Prev = p2;\r\n  }\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool HorzSegmentsOverlap(const IntPoint& pt1a, const IntPoint& pt1b, \r\n    const IntPoint& pt2a, const IntPoint& pt2b)\r\n{\r\n  //precondition: both segments are horizontal\r\n  if ((pt1a.X > pt2a.X) == (pt1a.X < pt2b.X)) return true;\r\n  else if ((pt1b.X > pt2a.X) == (pt1b.X < pt2b.X)) return true;\r\n  else if ((pt2a.X > pt1a.X) == (pt2a.X < pt1b.X)) return true;\r\n  else if ((pt2b.X > pt1a.X) == (pt2b.X < pt1b.X)) return true;\r\n  else if ((pt1a.X == pt2a.X) && (pt1b.X == pt2b.X)) return true;\r\n  else if ((pt1a.X == pt2b.X) && (pt1b.X == pt2a.X)) return true;\r\n  else return false;\r\n}\r\n\r\n\r\n//------------------------------------------------------------------------------\r\n// ClipperBase class methods ...\r\n//------------------------------------------------------------------------------\r\n\r\nClipperBase::ClipperBase() //constructor\r\n{\r\n  m_MinimaList = 0;\r\n  m_CurrentLM = 0;\r\n  m_UseFullRange = false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nClipperBase::~ClipperBase() //destructor\r\n{\r\n  Clear();\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid RangeTest(const IntPoint& Pt, bool& useFullRange)\r\n{\r\n  if (useFullRange)\r\n  {\r\n    if (Pt.X > hiRange || Pt.Y > hiRange || -Pt.X > hiRange || -Pt.Y > hiRange) \r\n      throw \"Coordinate outside allowed range\";\r\n  }\r\n  else if (Pt.X > loRange|| Pt.Y > loRange || -Pt.X > loRange || -Pt.Y > loRange) \r\n  {\r\n    useFullRange = true;\r\n    RangeTest(Pt, useFullRange);\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool ClipperBase::AddPath(const Path &pg, PolyType PolyTyp, bool Closed)\r\n{\r\n#ifdef use_lines\r\n  if (!Closed && PolyTyp == ptClip)\r\n    throw clipperException(\"AddPath: Open paths must be subject.\");\r\n#else\r\n  if (!Closed)\r\n    throw clipperException(\"AddPath: Open paths have been disabled.\");\r\n#endif\r\n\r\n  int highI = (int)pg.size() -1;\r\n  bool ClosedOrSemiClosed = (highI > 0) && (Closed || (pg[0] == pg[highI]));\r\n  while (highI > 0 && (pg[highI] == pg[0])) --highI;\r\n  while (highI > 0 && (pg[highI] == pg[highI -1])) --highI;\r\n  if ((Closed && highI < 2) || (!Closed && highI < 1)) return false;\r\n\r\n  //create a new edge array ...\r\n  TEdge *edges = new TEdge [highI +1];\r\n\r\n  //1. Basic initialization of Edges ...\r\n  try\r\n  {\r\n    edges[1].Curr = pg[1];\r\n    RangeTest(pg[0], m_UseFullRange);\r\n    RangeTest(pg[highI], m_UseFullRange);\r\n    InitEdge(&edges[0], &edges[1], &edges[highI], pg[0]);\r\n    InitEdge(&edges[highI], &edges[0], &edges[highI-1], pg[highI]);\r\n    for (int i = highI - 1; i >= 1; --i)\r\n    {\r\n      RangeTest(pg[i], m_UseFullRange);\r\n      InitEdge(&edges[i], &edges[i+1], &edges[i-1], pg[i]);\r\n    }\r\n  }\r\n  catch(...)\r\n  {\r\n    delete [] edges;\r\n    return false; //almost certainly a vertex has exceeded range\r\n  }\r\n\r\n  TEdge *eStart = &edges[0];\r\n  if (!ClosedOrSemiClosed) eStart->Prev->OutIdx = Skip;\r\n\r\n  //2. Remove duplicate vertices, and collinear edges (when closed) ...\r\n  TEdge *E = eStart, *eLoopStop = eStart;\r\n  for (;;)\r\n  {\r\n    if ((E->Curr == E->Next->Curr))\r\n    {\r\n      if (E == eStart) eStart = E->Next;\r\n      E = RemoveEdge(E);\r\n      eLoopStop = E;\r\n      continue;\r\n    }\r\n    if (E->Prev == E->Next) \r\n      break; //only two vertices\r\n    else if ((ClosedOrSemiClosed ||\r\n      (E->Prev->OutIdx != Skip && E->OutIdx != Skip &&\r\n      E->Next->OutIdx != Skip)) &&\r\n      SlopesEqual(E->Prev->Curr, E->Curr, E->Next->Curr, m_UseFullRange)) \r\n    {\r\n      //All collinear edges are allowed for open paths but in closed paths\r\n      //inner vertices of adjacent collinear edges are removed. However if the\r\n      //PreserveCollinear property has been enabled, only overlapping collinear\r\n      //edges (ie spikes) are removed from closed paths.\r\n      if (Closed && (!m_PreserveCollinear ||\r\n        !Pt2IsBetweenPt1AndPt3(E->Prev->Curr, E->Curr, E->Next->Curr))) \r\n      {\r\n        if (E == eStart) eStart = E->Next;\r\n        E = RemoveEdge(E);\r\n        E = E->Prev;\r\n        eLoopStop = E;\r\n        continue;\r\n      }\r\n    }\r\n    E = E->Next;\r\n    if (E == eLoopStop) break;\r\n  }\r\n\r\n  if ((!Closed && (E == E->Next)) || (Closed && (E->Prev == E->Next)))\r\n  {\r\n    delete [] edges;\r\n    return false;\r\n  }\r\n  m_edges.push_back(edges);\r\n\r\n  if (!Closed)\r\n    m_HasOpenPaths = true;\r\n\r\n  //3. Do final Init and also find the 'highest' Edge. (nb: since I'm much\r\n  //more familiar with positive downwards Y axes, 'highest' here will be\r\n  //the Edge with the *smallest* Top.Y.)\r\n  TEdge *eHighest = eStart;\r\n  E = eStart;\r\n  do\r\n  {\r\n    InitEdge2(*E, PolyTyp);\r\n    if (E->Top.Y < eHighest->Top.Y) eHighest = E;\r\n    E = E->Next;\r\n  }\r\n  while (E != eStart);\r\n\r\n  //4. build the local minima list ...\r\n  if (AllHorizontal(E))\r\n  {\r\n    if (ClosedOrSemiClosed)\r\n      E->Prev->OutIdx = Skip;\r\n    AscendToMax(E, false, false);\r\n    return true;\r\n  }\r\n\r\n  //if eHighest is also the Skip then it's a natural break, otherwise\r\n  //make sure eHighest is positioned so we're either at a top horizontal or\r\n  //just starting to head down one edge of the polygon\r\n  E = eStart->Prev; //EStart.Prev == Skip edge\r\n  if (E->Prev == E->Next)\r\n    eHighest = E->Next;\r\n  else if (!ClosedOrSemiClosed && E->Top.Y == eHighest->Top.Y)\r\n  {\r\n    if ((IsHorizontal(*E) || IsHorizontal(*E->Next)) && \r\n      E->Next->Bot.Y == eHighest->Top.Y)\r\n        eHighest = E->Next;\r\n    else if (SharedVertWithPrevAtTop(E)) eHighest = E;\r\n    else if (E->Top == E->Prev->Top) eHighest = E->Prev;\r\n    else eHighest = E->Next;\r\n  } else\r\n  {\r\n    E = eHighest;\r\n    while (IsHorizontal(*eHighest) ||\r\n      (eHighest->Top == eHighest->Next->Top) ||\r\n      (eHighest->Top == eHighest->Next->Bot)) //next is high horizontal\r\n    {\r\n      eHighest = eHighest->Next;\r\n      if (eHighest == E) \r\n      {\r\n        while (IsHorizontal(*eHighest) || !SharedVertWithPrevAtTop(eHighest))\r\n            eHighest = eHighest->Next;\r\n        break; //avoids potential endless loop\r\n      }\r\n    }\r\n  }\r\n  E = eHighest;\r\n  do\r\n    E = AddBoundsToLML(E, Closed);\r\n  while (E != eHighest);\r\n  return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool ClipperBase::AddPaths(const Paths &ppg, PolyType PolyTyp, bool Closed)\r\n{\r\n  bool result = false;\r\n  for (Paths::size_type i = 0; i < ppg.size(); ++i)\r\n    if (AddPath(ppg[i], PolyTyp, Closed)) result = true;\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClipperBase::InsertLocalMinima(LocalMinima *newLm)\r\n{\r\n  if( ! m_MinimaList )\r\n  {\r\n    m_MinimaList = newLm;\r\n  }\r\n  else if( newLm->Y >= m_MinimaList->Y )\r\n  {\r\n    newLm->Next = m_MinimaList;\r\n    m_MinimaList = newLm;\r\n  } else\r\n  {\r\n    LocalMinima* tmpLm = m_MinimaList;\r\n    while( tmpLm->Next  && ( newLm->Y < tmpLm->Next->Y ) )\r\n      tmpLm = tmpLm->Next;\r\n    newLm->Next = tmpLm->Next;\r\n    tmpLm->Next = newLm;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClipperBase::DoMinimaLML(TEdge* E1, TEdge* E2, bool IsClosed)\r\n{\r\n  if (!E1)\r\n  {\r\n    if (!E2) return;\r\n    LocalMinima* NewLm = new LocalMinima;\r\n    NewLm->Next = 0;\r\n    NewLm->Y = E2->Bot.Y;\r\n    NewLm->LeftBound = 0;\r\n    E2->WindDelta = 0;\r\n    NewLm->RightBound = E2;\r\n    InsertLocalMinima(NewLm);\r\n  } else\r\n  {\r\n    //E and E.Prev are now at a local minima ...\r\n    LocalMinima* NewLm = new LocalMinima;\r\n    NewLm->Y = E1->Bot.Y;\r\n    NewLm->Next = 0;\r\n    if (IsHorizontal(*E2)) //Horz. edges never start a Left bound\r\n    {\r\n      if (E2->Bot.X != E1->Bot.X) ReverseHorizontal(*E2);\r\n      NewLm->LeftBound = E1;\r\n      NewLm->RightBound = E2;\r\n    } else if (E2->Dx < E1->Dx)\r\n    {\r\n      NewLm->LeftBound = E1;\r\n      NewLm->RightBound = E2;\r\n    } else\r\n    {\r\n      NewLm->LeftBound = E2;\r\n      NewLm->RightBound = E1;\r\n    }\r\n    NewLm->LeftBound->Side = esLeft;\r\n    NewLm->RightBound->Side = esRight;\r\n    //set the winding state of the first edge in each bound\r\n    //(it'll be copied to subsequent edges in the bound) ...\r\n    if (!IsClosed) NewLm->LeftBound->WindDelta = 0;\r\n    else if (NewLm->LeftBound->Next == NewLm->RightBound) NewLm->LeftBound->WindDelta = -1;\r\n    else NewLm->LeftBound->WindDelta = 1;\r\n    NewLm->RightBound->WindDelta = -NewLm->LeftBound->WindDelta;\r\n    InsertLocalMinima(NewLm);\r\n  }\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nTEdge* ClipperBase::DescendToMin(TEdge *&E)\r\n{\r\n  //PRECONDITION: STARTING EDGE IS A VALID DESCENDING EDGE.\r\n  //Starting at the top of one bound we progress to the bottom where there's\r\n  //A local minima. We  go to the top of the Next bound. These two bounds\r\n  //form the left and right (or right and left) bounds of the local minima.\r\n  TEdge* EHorz;\r\n  E->NextInLML = 0;\r\n  if (IsHorizontal(*E)) \r\n  {\r\n    EHorz = E;\r\n    while (IsHorizontal(*EHorz->Next)) EHorz = EHorz->Next;\r\n    if (EHorz->Bot != EHorz->Next->Top)\r\n      ReverseHorizontal(*E);\r\n  }\r\n  for (;;)\r\n  {\r\n    E = E->Next;\r\n    if (E->OutIdx == Skip) break;\r\n    else if (IsHorizontal(*E))\r\n    {\r\n      //nb: proceed through horizontals when approaching from their right,\r\n      //    but break on horizontal minima if approaching from their left.\r\n      //    This ensures 'local minima' are always on the left of horizontals.\r\n\r\n      //look ahead is required in case of multiple consec. horizontals\r\n      EHorz = GetLastHorz(E);\r\n      if(EHorz == E->Prev ||                    //horizontal line\r\n        (EHorz->Next->Top.Y < E->Top.Y &&      //bottom horizontal\r\n        EHorz->Next->Bot.X > E->Prev->Bot.X))  //approaching from the left\r\n          break;\r\n      if (E->Top.X != E->Prev->Bot.X)  ReverseHorizontal(*E);\r\n      if (EHorz->OutIdx == Skip) EHorz = EHorz->Prev;\r\n      while (E != EHorz)\r\n      {\r\n        E->NextInLML = E->Prev;\r\n        E = E->Next;\r\n        if (E->Top.X != E->Prev->Bot.X) ReverseHorizontal(*E);\r\n      }\r\n    }\r\n    else if (E->Bot.Y == E->Prev->Bot.Y)  break;\r\n    E->NextInLML = E->Prev;\r\n  }\r\n  return E->Prev;\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nvoid ClipperBase::AscendToMax(TEdge *&E, bool Appending, bool IsClosed)\r\n{\r\n  if (E->OutIdx == Skip)\r\n  {\r\n    E = E->Next;\r\n    if (!MoreAbove(E->Prev)) return;\r\n  }\r\n\r\n  if (IsHorizontal(*E) && Appending && (E->Bot != E->Prev->Bot))\r\n      ReverseHorizontal(*E);\r\n  //now process the ascending bound ....\r\n  TEdge *EStart = E;\r\n  for (;;)\r\n  {\r\n    if (E->Next->OutIdx == Skip ||\r\n      ((E->Next->Top.Y == E->Top.Y) && !IsHorizontal(*E->Next))) break;\r\n    E->NextInLML = E->Next;\r\n    E = E->Next;\r\n    if (IsHorizontal(*E) && (E->Bot.X != E->Prev->Top.X))\r\n      ReverseHorizontal(*E);\r\n  }\r\n\r\n  if (!Appending)\r\n  {\r\n    if (EStart->OutIdx == Skip) EStart = EStart->Next;\r\n    if (EStart != E->Next)\r\n      DoMinimaLML(0, EStart, IsClosed);\r\n  }\r\n  E = E->Next;\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nTEdge* ClipperBase::AddBoundsToLML(TEdge* E, bool IsClosed)\r\n{\r\n  //Starting at the top of one bound we progress to the bottom where there's\r\n  //A local minima. We then go to the top of the Next bound. These two bounds\r\n  //form the left and right (or right and left) bounds of the local minima.\r\n\r\n  TEdge* B;\r\n  bool AppendMaxima;\r\n  //do minima ...\r\n  if (E->OutIdx == Skip)\r\n  {\r\n    if (MoreBelow(E))\r\n    {\r\n      E = E->Next;\r\n      B = DescendToMin(E);\r\n    } else\r\n      B = 0;\r\n  } else\r\n    B = DescendToMin(E);\r\n\r\n  if (E->OutIdx == Skip)    //nb: may be BEFORE, AT or just THRU LM\r\n  {\r\n    //do minima before Skip...\r\n    DoMinimaLML(0, B, IsClosed);      //store what we've got so far (if anything)\r\n    AppendMaxima = false;\r\n    //finish off any minima ...\r\n    if ((E->Bot != E->Prev->Bot) && MoreBelow(E)) \r\n    {\r\n      E = E->Next;\r\n      B = DescendToMin(E);\r\n      DoMinimaLML(B, E, IsClosed);\r\n      AppendMaxima = true;\r\n    }\r\n    else if (JustBeforeLocMin(E))\r\n      E = E->Next;\r\n  } else\r\n  {\r\n    DoMinimaLML(B, E, IsClosed);\r\n    AppendMaxima = true;\r\n  }\r\n\r\n  //now do maxima ...\r\n  AscendToMax(E, AppendMaxima, IsClosed);\r\n\r\n  if (E->OutIdx == Skip && (E->Top != E->Prev->Top))     \r\n  {\r\n    //may be BEFORE, AT or just AFTER maxima\r\n    //finish off any maxima ...\r\n    if (MoreAbove(E)) \r\n    {\r\n      E = E->Next;\r\n      AscendToMax(E, false, IsClosed);\r\n    }\r\n    else if ((E->Top == E->Next->Top) ||\r\n      (IsHorizontal(*E->Next) && (E->Top == E->Next->Bot))) \r\n      E = E->Next; //ie just before Maxima\r\n  }\r\n  return E;\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nvoid ClipperBase::Clear()\r\n{\r\n  DisposeLocalMinimaList();\r\n  for (EdgeList::size_type i = 0; i < m_edges.size(); ++i)\r\n  {\r\n    //for each edge array in turn, find the first used edge and \r\n    //check for and remove any hiddenPts in each edge in the array.\r\n    TEdge* edges = m_edges[i];\r\n    delete [] edges;\r\n  }\r\n  m_edges.clear();\r\n  m_UseFullRange = false;\r\n  m_HasOpenPaths = false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClipperBase::Reset()\r\n{\r\n  m_CurrentLM = m_MinimaList;\r\n  if( !m_CurrentLM ) return; //ie nothing to process\r\n\r\n  //reset all edges ...\r\n  LocalMinima* lm = m_MinimaList;\r\n  while( lm )\r\n  {\r\n    TEdge* e = lm->LeftBound;\r\n    if (e)\r\n    {\r\n      e->Curr = e->Bot;\r\n      e->Side = esLeft;\r\n      if (e->OutIdx != Skip)\r\n        e->OutIdx = Unassigned;\r\n    }\r\n    e = lm->RightBound;\r\n    e->Curr = e->Bot;\r\n    e->Side = esRight;\r\n    if (e->OutIdx != Skip)\r\n      e->OutIdx = Unassigned;\r\n\r\n    lm = lm->Next;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClipperBase::DisposeLocalMinimaList()\r\n{\r\n  while( m_MinimaList )\r\n  {\r\n    LocalMinima* tmpLm = m_MinimaList->Next;\r\n    delete m_MinimaList;\r\n    m_MinimaList = tmpLm;\r\n  }\r\n  m_CurrentLM = 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClipperBase::PopLocalMinima()\r\n{\r\n  if( ! m_CurrentLM ) return;\r\n  m_CurrentLM = m_CurrentLM->Next;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nIntRect ClipperBase::GetBounds()\r\n{\r\n  IntRect result;\r\n  LocalMinima* lm = m_MinimaList;\r\n  if (!lm)\r\n  {\r\n    result.left = result.top = result.right = result.bottom = 0;\r\n    return result;\r\n  }\r\n  result.left = lm->LeftBound->Bot.X;\r\n  result.top = lm->LeftBound->Bot.Y;\r\n  result.right = lm->LeftBound->Bot.X;\r\n  result.bottom = lm->LeftBound->Bot.Y;\r\n  while (lm)\r\n  {\r\n    if (lm->LeftBound->Bot.Y > result.bottom)\r\n      result.bottom = lm->LeftBound->Bot.Y;\r\n    TEdge* e = lm->LeftBound;\r\n    for (;;) {\r\n      TEdge* bottomE = e;\r\n      while (e->NextInLML)\r\n      {\r\n        if (e->Bot.X < result.left) result.left = e->Bot.X;\r\n        if (e->Bot.X > result.right) result.right = e->Bot.X;\r\n        e = e->NextInLML;\r\n      }\r\n      if (e->Bot.X < result.left) result.left = e->Bot.X;\r\n      if (e->Bot.X > result.right) result.right = e->Bot.X;\r\n      if (e->Top.X < result.left) result.left = e->Top.X;\r\n      if (e->Top.X > result.right) result.right = e->Top.X;\r\n      if (e->Top.Y < result.top) result.top = e->Top.Y;\r\n\r\n      if (bottomE == lm->LeftBound) e = lm->RightBound;\r\n      else break;\r\n    }\r\n    lm = lm->Next;\r\n  }\r\n  return result;\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// TClipper methods ...\r\n//------------------------------------------------------------------------------\r\n\r\nClipper::Clipper(int initOptions) : ClipperBase() //constructor\r\n{\r\n  m_ActiveEdges = 0;\r\n  m_SortedEdges = 0;\r\n  m_IntersectNodes = 0;\r\n  m_ExecuteLocked = false;\r\n  m_UseFullRange = false;\r\n  m_ReverseOutput = ((initOptions & ioReverseSolution) != 0);\r\n  m_StrictSimple = ((initOptions & ioStrictlySimple) != 0);\r\n  m_PreserveCollinear = ((initOptions & ioPreserveCollinear) != 0);\r\n  m_HasOpenPaths = false;\r\n#ifdef use_xyz  \r\n  m_ZFill = 0;\r\n#endif\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nClipper::~Clipper() //destructor\r\n{\r\n  Clear();\r\n  m_Scanbeam.clear();\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef use_xyz  \r\nvoid Clipper::ZFillFunction(TZFillCallback zFillFunc)\r\n{  \r\n  m_ZFill = zFillFunc;\r\n}\r\n//------------------------------------------------------------------------------\r\n#endif\r\n\r\nvoid Clipper::Clear()\r\n{\r\n  if (m_edges.empty()) return; //avoids problems with ClipperBase destructor\r\n  DisposeAllOutRecs();\r\n  ClipperBase::Clear();\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::Reset()\r\n{\r\n  ClipperBase::Reset();\r\n  m_Scanbeam.clear();\r\n  m_ActiveEdges = 0;\r\n  m_SortedEdges = 0;\r\n  DisposeAllOutRecs();\r\n  LocalMinima* lm = m_MinimaList;\r\n  while (lm)\r\n  {\r\n    InsertScanbeam(lm->Y);\r\n    lm = lm->Next;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::Execute(ClipType clipType, Paths &solution,\r\n    PolyFillType subjFillType, PolyFillType clipFillType)\r\n{\r\n  if( m_ExecuteLocked ) return false;\r\n  if (m_HasOpenPaths)\r\n    throw clipperException(\"Error: PolyTree struct is need for open path clipping.\");\r\n  m_ExecuteLocked = true;\r\n  solution.resize(0);\r\n  m_SubjFillType = subjFillType;\r\n  m_ClipFillType = clipFillType;\r\n  m_ClipType = clipType;\r\n  m_UsingPolyTree = false;\r\n  bool succeeded = ExecuteInternal();\r\n  if (succeeded) BuildResult(solution);\r\n  m_ExecuteLocked = false;\r\n  return succeeded;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::Execute(ClipType clipType, PolyTree& polytree,\r\n    PolyFillType subjFillType, PolyFillType clipFillType)\r\n{\r\n  if( m_ExecuteLocked ) return false;\r\n  m_ExecuteLocked = true;\r\n  m_SubjFillType = subjFillType;\r\n  m_ClipFillType = clipFillType;\r\n  m_ClipType = clipType;\r\n  m_UsingPolyTree = true;\r\n  bool succeeded = ExecuteInternal();\r\n  if (succeeded) BuildResult2(polytree);\r\n  m_ExecuteLocked = false;\r\n  return succeeded;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::FixHoleLinkage(OutRec &outrec)\r\n{\r\n  //skip OutRecs that (a) contain outermost polygons or\r\n  //(b) already have the correct owner/child linkage ...\r\n  if (!outrec.FirstLeft ||                \r\n      (outrec.IsHole != outrec.FirstLeft->IsHole &&\r\n      outrec.FirstLeft->Pts)) return;\r\n\r\n  OutRec* orfl = outrec.FirstLeft;\r\n  while (orfl && ((orfl->IsHole == outrec.IsHole) || !orfl->Pts))\r\n      orfl = orfl->FirstLeft;\r\n  outrec.FirstLeft = orfl;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::ExecuteInternal()\r\n{\r\n  bool succeeded = true;\r\n  try {\r\n    Reset();\r\n    if (!m_CurrentLM) return false;\r\n    cInt botY = PopScanbeam();\r\n    do {\r\n      InsertLocalMinimaIntoAEL(botY);\r\n      ClearGhostJoins();\r\n      ProcessHorizontals(false);\r\n      if (m_Scanbeam.empty()) break;\r\n      cInt topY = PopScanbeam();\r\n      succeeded = ProcessIntersections(botY, topY);\r\n      if (!succeeded) break;\r\n      ProcessEdgesAtTopOfScanbeam(topY);\r\n      botY = topY;\r\n    } while (!m_Scanbeam.empty() || m_CurrentLM);\r\n  }\r\n  catch(...) \r\n  {\r\n    succeeded = false;\r\n  }\r\n\r\n  if (succeeded)\r\n  {\r\n    //fix orientations ...\r\n    for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n    {\r\n      OutRec *outRec = m_PolyOuts[i];\r\n      if (!outRec->Pts || outRec->IsOpen) continue;\r\n      if ((outRec->IsHole ^ m_ReverseOutput) == (Area(*outRec) > 0))\r\n        ReversePolyPtLinks(outRec->Pts);\r\n    }\r\n\r\n    if (!m_Joins.empty()) JoinCommonEdges();\r\n\r\n    //unfortunately FixupOutPolygon() must be done after JoinCommonEdges()\r\n    for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n    {\r\n      OutRec *outRec = m_PolyOuts[i];\r\n      if (outRec->Pts && !outRec->IsOpen)\r\n        FixupOutPolygon(*outRec);\r\n    }\r\n\r\n    if (m_StrictSimple) DoSimplePolygons();\r\n  }\r\n\r\n  ClearJoins();\r\n  ClearGhostJoins();\r\n  return succeeded;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::InsertScanbeam(const cInt Y)\r\n{\r\n  m_Scanbeam.insert(Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ncInt Clipper::PopScanbeam()\r\n{\r\n  cInt Y = *m_Scanbeam.begin();\r\n  m_Scanbeam.erase(m_Scanbeam.begin());\r\n  return Y;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DisposeAllOutRecs(){\r\n  for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n    DisposeOutRec(i);\r\n  m_PolyOuts.clear();\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DisposeOutRec(PolyOutList::size_type index)\r\n{\r\n  OutRec *outRec = m_PolyOuts[index];\r\n  if (outRec->Pts) DisposeOutPts(outRec->Pts);\r\n  delete outRec;\r\n  m_PolyOuts[index] = 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::SetWindingCount(TEdge &edge)\r\n{\r\n  TEdge *e = edge.PrevInAEL;\r\n  //find the edge of the same polytype that immediately preceeds 'edge' in AEL\r\n  while (e  && ((e->PolyTyp != edge.PolyTyp) || (e->WindDelta == 0))) e = e->PrevInAEL;\r\n  if (!e)\r\n  {\r\n    edge.WindCnt = (edge.WindDelta == 0 ? 1 : edge.WindDelta);\r\n    edge.WindCnt2 = 0;\r\n    e = m_ActiveEdges; //ie get ready to calc WindCnt2\r\n  }   \r\n  else if (edge.WindDelta == 0 && m_ClipType != ctUnion)\r\n  {\r\n    edge.WindCnt = 1;\r\n    edge.WindCnt2 = e->WindCnt2;\r\n    e = e->NextInAEL; //ie get ready to calc WindCnt2\r\n  }\r\n  else if (IsEvenOddFillType(edge))\r\n  {\r\n    //EvenOdd filling ...\r\n    if (edge.WindDelta == 0)\r\n    {\r\n      //are we inside a subj polygon ...\r\n      bool Inside = true;\r\n      TEdge *e2 = e->PrevInAEL;\r\n      while (e2)\r\n      {\r\n        if (e2->PolyTyp == e->PolyTyp && e2->WindDelta != 0) \r\n          Inside = !Inside;\r\n        e2 = e2->PrevInAEL;\r\n      }\r\n      edge.WindCnt = (Inside ? 0 : 1);\r\n    }\r\n    else\r\n    {\r\n      edge.WindCnt = edge.WindDelta;\r\n    }\r\n    edge.WindCnt2 = e->WindCnt2;\r\n    e = e->NextInAEL; //ie get ready to calc WindCnt2\r\n  } \r\n  else\r\n  {\r\n    //nonZero, Positive or Negative filling ...\r\n    if (e->WindCnt * e->WindDelta < 0)\r\n    {\r\n      //prev edge is 'decreasing' WindCount (WC) toward zero\r\n      //so we're outside the previous polygon ...\r\n      if (Abs(e->WindCnt) > 1)\r\n      {\r\n        //outside prev poly but still inside another.\r\n        //when reversing direction of prev poly use the same WC \r\n        if (e->WindDelta * edge.WindDelta < 0) edge.WindCnt = e->WindCnt;\r\n        //otherwise continue to 'decrease' WC ...\r\n        else edge.WindCnt = e->WindCnt + edge.WindDelta;\r\n      } \r\n      else\r\n        //now outside all polys of same polytype so set own WC ...\r\n        edge.WindCnt = (edge.WindDelta == 0 ? 1 : edge.WindDelta);\r\n    } else\r\n    {\r\n      //prev edge is 'increasing' WindCount (WC) away from zero\r\n      //so we're inside the previous polygon ...\r\n      if (edge.WindDelta == 0) \r\n        edge.WindCnt = (e->WindCnt < 0 ? e->WindCnt - 1 : e->WindCnt + 1);\r\n      //if wind direction is reversing prev then use same WC\r\n      else if (e->WindDelta * edge.WindDelta < 0) edge.WindCnt = e->WindCnt;\r\n      //otherwise add to WC ...\r\n      else edge.WindCnt = e->WindCnt + edge.WindDelta;\r\n    }\r\n    edge.WindCnt2 = e->WindCnt2;\r\n    e = e->NextInAEL; //ie get ready to calc WindCnt2\r\n  }\r\n\r\n  //update WindCnt2 ...\r\n  if (IsEvenOddAltFillType(edge))\r\n  {\r\n    //EvenOdd filling ...\r\n    while (e != &edge)\r\n    {\r\n      if (e->WindDelta != 0)\r\n        edge.WindCnt2 = (edge.WindCnt2 == 0 ? 1 : 0);\r\n      e = e->NextInAEL;\r\n    }\r\n  } else\r\n  {\r\n    //nonZero, Positive or Negative filling ...\r\n    while ( e != &edge )\r\n    {\r\n      edge.WindCnt2 += e->WindDelta;\r\n      e = e->NextInAEL;\r\n    }\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::IsEvenOddFillType(const TEdge& edge) const\r\n{\r\n  if (edge.PolyTyp == ptSubject)\r\n    return m_SubjFillType == pftEvenOdd; else\r\n    return m_ClipFillType == pftEvenOdd;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::IsEvenOddAltFillType(const TEdge& edge) const\r\n{\r\n  if (edge.PolyTyp == ptSubject)\r\n    return m_ClipFillType == pftEvenOdd; else\r\n    return m_SubjFillType == pftEvenOdd;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::IsContributing(const TEdge& edge) const\r\n{\r\n  PolyFillType pft, pft2;\r\n  if (edge.PolyTyp == ptSubject)\r\n  {\r\n    pft = m_SubjFillType;\r\n    pft2 = m_ClipFillType;\r\n  } else\r\n  {\r\n    pft = m_ClipFillType;\r\n    pft2 = m_SubjFillType;\r\n  }\r\n\r\n  switch(pft)\r\n  {\r\n    case pftEvenOdd: \r\n      //return false if a subj line has been flagged as inside a subj polygon\r\n      if (edge.WindDelta == 0 && edge.WindCnt != 1) return false;\r\n      break;\r\n    case pftNonZero:\r\n      if (Abs(edge.WindCnt) != 1) return false;\r\n      break;\r\n    case pftPositive: \r\n      if (edge.WindCnt != 1) return false;\r\n      break;\r\n    default: //pftNegative\r\n      if (edge.WindCnt != -1) return false;\r\n  }\r\n\r\n  switch(m_ClipType)\r\n  {\r\n    case ctIntersection:\r\n      switch(pft2)\r\n      {\r\n        case pftEvenOdd: \r\n        case pftNonZero: \r\n          return (edge.WindCnt2 != 0);\r\n        case pftPositive: \r\n          return (edge.WindCnt2 > 0);\r\n        default: \r\n          return (edge.WindCnt2 < 0);\r\n      }\r\n      break;\r\n    case ctUnion:\r\n      switch(pft2)\r\n      {\r\n        case pftEvenOdd: \r\n        case pftNonZero: \r\n          return (edge.WindCnt2 == 0);\r\n        case pftPositive: \r\n          return (edge.WindCnt2 <= 0);\r\n        default: \r\n          return (edge.WindCnt2 >= 0);\r\n      }\r\n      break;\r\n    case ctDifference:\r\n      if (edge.PolyTyp == ptSubject)\r\n        switch(pft2)\r\n        {\r\n          case pftEvenOdd: \r\n          case pftNonZero: \r\n            return (edge.WindCnt2 == 0);\r\n          case pftPositive: \r\n            return (edge.WindCnt2 <= 0);\r\n          default: \r\n            return (edge.WindCnt2 >= 0);\r\n        }\r\n      else\r\n        switch(pft2)\r\n        {\r\n          case pftEvenOdd: \r\n          case pftNonZero: \r\n            return (edge.WindCnt2 != 0);\r\n          case pftPositive: \r\n            return (edge.WindCnt2 > 0);\r\n          default: \r\n            return (edge.WindCnt2 < 0);\r\n        }\r\n      break;\r\n    case ctXor:\r\n      if (edge.WindDelta == 0) //XOr always contributing unless open\r\n        switch(pft2)\r\n        {\r\n          case pftEvenOdd: \r\n          case pftNonZero: \r\n            return (edge.WindCnt2 == 0);\r\n          case pftPositive: \r\n            return (edge.WindCnt2 <= 0);\r\n          default: \r\n            return (edge.WindCnt2 >= 0);\r\n        }\r\n      else \r\n        return true;\r\n      break;\r\n    default:\r\n      return true;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutPt* Clipper::AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &Pt)\r\n{\r\n  OutPt* result;\r\n  TEdge *e, *prevE;\r\n  if (IsHorizontal(*e2) || ( e1->Dx > e2->Dx ))\r\n  {\r\n    result = AddOutPt(e1, Pt);\r\n    e2->OutIdx = e1->OutIdx;\r\n    e1->Side = esLeft;\r\n    e2->Side = esRight;\r\n    e = e1;\r\n    if (e->PrevInAEL == e2)\r\n      prevE = e2->PrevInAEL; \r\n    else\r\n      prevE = e->PrevInAEL;\r\n  } else\r\n  {\r\n    result = AddOutPt(e2, Pt);\r\n    e1->OutIdx = e2->OutIdx;\r\n    e1->Side = esRight;\r\n    e2->Side = esLeft;\r\n    e = e2;\r\n    if (e->PrevInAEL == e1)\r\n        prevE = e1->PrevInAEL;\r\n    else\r\n        prevE = e->PrevInAEL;\r\n  }\r\n\r\n  if (prevE && prevE->OutIdx >= 0 &&\r\n      (TopX(*prevE, Pt.Y) == TopX(*e, Pt.Y)) &&\r\n      SlopesEqual(*e, *prevE, m_UseFullRange) &&\r\n      (e->WindDelta != 0) && (prevE->WindDelta != 0))\r\n  {\r\n    OutPt* outPt = AddOutPt(prevE, Pt);\r\n    AddJoin(result, outPt, e->Top);\r\n  }\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &Pt)\r\n{\r\n  AddOutPt( e1, Pt );\r\n  if( e1->OutIdx == e2->OutIdx )\r\n  {\r\n    e1->OutIdx = Unassigned;\r\n    e2->OutIdx = Unassigned;\r\n  }\r\n  else if (e1->OutIdx < e2->OutIdx) \r\n    AppendPolygon(e1, e2); \r\n  else \r\n    AppendPolygon(e2, e1);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::AddEdgeToSEL(TEdge *edge)\r\n{\r\n  //SEL pointers in PEdge are reused to build a list of horizontal edges.\r\n  //However, we don't need to worry about order with horizontal edge processing.\r\n  if( !m_SortedEdges )\r\n  {\r\n    m_SortedEdges = edge;\r\n    edge->PrevInSEL = 0;\r\n    edge->NextInSEL = 0;\r\n  }\r\n  else\r\n  {\r\n    edge->NextInSEL = m_SortedEdges;\r\n    edge->PrevInSEL = 0;\r\n    m_SortedEdges->PrevInSEL = edge;\r\n    m_SortedEdges = edge;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::CopyAELToSEL()\r\n{\r\n  TEdge* e = m_ActiveEdges;\r\n  m_SortedEdges = e;\r\n  while ( e )\r\n  {\r\n    e->PrevInSEL = e->PrevInAEL;\r\n    e->NextInSEL = e->NextInAEL;\r\n    e = e->NextInAEL;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::AddJoin(OutPt *op1, OutPt *op2, const IntPoint OffPt)\r\n{\r\n  Join* j = new Join;\r\n  j->OutPt1 = op1;\r\n  j->OutPt2 = op2;\r\n  j->OffPt = OffPt;\r\n  m_Joins.push_back(j);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::ClearJoins()\r\n{\r\n  for (JoinList::size_type i = 0; i < m_Joins.size(); i++)\r\n    delete m_Joins[i];\r\n  m_Joins.resize(0);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::ClearGhostJoins()\r\n{\r\n  for (JoinList::size_type i = 0; i < m_GhostJoins.size(); i++)\r\n    delete m_GhostJoins[i];\r\n  m_GhostJoins.resize(0);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::AddGhostJoin(OutPt *op, const IntPoint OffPt)\r\n{\r\n  Join* j = new Join;\r\n  j->OutPt1 = op;\r\n  j->OutPt2 = 0;\r\n  j->OffPt = OffPt;\r\n  m_GhostJoins.push_back(j);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::InsertLocalMinimaIntoAEL(const cInt botY)\r\n{\r\n  while(  m_CurrentLM  && ( m_CurrentLM->Y == botY ) )\r\n  {\r\n    TEdge* lb = m_CurrentLM->LeftBound;\r\n    TEdge* rb = m_CurrentLM->RightBound;\r\n    PopLocalMinima();\r\n    OutPt *Op1 = 0;\r\n    if (!lb)\r\n    {\r\n      //nb: don't insert LB into either AEL or SEL\r\n      InsertEdgeIntoAEL(rb, 0);\r\n      SetWindingCount(*rb);\r\n      if (IsContributing(*rb))\r\n        Op1 = AddOutPt(rb, rb->Bot); \r\n    } \r\n    else\r\n    {\r\n      InsertEdgeIntoAEL(lb, 0);\r\n      InsertEdgeIntoAEL(rb, lb);\r\n      SetWindingCount( *lb );\r\n      rb->WindCnt = lb->WindCnt;\r\n      rb->WindCnt2 = lb->WindCnt2;\r\n      if (IsContributing(*lb))\r\n        Op1 = AddLocalMinPoly(lb, rb, lb->Bot);      \r\n      InsertScanbeam(lb->Top.Y);\r\n    }\r\n\r\n    if(IsHorizontal(*rb))\r\n      AddEdgeToSEL(rb);\r\n    else\r\n      InsertScanbeam( rb->Top.Y );\r\n\r\n    if (!lb) continue;\r\n\r\n    //if any output polygons share an edge, they'll need joining later ...\r\n    if (Op1 && IsHorizontal(*rb) && \r\n      m_GhostJoins.size() > 0 && (rb->WindDelta != 0))\r\n    {\r\n      for (JoinList::size_type i = 0; i < m_GhostJoins.size(); ++i)\r\n      {\r\n        Join* jr = m_GhostJoins[i];\r\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\r\n        //the 'ghost' join to a real join ready for later ...\r\n        if (HorzSegmentsOverlap(jr->OutPt1->Pt, jr->OffPt, rb->Bot, rb->Top))\r\n          AddJoin(jr->OutPt1, Op1, jr->OffPt);\r\n      }\r\n    }\r\n\r\n    if (lb->OutIdx >= 0 && lb->PrevInAEL && \r\n      lb->PrevInAEL->Curr.X == lb->Bot.X &&\r\n      lb->PrevInAEL->OutIdx >= 0 &&\r\n      SlopesEqual(*lb->PrevInAEL, *lb, m_UseFullRange) &&\r\n      (lb->WindDelta != 0) && (lb->PrevInAEL->WindDelta != 0))\r\n    {\r\n        OutPt *Op2 = AddOutPt(lb->PrevInAEL, lb->Bot);\r\n        AddJoin(Op1, Op2, lb->Top);\r\n    }\r\n\r\n    if(lb->NextInAEL != rb)\r\n    {\r\n\r\n      if (rb->OutIdx >= 0 && rb->PrevInAEL->OutIdx >= 0 &&\r\n        SlopesEqual(*rb->PrevInAEL, *rb, m_UseFullRange) &&\r\n        (rb->WindDelta != 0) && (rb->PrevInAEL->WindDelta != 0))\r\n      {\r\n          OutPt *Op2 = AddOutPt(rb->PrevInAEL, rb->Bot);\r\n          AddJoin(Op1, Op2, rb->Top);\r\n      }\r\n\r\n      TEdge* e = lb->NextInAEL;\r\n      if (e)\r\n      {\r\n        while( e != rb )\r\n        {\r\n          //nb: For calculating winding counts etc, IntersectEdges() assumes\r\n          //that param1 will be to the Right of param2 ABOVE the intersection ...\r\n          IntersectEdges(rb , e , lb->Curr); //order important here\r\n          e = e->NextInAEL;\r\n        }\r\n      }\r\n    }\r\n    \r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DeleteFromAEL(TEdge *e)\r\n{\r\n  TEdge* AelPrev = e->PrevInAEL;\r\n  TEdge* AelNext = e->NextInAEL;\r\n  if(  !AelPrev &&  !AelNext && (e != m_ActiveEdges) ) return; //already deleted\r\n  if( AelPrev ) AelPrev->NextInAEL = AelNext;\r\n  else m_ActiveEdges = AelNext;\r\n  if( AelNext ) AelNext->PrevInAEL = AelPrev;\r\n  e->NextInAEL = 0;\r\n  e->PrevInAEL = 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DeleteFromSEL(TEdge *e)\r\n{\r\n  TEdge* SelPrev = e->PrevInSEL;\r\n  TEdge* SelNext = e->NextInSEL;\r\n  if( !SelPrev &&  !SelNext && (e != m_SortedEdges) ) return; //already deleted\r\n  if( SelPrev ) SelPrev->NextInSEL = SelNext;\r\n  else m_SortedEdges = SelNext;\r\n  if( SelNext ) SelNext->PrevInSEL = SelPrev;\r\n  e->NextInSEL = 0;\r\n  e->PrevInSEL = 0;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef use_xyz\r\n\r\nvoid Clipper::SetZ(IntPoint& pt, TEdge& e)\r\n{\r\n  pt.Z = 0;\r\n  if (m_ZFill)\r\n  {\r\n    //put the 'preferred' point as first parameter ...\r\n    if (e.OutIdx < 0)\r\n      (*m_ZFill)(e.Bot, e.Top, pt); //outside a path so presume entering\r\n    else\r\n      (*m_ZFill)(e.Top, e.Bot, pt); //inside a path so presume exiting\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n#endif\r\n\r\nvoid Clipper::IntersectEdges(TEdge *e1, TEdge *e2,\r\n     const IntPoint &Pt, bool protect)\r\n{\r\n  //e1 will be to the Left of e2 BELOW the intersection. Therefore e1 is before\r\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\r\n  bool e1stops = !protect &&  !e1->NextInLML &&\r\n    e1->Top.X == Pt.X && e1->Top.Y == Pt.Y;\r\n  bool e2stops = !protect &&  !e2->NextInLML &&\r\n    e2->Top.X == Pt.X && e2->Top.Y == Pt.Y;\r\n  bool e1Contributing = ( e1->OutIdx >= 0 );\r\n  bool e2Contributing = ( e2->OutIdx >= 0 );\r\n\r\n#ifdef use_lines\r\n  //if either edge is on an OPEN path ...\r\n  if (e1->WindDelta == 0 || e2->WindDelta == 0)\r\n  {\r\n    //ignore subject-subject open path intersections UNLESS they\r\n    //are both open paths, AND they are both 'contributing maximas' ...\r\n    if (e1->WindDelta == 0 && e2->WindDelta == 0)\r\n    {\r\n      if ((e1stops || e2stops) && e1Contributing && e2Contributing)\r\n        AddLocalMaxPoly(e1, e2, Pt);\r\n    }\r\n\r\n    //if intersecting a subj line with a subj poly ...\r\n    else if (e1->PolyTyp == e2->PolyTyp && \r\n      e1->WindDelta != e2->WindDelta && m_ClipType == ctUnion)\r\n    {\r\n      if (e1->WindDelta == 0)\r\n      {\r\n        if (e2Contributing)\r\n        {\r\n          AddOutPt(e1, Pt);\r\n          if (e1Contributing) e1->OutIdx = Unassigned;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        if (e1Contributing)\r\n        {\r\n          AddOutPt(e2, Pt);\r\n          if (e2Contributing) e2->OutIdx = Unassigned;\r\n        }\r\n      }\r\n    }\r\n    else if (e1->PolyTyp != e2->PolyTyp)\r\n    {\r\n      //toggle subj open path OutIdx on/off when Abs(clip.WndCnt) == 1 ...\r\n      if ((e1->WindDelta == 0) && abs(e2->WindCnt) == 1 && \r\n        (m_ClipType != ctUnion || e2->WindCnt2 == 0))\r\n      {\r\n        AddOutPt(e1, Pt);\r\n        if (e1Contributing) e1->OutIdx = Unassigned;\r\n      }\r\n      else if ((e2->WindDelta == 0) && (abs(e1->WindCnt) == 1) && \r\n        (m_ClipType != ctUnion || e1->WindCnt2 == 0))\r\n      {\r\n        AddOutPt(e2, Pt);\r\n        if (e2Contributing) e2->OutIdx = Unassigned;\r\n      }\r\n    }\r\n\r\n    if (e1stops)\r\n      if (e1->OutIdx < 0) DeleteFromAEL(e1);\r\n      else throw clipperException(\"Error intersecting polylines\");\r\n    if (e2stops) \r\n      if (e2->OutIdx < 0) DeleteFromAEL(e2);\r\n      else throw clipperException(\"Error intersecting polylines\");\r\n    return;\r\n  }\r\n#endif\r\n\r\n  //update winding counts...\r\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\r\n  if ( e1->PolyTyp == e2->PolyTyp )\r\n  {\r\n    if ( IsEvenOddFillType( *e1) )\r\n    {\r\n      int oldE1WindCnt = e1->WindCnt;\r\n      e1->WindCnt = e2->WindCnt;\r\n      e2->WindCnt = oldE1WindCnt;\r\n    } else\r\n    {\r\n      if (e1->WindCnt + e2->WindDelta == 0 ) e1->WindCnt = -e1->WindCnt;\r\n      else e1->WindCnt += e2->WindDelta;\r\n      if ( e2->WindCnt - e1->WindDelta == 0 ) e2->WindCnt = -e2->WindCnt;\r\n      else e2->WindCnt -= e1->WindDelta;\r\n    }\r\n  } else\r\n  {\r\n    if (!IsEvenOddFillType(*e2)) e1->WindCnt2 += e2->WindDelta;\r\n    else e1->WindCnt2 = ( e1->WindCnt2 == 0 ) ? 1 : 0;\r\n    if (!IsEvenOddFillType(*e1)) e2->WindCnt2 -= e1->WindDelta;\r\n    else e2->WindCnt2 = ( e2->WindCnt2 == 0 ) ? 1 : 0;\r\n  }\r\n\r\n  PolyFillType e1FillType, e2FillType, e1FillType2, e2FillType2;\r\n  if (e1->PolyTyp == ptSubject)\r\n  {\r\n    e1FillType = m_SubjFillType;\r\n    e1FillType2 = m_ClipFillType;\r\n  } else\r\n  {\r\n    e1FillType = m_ClipFillType;\r\n    e1FillType2 = m_SubjFillType;\r\n  }\r\n  if (e2->PolyTyp == ptSubject)\r\n  {\r\n    e2FillType = m_SubjFillType;\r\n    e2FillType2 = m_ClipFillType;\r\n  } else\r\n  {\r\n    e2FillType = m_ClipFillType;\r\n    e2FillType2 = m_SubjFillType;\r\n  }\r\n\r\n  cInt e1Wc, e2Wc;\r\n  switch (e1FillType)\r\n  {\r\n    case pftPositive: e1Wc = e1->WindCnt; break;\r\n    case pftNegative: e1Wc = -e1->WindCnt; break;\r\n    default: e1Wc = Abs(e1->WindCnt);\r\n  }\r\n  switch(e2FillType)\r\n  {\r\n    case pftPositive: e2Wc = e2->WindCnt; break;\r\n    case pftNegative: e2Wc = -e2->WindCnt; break;\r\n    default: e2Wc = Abs(e2->WindCnt);\r\n  }\r\n\r\n  if ( e1Contributing && e2Contributing )\r\n  {\r\n    if ( e1stops || e2stops || \r\n      (e1Wc != 0 && e1Wc != 1) || (e2Wc != 0 && e2Wc != 1) ||\r\n      (e1->PolyTyp != e2->PolyTyp && m_ClipType != ctXor) )\r\n        AddLocalMaxPoly(e1, e2, Pt); \r\n    else\r\n    {\r\n      AddOutPt(e1, Pt);\r\n      AddOutPt(e2, Pt);\r\n      SwapSides( *e1 , *e2 );\r\n      SwapPolyIndexes( *e1 , *e2 );\r\n    }\r\n  }\r\n  else if ( e1Contributing )\r\n  {\r\n    if (e2Wc == 0 || e2Wc == 1) \r\n    {\r\n      AddOutPt(e1, Pt);\r\n      SwapSides(*e1, *e2);\r\n      SwapPolyIndexes(*e1, *e2);\r\n    }\r\n  }\r\n  else if ( e2Contributing )\r\n  {\r\n    if (e1Wc == 0 || e1Wc == 1) \r\n    {\r\n      AddOutPt(e2, Pt);\r\n      SwapSides(*e1, *e2);\r\n      SwapPolyIndexes(*e1, *e2);\r\n    }\r\n  } \r\n  else if ( (e1Wc == 0 || e1Wc == 1) && \r\n    (e2Wc == 0 || e2Wc == 1) && !e1stops && !e2stops )\r\n  {\r\n    //neither edge is currently contributing ...\r\n\r\n    cInt e1Wc2, e2Wc2;\r\n    switch (e1FillType2)\r\n    {\r\n      case pftPositive: e1Wc2 = e1->WindCnt2; break;\r\n      case pftNegative : e1Wc2 = -e1->WindCnt2; break;\r\n      default: e1Wc2 = Abs(e1->WindCnt2);\r\n    }\r\n    switch (e2FillType2)\r\n    {\r\n      case pftPositive: e2Wc2 = e2->WindCnt2; break;\r\n      case pftNegative: e2Wc2 = -e2->WindCnt2; break;\r\n      default: e2Wc2 = Abs(e2->WindCnt2);\r\n    }\r\n\r\n    if (e1->PolyTyp != e2->PolyTyp)\r\n        AddLocalMinPoly(e1, e2, Pt);\r\n    else if (e1Wc == 1 && e2Wc == 1)\r\n      switch( m_ClipType ) {\r\n        case ctIntersection:\r\n          if (e1Wc2 > 0 && e2Wc2 > 0)\r\n            AddLocalMinPoly(e1, e2, Pt);\r\n          break;\r\n        case ctUnion:\r\n          if ( e1Wc2 <= 0 && e2Wc2 <= 0 )\r\n            AddLocalMinPoly(e1, e2, Pt);\r\n          break;\r\n        case ctDifference:\r\n          if (((e1->PolyTyp == ptClip) && (e1Wc2 > 0) && (e2Wc2 > 0)) ||\r\n              ((e1->PolyTyp == ptSubject) && (e1Wc2 <= 0) && (e2Wc2 <= 0)))\r\n                AddLocalMinPoly(e1, e2, Pt);\r\n          break;\r\n        case ctXor:\r\n          AddLocalMinPoly(e1, e2, Pt);\r\n      }\r\n    else\r\n      SwapSides( *e1, *e2 );\r\n  }\r\n\r\n  if(  (e1stops != e2stops) &&\r\n    ( (e1stops && (e1->OutIdx >= 0)) || (e2stops && (e2->OutIdx >= 0)) ) )\r\n  {\r\n    SwapSides( *e1, *e2 );\r\n    SwapPolyIndexes( *e1, *e2 );\r\n  }\r\n\r\n  //finally, delete any non-contributing maxima edges  ...\r\n  if( e1stops ) DeleteFromAEL( e1 );\r\n  if( e2stops ) DeleteFromAEL( e2 );\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::SetHoleState(TEdge *e, OutRec *outrec)\r\n{\r\n  bool IsHole = false;\r\n  TEdge *e2 = e->PrevInAEL;\r\n  while (e2)\r\n  {\r\n    if (e2->OutIdx >= 0 && e2->WindDelta != 0)\r\n    {\r\n      IsHole = !IsHole;\r\n      if (! outrec->FirstLeft)\r\n        outrec->FirstLeft = m_PolyOuts[e2->OutIdx];\r\n    }\r\n    e2 = e2->PrevInAEL;\r\n  }\r\n  if (IsHole) outrec->IsHole = true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutRec* GetLowermostRec(OutRec *outRec1, OutRec *outRec2)\r\n{\r\n  //work out which polygon fragment has the correct hole state ...\r\n  if (!outRec1->BottomPt) \r\n    outRec1->BottomPt = GetBottomPt(outRec1->Pts);\r\n  if (!outRec2->BottomPt) \r\n    outRec2->BottomPt = GetBottomPt(outRec2->Pts);\r\n  OutPt *OutPt1 = outRec1->BottomPt;\r\n  OutPt *OutPt2 = outRec2->BottomPt;\r\n  if (OutPt1->Pt.Y > OutPt2->Pt.Y) return outRec1;\r\n  else if (OutPt1->Pt.Y < OutPt2->Pt.Y) return outRec2;\r\n  else if (OutPt1->Pt.X < OutPt2->Pt.X) return outRec1;\r\n  else if (OutPt1->Pt.X > OutPt2->Pt.X) return outRec2;\r\n  else if (OutPt1->Next == OutPt1) return outRec2;\r\n  else if (OutPt2->Next == OutPt2) return outRec1;\r\n  else if (FirstIsBottomPt(OutPt1, OutPt2)) return outRec1;\r\n  else return outRec2;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Param1RightOfParam2(OutRec* outRec1, OutRec* outRec2)\r\n{\r\n  do\r\n  {\r\n    outRec1 = outRec1->FirstLeft;\r\n    if (outRec1 == outRec2) return true;\r\n  } while (outRec1);\r\n  return false;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutRec* Clipper::GetOutRec(int Idx)\r\n{\r\n  OutRec* outrec = m_PolyOuts[Idx];\r\n  while (outrec != m_PolyOuts[outrec->Idx])\r\n    outrec = m_PolyOuts[outrec->Idx];\r\n  return outrec;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::AppendPolygon(TEdge *e1, TEdge *e2)\r\n{\r\n  //get the start and ends of both output polygons ...\r\n  OutRec *outRec1 = m_PolyOuts[e1->OutIdx];\r\n  OutRec *outRec2 = m_PolyOuts[e2->OutIdx];\r\n\r\n  OutRec *holeStateRec;\r\n  if (Param1RightOfParam2(outRec1, outRec2)) \r\n    holeStateRec = outRec2;\r\n  else if (Param1RightOfParam2(outRec2, outRec1)) \r\n    holeStateRec = outRec1;\r\n  else \r\n    holeStateRec = GetLowermostRec(outRec1, outRec2);\r\n\r\n  //get the start and ends of both output polygons and\r\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\r\n\r\n  OutPt* p1_lft = outRec1->Pts;\r\n  OutPt* p1_rt = p1_lft->Prev;\r\n  OutPt* p2_lft = outRec2->Pts;\r\n  OutPt* p2_rt = p2_lft->Prev;\r\n\r\n  EdgeSide Side;\r\n  //join e2 poly onto e1 poly and delete pointers to e2 ...\r\n  if(  e1->Side == esLeft )\r\n  {\r\n    if(  e2->Side == esLeft )\r\n    {\r\n      //z y x a b c\r\n      ReversePolyPtLinks(p2_lft);\r\n      p2_lft->Next = p1_lft;\r\n      p1_lft->Prev = p2_lft;\r\n      p1_rt->Next = p2_rt;\r\n      p2_rt->Prev = p1_rt;\r\n      outRec1->Pts = p2_rt;\r\n    } else\r\n    {\r\n      //x y z a b c\r\n      p2_rt->Next = p1_lft;\r\n      p1_lft->Prev = p2_rt;\r\n      p2_lft->Prev = p1_rt;\r\n      p1_rt->Next = p2_lft;\r\n      outRec1->Pts = p2_lft;\r\n    }\r\n    Side = esLeft;\r\n  } else\r\n  {\r\n    if(  e2->Side == esRight )\r\n    {\r\n      //a b c z y x\r\n      ReversePolyPtLinks(p2_lft);\r\n      p1_rt->Next = p2_rt;\r\n      p2_rt->Prev = p1_rt;\r\n      p2_lft->Next = p1_lft;\r\n      p1_lft->Prev = p2_lft;\r\n    } else\r\n    {\r\n      //a b c x y z\r\n      p1_rt->Next = p2_lft;\r\n      p2_lft->Prev = p1_rt;\r\n      p1_lft->Prev = p2_rt;\r\n      p2_rt->Next = p1_lft;\r\n    }\r\n    Side = esRight;\r\n  }\r\n\r\n  outRec1->BottomPt = 0;\r\n  if (holeStateRec == outRec2)\r\n  {\r\n    if (outRec2->FirstLeft != outRec1)\r\n      outRec1->FirstLeft = outRec2->FirstLeft;\r\n    outRec1->IsHole = outRec2->IsHole;\r\n  }\r\n  outRec2->Pts = 0;\r\n  outRec2->BottomPt = 0;\r\n  outRec2->FirstLeft = outRec1;\r\n\r\n  int OKIdx = e1->OutIdx;\r\n  int ObsoleteIdx = e2->OutIdx;\r\n\r\n  e1->OutIdx = Unassigned; //nb: safe because we only get here via AddLocalMaxPoly\r\n  e2->OutIdx = Unassigned;\r\n\r\n  TEdge* e = m_ActiveEdges;\r\n  while( e )\r\n  {\r\n    if( e->OutIdx == ObsoleteIdx )\r\n    {\r\n      e->OutIdx = OKIdx;\r\n      e->Side = Side;\r\n      break;\r\n    }\r\n    e = e->NextInAEL;\r\n  }\r\n\r\n  outRec2->Idx = outRec1->Idx;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutRec* Clipper::CreateOutRec()\r\n{\r\n  OutRec* result = new OutRec;\r\n  result->IsHole = false;\r\n  result->IsOpen = false;\r\n  result->FirstLeft = 0;\r\n  result->Pts = 0;\r\n  result->BottomPt = 0;\r\n  result->PolyNd = 0;\r\n  m_PolyOuts.push_back(result);\r\n  result->Idx = (int)m_PolyOuts.size()-1;\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nOutPt* Clipper::AddOutPt(TEdge *e, const IntPoint &pt)\r\n{\r\n  bool ToFront = (e->Side == esLeft);\r\n  if(  e->OutIdx < 0 )\r\n  {\r\n    OutRec *outRec = CreateOutRec();\r\n    outRec->IsOpen = (e->WindDelta == 0);\r\n    OutPt* newOp = new OutPt;\r\n    outRec->Pts = newOp;\r\n    newOp->Idx = outRec->Idx;\r\n    newOp->Pt = pt;\r\n    newOp->Next = newOp;\r\n    newOp->Prev = newOp;\r\n    if (!outRec->IsOpen)\r\n      SetHoleState(e, outRec);\r\n#ifdef use_xyz\r\n    if (pt == e->Bot) newOp->Pt = e->Bot;\r\n    else if (pt == e->Top) newOp->Pt = e->Top;\r\n    else SetZ(newOp->Pt, *e);\r\n#endif\r\n    e->OutIdx = outRec->Idx; //nb: do this after SetZ !\r\n    return newOp;\r\n  } else\r\n  {\r\n    OutRec *outRec = m_PolyOuts[e->OutIdx];\r\n    //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\r\n    OutPt* op = outRec->Pts;\r\n\r\n    if (ToFront && (pt == op->Pt)) return op;\r\n    else if (!ToFront && (pt == op->Prev->Pt)) return op->Prev;\r\n\r\n    OutPt* newOp = new OutPt;\r\n    newOp->Idx = outRec->Idx;\r\n    newOp->Pt = pt;\r\n    newOp->Next = op;\r\n    newOp->Prev = op->Prev;\r\n    newOp->Prev->Next = newOp;\r\n    op->Prev = newOp;\r\n    if (ToFront) outRec->Pts = newOp;\r\n#ifdef use_xyz\r\n    if (pt == e->Bot) newOp->Pt = e->Bot;\r\n    else if (pt == e->Top) newOp->Pt = e->Top;\r\n    else SetZ(newOp->Pt, *e);\r\n#endif\r\n    return newOp;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::ProcessHorizontals(bool IsTopOfScanbeam)\r\n{\r\n  TEdge* horzEdge = m_SortedEdges;\r\n  while(horzEdge)\r\n  {\r\n    DeleteFromSEL(horzEdge);\r\n    ProcessHorizontal(horzEdge, IsTopOfScanbeam);\r\n    horzEdge = m_SortedEdges;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool IsMinima(TEdge *e)\r\n{\r\n  return e  && (e->Prev->NextInLML != e) && (e->Next->NextInLML != e);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool IsMaxima(TEdge *e, const cInt Y)\r\n{\r\n  return e && e->Top.Y == Y && !e->NextInLML;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool IsIntermediate(TEdge *e, const cInt Y)\r\n{\r\n  return e->Top.Y == Y && e->NextInLML;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nTEdge *GetMaximaPair(TEdge *e)\r\n{\r\n  TEdge* result = 0;\r\n  if ((e->Next->Top == e->Top) && !e->Next->NextInLML)\r\n    result = e->Next;\r\n  else if ((e->Prev->Top == e->Top) && !e->Prev->NextInLML)\r\n    result = e->Prev;\r\n\r\n  if (result && (result->OutIdx == Skip ||\r\n    //result is false if both NextInAEL & PrevInAEL are nil & not horizontal ...\r\n    (result->NextInAEL == result->PrevInAEL && !IsHorizontal(*result))))\r\n      return 0;\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::SwapPositionsInAEL(TEdge *Edge1, TEdge *Edge2)\r\n{\r\n  //check that one or other edge hasn't already been removed from AEL ...\r\n  if (Edge1->NextInAEL == Edge1->PrevInAEL || \r\n    Edge2->NextInAEL == Edge2->PrevInAEL) return;\r\n\r\n  if(  Edge1->NextInAEL == Edge2 )\r\n  {\r\n    TEdge* Next = Edge2->NextInAEL;\r\n    if( Next ) Next->PrevInAEL = Edge1;\r\n    TEdge* Prev = Edge1->PrevInAEL;\r\n    if( Prev ) Prev->NextInAEL = Edge2;\r\n    Edge2->PrevInAEL = Prev;\r\n    Edge2->NextInAEL = Edge1;\r\n    Edge1->PrevInAEL = Edge2;\r\n    Edge1->NextInAEL = Next;\r\n  }\r\n  else if(  Edge2->NextInAEL == Edge1 )\r\n  {\r\n    TEdge* Next = Edge1->NextInAEL;\r\n    if( Next ) Next->PrevInAEL = Edge2;\r\n    TEdge* Prev = Edge2->PrevInAEL;\r\n    if( Prev ) Prev->NextInAEL = Edge1;\r\n    Edge1->PrevInAEL = Prev;\r\n    Edge1->NextInAEL = Edge2;\r\n    Edge2->PrevInAEL = Edge1;\r\n    Edge2->NextInAEL = Next;\r\n  }\r\n  else\r\n  {\r\n    TEdge* Next = Edge1->NextInAEL;\r\n    TEdge* Prev = Edge1->PrevInAEL;\r\n    Edge1->NextInAEL = Edge2->NextInAEL;\r\n    if( Edge1->NextInAEL ) Edge1->NextInAEL->PrevInAEL = Edge1;\r\n    Edge1->PrevInAEL = Edge2->PrevInAEL;\r\n    if( Edge1->PrevInAEL ) Edge1->PrevInAEL->NextInAEL = Edge1;\r\n    Edge2->NextInAEL = Next;\r\n    if( Edge2->NextInAEL ) Edge2->NextInAEL->PrevInAEL = Edge2;\r\n    Edge2->PrevInAEL = Prev;\r\n    if( Edge2->PrevInAEL ) Edge2->PrevInAEL->NextInAEL = Edge2;\r\n  }\r\n\r\n  if( !Edge1->PrevInAEL ) m_ActiveEdges = Edge1;\r\n  else if( !Edge2->PrevInAEL ) m_ActiveEdges = Edge2;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::SwapPositionsInSEL(TEdge *Edge1, TEdge *Edge2)\r\n{\r\n  if(  !( Edge1->NextInSEL ) &&  !( Edge1->PrevInSEL ) ) return;\r\n  if(  !( Edge2->NextInSEL ) &&  !( Edge2->PrevInSEL ) ) return;\r\n\r\n  if(  Edge1->NextInSEL == Edge2 )\r\n  {\r\n    TEdge* Next = Edge2->NextInSEL;\r\n    if( Next ) Next->PrevInSEL = Edge1;\r\n    TEdge* Prev = Edge1->PrevInSEL;\r\n    if( Prev ) Prev->NextInSEL = Edge2;\r\n    Edge2->PrevInSEL = Prev;\r\n    Edge2->NextInSEL = Edge1;\r\n    Edge1->PrevInSEL = Edge2;\r\n    Edge1->NextInSEL = Next;\r\n  }\r\n  else if(  Edge2->NextInSEL == Edge1 )\r\n  {\r\n    TEdge* Next = Edge1->NextInSEL;\r\n    if( Next ) Next->PrevInSEL = Edge2;\r\n    TEdge* Prev = Edge2->PrevInSEL;\r\n    if( Prev ) Prev->NextInSEL = Edge1;\r\n    Edge1->PrevInSEL = Prev;\r\n    Edge1->NextInSEL = Edge2;\r\n    Edge2->PrevInSEL = Edge1;\r\n    Edge2->NextInSEL = Next;\r\n  }\r\n  else\r\n  {\r\n    TEdge* Next = Edge1->NextInSEL;\r\n    TEdge* Prev = Edge1->PrevInSEL;\r\n    Edge1->NextInSEL = Edge2->NextInSEL;\r\n    if( Edge1->NextInSEL ) Edge1->NextInSEL->PrevInSEL = Edge1;\r\n    Edge1->PrevInSEL = Edge2->PrevInSEL;\r\n    if( Edge1->PrevInSEL ) Edge1->PrevInSEL->NextInSEL = Edge1;\r\n    Edge2->NextInSEL = Next;\r\n    if( Edge2->NextInSEL ) Edge2->NextInSEL->PrevInSEL = Edge2;\r\n    Edge2->PrevInSEL = Prev;\r\n    if( Edge2->PrevInSEL ) Edge2->PrevInSEL->NextInSEL = Edge2;\r\n  }\r\n\r\n  if( !Edge1->PrevInSEL ) m_SortedEdges = Edge1;\r\n  else if( !Edge2->PrevInSEL ) m_SortedEdges = Edge2;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nTEdge* GetNextInAEL(TEdge *e, Direction dir)\r\n{\r\n  return dir == dLeftToRight ? e->NextInAEL : e->PrevInAEL;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid GetHorzDirection(TEdge& HorzEdge, Direction& Dir, cInt& Left, cInt& Right)\r\n{\r\n  if (HorzEdge.Bot.X < HorzEdge.Top.X)\r\n  {\r\n    Left = HorzEdge.Bot.X;\r\n    Right = HorzEdge.Top.X;\r\n    Dir = dLeftToRight;\r\n  } else\r\n  {\r\n    Left = HorzEdge.Top.X;\r\n    Right = HorzEdge.Bot.X;\r\n    Dir = dRightToLeft;\r\n  }\r\n}\r\n//------------------------------------------------------------------------\r\n\r\nvoid Clipper::PrepareHorzJoins(TEdge* horzEdge, bool isTopOfScanbeam)\r\n{\r\n  //get the last Op for this horizontal edge\r\n  //the point may be anywhere along the horizontal ...\r\n  OutPt* outPt = m_PolyOuts[horzEdge->OutIdx]->Pts;\r\n  if (horzEdge->Side != esLeft) outPt = outPt->Prev;\r\n\r\n  //First, match up overlapping horizontal edges (eg when one polygon's\r\n  //intermediate horz edge overlaps an intermediate horz edge of another, or\r\n  //when one polygon sits on top of another) ...\r\n  for (JoinList::size_type i = 0; i < m_GhostJoins.size(); ++i)\r\n  {\r\n    Join* j = m_GhostJoins[i];\r\n    if (HorzSegmentsOverlap(j->OutPt1->Pt, j->OffPt, horzEdge->Bot, horzEdge->Top))\r\n        AddJoin(j->OutPt1, outPt, j->OffPt);\r\n  }\r\n  //Also, since horizontal edges at the top of one SB are often removed from\r\n  //the AEL before we process the horizontal edges at the bottom of the next,\r\n  //we need to create 'ghost' Join records of 'contrubuting' horizontals that\r\n  //we can compare with horizontals at the bottom of the next SB.\r\n  if (isTopOfScanbeam) {\r\n      if (outPt->Pt == horzEdge->Top)\r\n          AddGhostJoin(outPt, horzEdge->Bot);\r\n      else\r\n          AddGhostJoin(outPt, horzEdge->Top);\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\n/*******************************************************************************\r\n* Notes: Horizontal edges (HEs) at scanline intersections (ie at the Top or    *\r\n* Bottom of a scanbeam) are processed as if layered. The order in which HEs    *\r\n* are processed doesn't matter. HEs intersect with other HE Bot.Xs only [#]    *\r\n* (or they could intersect with Top.Xs only, ie EITHER Bot.Xs OR Top.Xs),      *\r\n* and with other non-horizontal edges [*]. Once these intersections are        *\r\n* processed, intermediate HEs then 'promote' the Edge above (NextInLML) into   *\r\n* the AEL. These 'promoted' edges may in turn intersect [%] with other HEs.    *\r\n*******************************************************************************/\r\n\r\nvoid Clipper::ProcessHorizontal(TEdge *horzEdge, bool isTopOfScanbeam)\r\n{\r\n  Direction dir;\r\n  cInt horzLeft, horzRight;\r\n\r\n  GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);\r\n\r\n  TEdge* eLastHorz = horzEdge, *eMaxPair = 0;\r\n  while (eLastHorz->NextInLML && IsHorizontal(*eLastHorz->NextInLML)) \r\n    eLastHorz = eLastHorz->NextInLML;\r\n  if (!eLastHorz->NextInLML)\r\n    eMaxPair = GetMaximaPair(eLastHorz);\r\n\r\n  for (;;)\r\n  {\r\n    bool IsLastHorz = (horzEdge == eLastHorz);\r\n    TEdge* e = GetNextInAEL(horzEdge, dir);\r\n    while(e)\r\n    {\r\n      //Break if we've got to the end of an intermediate horizontal edge ...\r\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\r\n      if (e->Curr.X == horzEdge->Top.X && horzEdge->NextInLML && \r\n        e->Dx < horzEdge->NextInLML->Dx) break;\r\n\r\n      TEdge* eNext = GetNextInAEL(e, dir); //saves eNext for later\r\n\r\n      if ((dir == dLeftToRight && e->Curr.X <= horzRight) ||\r\n        (dir == dRightToLeft && e->Curr.X >= horzLeft))\r\n      {\r\n        //so far we're still in range of the horizontal Edge  but make sure\r\n        //we're at the last of consec. horizontals when matching with eMaxPair\r\n        if(e == eMaxPair && IsLastHorz)\r\n        {\r\n          if (horzEdge->OutIdx >= 0 && horzEdge->WindDelta != 0) \r\n            PrepareHorzJoins(horzEdge, isTopOfScanbeam);\r\n          if (dir == dLeftToRight)\r\n            IntersectEdges(horzEdge, e, e->Top);\r\n          else\r\n            IntersectEdges(e, horzEdge, e->Top);\r\n          if (eMaxPair->OutIdx >= 0) throw clipperException(\"ProcessHorizontal error\");\r\n          return;\r\n        }\r\n        else if(dir == dLeftToRight)\r\n        {\r\n          IntPoint Pt = IntPoint(e->Curr.X, horzEdge->Curr.Y);\r\n          IntersectEdges(horzEdge, e, Pt, true);\r\n        }\r\n        else\r\n        {\r\n          IntPoint Pt = IntPoint(e->Curr.X, horzEdge->Curr.Y);\r\n          IntersectEdges( e, horzEdge, Pt, true);\r\n        }\r\n        SwapPositionsInAEL( horzEdge, e );\r\n      }\r\n      else if( (dir == dLeftToRight && e->Curr.X >= horzRight) ||\r\n       (dir == dRightToLeft && e->Curr.X <= horzLeft) ) break;\r\n      e = eNext;\r\n    } //end while\r\n\r\n    if (horzEdge->OutIdx >= 0 && horzEdge->WindDelta != 0)\r\n      PrepareHorzJoins(horzEdge, isTopOfScanbeam);\r\n\r\n    if (horzEdge->NextInLML && IsHorizontal(*horzEdge->NextInLML))\r\n    {\r\n      UpdateEdgeIntoAEL(horzEdge);\r\n      if (horzEdge->OutIdx >= 0) AddOutPt(horzEdge, horzEdge->Bot);\r\n      GetHorzDirection(*horzEdge, dir, horzLeft, horzRight);\r\n    } else\r\n      break;\r\n  } //end for (;;)\r\n\r\n  if(horzEdge->NextInLML)\r\n  {\r\n    if(horzEdge->OutIdx >= 0)\r\n    {\r\n      OutPt* op1 = AddOutPt( horzEdge, horzEdge->Top);\r\n      UpdateEdgeIntoAEL(horzEdge);\r\n      if (horzEdge->WindDelta == 0) return;\r\n      //nb: HorzEdge is no longer horizontal here\r\n      TEdge* ePrev = horzEdge->PrevInAEL;\r\n      TEdge* eNext = horzEdge->NextInAEL;\r\n      if (ePrev && ePrev->Curr.X == horzEdge->Bot.X &&\r\n        ePrev->Curr.Y == horzEdge->Bot.Y && ePrev->WindDelta != 0 &&\r\n        (ePrev->OutIdx >= 0 && ePrev->Curr.Y > ePrev->Top.Y &&\r\n        SlopesEqual(*horzEdge, *ePrev, m_UseFullRange)))\r\n      {\r\n        OutPt* op2 = AddOutPt(ePrev, horzEdge->Bot);\r\n        AddJoin(op1, op2, horzEdge->Top);\r\n      }\r\n      else if (eNext && eNext->Curr.X == horzEdge->Bot.X &&\r\n        eNext->Curr.Y == horzEdge->Bot.Y && eNext->WindDelta != 0 &&\r\n        eNext->OutIdx >= 0 && eNext->Curr.Y > eNext->Top.Y &&\r\n        SlopesEqual(*horzEdge, *eNext, m_UseFullRange))\r\n      {\r\n        OutPt* op2 = AddOutPt(eNext, horzEdge->Bot);\r\n        AddJoin(op1, op2, horzEdge->Top);\r\n      }\r\n    }\r\n    else\r\n      UpdateEdgeIntoAEL(horzEdge); \r\n  }\r\n  else if (eMaxPair)\r\n  {\r\n    if (eMaxPair->OutIdx >= 0)\r\n    {\r\n      if (dir == dLeftToRight)\r\n        IntersectEdges(horzEdge, eMaxPair, horzEdge->Top); \r\n      else\r\n        IntersectEdges(eMaxPair, horzEdge, horzEdge->Top);\r\n      if (eMaxPair->OutIdx >= 0)\r\n        throw clipperException(\"ProcessHorizontal error\");\r\n    } else\r\n    {\r\n      DeleteFromAEL(horzEdge);\r\n      DeleteFromAEL(eMaxPair);\r\n    }\r\n  } else\r\n  {\r\n    if (horzEdge->OutIdx >= 0) AddOutPt(horzEdge, horzEdge->Top);\r\n    DeleteFromAEL(horzEdge);\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::UpdateEdgeIntoAEL(TEdge *&e)\r\n{\r\n  if( !e->NextInLML ) throw\r\n    clipperException(\"UpdateEdgeIntoAEL: invalid call\");\r\n\r\n  e->NextInLML->OutIdx = e->OutIdx;\r\n  TEdge* AelPrev = e->PrevInAEL;\r\n  TEdge* AelNext = e->NextInAEL;\r\n  if (AelPrev) AelPrev->NextInAEL = e->NextInLML;\r\n  else m_ActiveEdges = e->NextInLML;\r\n  if (AelNext) AelNext->PrevInAEL = e->NextInLML;\r\n  e->NextInLML->Side = e->Side;\r\n  e->NextInLML->WindDelta = e->WindDelta;\r\n  e->NextInLML->WindCnt = e->WindCnt;\r\n  e->NextInLML->WindCnt2 = e->WindCnt2;\r\n  e = e->NextInLML;\r\n  e->Curr = e->Bot;\r\n  e->PrevInAEL = AelPrev;\r\n  e->NextInAEL = AelNext;\r\n  if (!IsHorizontal(*e)) InsertScanbeam(e->Top.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::ProcessIntersections(const cInt botY, const cInt topY)\r\n{\r\n  if( !m_ActiveEdges ) return true;\r\n  try {\r\n    BuildIntersectList(botY, topY);\r\n    if (!m_IntersectNodes) return true;\r\n    if (!m_IntersectNodes->Next || FixupIntersectionOrder()) ProcessIntersectList();\r\n    else return false;\r\n  }\r\n  catch(...) \r\n  {\r\n    m_SortedEdges = 0;\r\n    DisposeIntersectNodes();\r\n    throw clipperException(\"ProcessIntersections error\");\r\n  }\r\n  m_SortedEdges = 0;\r\n  return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DisposeIntersectNodes()\r\n{\r\n  while ( m_IntersectNodes )\r\n  {\r\n    IntersectNode* iNode = m_IntersectNodes->Next;\r\n    delete m_IntersectNodes;\r\n    m_IntersectNodes = iNode;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::BuildIntersectList(const cInt botY, const cInt topY)\r\n{\r\n  if ( !m_ActiveEdges ) return;\r\n\r\n  //prepare for sorting ...\r\n  TEdge* e = m_ActiveEdges;\r\n  m_SortedEdges = e;\r\n  while( e )\r\n  {\r\n    e->PrevInSEL = e->PrevInAEL;\r\n    e->NextInSEL = e->NextInAEL;\r\n    e->Curr.X = TopX( *e, topY );\r\n    e = e->NextInAEL;\r\n  }\r\n\r\n  //bubblesort ...\r\n  bool isModified;\r\n  do\r\n  {\r\n    isModified = false;\r\n    e = m_SortedEdges;\r\n    while( e->NextInSEL )\r\n    {\r\n      TEdge *eNext = e->NextInSEL;\r\n      IntPoint Pt;\r\n      if(e->Curr.X > eNext->Curr.X)\r\n      {\r\n        if (!IntersectPoint(*e, *eNext, Pt, m_UseFullRange) && e->Curr.X > eNext->Curr.X +1)\r\n          throw clipperException(\"Intersection error\");\r\n        if (Pt.Y > botY)\r\n        {\r\n            Pt.Y = botY;\r\n            if (std::fabs(e->Dx) > std::fabs(eNext->Dx))\r\n              Pt.X = TopX(*eNext, botY); else\r\n              Pt.X = TopX(*e, botY);\r\n        }\r\n        InsertIntersectNode( e, eNext, Pt );\r\n        SwapPositionsInSEL(e, eNext);\r\n        isModified = true;\r\n      }\r\n      else\r\n        e = eNext;\r\n    }\r\n    if( e->PrevInSEL ) e->PrevInSEL->NextInSEL = 0;\r\n    else break;\r\n  }\r\n  while ( isModified );\r\n  m_SortedEdges = 0; //important\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::InsertIntersectNode(TEdge *e1, TEdge *e2, const IntPoint &Pt)\r\n{\r\n  IntersectNode* newNode = new IntersectNode;\r\n  newNode->Edge1 = e1;\r\n  newNode->Edge2 = e2;\r\n  newNode->Pt = Pt;\r\n  newNode->Next = 0;\r\n  if( !m_IntersectNodes ) m_IntersectNodes = newNode;\r\n  else if(newNode->Pt.Y > m_IntersectNodes->Pt.Y )\r\n  {\r\n    newNode->Next = m_IntersectNodes;\r\n    m_IntersectNodes = newNode;\r\n  }\r\n  else\r\n  {\r\n    IntersectNode* iNode = m_IntersectNodes;\r\n    while(iNode->Next  && newNode->Pt.Y <= iNode->Next->Pt.Y)\r\n      iNode = iNode->Next;\r\n    newNode->Next = iNode->Next;\r\n    iNode->Next = newNode;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::ProcessIntersectList()\r\n{\r\n  while( m_IntersectNodes )\r\n  {\r\n    IntersectNode* iNode = m_IntersectNodes->Next;\r\n    {\r\n      IntersectEdges( m_IntersectNodes->Edge1 ,\r\n        m_IntersectNodes->Edge2 , m_IntersectNodes->Pt, true);\r\n      SwapPositionsInAEL( m_IntersectNodes->Edge1 , m_IntersectNodes->Edge2 );\r\n    }\r\n    delete m_IntersectNodes;\r\n    m_IntersectNodes = iNode;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DoMaxima(TEdge *e)\r\n{\r\n  TEdge* eMaxPair = GetMaximaPair(e);\r\n  if (!eMaxPair)\r\n  {\r\n    if (e->OutIdx >= 0)\r\n      AddOutPt(e, e->Top);\r\n    DeleteFromAEL(e);\r\n    return;\r\n  }\r\n\r\n  TEdge* eNext = e->NextInAEL;\r\n  while(eNext && eNext != eMaxPair)\r\n  {\r\n    IntersectEdges(e, eNext, e->Top, true);\r\n    SwapPositionsInAEL(e, eNext);\r\n    eNext = e->NextInAEL;\r\n  }\r\n\r\n  if(e->OutIdx == Unassigned && eMaxPair->OutIdx == Unassigned)\r\n  {\r\n    DeleteFromAEL(e);\r\n    DeleteFromAEL(eMaxPair);\r\n  }\r\n  else if( e->OutIdx >= 0 && eMaxPair->OutIdx >= 0 )\r\n  {\r\n    IntersectEdges( e, eMaxPair, e->Top);\r\n  }\r\n#ifdef use_lines\r\n  else if (e->WindDelta == 0)\r\n  {\r\n    if (e->OutIdx >= 0) \r\n    {\r\n      AddOutPt(e, e->Top);\r\n      e->OutIdx = Unassigned;\r\n    }\r\n    DeleteFromAEL(e);\r\n\r\n    if (eMaxPair->OutIdx >= 0)\r\n    {\r\n      AddOutPt(eMaxPair, e->Top);\r\n      eMaxPair->OutIdx = Unassigned;\r\n    }\r\n    DeleteFromAEL(eMaxPair);\r\n  } \r\n#endif\r\n  else throw clipperException(\"DoMaxima error\");\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::ProcessEdgesAtTopOfScanbeam(const cInt topY)\r\n{\r\n  TEdge* e = m_ActiveEdges;\r\n  while( e )\r\n  {\r\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\r\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\r\n    bool IsMaximaEdge = IsMaxima(e, topY);\r\n\r\n    if(IsMaximaEdge)\r\n    {\r\n      TEdge* eMaxPair = GetMaximaPair(e);\r\n      IsMaximaEdge = (!eMaxPair || !IsHorizontal(*eMaxPair));\r\n    }\r\n\r\n    if(IsMaximaEdge)\r\n    {\r\n      TEdge* ePrev = e->PrevInAEL;\r\n      DoMaxima(e);\r\n      if( !ePrev ) e = m_ActiveEdges;\r\n      else e = ePrev->NextInAEL;\r\n    }\r\n    else\r\n    {\r\n      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\r\n      if (IsIntermediate(e, topY) && IsHorizontal(*e->NextInLML))\r\n      {\r\n        UpdateEdgeIntoAEL(e);\r\n        if (e->OutIdx >= 0)\r\n          AddOutPt(e, e->Bot);\r\n        AddEdgeToSEL(e);\r\n      } \r\n      else\r\n      {\r\n        e->Curr.X = TopX( *e, topY );\r\n        e->Curr.Y = topY;\r\n      }\r\n\r\n      if (m_StrictSimple)\r\n      {  \r\n        TEdge* ePrev = e->PrevInAEL;\r\n        if ((e->OutIdx >= 0) && (e->WindDelta != 0) && ePrev && (ePrev->OutIdx >= 0) &&\r\n          (ePrev->Curr.X == e->Curr.X) && (ePrev->WindDelta != 0))\r\n        {\r\n          OutPt* op = AddOutPt(ePrev, e->Curr);\r\n          OutPt* op2 = AddOutPt(e, e->Curr);\r\n          AddJoin(op, op2, e->Curr); //StrictlySimple (type-3) join\r\n        }\r\n      }\r\n\r\n      e = e->NextInAEL;\r\n    }\r\n  }\r\n\r\n  //3. Process horizontals at the Top of the scanbeam ...\r\n  ProcessHorizontals(true);\r\n\r\n  //4. Promote intermediate vertices ...\r\n  e = m_ActiveEdges;\r\n  while(e)\r\n  {\r\n    if(IsIntermediate(e, topY))\r\n    {\r\n      OutPt* op = 0;\r\n      if( e->OutIdx >= 0 ) \r\n        op = AddOutPt(e, e->Top);\r\n      UpdateEdgeIntoAEL(e);\r\n\r\n      //if output polygons share an edge, they'll need joining later ...\r\n      TEdge* ePrev = e->PrevInAEL;\r\n      TEdge* eNext = e->NextInAEL;\r\n      if (ePrev && ePrev->Curr.X == e->Bot.X &&\r\n        ePrev->Curr.Y == e->Bot.Y && op &&\r\n        ePrev->OutIdx >= 0 && ePrev->Curr.Y > ePrev->Top.Y &&\r\n        SlopesEqual(*e, *ePrev, m_UseFullRange) &&\r\n        (e->WindDelta != 0) && (ePrev->WindDelta != 0))\r\n      {\r\n        OutPt* op2 = AddOutPt(ePrev, e->Bot);\r\n        AddJoin(op, op2, e->Top);\r\n      }\r\n      else if (eNext && eNext->Curr.X == e->Bot.X &&\r\n        eNext->Curr.Y == e->Bot.Y && op &&\r\n        eNext->OutIdx >= 0 && eNext->Curr.Y > eNext->Top.Y &&\r\n        SlopesEqual(*e, *eNext, m_UseFullRange) &&\r\n        (e->WindDelta != 0) && (eNext->WindDelta != 0))\r\n      {\r\n        OutPt* op2 = AddOutPt(eNext, e->Bot);\r\n        AddJoin(op, op2, e->Top);\r\n      }\r\n    }\r\n    e = e->NextInAEL;\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::FixupOutPolygon(OutRec &outrec)\r\n{\r\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\r\n  //parallel edges by removing the middle vertex.\r\n  OutPt *lastOK = 0;\r\n  outrec.BottomPt = 0;\r\n  OutPt *pp = outrec.Pts;\r\n\r\n  for (;;)\r\n  {\r\n    if (pp->Prev == pp || pp->Prev == pp->Next )\r\n    {\r\n      DisposeOutPts(pp);\r\n      outrec.Pts = 0;\r\n      return;\r\n    }\r\n\r\n    //test for duplicate points and collinear edges ...\r\n    if ((pp->Pt == pp->Next->Pt) || (pp->Pt == pp->Prev->Pt) || \r\n      (SlopesEqual(pp->Prev->Pt, pp->Pt, pp->Next->Pt, m_UseFullRange) &&\r\n      (!m_PreserveCollinear || \r\n      !Pt2IsBetweenPt1AndPt3(pp->Prev->Pt, pp->Pt, pp->Next->Pt))))\r\n    {\r\n      lastOK = 0;\r\n      OutPt *tmp = pp;\r\n      pp->Prev->Next = pp->Next;\r\n      pp->Next->Prev = pp->Prev;\r\n      pp = pp->Prev;\r\n      delete tmp;\r\n    }\r\n    else if (pp == lastOK) break;\r\n    else\r\n    {\r\n      if (!lastOK) lastOK = pp;\r\n      pp = pp->Next;\r\n    }\r\n  }\r\n  outrec.Pts = pp;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nint PointCount(OutPt *Pts)\r\n{\r\n    if (!Pts) return 0;\r\n    int result = 0;\r\n    OutPt* p = Pts;\r\n    do\r\n    {\r\n        result++;\r\n        p = p->Next;\r\n    }\r\n    while (p != Pts);\r\n    return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::BuildResult(Paths &polys)\r\n{\r\n  polys.reserve(m_PolyOuts.size());\r\n  for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n  {\r\n    if (!m_PolyOuts[i]->Pts) continue;\r\n    Path pg;\r\n    OutPt* p = m_PolyOuts[i]->Pts->Prev;\r\n    int cnt = PointCount(p);\r\n    if (cnt < 2) continue;\r\n    pg.reserve(cnt);\r\n    for (int i = 0; i < cnt; ++i)\r\n    {\r\n      pg.push_back(p->Pt);\r\n      p = p->Prev;\r\n    }\r\n    polys.push_back(pg);\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::BuildResult2(PolyTree& polytree)\r\n{\r\n    polytree.Clear();\r\n    polytree.AllNodes.reserve(m_PolyOuts.size());\r\n    //add each output polygon/contour to polytree ...\r\n    for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); i++)\r\n    {\r\n        OutRec* outRec = m_PolyOuts[i];\r\n        int cnt = PointCount(outRec->Pts);\r\n        if ((outRec->IsOpen && cnt < 2) || (!outRec->IsOpen && cnt < 3)) continue;\r\n        FixHoleLinkage(*outRec);\r\n        PolyNode* pn = new PolyNode();\r\n        //nb: polytree takes ownership of all the PolyNodes\r\n        polytree.AllNodes.push_back(pn);\r\n        outRec->PolyNd = pn;\r\n        pn->Parent = 0;\r\n        pn->Index = 0;\r\n        pn->Contour.reserve(cnt);\r\n        OutPt *op = outRec->Pts->Prev;\r\n        for (int j = 0; j < cnt; j++)\r\n        {\r\n            pn->Contour.push_back(op->Pt);\r\n            op = op->Prev;\r\n        }\r\n    }\r\n\r\n    //fixup PolyNode links etc ...\r\n    polytree.Childs.reserve(m_PolyOuts.size());\r\n    for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); i++)\r\n    {\r\n        OutRec* outRec = m_PolyOuts[i];\r\n        if (!outRec->PolyNd) continue;\r\n        if (outRec->IsOpen) \r\n        {\r\n          outRec->PolyNd->m_IsOpen = true;\r\n          polytree.AddChild(*outRec->PolyNd);\r\n        }\r\n        else if (outRec->FirstLeft) \r\n          outRec->FirstLeft->PolyNd->AddChild(*outRec->PolyNd);\r\n        else\r\n          polytree.AddChild(*outRec->PolyNd);\r\n    }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid SwapIntersectNodes(IntersectNode &int1, IntersectNode &int2)\r\n{\r\n  //just swap the contents (because fIntersectNodes is a single-linked-list)\r\n  IntersectNode inode = int1; //gets a copy of Int1\r\n  int1.Edge1 = int2.Edge1;\r\n  int1.Edge2 = int2.Edge2;\r\n  int1.Pt = int2.Pt;\r\n  int2.Edge1 = inode.Edge1;\r\n  int2.Edge2 = inode.Edge2;\r\n  int2.Pt = inode.Pt;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool EdgesAdjacent(const IntersectNode &inode)\r\n{\r\n  return (inode.Edge1->NextInSEL == inode.Edge2) ||\r\n    (inode.Edge1->PrevInSEL == inode.Edge2);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::FixupIntersectionOrder()\r\n{\r\n  //pre-condition: intersections are sorted Bottom-most (then Left-most) first.\r\n  //Now it's crucial that intersections are made only between adjacent edges,\r\n  //so to ensure this the order of intersections may need adjusting ...\r\n  IntersectNode *inode = m_IntersectNodes;  \r\n  CopyAELToSEL();\r\n  while (inode) \r\n  {\r\n    if (!EdgesAdjacent(*inode))\r\n    {\r\n      IntersectNode *nextNode = inode->Next;\r\n      while (nextNode && !EdgesAdjacent(*nextNode))\r\n        nextNode = nextNode->Next;\r\n      if (!nextNode) \r\n        return false;\r\n      SwapIntersectNodes(*inode, *nextNode);\r\n    }\r\n    SwapPositionsInSEL(inode->Edge1, inode->Edge2);\r\n    inode = inode->Next;\r\n  }\r\n  return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline bool E2InsertsBeforeE1(TEdge &e1, TEdge &e2)\r\n{\r\n  if (e2.Curr.X == e1.Curr.X) \r\n  {\r\n    if (e2.Top.Y > e1.Top.Y)\r\n      return e2.Top.X < TopX(e1, e2.Top.Y); \r\n      else return e1.Top.X > TopX(e2, e1.Top.Y);\r\n  } \r\n  else return e2.Curr.X < e1.Curr.X;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool GetOverlap(const cInt a1, const cInt a2, const cInt b1, const cInt b2, \r\n    cInt& Left, cInt& Right)\r\n{\r\n  if (a1 < a2)\r\n  {\r\n    if (b1 < b2) {Left = std::max(a1,b1); Right = std::min(a2,b2);}\r\n    else {Left = std::max(a1,b2); Right = std::min(a2,b1);}\r\n  } \r\n  else\r\n  {\r\n    if (b1 < b2) {Left = std::max(a2,b1); Right = std::min(a1,b2);}\r\n    else {Left = std::max(a2,b2); Right = std::min(a1,b1);}\r\n  }\r\n  return Left < Right;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline void UpdateOutPtIdxs(OutRec& outrec)\r\n{  \r\n  OutPt* op = outrec.Pts;\r\n  do\r\n  {\r\n    op->Idx = outrec.Idx;\r\n    op = op->Prev;\r\n  }\r\n  while(op != outrec.Pts);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::InsertEdgeIntoAEL(TEdge *edge, TEdge* startEdge)\r\n{\r\n  if(!m_ActiveEdges)\r\n  {\r\n    edge->PrevInAEL = 0;\r\n    edge->NextInAEL = 0;\r\n    m_ActiveEdges = edge;\r\n  }\r\n  else if(!startEdge && E2InsertsBeforeE1(*m_ActiveEdges, *edge))\r\n  {\r\n      edge->PrevInAEL = 0;\r\n      edge->NextInAEL = m_ActiveEdges;\r\n      m_ActiveEdges->PrevInAEL = edge;\r\n      m_ActiveEdges = edge;\r\n  } \r\n  else\r\n  {\r\n    if(!startEdge) startEdge = m_ActiveEdges;\r\n    while(startEdge->NextInAEL  && \r\n      !E2InsertsBeforeE1(*startEdge->NextInAEL , *edge))\r\n        startEdge = startEdge->NextInAEL;\r\n    edge->NextInAEL = startEdge->NextInAEL;\r\n    if(startEdge->NextInAEL) startEdge->NextInAEL->PrevInAEL = edge;\r\n    edge->PrevInAEL = startEdge;\r\n    startEdge->NextInAEL = edge;\r\n  }\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nOutPt* DupOutPt(OutPt* outPt, bool InsertAfter)\r\n{\r\n  OutPt* result = new OutPt;\r\n  result->Pt = outPt->Pt;\r\n  result->Idx = outPt->Idx;\r\n  if (InsertAfter)\r\n  {\r\n    result->Next = outPt->Next;\r\n    result->Prev = outPt;\r\n    outPt->Next->Prev = result;\r\n    outPt->Next = result;\r\n  } \r\n  else\r\n  {\r\n    result->Prev = outPt->Prev;\r\n    result->Next = outPt;\r\n    outPt->Prev->Next = result;\r\n    outPt->Prev = result;\r\n  }\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool JoinHorz(OutPt* op1, OutPt* op1b, OutPt* op2, OutPt* op2b,\r\n  const IntPoint Pt, bool DiscardLeft)\r\n{\r\n  Direction Dir1 = (op1->Pt.X > op1b->Pt.X ? dRightToLeft : dLeftToRight);\r\n  Direction Dir2 = (op2->Pt.X > op2b->Pt.X ? dRightToLeft : dLeftToRight);\r\n  if (Dir1 == Dir2) return false;\r\n\r\n  //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\r\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\r\n  //So, to facilitate this while inserting Op1b and Op2b ...\r\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\r\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\r\n  if (Dir1 == dLeftToRight) \r\n  {\r\n    while (op1->Next->Pt.X <= Pt.X && \r\n      op1->Next->Pt.X >= op1->Pt.X && op1->Next->Pt.Y == Pt.Y)  \r\n        op1 = op1->Next;\r\n    if (DiscardLeft && (op1->Pt.X != Pt.X)) op1 = op1->Next;\r\n    op1b = DupOutPt(op1, !DiscardLeft);\r\n    if (op1b->Pt != Pt) \r\n    {\r\n      op1 = op1b;\r\n      op1->Pt = Pt;\r\n      op1b = DupOutPt(op1, !DiscardLeft);\r\n    }\r\n  } \r\n  else\r\n  {\r\n    while (op1->Next->Pt.X >= Pt.X && \r\n      op1->Next->Pt.X <= op1->Pt.X && op1->Next->Pt.Y == Pt.Y) \r\n        op1 = op1->Next;\r\n    if (!DiscardLeft && (op1->Pt.X != Pt.X)) op1 = op1->Next;\r\n    op1b = DupOutPt(op1, DiscardLeft);\r\n    if (op1b->Pt != Pt)\r\n    {\r\n      op1 = op1b;\r\n      op1->Pt = Pt;\r\n      op1b = DupOutPt(op1, DiscardLeft);\r\n    }\r\n  }\r\n\r\n  if (Dir2 == dLeftToRight)\r\n  {\r\n    while (op2->Next->Pt.X <= Pt.X && \r\n      op2->Next->Pt.X >= op2->Pt.X && op2->Next->Pt.Y == Pt.Y)\r\n        op2 = op2->Next;\r\n    if (DiscardLeft && (op2->Pt.X != Pt.X)) op2 = op2->Next;\r\n    op2b = DupOutPt(op2, !DiscardLeft);\r\n    if (op2b->Pt != Pt)\r\n    {\r\n      op2 = op2b;\r\n      op2->Pt = Pt;\r\n      op2b = DupOutPt(op2, !DiscardLeft);\r\n    };\r\n  } else\r\n  {\r\n    while (op2->Next->Pt.X >= Pt.X && \r\n      op2->Next->Pt.X <= op2->Pt.X && op2->Next->Pt.Y == Pt.Y) \r\n        op2 = op2->Next;\r\n    if (!DiscardLeft && (op2->Pt.X != Pt.X)) op2 = op2->Next;\r\n    op2b = DupOutPt(op2, DiscardLeft);\r\n    if (op2b->Pt != Pt)\r\n    {\r\n      op2 = op2b;\r\n      op2->Pt = Pt;\r\n      op2b = DupOutPt(op2, DiscardLeft);\r\n    };\r\n  };\r\n\r\n  if ((Dir1 == dLeftToRight) == DiscardLeft)\r\n  {\r\n    op1->Prev = op2;\r\n    op2->Next = op1;\r\n    op1b->Next = op2b;\r\n    op2b->Prev = op1b;\r\n  }\r\n  else\r\n  {\r\n    op1->Next = op2;\r\n    op2->Prev = op1;\r\n    op1b->Prev = op2b;\r\n    op2b->Next = op1b;\r\n  }\r\n  return true;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool Clipper::JoinPoints(const Join *j, OutPt *&p1, OutPt *&p2)\r\n{\r\n  OutRec* outRec1 = GetOutRec(j->OutPt1->Idx);\r\n  OutRec* outRec2 = GetOutRec(j->OutPt2->Idx);\r\n  OutPt *op1 = j->OutPt1, *op1b;\r\n  OutPt *op2 = j->OutPt2, *op2b;\r\n\r\n  //There are 3 kinds of joins for output polygons ...\r\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\r\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\r\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\r\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\r\n  //3. StrictSimple joins where edges touch but are not collinear and where\r\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\r\n  bool isHorizontal = (j->OutPt1->Pt.Y == j->OffPt.Y);\r\n\r\n  if (isHorizontal  && (j->OffPt == j->OutPt1->Pt) &&\r\n  (j->OffPt == j->OutPt2->Pt))\r\n  {\r\n    //Strictly Simple join ...\r\n    op1b = j->OutPt1->Next;\r\n    while (op1b != op1 && (op1b->Pt == j->OffPt)) \r\n      op1b = op1b->Next;\r\n    bool reverse1 = (op1b->Pt.Y > j->OffPt.Y);\r\n    op2b = j->OutPt2->Next;\r\n    while (op2b != op2 && (op2b->Pt == j->OffPt)) \r\n      op2b = op2b->Next;\r\n    bool reverse2 = (op2b->Pt.Y > j->OffPt.Y);\r\n    if (reverse1 == reverse2) return false;\r\n    if (reverse1)\r\n    {\r\n      op1b = DupOutPt(op1, false);\r\n      op2b = DupOutPt(op2, true);\r\n      op1->Prev = op2;\r\n      op2->Next = op1;\r\n      op1b->Next = op2b;\r\n      op2b->Prev = op1b;\r\n      p1 = op1;\r\n      p2 = op1b;\r\n      return true;\r\n    } else\r\n    {\r\n      op1b = DupOutPt(op1, true);\r\n      op2b = DupOutPt(op2, false);\r\n      op1->Next = op2;\r\n      op2->Prev = op1;\r\n      op1b->Prev = op2b;\r\n      op2b->Next = op1b;\r\n      p1 = op1;\r\n      p2 = op1b;\r\n      return true;\r\n    }\r\n  } \r\n  else if (isHorizontal)\r\n  {\r\n    //treat horizontal joins differently to non-horizontal joins since with\r\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\r\n    //may be anywhere along the horizontal edge.\r\n    op1b = op1;\r\n    while (op1->Prev->Pt.Y == op1->Pt.Y && op1->Prev != op1b && op1->Prev != op2)\r\n      op1 = op1->Prev;\r\n    while (op1b->Next->Pt.Y == op1b->Pt.Y && op1b->Next != op1 && op1b->Next != op2)\r\n      op1b = op1b->Next;\r\n    if (op1b->Next == op1 || op1b->Next == op2) return false; //a flat 'polygon'\r\n\r\n    op2b = op2;\r\n    while (op2->Prev->Pt.Y == op2->Pt.Y && op2->Prev != op2b && op2->Prev != op1b)\r\n      op2 = op2->Prev;\r\n    while (op2b->Next->Pt.Y == op2b->Pt.Y && op2b->Next != op2 && op2b->Next != op1)\r\n      op2b = op2b->Next;\r\n    if (op2b->Next == op2 || op2b->Next == op1) return false; //a flat 'polygon'\r\n\r\n    cInt Left, Right;\r\n    //Op1 --> Op1b & Op2 --> Op2b are the extremites of the horizontal edges\r\n    if (!GetOverlap(op1->Pt.X, op1b->Pt.X, op2->Pt.X, op2b->Pt.X, Left, Right))\r\n      return false;\r\n\r\n    //DiscardLeftSide: when overlapping edges are joined, a spike will created\r\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\r\n    //on the discard Side as either may still be needed for other joins ...\r\n    IntPoint Pt;\r\n    bool DiscardLeftSide;\r\n    if (op1->Pt.X >= Left && op1->Pt.X <= Right) \r\n    {\r\n      Pt = op1->Pt; DiscardLeftSide = (op1->Pt.X > op1b->Pt.X);\r\n    } \r\n    else if (op2->Pt.X >= Left&& op2->Pt.X <= Right) \r\n    {\r\n      Pt = op2->Pt; DiscardLeftSide = (op2->Pt.X > op2b->Pt.X);\r\n    } \r\n    else if (op1b->Pt.X >= Left && op1b->Pt.X <= Right)\r\n    {\r\n      Pt = op1b->Pt; DiscardLeftSide = op1b->Pt.X > op1->Pt.X;\r\n    } \r\n    else\r\n    {\r\n      Pt = op2b->Pt; DiscardLeftSide = (op2b->Pt.X > op2->Pt.X);\r\n    }\r\n    p1 = op1; p2 = op2;\r\n    return JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\r\n  } else\r\n  {\r\n    //nb: For non-horizontal joins ...\r\n    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\r\n    //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\r\n\r\n    //make sure the polygons are correctly oriented ...\r\n    op1b = op1->Next;\r\n    while ((op1b->Pt == op1->Pt) && (op1b != op1)) op1b = op1b->Next;\r\n    bool Reverse1 = ((op1b->Pt.Y > op1->Pt.Y) ||\r\n      !SlopesEqual(op1->Pt, op1b->Pt, j->OffPt, m_UseFullRange));\r\n    if (Reverse1)\r\n    {\r\n      op1b = op1->Prev;\r\n      while ((op1b->Pt == op1->Pt) && (op1b != op1)) op1b = op1b->Prev;\r\n      if ((op1b->Pt.Y > op1->Pt.Y) ||\r\n        !SlopesEqual(op1->Pt, op1b->Pt, j->OffPt, m_UseFullRange)) return false;\r\n    };\r\n    op2b = op2->Next;\r\n    while ((op2b->Pt == op2->Pt) && (op2b != op2))op2b = op2b->Next;\r\n    bool Reverse2 = ((op2b->Pt.Y > op2->Pt.Y) ||\r\n      !SlopesEqual(op2->Pt, op2b->Pt, j->OffPt, m_UseFullRange));\r\n    if (Reverse2)\r\n    {\r\n      op2b = op2->Prev;\r\n      while ((op2b->Pt == op2->Pt) && (op2b != op2)) op2b = op2b->Prev;\r\n      if ((op2b->Pt.Y > op2->Pt.Y) ||\r\n        !SlopesEqual(op2->Pt, op2b->Pt, j->OffPt, m_UseFullRange)) return false;\r\n    }\r\n\r\n    if ((op1b == op1) || (op2b == op2) || (op1b == op2b) ||\r\n      ((outRec1 == outRec2) && (Reverse1 == Reverse2))) return false;\r\n\r\n    if (Reverse1)\r\n    {\r\n      op1b = DupOutPt(op1, false);\r\n      op2b = DupOutPt(op2, true);\r\n      op1->Prev = op2;\r\n      op2->Next = op1;\r\n      op1b->Next = op2b;\r\n      op2b->Prev = op1b;\r\n      p1 = op1;\r\n      p2 = op1b;\r\n      return true;\r\n    } else\r\n    {\r\n      op1b = DupOutPt(op1, true);\r\n      op2b = DupOutPt(op2, false);\r\n      op1->Next = op2;\r\n      op2->Prev = op1;\r\n      op1b->Prev = op2b;\r\n      op2b->Next = op1b;\r\n      p1 = op1;\r\n      p2 = op1b;\r\n      return true;\r\n    }\r\n  }\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nbool Poly2ContainsPoly1(OutPt* OutPt1, OutPt* OutPt2, bool UseFullInt64Range)\r\n{\r\n  OutPt* Pt = OutPt1;\r\n  //Because the polygons may be touching, we need to find a vertex that\r\n  //isn't touching the other polygon ...\r\n  if (PointOnPolygon(Pt->Pt, OutPt2, UseFullInt64Range))\r\n  {\r\n    Pt = Pt->Next;\r\n    while (Pt != OutPt1 && PointOnPolygon(Pt->Pt, OutPt2, UseFullInt64Range))\r\n        Pt = Pt->Next;\r\n    if (Pt == OutPt1) return true;\r\n  }\r\n  return PointInPolygon(Pt->Pt, OutPt2, UseFullInt64Range);\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nvoid Clipper::FixupFirstLefts1(OutRec* OldOutRec, OutRec* NewOutRec)\r\n{ \r\n  \r\n  for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n  {\r\n    OutRec* outRec = m_PolyOuts[i];\r\n    if (outRec->Pts && outRec->FirstLeft == OldOutRec) \r\n    {\r\n      if (Poly2ContainsPoly1(outRec->Pts, NewOutRec->Pts, m_UseFullRange))\r\n        outRec->FirstLeft = NewOutRec;\r\n    }\r\n  }\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nvoid Clipper::FixupFirstLefts2(OutRec* OldOutRec, OutRec* NewOutRec)\r\n{ \r\n  for (PolyOutList::size_type i = 0; i < m_PolyOuts.size(); ++i)\r\n  {\r\n    OutRec* outRec = m_PolyOuts[i];\r\n    if (outRec->FirstLeft == OldOutRec) outRec->FirstLeft = NewOutRec;\r\n  }\r\n}\r\n//----------------------------------------------------------------------\r\n\r\nvoid Clipper::JoinCommonEdges()\r\n{\r\n  for (JoinList::size_type i = 0; i < m_Joins.size(); i++)\r\n  {\r\n    Join* j = m_Joins[i];\r\n\r\n    OutRec *outRec1 = GetOutRec(j->OutPt1->Idx);\r\n    OutRec *outRec2 = GetOutRec(j->OutPt2->Idx);\r\n\r\n    if (!outRec1->Pts || !outRec2->Pts) continue;\r\n\r\n    //get the polygon fragment with the correct hole state (FirstLeft)\r\n    //before calling JoinPoints() ...\r\n    OutRec *holeStateRec;\r\n    if (outRec1 == outRec2) holeStateRec = outRec1;\r\n    else if (Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;\r\n    else if (Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;\r\n    else holeStateRec = GetLowermostRec(outRec1, outRec2);\r\n\r\n    OutPt *p1, *p2;\r\n    if (!JoinPoints(j, p1, p2)) continue;\r\n\r\n    if (outRec1 == outRec2)\r\n    {\r\n      //instead of joining two polygons, we've just created a new one by\r\n      //splitting one polygon into two.\r\n      outRec1->Pts = p1;\r\n      outRec1->BottomPt = 0;\r\n      outRec2 = CreateOutRec();\r\n      outRec2->Pts = p2;\r\n\r\n      //update all OutRec2.Pts Idx's ...\r\n      UpdateOutPtIdxs(*outRec2);\r\n\r\n      if (Poly2ContainsPoly1(outRec2->Pts, outRec1->Pts, m_UseFullRange))\r\n      {\r\n        //outRec2 is contained by outRec1 ...\r\n        outRec2->IsHole = !outRec1->IsHole;\r\n        outRec2->FirstLeft = outRec1;\r\n\r\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\r\n        if (m_UsingPolyTree) FixupFirstLefts2(outRec2, outRec1);\r\n\r\n        if ((outRec2->IsHole ^ m_ReverseOutput) == (Area(*outRec2) > 0))\r\n          ReversePolyPtLinks(outRec2->Pts);\r\n            \r\n      } else if (Poly2ContainsPoly1(outRec1->Pts, outRec2->Pts, m_UseFullRange))\r\n      {\r\n        //outRec1 is contained by outRec2 ...\r\n        outRec2->IsHole = outRec1->IsHole;\r\n        outRec1->IsHole = !outRec2->IsHole;\r\n        outRec2->FirstLeft = outRec1->FirstLeft;\r\n        outRec1->FirstLeft = outRec2;\r\n\r\n        //fixup FirstLeft pointers that may need reassigning to OutRec1\r\n        if (m_UsingPolyTree) FixupFirstLefts2(outRec1, outRec2);\r\n\r\n        if ((outRec1->IsHole ^ m_ReverseOutput) == (Area(*outRec1) > 0))\r\n          ReversePolyPtLinks(outRec1->Pts);\r\n      } \r\n      else\r\n      {\r\n        //the 2 polygons are completely separate ...\r\n        outRec2->IsHole = outRec1->IsHole;\r\n        outRec2->FirstLeft = outRec1->FirstLeft;\r\n\r\n        //fixup FirstLeft pointers that may need reassigning to OutRec2\r\n        if (m_UsingPolyTree) FixupFirstLefts1(outRec1, outRec2);\r\n      }\r\n     \r\n    } else\r\n    {\r\n      //joined 2 polygons together ...\r\n\r\n      outRec2->Pts = 0;\r\n      outRec2->BottomPt = 0;\r\n      outRec2->Idx = outRec1->Idx;\r\n\r\n      outRec1->IsHole = holeStateRec->IsHole;\r\n      if (holeStateRec == outRec2) \r\n        outRec1->FirstLeft = outRec2->FirstLeft;\r\n      outRec2->FirstLeft = outRec1;\r\n\r\n      //fixup FirstLeft pointers that may need reassigning to OutRec1\r\n      if (m_UsingPolyTree) FixupFirstLefts2(outRec2, outRec1);\r\n    }\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Clipper::DoSimplePolygons()\r\n{\r\n  PolyOutList::size_type i = 0;\r\n  while (i < m_PolyOuts.size()) \r\n  {\r\n    OutRec* outrec = m_PolyOuts[i++];\r\n    OutPt* op = outrec->Pts;\r\n    if (!op) continue;\r\n    do //for each Pt in Polygon until duplicate found do ...\r\n    {\r\n      OutPt* op2 = op->Next;\r\n      while (op2 != outrec->Pts) \r\n      {\r\n        if ((op->Pt == op2->Pt) && op2->Next != op && op2->Prev != op) \r\n        {\r\n          //split the polygon into two ...\r\n          OutPt* op3 = op->Prev;\r\n          OutPt* op4 = op2->Prev;\r\n          op->Prev = op4;\r\n          op4->Next = op;\r\n          op2->Prev = op3;\r\n          op3->Next = op2;\r\n\r\n          outrec->Pts = op;\r\n          OutRec* outrec2 = CreateOutRec();\r\n          outrec2->Pts = op2;\r\n          UpdateOutPtIdxs(*outrec2);\r\n          if (Poly2ContainsPoly1(outrec2->Pts, outrec->Pts, m_UseFullRange))\r\n          {\r\n            //OutRec2 is contained by OutRec1 ...\r\n            outrec2->IsHole = !outrec->IsHole;\r\n            outrec2->FirstLeft = outrec;\r\n          }\r\n          else\r\n            if (Poly2ContainsPoly1(outrec->Pts, outrec2->Pts, m_UseFullRange))\r\n          {\r\n            //OutRec1 is contained by OutRec2 ...\r\n            outrec2->IsHole = outrec->IsHole;\r\n            outrec->IsHole = !outrec2->IsHole;\r\n            outrec2->FirstLeft = outrec->FirstLeft;\r\n            outrec->FirstLeft = outrec2;\r\n          } else\r\n          {\r\n            //the 2 polygons are separate ...\r\n            outrec2->IsHole = outrec->IsHole;\r\n            outrec2->FirstLeft = outrec->FirstLeft;\r\n          }\r\n          op2 = op; //ie get ready for the Next iteration\r\n        }\r\n        op2 = op2->Next;\r\n      }\r\n      op = op->Next;\r\n    }\r\n    while (op != outrec->Pts);\r\n  }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ReversePath(Path& p)\r\n{\r\n  std::reverse(p.begin(), p.end());\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ReversePaths(Paths& p)\r\n{\r\n  for (Paths::size_type i = 0; i < p.size(); ++i)\r\n    ReversePath(p[i]);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n// OffsetPolygon functions ...\r\n//------------------------------------------------------------------------------\r\n\r\nDoublePoint GetUnitNormal(const IntPoint &pt1, const IntPoint &pt2)\r\n{\r\n  if(pt2.X == pt1.X && pt2.Y == pt1.Y) \r\n    return DoublePoint(0, 0);\r\n\r\n  double Dx = (double)(pt2.X - pt1.X);\r\n  double dy = (double)(pt2.Y - pt1.Y);\r\n  double f = 1 *1.0/ std::sqrt( Dx*Dx + dy*dy );\r\n  Dx *= f;\r\n  dy *= f;\r\n  return DoublePoint(dy, -Dx);\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n//------------------------------------------------------------------------------\r\n\r\nclass OffsetBuilder\r\n{\r\nprivate:\r\n  const Paths& m_p;\r\n  Path* m_curr_poly;\r\n  std::vector<DoublePoint> normals;\r\n  double m_delta, m_sinA, m_sin, m_cos;\r\n  double m_miterLim, m_Steps360;\r\n  size_t m_i, m_j, m_k;\r\n  static const int buffLength = 128;\r\n \r\npublic:\r\n\r\nOffsetBuilder(const Paths& in_polys, Paths& out_polys,\r\n  double Delta, JoinType jointype, EndType endtype, double limit): m_p(in_polys)\r\n{\r\n    //precondition: &out_polys != &in_polys\r\n\r\n    if (NEAR_ZERO(Delta)) {out_polys = in_polys; return;}\r\n    //we can't shrink a polyline so ...\r\n    if (endtype != etClosed && Delta < 0) Delta = -Delta;\r\n    m_delta = Delta;\r\n\r\n  if (jointype == jtMiter) \r\n  {\r\n    //m_miterLim: see offset_triginometry.svg in the documentation folder ...\r\n    if (limit > 2) m_miterLim = 2/(limit*limit);\r\n    else m_miterLim = 0.5;\r\n    if (endtype == etRound) limit = 0.25;\r\n  }\r\n\r\n  if (jointype == jtRound || endtype == etRound)\r\n  {\r\n    if (limit <= 0) limit = 0.25;\r\n    else if (limit > std::fabs(Delta)*0.25) limit = std::fabs(Delta)*0.25;\r\n    //m_Steps360: see offset_triginometry2.svg in the documentation folder ...\r\n    m_Steps360 = pi / acos(1 - limit / std::fabs(Delta));\r\n    m_sin = std::sin(2 * pi / m_Steps360);\r\n    m_cos = std::cos(2 * pi / m_Steps360);\r\n    m_Steps360 /= pi * 2;\r\n    if (Delta < 0) m_sin = -m_sin;\r\n  }\r\n\r\n  out_polys.clear();\r\n  out_polys.resize(m_p.size());\r\n  for (m_i = 0; m_i < m_p.size(); m_i++)\r\n  {\r\n      size_t len = m_p[m_i].size();\r\n\r\n      if (len == 0 || (len < 3 && Delta <= 0)) continue;\r\n      \r\n      if (len == 1)\r\n      {\r\n        if (jointype == jtRound)\r\n        {\r\n          double X = 1.0, Y = 0.0;\r\n          for (cInt j = 1; j <= Round(m_Steps360 * 2 * pi); j++)\r\n          {\r\n            AddPoint(IntPoint(\r\n              Round(m_p[m_i][0].X + X * Delta),\r\n              Round(m_p[m_i][0].Y + Y * Delta)));\r\n            double X2 = X;\r\n            X = X * m_cos - m_sin * Y;\r\n            Y = X2 * m_sin + Y * m_cos;\r\n          }\r\n        } else\r\n        {\r\n          double X = -1.0, Y = -1.0;\r\n          for (int j = 0; j < 4; ++j)\r\n          {\r\n            AddPoint(IntPoint( Round(m_p[m_i][0].X + X * Delta),\r\n              Round(m_p[m_i][0].Y + Y * Delta)));\r\n            if (X < 0) X = 1;\r\n            else if (Y < 0) Y = 1;\r\n            else X = -1;\r\n          }\r\n        }\r\n        continue;\r\n      }\r\n\r\n      //build normals ...\r\n      normals.clear();\r\n      normals.resize(len);\r\n      for (m_j = 0; m_j < len -1; ++m_j)\r\n          normals[m_j] = GetUnitNormal(m_p[m_i][m_j], m_p[m_i][m_j +1]);\r\n      if (endtype == etClosed) \r\n        normals[len-1] = GetUnitNormal(m_p[m_i][len-1], m_p[m_i][0]);\r\n      else //is open polyline\r\n        normals[len-1] = normals[len-2];\r\n        \r\n      m_curr_poly = &out_polys[m_i];\r\n      m_curr_poly->reserve(len);\r\n\r\n      if (endtype == etClosed)\r\n      {\r\n        m_k = len -1;\r\n        for (m_j = 0; m_j < len; ++m_j)\r\n          OffsetPoint(jointype);\r\n      }\r\n      else //is open polyline\r\n      {\r\n        //offset the polyline going forward ...\r\n        m_k = 0;\r\n        for (m_j = 1; m_j < len -1; ++m_j)\r\n          OffsetPoint(jointype);\r\n\r\n        //handle the end (butt, round or square) ...\r\n        IntPoint pt1;\r\n        if (endtype == etButt)\r\n        {\r\n          m_j = len - 1;\r\n          pt1 = IntPoint(Round(m_p[m_i][m_j].X + normals[m_j].X * m_delta), \r\n            Round(m_p[m_i][m_j].Y + normals[m_j].Y * m_delta));\r\n          AddPoint(pt1);\r\n          pt1 = IntPoint(Round(m_p[m_i][m_j].X - normals[m_j].X * m_delta), \r\n            Round(m_p[m_i][m_j].Y - normals[m_j].Y * m_delta));\r\n          AddPoint(pt1);\r\n        } \r\n        else\r\n        {\r\n          m_j = len - 1;\r\n          m_k = len - 2;\r\n          m_sinA = 0;\r\n          normals[m_j].X = -normals[m_j].X;\r\n          normals[m_j].Y = -normals[m_j].Y;\r\n          if (endtype == etSquare) \r\n            DoSquare();\r\n          else \r\n            DoRound();\r\n        }\r\n\r\n        //re-build Normals ...\r\n        for (int j = len - 1; j > 0; --j)\r\n        {\r\n            normals[j].X = -normals[j - 1].X;\r\n            normals[j].Y = -normals[j - 1].Y;\r\n        }\r\n        normals[0].X = -normals[1].X;\r\n        normals[0].Y = -normals[1].Y;\r\n\r\n        //offset the polyline going backward ...\r\n        m_k = len -1;\r\n        for (m_j = m_k - 1; m_j > 0; --m_j)\r\n          OffsetPoint(jointype);\r\n\r\n        //finally handle the start (butt, round or square) ...\r\n        if (endtype == etButt) \r\n        {\r\n          pt1 = IntPoint(Round(m_p[m_i][0].X - normals[0].X * m_delta), \r\n            Round(m_p[m_i][0].Y - normals[0].Y * m_delta));\r\n          AddPoint(pt1);\r\n          pt1 = IntPoint(Round(m_p[m_i][0].X + normals[0].X * m_delta), \r\n            Round(m_p[m_i][0].Y + normals[0].Y * m_delta));\r\n          AddPoint(pt1);\r\n        } else\r\n        {\r\n          m_sinA = 0;\r\n          m_k = 1;\r\n          if (endtype == etSquare) \r\n            DoSquare(); \r\n          else \r\n            DoRound();\r\n        }\r\n      }\r\n    }\r\n\r\n    //and clean up untidy corners using Clipper ...\r\n    Clipper clpr;\r\n    clpr.AddPaths(out_polys, ptSubject, true);\r\n    if (Delta > 0)\r\n    {\r\n        if (!clpr.Execute(ctUnion, out_polys, pftPositive, pftPositive))\r\n            out_polys.clear();\r\n    }\r\n    else\r\n    {\r\n        IntRect r = clpr.GetBounds();\r\n        Path outer(4);\r\n        outer[0] = IntPoint(r.left - 10, r.bottom + 10);\r\n        outer[1] = IntPoint(r.right + 10, r.bottom + 10);\r\n        outer[2] = IntPoint(r.right + 10, r.top - 10);\r\n        outer[3] = IntPoint(r.left - 10, r.top - 10);\r\n\r\n        clpr.AddPath(outer, ptSubject, true);\r\n        clpr.ReverseSolution(true);\r\n        if (clpr.Execute(ctUnion, out_polys, pftNegative, pftNegative))\r\n            out_polys.erase(out_polys.begin());\r\n        else\r\n            out_polys.clear();\r\n    }\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nprivate:\r\n\r\nvoid OffsetPoint(JoinType jointype)\r\n{\r\n  m_sinA = (normals[m_k].X * normals[m_j].Y - normals[m_j].X * normals[m_k].Y);\r\n  if (std::fabs(m_sinA) < 0.00005) return; //ie collinear\r\n  else if (m_sinA > 1.0) m_sinA = 1.0; \r\n  else if (m_sinA < -1.0) m_sinA = -1.0;\r\n\r\n  if (m_sinA * m_delta < 0)\r\n  {\r\n    AddPoint(IntPoint(Round(m_p[m_i][m_j].X + normals[m_k].X * m_delta),\r\n      Round(m_p[m_i][m_j].Y + normals[m_k].Y * m_delta)));\r\n    AddPoint(m_p[m_i][m_j]);\r\n    AddPoint(IntPoint(Round(m_p[m_i][m_j].X + normals[m_j].X * m_delta),\r\n      Round(m_p[m_i][m_j].Y + normals[m_j].Y * m_delta)));\r\n  }\r\n  else\r\n    switch (jointype)\r\n      {\r\n        case jtMiter:\r\n        {\r\n          double r = 1 + (normals[m_j].X*normals[m_k].X + \r\n            normals[m_j].Y*normals[m_k].Y);\r\n          if (r >= m_miterLim) DoMiter(r); else DoSquare();\r\n          break;\r\n        }\r\n        case jtSquare: DoSquare(); break;\r\n        case jtRound: DoRound(); break;\r\n      }\r\n      m_k = m_j;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid AddPoint(const IntPoint& Pt)\r\n{\r\n    if (m_curr_poly->size() == m_curr_poly->capacity())\r\n        m_curr_poly->reserve(m_curr_poly->capacity() + buffLength);\r\n    m_curr_poly->push_back(Pt);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid DoSquare()\r\n{\r\n  double Dx = std::tan(std::atan2(m_sinA, \r\n    normals[m_k].X * normals[m_j].X + normals[m_k].Y * normals[m_j].Y)/4);\r\n  AddPoint(IntPoint(\r\n    Round(m_p[m_i][m_j].X + m_delta * (normals[m_k].X - normals[m_k].Y *Dx)),\r\n    Round(m_p[m_i][m_j].Y + m_delta * (normals[m_k].Y + normals[m_k].X *Dx))));\r\n  AddPoint(IntPoint(\r\n    Round(m_p[m_i][m_j].X + m_delta * (normals[m_j].X + normals[m_j].Y *Dx)),\r\n    Round(m_p[m_i][m_j].Y + m_delta * (normals[m_j].Y - normals[m_j].X *Dx))));\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid DoMiter(double r)\r\n{\r\n    double q = m_delta / r;\r\n    AddPoint(IntPoint(Round(m_p[m_i][m_j].X + (normals[m_k].X + normals[m_j].X) * q),\r\n        Round(m_p[m_i][m_j].Y + (normals[m_k].Y + normals[m_j].Y) * q)));\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid DoRound()\r\n{\r\n  double a = std::atan2(m_sinA, \r\n    normals[m_k].X * normals[m_j].X + normals[m_k].Y * normals[m_j].Y);\r\n  int steps = (int)Round(m_Steps360 * std::fabs(a));\r\n\r\n  double X = normals[m_k].X, Y = normals[m_k].Y, X2;\r\n  for (int i = 0; i < steps; ++i)\r\n  {\r\n    AddPoint(IntPoint(\r\n      Round(m_p[m_i][m_j].X + X * m_delta),\r\n      Round(m_p[m_i][m_j].Y + Y * m_delta)));\r\n    X2 = X;\r\n    X = X * m_cos - m_sin * Y;\r\n    Y = X2 * m_sin + Y * m_cos;\r\n  }\r\n  AddPoint(IntPoint(\r\n    Round(m_p[m_i][m_j].X + normals[m_j].X * m_delta),\r\n    Round(m_p[m_i][m_j].Y + normals[m_j].Y * m_delta)));\r\n}\r\n//--------------------------------------------------------------------------\r\n\r\n}; //end PolyOffsetBuilder\r\n\r\n//------------------------------------------------------------------------------\r\n//------------------------------------------------------------------------------\r\n\r\nvoid StripDupsAndGetBotPt(Path& in_path, Path& out_path, bool closed, IntPoint* botPt)\r\n{\r\n  botPt = 0;\r\n  size_t len = in_path.size();\r\n  if (closed)    \r\n    while (len > 0 && (in_path[0] == in_path[len -1])) len--;\r\n  if (len == 0) return;\r\n  out_path.resize(len);\r\n  int j = 0;\r\n  out_path[0] = in_path[0];\r\n  botPt = &out_path[0];\r\n  for (size_t i = 1; i < len; ++i)\r\n    if (in_path[i] != out_path[j])\r\n    {\r\n      j++;\r\n      out_path[j] = in_path[i];\r\n      if (out_path[j].Y > botPt->Y)\r\n        botPt = &out_path[j];\r\n      else if ((out_path[j].Y == botPt->Y) && out_path[j].X < botPt->X) \r\n        botPt = &out_path[j];\r\n    }\r\n  j++;\r\n  if (j < 2 || (closed && (j == 2))) j = 0;\r\n  out_path.resize(j);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid OffsetPaths(const Paths &in_polys, Paths &out_polys,\r\n  double delta, JoinType jointype, EndType endtype, double limit)\r\n{\r\n  //just in case in_polys == &out_polys ...\r\n  Paths inPolys = Paths(in_polys);\r\n  out_polys.clear();\r\n  out_polys.resize(inPolys.size());\r\n\r\n  IntPoint *botPt = 0, *pt = 0;\r\n  int botIdx = -1;\r\n  for (size_t i = 0; i < in_polys.size(); ++i)\r\n  {\r\n    StripDupsAndGetBotPt(inPolys[i], out_polys[i], endtype == etClosed, pt);\r\n    if (botPt) \r\n      if (!botPt || pt->Y > botPt->Y || (pt->Y == botPt->Y && pt->X < botPt->X))\r\n      {\r\n        botPt = pt;\r\n        botIdx = i;\r\n      }\r\n\r\n  }\r\n  if (endtype == etClosed && botIdx >= 0 && !Orientation(inPolys[botIdx]))\r\n      ReversePaths(inPolys);\r\n\r\n  OffsetBuilder(inPolys, out_polys, delta, jointype, endtype, limit);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid SimplifyPolygons(const Paths &in_polys, Paths &out_polys, PolyFillType fillType)\r\n{\r\n  Clipper c;\r\n  c.StrictlySimple(true);\r\n  c.AddPaths(in_polys, ptSubject, true);\r\n  c.Execute(ctUnion, out_polys, fillType, fillType);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid SimplifyPolygons(Paths &polys, PolyFillType fillType)\r\n{\r\n  SimplifyPolygons(polys, polys, fillType);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\ninline double DistanceSqrd(const IntPoint& pt1, const IntPoint& pt2)\r\n{\r\n  double Dx = ((double)pt1.X - pt2.X);\r\n  double dy = ((double)pt1.Y - pt2.Y);\r\n  return (Dx*Dx + dy*dy);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nDoublePoint ClosestPointOnLine(const IntPoint& Pt, const IntPoint& linePt1, const IntPoint& linePt2)\r\n{\r\n  double Dx = ((double)linePt2.X - linePt1.X);\r\n  double dy = ((double)linePt2.Y - linePt1.Y);\r\n  if (Dx == 0 && dy == 0) \r\n    return DoublePoint((double)linePt1.X, (double)linePt1.Y);\r\n  double q = ((Pt.X-linePt1.X)*Dx + (Pt.Y-linePt1.Y)*dy) / (Dx*Dx + dy*dy);\r\n  return DoublePoint(\r\n    (1-q)*linePt1.X + q*linePt2.X,\r\n    (1-q)*linePt1.Y + q*linePt2.Y);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool SlopesNearCollinear(const IntPoint& pt1, \r\n    const IntPoint& pt2, const IntPoint& pt3, double distSqrd)\r\n{\r\n  if (DistanceSqrd(pt1, pt2) > DistanceSqrd(pt1, pt3)) return false;\r\n  DoublePoint cpol = ClosestPointOnLine(pt2, pt1, pt3);\r\n  double Dx = pt2.X - cpol.X;\r\n  double dy = pt2.Y - cpol.Y;\r\n  return (Dx*Dx + dy*dy) < distSqrd;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool PointsAreClose(IntPoint pt1, IntPoint pt2, double distSqrd)\r\n{\r\n    double Dx = (double)pt1.X - pt2.X;\r\n    double dy = (double)pt1.Y - pt2.Y;\r\n    return ((Dx * Dx) + (dy * dy) <= distSqrd);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid CleanPolygon(const Path& in_poly, Path& out_poly, double distance)\r\n{\r\n  //distance = proximity in units/pixels below which vertices\r\n  //will be stripped. Default ~= sqrt(2).\r\n  int highI = in_poly.size() -1;\r\n  double distSqrd = distance * distance;\r\n  while (highI > 0 && PointsAreClose(in_poly[highI], in_poly[0], distSqrd)) highI--;\r\n  if (highI < 2) { out_poly.clear(); return; }\r\n  \r\n  if (&in_poly != &out_poly) \r\n    out_poly.resize(highI + 1);\r\n\r\n  IntPoint Pt = in_poly[highI];\r\n  int i = 0, k = 0;\r\n  for (;;)\r\n  {\r\n    while (i < highI && PointsAreClose(Pt, in_poly[i+1], distSqrd)) i+=2;\r\n    int i2 = i;\r\n    while (i < highI && (PointsAreClose(in_poly[i], in_poly[i+1], distSqrd) ||\r\n      SlopesNearCollinear(Pt, in_poly[i], in_poly[i+1], distSqrd))) i++;\r\n    if (i >= highI) break;\r\n    else if (i != i2) continue;\r\n    Pt = in_poly[i++];\r\n    out_poly[k++] = Pt;\r\n  }\r\n  if (i <= highI) out_poly[k++] = in_poly[i];\r\n  if (k > 2 && SlopesNearCollinear(out_poly[k -2], out_poly[k -1], out_poly[0], distSqrd)) k--;    \r\n  if (k < 3) out_poly.clear();\r\n  else if (k <= highI) out_poly.resize(k);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid CleanPolygon(Path& poly, double distance)\r\n{\r\n  CleanPolygon(poly, poly, distance);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid CleanPolygons(const Paths& in_polys, Paths& out_polys, double distance)\r\n{\r\n  for (Paths::size_type i = 0; i < in_polys.size(); ++i)\r\n    CleanPolygon(in_polys[i], out_polys[i], distance);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid CleanPolygons(Paths& polys, double distance)\r\n{\r\n  CleanPolygons(polys, polys, distance);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid Minkowki(const Path& poly, const Path& path, \r\n  Paths& solution, bool isSum, bool isClosed)\r\n{\r\n  int delta = (isClosed ? 1 : 0);\r\n  size_t polyCnt = poly.size();\r\n  size_t pathCnt = path.size();\r\n  Paths pp;\r\n  pp.reserve(pathCnt);\r\n  if (isSum)\r\n    for (size_t i = 0; i < pathCnt; ++i)\r\n    {\r\n      Path p;\r\n      p.reserve(polyCnt);\r\n      for (size_t j = 0; j < poly.size(); ++j)\r\n        p.push_back(IntPoint(path[i].X + poly[j].X, path[i].Y + poly[j].Y));\r\n      pp.push_back(p);\r\n    }\r\n  else\r\n    for (size_t i = 0; i < pathCnt; ++i)\r\n    {\r\n      Path p;\r\n      p.reserve(polyCnt);\r\n      for (size_t j = 0; j < poly.size(); ++j)\r\n        p.push_back(IntPoint(path[i].X - poly[j].X, path[i].Y - poly[j].Y));\r\n      pp.push_back(p);\r\n    }\r\n\r\n  Paths quads; \r\n  quads.reserve((pathCnt + delta) * (polyCnt + 1));\r\n  for (size_t i = 0; i <= pathCnt - 2 + delta; ++i)\r\n    for (size_t j = 0; j <= polyCnt - 1; ++j)\r\n    {\r\n      Path quad;\r\n      quad.reserve(4);\r\n      quad.push_back(pp[i % pathCnt][j % polyCnt]);\r\n      quad.push_back(pp[(i + 1) % pathCnt][j % polyCnt]);\r\n      quad.push_back(pp[(i + 1) % pathCnt][(j + 1) % polyCnt]);\r\n      quad.push_back(pp[i % pathCnt][(j + 1) % polyCnt]);\r\n      if (!Orientation(quad)) ReversePath(quad);\r\n      quads.push_back(quad);\r\n    }\r\n\r\n  Clipper c;\r\n  c.AddPaths(quads, ptSubject, true);\r\n  c.Execute(ctUnion, solution, pftNonZero, pftNonZero);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid MinkowkiSum(const Path& poly, const Path& path, Paths& solution, bool isClosed)\r\n{\r\n  Minkowki(poly, path, solution, true, isClosed);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid MinkowkiDiff(const Path& poly, const Path& path, Paths& solution, bool isClosed)\r\n{\r\n  Minkowki(poly, path, solution, false, isClosed);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nenum NodeType {ntAny, ntOpen, ntClosed};\r\n\r\nvoid AddPolyNodeToPolygons(const PolyNode& polynode, NodeType nodetype, Paths& paths)\r\n{\r\n  bool match = true;\r\n  if (nodetype == ntClosed) match = !polynode.IsOpen();\r\n  else if (nodetype == ntOpen) return;\r\n\r\n  if (!polynode.Contour.empty() && match)\r\n    paths.push_back(polynode.Contour);\r\n  for (int i = 0; i < polynode.ChildCount(); ++i)\r\n    AddPolyNodeToPolygons(*polynode.Childs[i], nodetype, paths);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid PolyTreeToPaths(const PolyTree& polytree, Paths& paths)\r\n{\r\n  paths.resize(0); \r\n  paths.reserve(polytree.Total());\r\n  AddPolyNodeToPolygons(polytree, ntAny, paths);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ClosedPathsFromPolyTree(const PolyTree& polytree, Paths& paths)\r\n{\r\n  paths.resize(0); \r\n  paths.reserve(polytree.Total());\r\n  AddPolyNodeToPolygons(polytree, ntClosed, paths);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid OpenPathsFromPolyTree(PolyTree& polytree, Paths& paths)\r\n{\r\n  paths.resize(0); \r\n  paths.reserve(polytree.Total());\r\n  //Open paths are top level only, so ...\r\n  for (int i = 0; i < polytree.ChildCount(); ++i)\r\n    if (polytree.Childs[i]->IsOpen())\r\n      paths.push_back(polytree.Childs[i]->Contour);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nstd::ostream& operator <<(std::ostream &s, const IntPoint &p)\r\n{\r\n  s << \"(\" << p.X << \",\" << p.Y << \")\";\r\n  return s;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nstd::ostream& operator <<(std::ostream &s, const Path &p)\r\n{\r\n  if (p.empty()) return s;\r\n  Path::size_type last = p.size() -1;\r\n  for (Path::size_type i = 0; i < last; i++)\r\n    s << \"(\" << p[i].X << \",\" << p[i].Y << \"), \";\r\n  s << \"(\" << p[last].X << \",\" << p[last].Y << \")\\n\";\r\n  return s;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nstd::ostream& operator <<(std::ostream &s, const Paths &p)\r\n{\r\n  for (Paths::size_type i = 0; i < p.size(); i++)\r\n    s << p[i];\r\n  s << \"\\n\";\r\n  return s;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef use_deprecated\r\nbool ClipperBase::AddPolygon(const Path &pg, PolyType PolyTyp)\r\n{\r\n  return AddPath(pg, PolyTyp, true);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nbool ClipperBase::AddPolygons(const Paths &ppg, PolyType PolyTyp)\r\n{\r\n  bool result = false;\r\n  for (Paths::size_type i = 0; i < ppg.size(); ++i)\r\n    if (AddPath(ppg[i], PolyTyp, true)) result = true;\r\n  return result;\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid OffsetPolygons(const Polygons &in_polys, Polygons &out_polys,\r\n  double delta, JoinType jointype, double limit, bool autoFix)\r\n{\r\n  OffsetPaths(in_polys, out_polys, delta, jointype, etClosed, limit);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid PolyTreeToPolygons(const PolyTree& polytree, Paths& paths)\r\n{\r\n  PolyTreeToPaths(polytree, paths);\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ReversePolygon(Path& p)\r\n{\r\n  std::reverse(p.begin(), p.end());\r\n}\r\n//------------------------------------------------------------------------------\r\n\r\nvoid ReversePolygons(Paths& p)\r\n{\r\n  for (Paths::size_type i = 0; i < p.size(); ++i)\r\n    ReversePolygon(p[i]);\r\n}\r\n#endif\r\n\r\n\r\n} //ClipperLib namespace\r\n","/*******************************************************************************\r\n*                                                                              *\r\n* Author    :  Angus Johnson                                                   *\r\n* Version   :  6.0.0                                                           *\r\n* Date      :  30 October 2013                                                 *\r\n* Website   :  http://www.angusj.com                                           *\r\n* Copyright :  Angus Johnson 2010-2013                                         *\r\n*                                                                              *\r\n* License:                                                                     *\r\n* Use, modification & distribution is subject to Boost Software License Ver 1. *\r\n* http://www.boost.org/LICENSE_1_0.txt                                         *\r\n*                                                                              *\r\n* Attributions:                                                                *\r\n* The code in this library is an extension of Bala Vatti's clipping algorithm: *\r\n* \"A generic solution to polygon clipping\"                                     *\r\n* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\r\n* http://portal.acm.org/citation.cfm?id=129906                                 *\r\n*                                                                              *\r\n* Computer graphics and geometric modeling: implementation and algorithms      *\r\n* By Max K. Agoston                                                            *\r\n* Springer; 1 edition (January 4, 2005)                                        *\r\n* http://books.google.com/books?q=vatti+clipping+agoston                       *\r\n*                                                                              *\r\n* See also:                                                                    *\r\n* \"Polygon Offsetting by Computing Winding Numbers\"                            *\r\n* Paper no. DETC2005-85513 pp. 565-575                                         *\r\n* ASME 2005 International Design Engineering Technical Conferences             *\r\n* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\r\n* September 24-28, 2005 , Long Beach, California, USA                          *\r\n* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\r\n*                                                                              *\r\n*******************************************************************************/\r\n\r\n#ifndef clipper_hpp\r\n#define clipper_hpp\r\n\r\n#define CLIPPER_VERSION \"6.0.0\"\r\n\r\n//use_int32: When enabled 32bit ints are used instead of 64bit ints. This\r\n//improve performance but coordinate values are limited to the range +/- 46340\r\n//#define use_int32\r\n\r\n//use_xyz: adds a Z member to IntPoint. Adds a minor cost to perfomance.\r\n//#define use_xyz\r\n\r\n//use_lines: Enables line clipping. Adds a very minor cost to performance.\r\n//#define use_lines\r\n  \r\n//When enabled, code developed with earlier versions of Clipper \r\n//(ie prior to ver 6) should compile without changes. \r\n//In a future update, this compatability code will be removed.\r\n#define use_deprecated  \r\n\r\n#include <vector>\r\n#include <set>\r\n#include <stdexcept>\r\n#include <cstring>\r\n#include <cstdlib>\r\n#include <ostream>\r\n#include <functional>\r\n\r\nnamespace ClipperLib {\r\n\r\nenum ClipType { ctIntersection, ctUnion, ctDifference, ctXor };\r\nenum PolyType { ptSubject, ptClip };\r\n//By far the most widely used winding rules for polygon filling are\r\n//EvenOdd & NonZero (GDI, GDI+, XLib, OpenGL, Cairo, AGG, Quartz, SVG, Gr32)\r\n//Others rules include Positive, Negative and ABS_GTR_EQ_TWO (only in OpenGL)\r\n//see http://glprogramming.com/red/chapter11.html\r\nenum PolyFillType { pftEvenOdd, pftNonZero, pftPositive, pftNegative };\r\n\r\n#ifdef use_int32\r\ntypedef int cInt;\r\ntypedef unsigned int cUInt;\r\n#else\r\ntypedef signed long long cInt;\r\ntypedef unsigned long long cUInt;\r\n#endif\r\n\r\nstruct IntPoint {\r\n  cInt X;\r\n  cInt Y;\r\n#ifdef use_xyz\r\n  cInt Z;\r\n  IntPoint(cInt x = 0, cInt y = 0, cInt z = 0): X(x), Y(y), Z(z) {};\r\n#else\r\n  IntPoint(cInt x = 0, cInt y = 0): X(x), Y(y) {};\r\n#endif\r\n\r\n  friend inline bool operator== (const IntPoint& a, const IntPoint& b)\r\n  {\r\n    return a.X == b.X && a.Y == b.Y;\r\n  }\r\n  friend inline bool operator!= (const IntPoint& a, const IntPoint& b)\r\n  {\r\n    return a.X != b.X  || a.Y != b.Y; \r\n  }\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\ntypedef std::vector< IntPoint > Path;\r\ntypedef std::vector< Path > Paths;\r\n\r\ninline Path& operator <<(Path& poly, const IntPoint& p) {poly.push_back(p); return poly;}\r\ninline Paths& operator <<(Paths& polys, const Path& p) {polys.push_back(p); return polys;}\r\n\r\nstd::ostream& operator <<(std::ostream &s, const IntPoint &p);\r\nstd::ostream& operator <<(std::ostream &s, const Path &p);\r\nstd::ostream& operator <<(std::ostream &s, const Paths &p);\r\n\r\n#ifdef use_deprecated\r\ntypedef signed long long long64; //backward compatibility only\r\ntypedef Path Polygon;\r\ntypedef Paths Polygons;\r\n#endif\r\n\r\nstruct DoublePoint\r\n{\r\n  double X;\r\n  double Y;\r\n  DoublePoint(double x = 0, double y = 0) : X(x), Y(y) {}\r\n  DoublePoint(IntPoint ip) : X((double)ip.X), Y((double)ip.Y) {}\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\n#ifdef use_xyz\r\ntypedef void (*TZFillCallback)(IntPoint& z1, IntPoint& z2, IntPoint& pt);\r\n#endif\r\n\r\nclass PolyNode;\r\ntypedef std::vector< PolyNode* > PolyNodes;\r\n\r\nclass PolyNode \r\n{ \r\npublic:\r\n    PolyNode();\r\n    Path Contour;\r\n    PolyNodes Childs;\r\n    PolyNode* Parent;\r\n    PolyNode* GetNext() const;\r\n    bool IsHole() const;\r\n    bool IsOpen() const;\r\n    int ChildCount() const;\r\nprivate:\r\n    bool m_IsOpen;\r\n    PolyNode* GetNextSiblingUp() const;\r\n    unsigned Index; //node index in Parent.Childs\r\n    void AddChild(PolyNode& child);\r\n    friend class Clipper; //to access Index\r\n};\r\n\r\nclass PolyTree: public PolyNode\r\n{ \r\npublic:\r\n    ~PolyTree(){Clear();};\r\n    PolyNode* GetFirst() const;\r\n    void Clear();\r\n    int Total() const;\r\nprivate:\r\n    PolyNodes AllNodes;\r\n    friend class Clipper; //to access AllNodes\r\n};\r\n\r\nenum InitOptions {ioReverseSolution = 1, ioStrictlySimple = 2, ioPreserveCollinear = 4};\r\nenum JoinType {jtSquare, jtRound, jtMiter};\r\nenum EndType {etClosed, etButt, etSquare, etRound};\r\n\r\nbool Orientation(const Path &poly);\r\ndouble Area(const Path &poly);\r\n\r\n#ifdef use_deprecated\r\n  void OffsetPolygons(const Polygons &in_polys, Polygons &out_polys,\r\n    double delta, JoinType jointype = jtSquare, double limit = 0, bool autoFix = true);\r\n  void PolyTreeToPolygons(const PolyTree& polytree, Paths& paths);\r\n  void ReversePolygon(Path& p);\r\n  void ReversePolygons(Paths& p);\r\n#endif\r\n\r\nvoid OffsetPaths(const Paths &in_polys, Paths &out_polys,\r\n  double delta, JoinType jointype, EndType endtype, double limit = 0);\r\n\r\nvoid SimplifyPolygon(const Path &in_poly, Paths &out_polys, PolyFillType fillType = pftEvenOdd);\r\nvoid SimplifyPolygons(const Paths &in_polys, Paths &out_polys, PolyFillType fillType = pftEvenOdd);\r\nvoid SimplifyPolygons(Paths &polys, PolyFillType fillType = pftEvenOdd);\r\n\r\nvoid CleanPolygon(const Path& in_poly, Path& out_poly, double distance = 1.415);\r\nvoid CleanPolygon(Path& poly, double distance = 1.415);\r\nvoid CleanPolygons(const Paths& in_polys, Paths& out_polys, double distance = 1.415);\r\nvoid CleanPolygons(Paths& polys, double distance = 1.415);\r\n\r\nvoid MinkowkiSum(const Path& poly, const Path& path, Paths& solution, bool isClosed);\r\nvoid MinkowkiDiff(const Path& poly, const Path& path, Paths& solution, bool isClosed);\r\n\r\nvoid PolyTreeToPaths(const PolyTree& polytree, Paths& paths);\r\nvoid ClosedPathsFromPolyTree(const PolyTree& polytree, Paths& paths);\r\nvoid OpenPathsFromPolyTree(PolyTree& polytree, Paths& paths);\r\n\r\nvoid ReversePath(Path& p);\r\nvoid ReversePaths(Paths& p);\r\n\r\nstruct IntRect { cInt left; cInt top; cInt right; cInt bottom; };\r\n\r\n//enums that are used internally ...\r\nenum EdgeSide { esLeft = 1, esRight = 2};\r\n\r\n//forward declarations (for stuff used internally) ...\r\nstruct TEdge;\r\nstruct IntersectNode;\r\nstruct LocalMinima;\r\nstruct Scanbeam;\r\nstruct OutPt;\r\nstruct OutRec;\r\nstruct Join;\r\n\r\ntypedef std::vector < OutRec* > PolyOutList;\r\ntypedef std::vector < TEdge* > EdgeList;\r\ntypedef std::vector < Join* > JoinList;\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n//ClipperBase is the ancestor to the Clipper class. It should not be\r\n//instantiated directly. This class simply abstracts the conversion of sets of\r\n//polygon coordinates into edge objects that are stored in a LocalMinima list.\r\nclass ClipperBase\r\n{\r\npublic:\r\n  ClipperBase();\r\n  virtual ~ClipperBase();\r\n  bool AddPath(const Path &pg, PolyType PolyTyp, bool Closed);\r\n  bool AddPaths(const Paths &ppg, PolyType PolyTyp, bool Closed);\r\n\r\n#ifdef use_deprecated\r\n  bool AddPolygon(const Path &pg, PolyType PolyTyp);\r\n  bool AddPolygons(const Paths &ppg, PolyType PolyTyp);\r\n#endif\r\n\r\n  virtual void Clear();\r\n  IntRect GetBounds();\r\n  bool PreserveCollinear() {return m_PreserveCollinear;};\r\n  void PreserveCollinear(bool value) {m_PreserveCollinear = value;};\r\nprotected:\r\n  void DisposeLocalMinimaList();\r\n  TEdge* AddBoundsToLML(TEdge *e, bool IsClosed);\r\n  void PopLocalMinima();\r\n  virtual void Reset();\r\n  void InsertLocalMinima(LocalMinima *newLm);\r\n  void DoMinimaLML(TEdge* E1, TEdge* E2, bool IsClosed);\r\n  TEdge* DescendToMin(TEdge *&E);\r\n  void AscendToMax(TEdge *&E, bool Appending, bool IsClosed);\r\n  LocalMinima      *m_CurrentLM;\r\n  LocalMinima      *m_MinimaList;\r\n  bool              m_UseFullRange;\r\n  EdgeList          m_edges;\r\n  bool             m_PreserveCollinear;\r\n  bool             m_HasOpenPaths;\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\nclass Clipper : public virtual ClipperBase\r\n{\r\npublic:\r\n  Clipper(int initOptions = 0);\r\n  ~Clipper();\r\n  bool Execute(ClipType clipType,\r\n    Paths &solution,\r\n    PolyFillType subjFillType = pftEvenOdd,\r\n    PolyFillType clipFillType = pftEvenOdd);\r\n  bool Execute(ClipType clipType,\r\n    PolyTree &polytree,\r\n    PolyFillType subjFillType = pftEvenOdd,\r\n    PolyFillType clipFillType = pftEvenOdd);\r\n  void Clear();\r\n  bool ReverseSolution() {return m_ReverseOutput;};\r\n  void ReverseSolution(bool value) {m_ReverseOutput = value;};\r\n  bool StrictlySimple() {return m_StrictSimple;};\r\n  void StrictlySimple(bool value) {m_StrictSimple = value;};\r\n  //set the callback function for z value filling on intersections (otherwise Z is 0)\r\n#ifdef use_xyz\r\n  void ZFillFunction(TZFillCallback zFillFunc);\r\n#endif\r\nprotected:\r\n  void Reset();\r\n  virtual bool ExecuteInternal();\r\nprivate:\r\n  PolyOutList       m_PolyOuts;\r\n  JoinList          m_Joins;\r\n  JoinList          m_GhostJoins;\r\n  ClipType          m_ClipType;\r\n  std::set< cInt, std::greater<cInt> > m_Scanbeam;\r\n  TEdge           *m_ActiveEdges;\r\n  TEdge           *m_SortedEdges;\r\n  IntersectNode   *m_IntersectNodes;\r\n  bool             m_ExecuteLocked;\r\n  PolyFillType     m_ClipFillType;\r\n  PolyFillType     m_SubjFillType;\r\n  bool             m_ReverseOutput;\r\n  bool             m_UsingPolyTree; \r\n  bool             m_StrictSimple;\r\n#ifdef use_xyz\r\n  TZFillCallback   m_ZFill; //custom callback \r\n#endif\r\n  void SetWindingCount(TEdge& edge);\r\n  bool IsEvenOddFillType(const TEdge& edge) const;\r\n  bool IsEvenOddAltFillType(const TEdge& edge) const;\r\n  void InsertScanbeam(const cInt Y);\r\n  cInt PopScanbeam();\r\n  void InsertLocalMinimaIntoAEL(const cInt botY);\r\n  void InsertEdgeIntoAEL(TEdge *edge, TEdge* startEdge);\r\n  void AddEdgeToSEL(TEdge *edge);\r\n  void CopyAELToSEL();\r\n  void DeleteFromSEL(TEdge *e);\r\n  void DeleteFromAEL(TEdge *e);\r\n  void UpdateEdgeIntoAEL(TEdge *&e);\r\n  void SwapPositionsInSEL(TEdge *edge1, TEdge *edge2);\r\n  bool IsContributing(const TEdge& edge) const;\r\n  bool IsTopHorz(const cInt XPos);\r\n  void SwapPositionsInAEL(TEdge *edge1, TEdge *edge2);\r\n  void DoMaxima(TEdge *e);\r\n  void PrepareHorzJoins(TEdge* horzEdge, bool isTopOfScanbeam);\r\n  void ProcessHorizontals(bool IsTopOfScanbeam);\r\n  void ProcessHorizontal(TEdge *horzEdge, bool isTopOfScanbeam);\r\n  void AddLocalMaxPoly(TEdge *e1, TEdge *e2, const IntPoint &pt);\r\n  OutPt* AddLocalMinPoly(TEdge *e1, TEdge *e2, const IntPoint &pt);\r\n  OutRec* GetOutRec(int idx);\r\n  void AppendPolygon(TEdge *e1, TEdge *e2);\r\n  void IntersectEdges(TEdge *e1, TEdge *e2,\r\n    const IntPoint &pt, bool protect = false);\r\n  OutRec* CreateOutRec();\r\n  OutPt* AddOutPt(TEdge *e, const IntPoint &pt);\r\n  void DisposeAllOutRecs();\r\n  void DisposeOutRec(PolyOutList::size_type index);\r\n  bool ProcessIntersections(const cInt botY, const cInt topY);\r\n  void InsertIntersectNode(TEdge *e1, TEdge *e2, const IntPoint &pt);\r\n  void BuildIntersectList(const cInt botY, const cInt topY);\r\n  void ProcessIntersectList();\r\n  void ProcessEdgesAtTopOfScanbeam(const cInt topY);\r\n  void BuildResult(Paths& polys);\r\n  void BuildResult2(PolyTree& polytree);\r\n  void SetHoleState(TEdge *e, OutRec *outrec);\r\n  void DisposeIntersectNodes();\r\n  bool FixupIntersectionOrder();\r\n  void FixupOutPolygon(OutRec &outrec);\r\n  bool IsHole(TEdge *e);\r\n  void FixHoleLinkage(OutRec &outrec);\r\n  void AddJoin(OutPt *op1, OutPt *op2, const IntPoint offPt);\r\n  void ClearJoins();\r\n  void ClearGhostJoins();\r\n  void AddGhostJoin(OutPt *op, const IntPoint offPt);\r\n  bool JoinPoints(const Join *j, OutPt *&p1, OutPt *&p2);\r\n  void JoinCommonEdges();\r\n  void DoSimplePolygons();\r\n  void FixupFirstLefts1(OutRec* OldOutRec, OutRec* NewOutRec);\r\n  void FixupFirstLefts2(OutRec* OldOutRec, OutRec* NewOutRec);\r\n#ifdef use_xyz\r\n  void SetZ(IntPoint& pt, TEdge& e);\r\n#endif\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\nclass clipperException : public std::exception\r\n{\r\n  public:\r\n    clipperException(const char* description): m_descr(description) {}\r\n    virtual ~clipperException() throw() {}\r\n    virtual const char* what() const throw() {return m_descr.c_str();}\r\n  private:\r\n    std::string m_descr;\r\n};\r\n//------------------------------------------------------------------------------\r\n\r\n} //ClipperLib namespace\r\n\r\n#endif //clipper_hpp\r\n\r\n\r\n","// -*- C++ -*-\n//===---------------------------- set -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_SET\n#define _LIBCPP_SET\n\n/*\n\n    set synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass set\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    set()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit set(const value_compare& comp);\n    set(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last,\n            const value_compare& comp = value_compare());\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const value_compare& comp,\n            const allocator_type& a);\n    set(const set& s);\n    set(set&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit set(const allocator_type& a);\n    set(const set& s, const allocator_type& a);\n    set(set&& s, const allocator_type& a);\n    set(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    set(initializer_list<value_type> il, const value_compare& comp,\n        const allocator_type& a);\n    template <class InputIterator>\n        set(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    set(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~set();\n\n    set& operator=(const set& s);\n    set& operator=(set&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    set& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator,bool> insert(const value_type& v);\n    pair<iterator,bool> insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(set& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;        // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const set<Key, Compare, Allocator>& x,\n           const set<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(set<Key, Compare, Allocator>& x, set<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class Compare = less<Key>,\n          class Allocator = allocator<Key>>\nclass multiset\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    multiset()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multiset(const value_compare& comp);\n    multiset(const value_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp = value_compare());\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last,\n                 const value_compare& comp, const allocator_type& a);\n    multiset(const multiset& s);\n    multiset(multiset&& s)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multiset(const allocator_type& a);\n    multiset(const multiset& s, const allocator_type& a);\n    multiset(multiset&& s, const allocator_type& a);\n    multiset(initializer_list<value_type> il, const value_compare& comp = value_compare());\n    multiset(initializer_list<value_type> il, const value_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multiset(InputIterator first, InputIterator last, const allocator_type& a)\n            : set(first, last, Compare(), a) {}  // C++14\n    multiset(initializer_list<value_type> il, const allocator_type& a)\n        : set(il, Compare(), a) {}  // C++14\n    ~multiset();\n\n    multiset& operator=(const multiset& s);\n    multiset& operator=(multiset&& s)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multiset& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    iterator insert(value_type&& v);\n    iterator insert(const_iterator position, const value_type& v);\n    iterator insert(const_iterator position, value_type&& v);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multiset& s)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // set operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator==(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator< (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator!=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator> (const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator>=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\ntemplate <class Key, class Compare, class Allocator>\nbool\noperator<=(const multiset<Key, Compare, Allocator>& x,\n           const multiset<Key, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class Compare, class Allocator>\nvoid\nswap(multiset<Key, Compare, Allocator>& x, multiset<Key, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <functional>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY set\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                 key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const value_compare& __comp = value_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n    _LIBCPP_INLINE_VISIBILITY\n    set(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l,\n            const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,\n            const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : set(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s)\n        : __tree_(__s.__tree_)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(const set& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit set(const allocator_type& __a)\n        : __tree_(__a) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(const set& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    set(set&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    set(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    set(initializer_list<value_type> __il, const allocator_type& __a)\n        : set(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    set& operator=(set&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __tree_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_unique(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(const value_type& __v)\n        {return __tree_.__insert_unique(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,bool> insert(value_type&& __v)\n        {return __tree_.__insert_unique(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_unique(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_unique(__p, _VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_unique(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(set& __s) _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nset<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const set<_Key, _Compare, _Allocator>& __x,\n           const set<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\n// specialized algorithms:\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(set<_Key, _Compare, _Allocator>& __x,\n     set<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Compare = less<_Key>,\n          class _Allocator = allocator<_Key> >\nclass _LIBCPP_TYPE_VIS_ONLY multiset\n{\npublic:\n    // types:\n    typedef _Key                                      key_type;\n    typedef key_type                                 value_type;\n    typedef _Compare                                  key_compare;\n    typedef key_compare                              value_compare;\n    typedef _Allocator                                allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\nprivate:\n    typedef __tree<value_type, value_compare, allocator_type> __base;\n    typedef allocator_traits<allocator_type>                  __alloc_traits;\n    typedef typename __base::__node_holder                    __node_holder;\n\n    __base __tree_;\n\npublic:\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n    typedef typename __base::const_iterator        iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const value_compare& __comp = value_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__comp) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a) {}\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n        template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY \n        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n            : multiset(__f, __l, key_compare(), __a) {}\n#endif\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multiset(_InputIterator __f, _InputIterator __l,\n                 const value_compare& __comp, const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__f, __l);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s)\n        : __tree_(__s.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))\n        {\n            insert(__s.begin(), __s.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(const multiset& __s)\n        {\n            __tree_ = __s.__tree_;\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__s.__tree_)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multiset(const allocator_type& __a)\n        : __tree_(__a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(const multiset& __s, const allocator_type& __a)\n        : __tree_(__s.__tree_.value_comp(), __a)\n        {\n            insert(__s.begin(), __s.end());\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    multiset(multiset&& __s, const allocator_type& __a);\n#endif\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())\n        : __tree_(__comp)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset(initializer_list<value_type> __il, const value_compare& __comp,\n        const allocator_type& __a)\n        : __tree_(__comp, __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multiset(initializer_list<value_type> __il, const allocator_type& __a)\n        : multiset(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    multiset& operator=(multiset&& __s)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__s.__tree_);\n            return *this;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT       {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT         {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT\n            {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    // modifiers:\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __tree_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __tree_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v)\n        {return __tree_.__insert_multi(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n        {return __tree_.__insert_multi(__p, __v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __v)\n        {return __tree_.__insert_multi(_VSTD::move(__v));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __p) {return __tree_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f, __l);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multiset& __s)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__s.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return __tree_.value_comp();}\n\n    // set operations:\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename _VSTD::enable_if<_VSTD::__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\nmultiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)\n    : __tree_(_VSTD::move(__s.__tree_), __a)\n{\n    if (__a != __s.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__s.empty())\n            insert(__e, _VSTD::move(__s.__tree_.remove(__s.begin())->__value_));\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multiset<_Key, _Compare, _Allocator>& __x,\n           const multiset<_Key, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multiset<_Key, _Compare, _Allocator>& __x,\n     multiset<_Key, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SET\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___TREE\n#define _LIBCPP___TREE\n\n#include <__config>\n#include <iterator>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Compare, class _Allocator> class __tree;\ntemplate <class _Tp, class _NodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_iterator;\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\n    class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multimap;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY set;\ntemplate <class _Key, class _Compare, class _Allocator>\n    class _LIBCPP_TYPE_VIS_ONLY multiset;\n\n/*\n\n_NodePtr algorithms\n\nThe algorithms taking _NodePtr are red black tree algorithms.  Those\nalgorithms taking a parameter named __root should assume that __root\npoints to a proper red black tree (unless otherwise specified).\n\nEach algorithm herein assumes that __root->__parent_ points to a non-null\nstructure which has a member __left_ which points back to __root.  No other\nmember is read or written to at __root->__parent_.\n\n__root->__parent_ will be referred to below (in comments only) as end_node.\nend_node->__left_ is an externably accessible lvalue for __root, and can be\nchanged by node insertion and removal (without explicit reference to end_node).\n\nAll nodes (with the exception of end_node), even the node referred to as\n__root, have a non-null __parent_ field.\n\n*/\n\n// Returns:  true if __x is a left child of its parent, else false\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__tree_is_left_child(_NodePtr __x) _NOEXCEPT\n{\n    return __x == __x->__parent_->__left_;\n}\n\n// Determintes if the subtree rooted at __x is a proper red black subtree.  If\n//    __x is a proper subtree, returns the black height (null counts as 1).  If\n//    __x is an improper subtree, returns 0.\ntemplate <class _NodePtr>\nunsigned\n__tree_sub_invariant(_NodePtr __x)\n{\n    if (__x == nullptr)\n        return 1;\n    // parent consistency checked by caller\n    // check __x->__left_ consistency\n    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)\n        return 0;\n    // check __x->__right_ consistency\n    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)\n        return 0;\n    // check __x->__left_ != __x->__right_ unless both are nullptr\n    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)\n        return 0;\n    // If this is red, neither child can be red\n    if (!__x->__is_black_)\n    {\n        if (__x->__left_ && !__x->__left_->__is_black_)\n            return 0;\n        if (__x->__right_ && !__x->__right_->__is_black_)\n            return 0;\n    }\n    unsigned __h = __tree_sub_invariant(__x->__left_);\n    if (__h == 0)\n        return 0;  // invalid left subtree\n    if (__h != __tree_sub_invariant(__x->__right_))\n        return 0;  // invalid or different height right subtree\n    return __h + __x->__is_black_;  // return black height of this node\n}\n\n// Determintes if the red black tree rooted at __root is a proper red black tree.\n//    __root == nullptr is a proper tree.  Returns true is __root is a proper\n//    red black tree, else returns false.\ntemplate <class _NodePtr>\nbool\n__tree_invariant(_NodePtr __root)\n{\n    if (__root == nullptr)\n        return true;\n    // check __x->__parent_ consistency\n    if (__root->__parent_ == nullptr)\n        return false;\n    if (!__tree_is_left_child(__root))\n        return false;\n    // root must be black\n    if (!__root->__is_black_)\n        return false;\n    // do normal node checks\n    return __tree_sub_invariant(__root) != 0;\n}\n\n// Returns:  pointer to the left-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_min(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__left_ != nullptr)\n        __x = __x->__left_;\n    return __x;\n}\n\n// Returns:  pointer to the right-most node under __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\ninline _LIBCPP_INLINE_VISIBILITY\n_NodePtr\n__tree_max(_NodePtr __x) _NOEXCEPT\n{\n    while (__x->__right_ != nullptr)\n        __x = __x->__right_;\n    return __x;\n}\n\n// Returns:  pointer to the next in-order node after __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_next(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__right_ != nullptr)\n        return __tree_min(__x->__right_);\n    while (!__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to the previous in-order node before __x.\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_prev(_NodePtr __x) _NOEXCEPT\n{\n    if (__x->__left_ != nullptr)\n        return __tree_max(__x->__left_);\n    while (__tree_is_left_child(__x))\n        __x = __x->__parent_;\n    return __x->__parent_;\n}\n\n// Returns:  pointer to a node which has no children\n// Precondition:  __x != nullptr.\ntemplate <class _NodePtr>\n_NodePtr\n__tree_leaf(_NodePtr __x) _NOEXCEPT\n{\n    while (true)\n    {\n        if (__x->__left_ != nullptr)\n        {\n            __x = __x->__left_;\n            continue;\n        }\n        if (__x->__right_ != nullptr)\n        {\n            __x = __x->__right_;\n            continue;\n        }\n        break;\n    }\n    return __x;\n}\n\n// Effects:  Makes __x->__right_ the subtree root with __x as its left child\n//           while preserving in-order order.\n// Precondition:  __x->__right_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_left_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__right_;\n    __x->__right_ = __y->__left_;\n    if (__x->__right_ != nullptr)\n        __x->__right_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__left_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Makes __x->__left_ the subtree root with __x as its right child\n//           while preserving in-order order.\n// Precondition:  __x->__left_ != nullptr\ntemplate <class _NodePtr>\nvoid\n__tree_right_rotate(_NodePtr __x) _NOEXCEPT\n{\n    _NodePtr __y = __x->__left_;\n    __x->__left_ = __y->__right_;\n    if (__x->__left_ != nullptr)\n        __x->__left_->__parent_ = __x;\n    __y->__parent_ = __x->__parent_;\n    if (__tree_is_left_child(__x))\n        __x->__parent_->__left_ = __y;\n    else\n        __x->__parent_->__right_ = __y;\n    __y->__right_ = __x;\n    __x->__parent_ = __y;\n}\n\n// Effects:  Rebalances __root after attaching __x to a leaf.\n// Precondition:  __root != nulptr && __x != nullptr.\n//                __x has no children.\n//                __x == __root or == a direct or indirect child of __root.\n//                If __x were to be unlinked from __root (setting __root to\n//                  nullptr if __root == __x), __tree_invariant(__root) == true.\n// Postcondition: __tree_invariant(end_node->__left_) == true.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) _NOEXCEPT\n{\n    __x->__is_black_ = __x == __root;\n    while (__x != __root && !__x->__parent_->__is_black_)\n    {\n        // __x->__parent_ != __root because __x->__parent_->__is_black == false\n        if (__tree_is_left_child(__x->__parent_))\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__right_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (!__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_left_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_right_rotate(__x);\n                break;\n            }\n        }\n        else\n        {\n            _NodePtr __y = __x->__parent_->__parent_->__left_;\n            if (__y != nullptr && !__y->__is_black_)\n            {\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = __x == __root;\n                __y->__is_black_ = true;\n            }\n            else\n            {\n                if (__tree_is_left_child(__x))\n                {\n                    __x = __x->__parent_;\n                    __tree_right_rotate(__x);\n                }\n                __x = __x->__parent_;\n                __x->__is_black_ = true;\n                __x = __x->__parent_;\n                __x->__is_black_ = false;\n                __tree_left_rotate(__x);\n                break;\n            }\n        }\n    }\n}\n\n// Precondition:  __root != nullptr && __z != nullptr.\n//                __tree_invariant(__root) == true.\n//                __z == __root or == a direct or indirect child of __root.\n// Effects:  unlinks __z from the tree rooted at __root, rebalancing as needed.\n// Postcondition: __tree_invariant(end_node->__left_) == true && end_node->__left_\n//                nor any of its children refer to __z.  end_node->__left_\n//                may be different than the value passed in as __root.\ntemplate <class _NodePtr>\nvoid\n__tree_remove(_NodePtr __root, _NodePtr __z) _NOEXCEPT\n{\n    // __z will be removed from the tree.  Client still needs to destruct/deallocate it\n    // __y is either __z, or if __z has two children, __tree_next(__z).\n    // __y will have at most one child.\n    // __y will be the initial hole in the tree (make the hole at a leaf)\n    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?\n                    __z : __tree_next(__z);\n    // __x is __y's possibly null single child\n    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;\n    // __w is __x's possibly null uncle (will become __x's sibling)\n    _NodePtr __w = nullptr;\n    // link __x to __y's parent, and find __w\n    if (__x != nullptr)\n        __x->__parent_ = __y->__parent_;\n    if (__tree_is_left_child(__y))\n    {\n        __y->__parent_->__left_ = __x;\n        if (__y != __root)\n            __w = __y->__parent_->__right_;\n        else\n            __root = __x;  // __w == nullptr\n    }\n    else\n    {\n        __y->__parent_->__right_ = __x;\n        // __y can't be root if it is a right child\n        __w = __y->__parent_->__left_;\n    }\n    bool __removed_black = __y->__is_black_;\n    // If we didn't remove __z, do so now by splicing in __y for __z,\n    //    but copy __z's color.  This does not impact __x or __w.\n    if (__y != __z)\n    {\n        // __z->__left_ != nulptr but __z->__right_ might == __x == nullptr\n        __y->__parent_ = __z->__parent_;\n        if (__tree_is_left_child(__z))\n            __y->__parent_->__left_ = __y;\n        else\n            __y->__parent_->__right_ = __y;\n        __y->__left_ = __z->__left_;\n        __y->__left_->__parent_ = __y;\n        __y->__right_ = __z->__right_;\n        if (__y->__right_ != nullptr)\n            __y->__right_->__parent_ = __y;\n        __y->__is_black_ = __z->__is_black_;\n        if (__root == __z)\n            __root = __y;\n    }\n    // There is no need to rebalance if we removed a red, or if we removed\n    //     the last node.\n    if (__removed_black && __root != nullptr)\n    {\n        // Rebalance:\n        // __x has an implicit black color (transferred from the removed __y)\n        //    associated with it, no matter what its color is.\n        // If __x is __root (in which case it can't be null), it is supposed\n        //    to be black anyway, and if it is doubly black, then the double\n        //    can just be ignored.\n        // If __x is red (in which case it can't be null), then it can absorb\n        //    the implicit black just by setting its color to black.\n        // Since __y was black and only had one child (which __x points to), __x\n        //   is either red with no children, else null, otherwise __y would have\n        //   different black heights under left and right pointers.\n        // if (__x == __root || __x != nullptr && !__x->__is_black_)\n        if (__x != nullptr)\n            __x->__is_black_ = true;\n        else\n        {\n            //  Else __x isn't root, and is \"doubly black\", even though it may\n            //     be null.  __w can not be null here, else the parent would\n            //     see a black height >= 2 on the __x side and a black height\n            //     of 1 on the __w side (__w must be a non-null black or a red\n            //     with a non-null black child).\n            while (true)\n            {\n                if (!__tree_is_left_child(__w))  // if x is left child\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_left_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__left_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__left_->__right_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (__x == __root || !__x->__is_black_)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)\n                        {\n                            // __w left child is non-null and red\n                            __w->__left_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_right_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a right red child, left child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__right_->__is_black_ = true;\n                        __tree_left_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n                else\n                {\n                    if (!__w->__is_black_)\n                    {\n                        __w->__is_black_ = true;\n                        __w->__parent_->__is_black_ = false;\n                        __tree_right_rotate(__w->__parent_);\n                        // __x is still valid\n                        // reset __root only if necessary\n                        if (__root == __w->__right_)\n                            __root = __w;\n                        // reset sibling, and it still can't be null\n                        __w = __w->__right_->__left_;\n                    }\n                    // __w->__is_black_ is now true, __w may have null children\n                    if ((__w->__left_  == nullptr || __w->__left_->__is_black_) &&\n                        (__w->__right_ == nullptr || __w->__right_->__is_black_))\n                    {\n                        __w->__is_black_ = false;\n                        __x = __w->__parent_;\n                        // __x can no longer be null\n                        if (!__x->__is_black_ || __x == __root)\n                        {\n                            __x->__is_black_ = true;\n                            break;\n                        }\n                        // reset sibling, and it still can't be null\n                        __w = __tree_is_left_child(__x) ?\n                                    __x->__parent_->__right_ :\n                                    __x->__parent_->__left_;\n                        // continue;\n                    }\n                    else  // __w has a red child\n                    {\n                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)\n                        {\n                            // __w right child is non-null and red\n                            __w->__right_->__is_black_ = true;\n                            __w->__is_black_ = false;\n                            __tree_left_rotate(__w);\n                            // __w is known not to be root, so root hasn't changed\n                            // reset sibling, and it still can't be null\n                            __w = __w->__parent_;\n                        }\n                        // __w has a left red child, right child may be null\n                        __w->__is_black_ = __w->__parent_->__is_black_;\n                        __w->__parent_->__is_black_ = true;\n                        __w->__left_->__is_black_ = true;\n                        __tree_right_rotate(__w->__parent_);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Allocator> class __map_node_destructor;\n\ntemplate <class _Allocator>\nclass __tree_node_destructor\n{\n    typedef _Allocator                                      allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __tree_node_destructor& operator=(const __tree_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(false)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __map_node_destructor;\n};\n\n// node\n\ntemplate <class _Pointer>\nclass __tree_end_node\n{\npublic:\n    typedef _Pointer pointer;\n    pointer __left_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_end_node() _NOEXCEPT : __left_() {}\n};\n\ntemplate <class _VoidPtr>\nclass __tree_node_base\n    : public __tree_end_node\n             <\n                typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__tree_node_base<_VoidPtr> >\n#else\n                     rebind<__tree_node_base<_VoidPtr> >::other\n#endif\n             >\n{\n    __tree_node_base(const __tree_node_base&);\n    __tree_node_base& operator=(const __tree_node_base&);\npublic:\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__tree_node_base>\n#else\n            rebind<__tree_node_base>::other\n#endif\n                                                pointer;\n    typedef typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const __tree_node_base>\n#else\n            rebind<const __tree_node_base>::other\n#endif\n                                                const_pointer;\n    typedef __tree_end_node<pointer> base;\n\n    pointer __right_;\n    pointer __parent_;\n    bool __is_black_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_node_base() _NOEXCEPT\n        : __right_(), __parent_(), __is_black_(false) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nclass __tree_node\n    : public __tree_node_base<_VoidPtr>\n{\npublic:\n    typedef __tree_node_base<_VoidPtr> base;\n    typedef _Tp value_type;\n\n    value_type __value_;\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit __tree_node(_Args&& ...__args)\n            : __value_(_VSTD::forward<_Args>(__args)...) {}\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_node(const value_type& __v)\n            : __value_(__v) {}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n};\n\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\ntemplate <class _TreeIterator> class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n\ntemplate <class _Tp, class _NodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_iterator\n{\n    typedef _NodePtr                                              __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename __node_base::pointer                         __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag iterator_category;\n    typedef _Tp                        value_type;\n    typedef _DiffType                  difference_type;\n    typedef value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator++(int)\n        {__tree_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_iterator operator--(int)\n        {__tree_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY \n        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_iterator(__node_pointer __p) _NOEXCEPT : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_iterator;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n};\n\ntemplate <class _Tp, class _ConstNodePtr, class _DiffType>\nclass _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator\n{\n    typedef _ConstNodePtr                                         __node_pointer;\n    typedef typename pointer_traits<__node_pointer>::element_type __node;\n    typedef typename __node::base                                 __node_base;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node_base>\n#else\n            rebind<__node_base>::other\n#endif\n                                                                  __node_base_pointer;\n\n    __node_pointer __ptr_;\n\n    typedef pointer_traits<__node_pointer> __pointer_traits;\npublic:\n    typedef bidirectional_iterator_tag       iterator_category;\n    typedef _Tp                              value_type;\n    typedef _DiffType                        difference_type;\n    typedef const value_type&                reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __tree_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __ptr_(nullptr)\n#endif\n    {}\n\nprivate:\n    typedef typename remove_const<__node>::type  __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                 __non_const_node_pointer;\n    typedef __tree_iterator<value_type, __non_const_node_pointer, difference_type>\n                                                 __non_const_iterator;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator(__non_const_iterator __p) _NOEXCEPT\n        : __ptr_(__p.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return __ptr_->__value_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const\n        {return pointer_traits<pointer>::pointer_to(__ptr_->__value_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator++()\n        {__ptr_ = static_cast<__node_pointer>(__tree_next(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator++(int)\n        {__tree_const_iterator __t(*this); ++(*this); return __t;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator& operator--()\n        {__ptr_ = static_cast<__node_pointer>(__tree_prev(static_cast<__node_base_pointer>(__ptr_)));\n         return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __tree_const_iterator operator--(int)\n        {__tree_const_iterator __t(*this); --(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __tree_const_iterator(__node_pointer __p) _NOEXCEPT\n        : __ptr_(__p) {}\n    template <class, class, class> friend class __tree;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY set;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multiset;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nclass __tree\n{\npublic:\n    typedef _Tp                                      value_type;\n    typedef _Compare                                 value_compare;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef typename __alloc_traits::void_pointer  __void_pointer;\n\n    typedef __tree_node<value_type, __void_pointer> __node;\n    typedef __tree_node_base<__void_pointer>        __node_base;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef typename __node_base::pointer            __node_base_pointer;\n    typedef typename __node_base::pointer            __node_base_const_pointer;\nprivate:\n    typedef typename __node_base::base __end_node_t;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_ptr;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__end_node_t>\n#else\n            rebind<__end_node_t>::other\n#endif\n                                                     __end_node_const_ptr;\n\n    __node_pointer                                          __begin_node_;\n    __compressed_pair<__end_node_t, __node_allocator>  __pair1_;\n    __compressed_pair<size_type, value_compare>        __pair3_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __end_node() _NOEXCEPT\n    {\n        return static_cast<__node_pointer>\n               (\n                   pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __end_node() const _NOEXCEPT\n    {\n        return static_cast<__node_const_pointer>\n               (\n                   pointer_traits<__end_node_const_ptr>::pointer_to(const_cast<__end_node_t&>(__pair1_.first()))\n               );\n    }\n    _LIBCPP_INLINE_VISIBILITY\n          __node_allocator& __node_alloc() _NOEXCEPT {return __pair1_.second();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __pair1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n          __node_pointer& __begin_node() _NOEXCEPT {return __begin_node_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_pointer& __begin_node() const _NOEXCEPT {return __begin_node_;}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type __alloc() const _NOEXCEPT\n        {return allocator_type(__node_alloc());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n          size_type& size() _NOEXCEPT {return __pair3_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __pair3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n          value_compare& value_comp() _NOEXCEPT {return __pair3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_compare& value_comp() const _NOEXCEPT\n        {return __pair3_.second();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __node_pointer __root() _NOEXCEPT\n        {return static_cast<__node_pointer>      (__end_node()->__left_);}\n    _LIBCPP_INLINE_VISIBILITY\n    __node_const_pointer __root() const _NOEXCEPT\n        {return static_cast<__node_const_pointer>(__end_node()->__left_);}\n\n    typedef __tree_iterator<value_type, __node_pointer, difference_type>             iterator;\n    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;\n\n    explicit __tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value);\n    explicit __tree(const allocator_type& __a);\n    __tree(const value_compare& __comp, const allocator_type& __a);\n    __tree(const __tree& __t);\n    __tree& operator=(const __tree& __t);\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __tree(__tree&& __t)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<value_compare>::value);\n    __tree(__tree&& __t, const allocator_type& __a);\n    __tree& operator=(__tree&& __t)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<value_compare>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~__tree();\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin()  _NOEXCEPT {return       iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return const_iterator(__begin_node());}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return       iterator(__end_node());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return const_iterator(__end_node());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __node_traits::max_size(__node_alloc());}\n\n    void clear() _NOEXCEPT;\n\n    void swap(__tree& __t)\n        _NOEXCEPT_(\n            __is_nothrow_swappable<value_compare>::value &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value));\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        pair<iterator, bool>\n        __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_multi(_Args&&... __args);\n\n    template <class... _Args>\n        iterator\n        __emplace_hint_unique(const_iterator __p, _Args&&... __args);\n    template <class... _Args>\n        iterator\n        __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Vp>\n        pair<iterator, bool> __insert_unique(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_unique(const_iterator __p, _Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(_Vp&& __v);\n    template <class _Vp>\n        iterator __insert_multi(const_iterator __p, _Vp&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    pair<iterator, bool> __insert_unique(const value_type& __v);\n    iterator __insert_unique(const_iterator __p, const value_type& __v);\n    iterator __insert_multi(const value_type& __v);\n    iterator __insert_multi(const_iterator __p, const value_type& __v);\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_unique(const_iterator __p,\n                                              __node_pointer __nd);\n\n    iterator __node_insert_multi(__node_pointer __nd);\n    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n\n    void __insert_node_at(__node_base_pointer __parent,\n                          __node_base_pointer& __child,\n                          __node_base_pointer __new_node);\n\n    template <class _Key>\n        iterator find(const _Key& __v);\n    template <class _Key>\n        const_iterator find(const _Key& __v) const;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator lower_bound(const _Key& __v)\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __lower_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator lower_bound(const _Key& __v) const\n            {return __lower_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __lower_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator upper_bound(const _Key& __v)\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        iterator __upper_bound(const _Key& __v,\n                               __node_pointer __root,\n                               __node_pointer __result);\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        const_iterator upper_bound(const _Key& __v) const\n            {return __upper_bound(__v, __root(), __end_node());}\n    template <class _Key>\n        const_iterator __upper_bound(const _Key& __v,\n                                     __node_const_pointer __root,\n                                     __node_const_pointer __result) const;\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    typedef __tree_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\nprivate:\n    typename __node_base::pointer&\n        __find_leaf_low(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf_high(typename __node_base::pointer& __parent, const value_type& __v);\n    typename __node_base::pointer&\n        __find_leaf(const_iterator __hint,\n                    typename __node_base::pointer& __parent, const value_type& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(typename __node_base::pointer& __parent, const _Key& __v);\n    template <class _Key>\n        typename __node_base::pointer&\n        __find_equal(const_iterator __hint, typename __node_base::pointer& __parent,\n                     const _Key& __v);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        __node_holder __construct_node(const value_type& __v);\n#endif\n\n    void destroy(__node_pointer __nd) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t)\n        {__copy_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, true_type)\n        {__node_alloc() = __t.__node_alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __tree& __t, false_type) {}\n\n    void __move_assign(__tree& __t, false_type);\n    void __move_assign(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n                   is_nothrow_move_assignable<__node_allocator>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<__node_allocator>::value)\n        {__move_assign_alloc(__t, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<__node_allocator>::value)\n        {__node_alloc() = _VSTD::move(__t.__node_alloc());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__tree& __t, false_type) _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<__node_allocator>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __node_traits::propagate_on_container_swap::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__node_allocator>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__node_allocator& __x, __node_allocator& __y, false_type)\n        _NOEXCEPT\n        {}\n\n    __node_pointer __detach();\n    static __node_pointer __detach(__node_pointer);\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n};\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_copy_constructible<value_compare>::value)\n    : __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0)\n{\n    __begin_node() = __end_node();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,\n                                           const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __begin_node_(__node_pointer()),\n      __pair3_(0, __comp)\n{\n    __begin_node() = __end_node();\n}\n\n// Precondition:  size() != 0\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach()\n{\n    __node_pointer __cache = __begin_node();\n    __begin_node() = __end_node();\n    __end_node()->__left_->__parent_ = nullptr;\n    __end_node()->__left_ = nullptr;\n    size() = 0;\n    // __cache->__left_ == nullptr\n    if (__cache->__right_ != nullptr)\n        __cache = static_cast<__node_pointer>(__cache->__right_);\n    // __cache->__left_ == nullptr\n    // __cache->__right_ == nullptr\n    return __cache;\n}\n\n// Precondition:  __cache != nullptr\n//    __cache->left_ == nullptr\n//    __cache->right_ == nullptr\n//    This is no longer a red-black tree\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_pointer\n__tree<_Tp, _Compare, _Allocator>::__detach(__node_pointer __cache)\n{\n    if (__cache->__parent_ == nullptr)\n        return nullptr;\n    if (__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))\n    {\n        __cache->__parent_->__left_ = nullptr;\n        __cache = static_cast<__node_pointer>(__cache->__parent_);\n        if (__cache->__right_ == nullptr)\n            return __cache;\n        return static_cast<__node_pointer>(__tree_leaf(__cache->__right_));\n    }\n    // __cache is right child\n    __cache->__parent_->__right_ = nullptr;\n    __cache = static_cast<__node_pointer>(__cache->__parent_);\n    if (__cache->__left_ == nullptr)\n        return __cache;\n    return static_cast<__node_pointer>(__tree_leaf(__cache->__left_));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)\n{\n    if (this != &__t)\n    {\n        value_comp() = __t.value_comp();\n        __copy_assign_alloc(__t);\n        __assign_multi(__t.begin(), __t.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_unique(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _InputIterator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)\n{\n    if (size() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __detach(__cache);\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (__cache != nullptr)\n        {\n            while (__cache->__parent_ != nullptr)\n                __cache = static_cast<__node_pointer>(__cache->__parent_);\n            destroy(__cache);\n        }\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)\n    : __begin_node_(__node_pointer()),\n      __pair1_(__node_traits::select_on_container_copy_construction(__t.__node_alloc())),\n      __pair3_(0, __t.value_comp())\n{\n    __begin_node() = __end_node();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)\n    _NOEXCEPT_(\n        is_nothrow_move_constructible<__node_allocator>::value &&\n        is_nothrow_move_constructible<value_compare>::value)\n    : __begin_node_(_VSTD::move(__t.__begin_node_)),\n      __pair1_(_VSTD::move(__t.__pair1_)),\n      __pair3_(_VSTD::move(__t.__pair3_))\n{\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)\n    : __pair1_(__node_allocator(__a)),\n      __pair3_(0, _VSTD::move(__t.value_comp()))\n{\n    if (__a == __t.__alloc())\n    {\n        if (__t.size() == 0)\n            __begin_node() = __end_node();\n        else\n        {\n            __begin_node() = __t.__begin_node();\n            __end_node()->__left_ = __t.__end_node()->__left_;\n            __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n            size() = __t.size();\n            __t.__begin_node() = __t.__end_node();\n            __t.__end_node()->__left_ = nullptr;\n            __t.size() = 0;\n        }\n    }\n    else\n    {\n        __begin_node() = __end_node();\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<value_compare>::value &&\n               is_nothrow_move_assignable<__node_allocator>::value)\n{\n    destroy(static_cast<__node_pointer>(__end_node()->__left_));\n    __begin_node_ = __t.__begin_node_;\n    __pair1_.first() = __t.__pair1_.first();\n    __move_assign_alloc(__t);\n    __pair3_ = _VSTD::move(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n    {\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n        __t.__begin_node() = __t.__end_node();\n        __t.__end_node()->__left_ = nullptr;\n        __t.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)\n{\n    if (__node_alloc() == __t.__node_alloc())\n        __move_assign(__t, true_type());\n    else\n    {\n        value_comp() = _VSTD::move(__t.value_comp());\n        const_iterator __e = end();\n        if (size() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                while (__cache != nullptr && __t.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__t.remove(__t.begin())->__value_);\n                    __node_pointer __next = __detach(__cache);\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__cache != nullptr)\n            {\n                while (__cache->__parent_ != nullptr)\n                    __cache = static_cast<__node_pointer>(__cache->__parent_);\n                destroy(__cache);\n            }\n        }\n        while (__t.size() != 0)\n            __insert_multi(__e, _VSTD::move(__t.remove(__t.begin())->__value_));\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>&\n__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<value_compare>::value &&\n        is_nothrow_move_assignable<__node_allocator>::value)\n        \n{\n    __move_assign(__t, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\n__tree<_Tp, _Compare, _Allocator>::~__tree()\n{\n    destroy(__root());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) _NOEXCEPT\n{\n    if (__nd != nullptr)\n    {\n        destroy(static_cast<__node_pointer>(__nd->__left_));\n        destroy(static_cast<__node_pointer>(__nd->__right_));\n        __node_allocator& __na = __node_alloc();\n        __node_traits::destroy(__na, _VSTD::addressof(__nd->__value_));\n        __node_traits::deallocate(__na, __nd, 1);\n    }\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)\n    _NOEXCEPT_(\n        __is_nothrow_swappable<value_compare>::value &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value))\n{\n    using _VSTD::swap;\n    swap(__begin_node_, __t.__begin_node_);\n    swap(__pair1_.first(), __t.__pair1_.first());\n    __swap_alloc(__node_alloc(), __t.__node_alloc());\n    __pair3_.swap(__t.__pair3_);\n    if (size() == 0)\n        __begin_node() = __end_node();\n    else\n        __end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__end_node());\n    if (__t.size() == 0)\n        __t.__begin_node() = __t.__end_node();\n    else\n        __t.__end_node()->__left_->__parent_ = static_cast<__node_base_pointer>(__t.__end_node());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::clear() _NOEXCEPT\n{\n    destroy(__root());\n    size() = 0;\n    __begin_node() = __end_node();\n    __end_node()->__left_ = nullptr;\n}\n\n// Find lower_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(typename __node_base::pointer& __parent,\n                                                   const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find upper_bound place to insert\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(typename __node_base::pointer& __parent,\n                                                    const value_type& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find leaf place to insert closest to __hint\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,\n                                               typename __node_base::pointer& __parent,\n                                               const value_type& __v)\n{\n    if (__hint == end() || !value_comp()(*__hint, __v))  // check before\n    {\n        // __v <= *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || !value_comp()(__v, *--__prior))\n        {\n            // *prev(__hint) <= __v <= *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v < *prev(__hint)\n        return __find_leaf_high(__parent, __v);\n    }\n    // else __v > *__hint\n    return __find_leaf_low(__parent, __v);\n}\n\n// Find place to insert if __v doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    __node_pointer __nd = __root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (value_comp()(__v, __nd->__value_))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (value_comp()(__nd->__value_, __v))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__end_node());\n    return __parent->__left_;\n}\n\n// Find place to insert if __v doesn't exist\n// First check prior to __hint.\n// Next check after __hint.\n// Next do O(log N) search.\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __v exists, set parent to node of __v and return reference to node of __v\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_base::pointer&\n__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,\n                                                typename __node_base::pointer& __parent,\n                                                const _Key& __v)\n{\n    if (__hint == end() || value_comp()(__v, *__hint))  // check before\n    {\n        // __v < *__hint\n        const_iterator __prior = __hint;\n        if (__prior == begin() || value_comp()(*--__prior, __v))\n        {\n            // *prev(__hint) < __v < *__hint\n            if (__hint.__ptr_->__left_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__left_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__prior.__ptr_);\n                return __parent->__right_;\n            }\n        }\n        // __v <= *prev(__hint)\n        return __find_equal(__parent, __v);\n    }\n    else if (value_comp()(*__hint, __v))  // check after\n    {\n        // *__hint < __v\n        const_iterator __next = _VSTD::next(__hint);\n        if (__next == end() || value_comp()(__v, *__next))\n        {\n            // *__hint < __v < *_VSTD::next(__hint)\n            if (__hint.__ptr_->__right_ == nullptr)\n            {\n                __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n                return __parent->__right_;\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__next.__ptr_);\n                return __parent->__left_;\n            }\n        }\n        // *next(__hint) <= __v\n        return __find_equal(__parent, __v);\n    }\n    // else __v == *__hint\n    __parent = static_cast<__node_base_pointer>(__hint.__ptr_);\n    return __parent;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\nvoid\n__tree<_Tp, _Compare, _Allocator>::__insert_node_at(__node_base_pointer __parent,\n                                                    __node_base_pointer& __child,\n                                                    __node_base_pointer __new_node)\n{\n    __new_node->__left_   = nullptr;\n    __new_node->__right_  = nullptr;\n    __new_node->__parent_ = __parent;\n    __child = __new_node;\n    if (__begin_node()->__left_ != nullptr)\n        __begin_node() = static_cast<__node_pointer>(__begin_node()->__left_);\n    __tree_balance_after_insert(__end_node()->__left_, __child);\n    ++size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    return __h;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique(const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __h->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class... _Args>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,\n                                                        _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(static_cast<__node_pointer>(__h.release()));\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    iterator __r = __node_insert_unique(__p, __h.get());\n    if (__r.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(_Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Vp>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, _Vp&& __v)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Vp>(__v));\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __h->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_unique(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __v);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node(__v);\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__insert_multi(const_iterator __p, const value_type& __v)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __v);\n    __node_holder __h = __construct_node(__v);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n    return iterator(__h.release());\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    bool __inserted = false;\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n        __inserted = true;\n    }\n    return pair<iterator, bool>(iterator(__r), __inserted);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_unique(const_iterator __p,\n                                                        __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal(__p, __parent, __nd->__value_);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n        __r = __nd;\n    }\n    return iterator(__r);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf_high(__parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,\n                                                       __node_pointer __nd)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_leaf(__p, __parent, __nd->__value_);\n    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));\n    return iterator(__nd);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__ptr_;\n    iterator __r(__np);\n    ++__r;\n    if (__begin_node() == __np)\n        __begin_node() = __r.__ptr_;\n    --size();\n    __node_allocator& __na = __node_alloc();\n    __node_traits::destroy(__na, const_cast<value_type*>(_VSTD::addressof(*__p)));\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    __node_traits::deallocate(__na, __np, 1);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    while (__f != __l)\n        __f = erase(__f);\n    return iterator(__l.__ptr_);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)\n{\n    pair<iterator, iterator> __p = __equal_range_multi(__k);\n    size_type __r = 0;\n    for (; __p.first != __p.second; ++__r)\n        __p.first = erase(__p.first);\n    return __r;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)\n{\n    iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const\n{\n    const_iterator __p = __lower_bound(__v, __root(), __end_node());\n    if (__p != end() && !value_comp()(__v, *__p))\n        return __p;\n    return end();\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const\n{\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::size_type\n__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _VSTD::distance(\n                __lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result)\n            );\n    }\n    return 0;\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (!value_comp()(__root->__value_, __v))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_pointer __root,\n                                                 __node_pointer __result)\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_pointer>(__root->__right_);\n    }\n    return iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\ntypename __tree<_Tp, _Compare, _Allocator>::const_iterator\n__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,\n                                                 __node_const_pointer __root,\n                                                 __node_const_pointer __result) const\n{\n    while (__root != nullptr)\n    {\n        if (value_comp()(__v, __root->__value_))\n        {\n            __result = __root;\n            __root = static_cast<__node_const_pointer>(__root->__left_);\n        }\n        else\n            __root = static_cast<__node_const_pointer>(__root->__right_);\n    }\n    return const_iterator(__result);\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(iterator(__rt),\n                      iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(const_iterator(__rt),\n                      const_iterator(\n                          __rt->__right_ != nullptr ?\n                              static_cast<__node_const_pointer>(__tree_min(__rt->__right_))\n                            : __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)\n{\n    typedef pair<iterator, iterator> _Pp;\n    __node_pointer __result = __end_node();\n    __node_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(iterator(__result), iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntemplate <class _Key>\npair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,\n     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>\n__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const\n{\n    typedef pair<const_iterator, const_iterator> _Pp;\n    __node_const_pointer __result = __end_node();\n    __node_const_pointer __rt = __root();\n    while (__rt != nullptr)\n    {\n        if (value_comp()(__k, __rt->__value_))\n        {\n            __result = __rt;\n            __rt = static_cast<__node_const_pointer>(__rt->__left_);\n        }\n        else if (value_comp()(__rt->__value_, __k))\n            __rt = static_cast<__node_const_pointer>(__rt->__right_);\n        else\n            return _Pp(__lower_bound(__k, static_cast<__node_const_pointer>(__rt->__left_), __rt),\n                      __upper_bound(__k, static_cast<__node_const_pointer>(__rt->__right_), __result));\n    }\n    return _Pp(const_iterator(__result), const_iterator(__result));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ntypename __tree<_Tp, _Compare, _Allocator>::__node_holder\n__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) _NOEXCEPT\n{\n    __node_pointer __np = __p.__ptr_;\n    if (__begin_node() == __np)\n    {\n        if (__np->__right_ != nullptr)\n            __begin_node() = static_cast<__node_pointer>(__np->__right_);\n        else\n            __begin_node() = static_cast<__node_pointer>(__np->__parent_);\n    }\n    --size();\n    __tree_remove(__end_node()->__left_,\n                  static_cast<__node_base_pointer>(__np));\n    return __node_holder(__np, _Dp(__node_alloc()));\n}\n\ntemplate <class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__tree<_Tp, _Compare, _Allocator>& __x,\n     __tree<_Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___TREE\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return -_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_return<type, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args)\n          {\n              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm)\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    template <class _Fp>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const _Fp&) {return true;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const function<_Rp(_Ap...)>& __p) {return __p;}\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value =\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<_FF>\n#else\n                rebind_alloc<_FF>::other\n#endif\n                                                         _Ap;\n            _Ap __a(__a0);\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = (__base*)&__tempbuf;\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = (__base*)&__buf_;\n        __t->__clone((__base*)&__f.__buf_);\n        __t->destroy();\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f_ == (__base*)&__buf_)\n    {\n        __f_->__clone((__base*)&__f.__buf_);\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = (__base*)&__buf_;\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_bind_expression<_Ti>::value,\n    typename __invoke_of<_Ti&, _Uj...>::type\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__c = 0;\n        __u.__d = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===-------------------------- exception ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_EXCEPTION\n#define _LIBCPP_EXCEPTION\n\n/*\n    exception synopsis\n\nnamespace std\n{\n\nclass exception\n{\npublic:\n    exception() noexcept;\n    exception(const exception&) noexcept;\n    exception& operator=(const exception&) noexcept;\n    virtual ~exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_exception\n    : public exception\n{\npublic:\n    bad_exception() noexcept;\n    bad_exception(const bad_exception&) noexcept;\n    bad_exception& operator=(const bad_exception&) noexcept;\n    virtual ~bad_exception() noexcept;\n    virtual const char* what() const noexcept;\n};\n\ntypedef void (*unexpected_handler)();\nunexpected_handler set_unexpected(unexpected_handler  f ) noexcept;\nunexpected_handler get_unexpected() noexcept;\n[[noreturn]] void unexpected();\n\ntypedef void (*terminate_handler)();\nterminate_handler set_terminate(terminate_handler  f ) noexcept;\nterminate_handler get_terminate() noexcept;\n[[noreturn]] void terminate() noexcept;\n\nbool uncaught_exception() noexcept;\n\ntypedef unspecified exception_ptr;\n\nexception_ptr current_exception() noexcept;\nvoid rethrow_exception [[noreturn]] (exception_ptr p);\ntemplate<class E> exception_ptr make_exception_ptr(E e) noexcept;\n\nclass nested_exception\n{\npublic:\n    nested_exception() noexcept;\n    nested_exception(const nested_exception&) noexcept = default;\n    nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() = default;\n\n    // access functions\n    [[noreturn]] void rethrow_nested() const;\n    exception_ptr nested_ptr() const noexcept;\n};\n\ntemplate <class T> [[noreturn]] void throw_with_nested(T&& t);\ntemplate <class E> void rethrow_if_nested(const E& e);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <cstddef>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception() _NOEXCEPT {}\n    virtual ~exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_exception\n    : public exception\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY bad_exception() _NOEXCEPT {}\n    virtual ~bad_exception() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\ntypedef void (*unexpected_handler)();\n_LIBCPP_FUNC_VIS unexpected_handler set_unexpected(unexpected_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS unexpected_handler get_unexpected() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void unexpected();\n\ntypedef void (*terminate_handler)();\n_LIBCPP_FUNC_VIS terminate_handler set_terminate(terminate_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS terminate_handler get_terminate() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void terminate() _NOEXCEPT;\n\n_LIBCPP_FUNC_VIS bool uncaught_exception() _NOEXCEPT;\n\nclass _LIBCPP_TYPE_VIS exception_ptr;\n\n_LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n_LIBCPP_NORETURN _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n\nclass _LIBCPP_TYPE_VIS exception_ptr\n{\n    void* __ptr_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY exception_ptr() _NOEXCEPT : __ptr_() {}\n    _LIBCPP_INLINE_VISIBILITY exception_ptr(nullptr_t) _NOEXCEPT : __ptr_() {}\n    exception_ptr(const exception_ptr&) _NOEXCEPT;\n    exception_ptr& operator=(const exception_ptr&) _NOEXCEPT;\n    ~exception_ptr() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT\n        operator bool() const _NOEXCEPT {return __ptr_ != nullptr;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return __x.__ptr_ == __y.__ptr_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const exception_ptr& __x, const exception_ptr& __y) _NOEXCEPT\n        {return !(__x == __y);}\n\n    friend _LIBCPP_FUNC_VIS exception_ptr current_exception() _NOEXCEPT;\n    friend _LIBCPP_FUNC_VIS void rethrow_exception(exception_ptr);\n};\n\ntemplate<class _Ep>\nexception_ptr\nmake_exception_ptr(_Ep __e) _NOEXCEPT\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n        throw __e;\n    }\n    catch (...)\n    {\n        return current_exception();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\n// nested_exception\n\nclass _LIBCPP_EXCEPTION_ABI nested_exception\n{\n    exception_ptr __ptr_;\npublic:\n    nested_exception() _NOEXCEPT;\n//     nested_exception(const nested_exception&) noexcept = default;\n//     nested_exception& operator=(const nested_exception&) noexcept = default;\n    virtual ~nested_exception() _NOEXCEPT;\n\n    // access functions\n    _LIBCPP_NORETURN void rethrow_nested() const;\n    _LIBCPP_INLINE_VISIBILITY exception_ptr nested_ptr() const _NOEXCEPT {return __ptr_;}\n};\n\ntemplate <class _Tp>\nstruct __nested\n    : public _Tp,\n      public nested_exception\n{\n    _LIBCPP_INLINE_VISIBILITY explicit __nested(const _Tp& __t) : _Tp(__t) {}\n};\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  is_class<typename remove_reference<_Tp>::type>::value &&\n                  !is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  is_class<_Tp>::value && !is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw __nested<typename remove_reference<_Tp>::type>(_VSTD::forward<_Tp>(__t));\n#endif\n}\n\ntemplate <class _Tp>\n_LIBCPP_NORETURN\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested(_Tp&& __t, typename enable_if<\n                  !is_class<typename remove_reference<_Tp>::type>::value ||\n                  is_base_of<nested_exception, typename remove_reference<_Tp>::type>::value\n                                    >::type* = 0)\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nthrow_with_nested (_Tp& __t, typename enable_if<\n                  !is_class<_Tp>::value || is_base_of<nested_exception, _Tp>::value\n                                    >::type* = 0)\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw _VSTD::forward<_Tp>(__t);\n#endif\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep& __e, typename enable_if<\n                                   is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n    const nested_exception* __nep = dynamic_cast<const nested_exception*>(&__e);\n    if (__nep)\n        __nep->rethrow_nested();\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nrethrow_if_nested(const _Ep&, typename enable_if<\n                                   !is_polymorphic<_Ep>::value\n                                                   >::type* = 0)\n{\n}\n\n}  // std\n\n#endif  // _LIBCPP_EXCEPTION\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenCAMlib is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenCAMlib is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenCAMlib.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checker.hpp\"\n#include \"voronoidiagram.hpp\"\n\nnamespace ovd {\n\nVoronoiDiagramChecker::VoronoiDiagramChecker(HEGraph& gi) : g(gi) {}\n\nVoronoiDiagramChecker::~VoronoiDiagramChecker() {}\n\n/// overall sanity-check for the diagram, calls other sanity-check functions\nbool VoronoiDiagramChecker::is_valid() {\n    return  (   all_faces_ok() && \n                vertex_degree_ok() &&\n                face_count_equals_generator_count()\n            );\n}\n\n/// check that number of faces equals the number of generators\n/// \\todo not implemented!\nbool VoronoiDiagramChecker::face_count_equals_generator_count() {\n    // Euler formula for planar graphs\n    // v - e + f = 2\n    // in a half-edge diagram all edges occur twice, so:\n    // f = 2-v+e\n    //int vertex_count = hedi::num_vertices(g);\n    /*int vertex_count = 0;\n    BOOST_FOREACH( HEVertex v, hedi::vertices( g ) ) {\n        if ( g[v].type == NORMAL )\n            vertex_count++;\n    }\n    int face_count = (vertex_count- 4)/2 + 3; // degree three graph\n    //int face_count = hed.num_faces();\n    if (face_count != gen_count) {\n        std::cout << \" face_count_equals_generator_count() ERROR:\\n\";\n        std::cout << \" num_vertices = \" << vertex_count << \"\\n\";\n        std::cout << \" gen_count = \" << gen_count << \"\\n\";\n        std::cout << \" face_count = \" << face_count << \"\\n\";\n    }\n    return ( face_count == gen_count );\n    * */\n    return true;\n}\n\n/// check that the diagram is of degree three.\n/// however ::SPLIT and ::APEX vertices are of degree 2.\nbool VoronoiDiagramChecker::vertex_degree_ok() {\n    BOOST_FOREACH(HEVertex v, g.vertices() ) {\n        if ( g.degree(v) != VoronoiVertex::expected_degree[ g[v].type ] ) {\n            std::cout << \" vertex_degree_ok() ERROR\\n\";\n            std::cout << \" vertex \" << g[v].index << \" type = \" << g[v].type << \"\\n\";\n            std::cout << \" vertex degree = \" << g.degree(v) << \"\\n\";\n            std::cout << \" expected degree = \" << VoronoiVertex::expected_degree[ g[v].type ]  << \"\\n\";\n            return false;\n        }\n    }\n    return true;\n}\n\n// traverse the incident faces and check next-pointers\n/*\nbool VoronoiDiagramChecker::allIncidentFacesOK() { // have this take incident_faces as a parameter?\n    // all incident faces should pass the sanity-check\n    BOOST_FOREACH( HEFace f, incident_faces ) {\n        if ( !faceVerticesConnected(  f, IN ) )\n            return false; // IN vertices should be connected\n        if ( !faceVerticesConnected(  f, OUT ) )  // OUT vertices should be connected\n            return false;\n        if ( !noUndecidedInFace( f ) )            // no UNDECIDED vertices should remain\n            return false;\n    }\n    return true;\n}*/\n\n/// check that all vertices in the input vector have status ::IN\nbool VoronoiDiagramChecker::all_in( const VertexVector& q) {\n    BOOST_FOREACH( HEVertex v, q) {\n        if ( g[v].status != IN )\n            return false;\n    }\n    return true;\n}\n\n/// check that no undecided vertices remain in the face\nbool  VoronoiDiagramChecker::noUndecidedInFace( HEFace f ) { // is this true??\n    VertexVector face_verts = g.face_vertices(f);\n    BOOST_FOREACH( HEVertex v, face_verts ) {\n        if ( g[v].status == UNDECIDED )\n            return false;\n    }\n    return true;\n}\n\n/// check that for HEFace f the vertices TYPE are connected\nbool VoronoiDiagramChecker::faceVerticesConnected(  HEFace f, VertexStatus Vtype ) {\n    VertexVector face_verts = g.face_vertices(f);\n    VertexVector type_verts;\n    BOOST_FOREACH( HEVertex v, face_verts ) {\n        if ( g[v].status == Vtype )\n            type_verts.push_back(v); // build a vector of all Vtype vertices\n    }\n    assert( !type_verts.empty() );\n    if (type_verts.size()==1) // set of 1 is allways connected\n        return true;\n    \n    // check that type_verts are connected\n    HEEdge currentEdge = g[f].edge;\n    HEVertex endVertex = g.source(currentEdge); // stop when target here\n    EdgeVector startEdges;\n    bool done = false;\n    while (!done) { \n        HEVertex src = g.source( currentEdge );\n        HEVertex trg = g.target( currentEdge );\n        if ( g[src].status != Vtype ) { // seach ?? - Vtype\n            if ( g[trg].status == Vtype ) { // we have found ?? - Vtype\n                startEdges.push_back( currentEdge );\n            }\n        }\n        currentEdge = g[currentEdge].next;\n        if ( trg == endVertex ) {\n            done = true;\n        }\n    }\n    assert( !startEdges.empty() );\n    if ( startEdges.size() != 1 ) // when the Vtype vertices are connected, there is exactly one startEdge\n        return false;\n    else \n        return true;\n}\n\n// sanity check: IN-vertices on each INCIDENT face should be connected\n/*\nbool VoronoiDiagramChecker::incidentFaceVerticesConnected( VoronoiVertexStatus  ) {    \n    BOOST_FOREACH( HEFace f1, incident_faces ) {\n        if ( !faceVerticesConnected(  f1, IN ) ) {\n            std::cout << \" VoronoiDiagramChecker::incidentFaceVerticesConnected() ERROR, IN-vertices not connected.\\n\";\n            std::cout << \" printing all incident faces for debug: \\n\";\n            BOOST_FOREACH( HEFace f2, incident_faces ) {\n                g.print_face( f2 );\n            } \n            return false;\n        }\n    }\n    return true;\n}*/\n\n\n/// check that all faces are ok. calls face_ok()\nbool VoronoiDiagramChecker::all_faces_ok() {\n    for(HEFace f=0;f< g.num_faces() ; f++ ) {\n        if (!face_ok(f)) {\n            std::cout << \"VoronoiDiagramChecker::all_faces_ok() ERROR: f= \" << f << \"\\n\";\n            g.print_face(f);\n            return false;\n        }\n    }\n    return true;\n}\n\n/// check that the face is ok\nbool VoronoiDiagramChecker::face_ok(HEFace f, bool debug) {\n    HEEdge current_edge = g[f].edge;\n    //std::cout << \" face_ok( \" << f << \" )\\n\";\n    \n    HEEdge start_edge= current_edge;\n    double k = g[current_edge].k;\n    if ( !((k==1) || (k==-1)) ) {\n        std::cout << \" VoronoiDiagramChecker::face_ok() f=\" << f << \" ERROR:\\n\";\n        std::cout << \" illegal k-value for edge:\";\n        std::cout << g[ g.source(current_edge)].index << \" - \"; \n        std::cout <<  g[ g.target(current_edge)].index  ;\n        std::cout << \" k= \" << k << \"\\n\";\n        return false;\n    }\n    if (g[f].site!=0) { // guard against null-faces that dont have Site\n        if ( g[f].site->isPoint() ) {\n            if ( !(k==1) ) {\n                std::cout << \" VoronoiDiagramChecker::face_ok() f=\" << f << \" ERROR:\\n\";\n                std::cout << \" f = \" << f << \" site is \" << g[f].site->str() << \" but k=\" << k  << \"\\n\";\n                std::cout << \" null? \" << g[f].null << \"\\n\";\n                return false;\n            }\n        }\n    }\n    int n=0;\n    if (debug) std::cout << \" checking face \" << f << \"\\n\";\n    do {\n        if(debug) {\n            std::cout << \" edge: \" << g[ g.source(current_edge)].index << \" - \"; \n            std::cout <<  g[ g.target(current_edge)].index  ;\n            std::cout << \" edge.face= \" << g[ current_edge ].face;\n            std::cout << \" edge.k= \" << g[ current_edge ].k;\n            std::cout << \"\\n\";\n        }\n        if (g[current_edge].k != k )  { // all edges should have the same k-value\n            std::cout << \" face_ok() g[current_edge].k != k ! \\n\";\n            return false;\n        }\n        if ( !current_face_equals_next_face(current_edge) )  {// all edges should have the same face\n            std::cout << \" face_ok() !current_face_equals_next_face(current_edge) ! \\n\";\n            return false;\n        }\n        \n        if ( !check_edge(current_edge) ) {\n            std::cout << \" VoronoiDiagramChecker::face_ok() f= \" << f << \" check_edge ERROR\\n\";\n            std::cout << \" edge: \" << g[ g.source(current_edge)].index << \" t=\" << g[ g.source(current_edge)].type; \n            std::cout << \" - \";\n            std::cout <<  g[ g.target(current_edge)].index << \" t=\" << g[ g.target(current_edge) ].type << \"\\n\"; \n            HEEdge twin = g[current_edge].twin;\n            std::cout << \" twin: \" << g[ g.source(twin)].index  << \" t=\" << g[ g.source(twin)].type; \n            std::cout << \" - \";\n            std::cout <<  g[ g.target(twin)].index << \" t=\" << g[ g.target(twin) ].type << \"\\n\"; \n            //std::cout << \" twin: \" << g[ g.source(twin)].index << \" - \" <<  g[ g.target(twin)].index << \"\\n\";\n            \n            std::cout << \" edge-type= \" << g[current_edge].type << \"\\n\";\n\n            return false;\n        }\n        \n        current_edge = g[current_edge].next; \n        n++;\n        assert( n < 10000 ); // reasonable max\n    } while( current_edge != start_edge);\n    //std::cout << \" face ok, edges=\" << n-1 << \"\\n\";\n    return true;\n}\n\n/// check that current edge and next-edge are on the same face\nbool VoronoiDiagramChecker::current_face_equals_next_face( HEEdge e) {\n    if ( g[e].face !=  g[ g[e].next ].face) {\n        std::cout << \" current_face_equals_next_face() ERROR.\\n\";\n        std::cout << \"   current.face = \" << g[e].face << \" IS NOT next_face = \" << g[ g[e].next ].face << std::endl;\n        HEVertex c_trg = g.target( e );\n        HEVertex c_src = g.source( e );\n\n        HEVertex n_trg = g.target( g[e].next );\n        HEVertex n_src = g.source( g[e].next );\n        \n        std::cout << \"   current_edge = \" << g[c_src].index << \" - \" << g[c_trg].index << \" type=\" << g[e].type << \" face=\" << g[e].face  <<\"\\n\";\n        std::cout << \"   next_edge = \" << g[n_src].index << \" - \" << g[n_trg].index << \" type=\" << g[ g[e].next ].type << \" face=\"<< g[ g[e].next ].face << \"\\n\";\n        \n        g.print_face( g[e].face );\n        g.print_face( g[ g[e].next ].face );\n        \n        //std::cout << \" printing all incident faces for debug: \\n\";\n        //BOOST_FOREACH( HEFace f, incident_faces ) {\n        //    g.print_face( f );\n        //} \n        return false;\n    }\n    return true;\n}\n\n/// sanity-check for edge\nbool VoronoiDiagramChecker::check_edge(HEEdge e) const {\n    HEVertex src = g.source(e);\n    HEVertex trg = g.target(e);\n    HEEdge twine = g[e].twin;\n\n    if (twine == HEEdge() ) {\n        return true;\n    } else if ( !( e == g[twine].twin ) ) {\n        std::cout << \" VoronoiDiagramChecker::check_edge() twinning error!\\n\";\n        return false;\n    }\n    \n    HEVertex tw_src = g.source(twine);\n    HEVertex tw_trg = g.target(twine);\n    //std::cout << (src==tw_trg) << \" && \" << (trg==tw_src) << \"\\n\";\n    if ( !((src==tw_trg) && (trg==tw_src)) ) {\n        std::cout << \"VoronoiDiagramChecker::check_edge() ERROR: \\n\";\n        std::cout << \"      edge: \" << g[src].index << \"(\"<< g[src].type << \")\";\n        std::cout << \" - \" << g[trg].index << \"(\"<< g[trg].type << \")\" << \"\\n\";\n        //std::cout << \"      twin: \" << g[tw_src].index << \" - \" << g[tw_src].index << \"\\n\";\n        std::cout << \"      edge: \" << e << \"\\n\";\n        std::cout << \"      twin: \" << twine << \"\\n\";\n        std::cout << \"      edge: \" << src << \" - \" << trg << \"\\n\";\n        std::cout << \"      twin: \" << tw_src << \" - \" << tw_trg << \"\\n\";\n\n    }\n    return ( (src==tw_trg) && (trg==tw_src) );\n}\n\n} // end namespace\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <vector>\n#include <list>\n\n#include <boost/graph/adjacency_list.hpp>\n#include <boost/foreach.hpp> \n#include <boost/iterator/iterator_facade.hpp>\n#include <boost/assign/list_of.hpp>\n\n// bundled BGL properties, see: http://www.boost.org/doc/libs/1_44_0/libs/graph/doc/bundles.html\n\n// dcel notes from http://www.holmes3d.net/graphics/dcel/\n\n// vertex (boost::out_edges)\n//  -leaving pointer to HalfEdge that has this vertex as origin\n//   if many HalfEdges have this vertex as origin, choose one arbitrarily\n\n// HalfEdge\n//  - origin pointer to vertex (boost::source)\n//  - face to the left of halfedge\n//  - twin pointer to HalfEdge (on the right of this edge)\n//  - next pointer to HalfEdge\n//     this edge starts from h->twin->origin and ends at next vertex in h->face\n//     traveling ccw around boundary\n//     (allows face traverse, follow h->next until we arrive back at h)\n\n// Face\n//  - edge pointer to HalfEdge\n//    this edge has this Face object as face\n//    half-edge can be any one on the boundary of face\n// special \"infinite face\", face on \"outside\" of boundary\n// may or may not store edge pointer\n\n\n\n\n\nnamespace hedi  { \n/*! \n * \\namespace hedi\n * \\brief Half-edge diagram\n */\n\n/// \\brief half-edge diagram, based on the boost graph-library\n///\n/// half_edge_diagram is a half-edge diagram class.\n/// Templated on Vertex/Edge/Face property classes which allow\n/// attaching information to vertices/edges/faces that is \n/// required for a particular algorithm.\n/// \n/// Inherits from boost::adjacency_list\n/// minor additions allow storing face-properties.\n///\n/// the hedi namespace contains functions for manipulating HEDIGraphs\n///\n/// For a general description of the half-edge data structure see e.g.:\n///  - http://www.holmes3d.net/graphics/dcel/\n///  - http://openmesh.org/index.php?id=228\ntemplate <class TOutEdgeList, \n          class TVertexList,\n          class TDirected, \n          class TVertexProperties,\n          class TEdgeProperties,\n          class TFaceProperties,\n          class TGraphProperties,\n          class TEdgeList \n          >\nclass half_edge_diagram {\npublic:\n    /// type of face descriptor\n    typedef unsigned int Face; \n    /// underlying boost graph type\n    typedef typename boost::adjacency_list< TOutEdgeList,            \n                                            TVertexList,            \n                                            TDirected,   \n                                            TVertexProperties,             \n                                            TEdgeProperties,                \n                                            TGraphProperties,\n                                            TEdgeList\n                                            > BGLGraph;\n    /// edge descriptor\n    typedef typename boost::graph_traits< BGLGraph >::edge_descriptor   Edge;\n    /// vertex descriptor\n    typedef typename boost::graph_traits< BGLGraph >::vertex_descriptor Vertex;\n    /// vertex iterator type\n    typedef typename boost::graph_traits< BGLGraph >::vertex_iterator   VertexItr;\n    /// out edge iterator type\n    typedef typename boost::graph_traits< BGLGraph >::out_edge_iterator OutEdgeItr;\n    /// edge iterator type\n    typedef typename boost::graph_traits< BGLGraph >::edge_iterator     EdgeItr; \n\n    /// vertex descriptor\n    typedef typename boost::graph_traits< BGLGraph >::vertex_descriptor      vertex_descriptor;\n    /// edge descriptor\n    typedef typename boost::graph_traits< BGLGraph >::edge_descriptor        edge_descriptor;\n    /// edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::edge_iterator          edge_iterator;\n    /// out edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::out_edge_iterator      out_edge_iterator;\n    /// in edge iterator\n    typedef typename boost::graph_traits< BGLGraph >::in_edge_iterator       in_edge_iterator;\n    /// vertex iterator\n    typedef typename boost::graph_traits< BGLGraph >::vertex_iterator        vertex_iterator;\n    /// directed or underected graph\n    typedef typename boost::graph_traits< BGLGraph >::directed_category      directed_category;\n    /// allow or disallow parallel edges\n    typedef typename boost::graph_traits< BGLGraph >::edge_parallel_category edge_parallel_category;\n    /// ?\n    typedef typename boost::graph_traits< BGLGraph >::traversal_category     traversal_category;\n    /// vertex size type\n    typedef typename boost::graph_traits< BGLGraph >::vertices_size_type     vertices_size_type;\n    /// edge size type\n    typedef typename boost::graph_traits< BGLGraph >::edges_size_type        edges_size_type;\n    /// degree size type\n    typedef typename boost::graph_traits< BGLGraph >::degree_size_type       degree_size_type;\n    /// adjacency iterator\n    typedef typename boost::graph_traits< BGLGraph >::adjacency_iterator     adjacency_iterator;\n\n    /// vector of vertices\n    typedef std::vector<Vertex> VertexVector;\n    /// vector of faces\n    typedef std::vector<Face>   FaceVector;\n    /// vector of edges\n    typedef std::vector<Edge>   EdgeVector;  \n    \n    /// access to Face properties\n    inline TFaceProperties& operator[](Face f) { return faces[f]; }\n    /// const access to Face properties\n    inline const TFaceProperties& operator[](Face f) const { return faces[f]; } \n    /// access to Edge properties\n    inline TEdgeProperties& operator[](Edge e) { return g[e]; }\n    /// const access to Edge properties\n    inline const TEdgeProperties& operator[](Edge e) const { return g[e]; }\n    /// access to Vertex properties\n    inline TVertexProperties& operator[](Vertex v)  { return g[v]; }\n    /// const access to Vertex properties\n    inline const TVertexProperties& operator[](Vertex v) const  { return g[v]; }\n\n//DATA\n    /// container for face properties\n    std::vector< TFaceProperties > faces; // this could maybe be held as a GraphProperty of the BGL-graph?\n    /// underlying BGL graph\n    BGLGraph g;\n    \n// NOTE: there is no HEDIGraph constructor, we use the default one..\n\n/// dtor\nvirtual ~half_edge_diagram(){\n    // sites are associated with faces. go through all faces and delete the site\n    //std::cout << \"~half_edge_diagram()...\";\n    /*\n    BOOST_FOREACH( TFaceProperties fprop, faces ) {\n        if (fprop.site)\n            delete fprop.site;\n    }\n    g.clear();\n    */\n    //std::cout << \"DONE.\";\n}\n\n// One-liner wrappers around boost-graph-library functions:\n\n/// return an invalid face_descriptor\nFace HFace() { return std::numeric_limits<Face>::quiet_NaN(); }\n/// add a blank vertex and return its descriptor\nVertex add_vertex() { return boost::add_vertex( g ); }\n/// add a vertex with given properties, return vertex descriptor\nVertex add_vertex(const TVertexProperties& prop) { return boost::add_vertex( prop, g ); }\n/// return the target vertex of the given edge\nVertex target(const Edge e ) const { return boost::target( e, g ); }\n/// return the source vertex of the given edge\nVertex source(const Edge e ) const { return boost::source( e, g ); }\n/// return degree of given vertex\nunsigned int degree( Vertex v)  { return boost::degree( v, g); }\n/// return number of faces in graph\nunsigned int num_faces() const { return faces.size(); }\n/// return number of vertices in graph\nunsigned int num_vertices() const { return boost::num_vertices( g ); }\n/// return number of edges in graph\nunsigned int num_edges() const { return boost::num_edges( g ); }\n/// return number of edges on Face f\nunsigned int num_edges(Face f) { return face_edges(f).size(); }\n/// add an edge between vertices v1-v2\nEdge add_edge(Vertex v1, Vertex v2) { return boost::add_edge( v1, v2, g).first; }\n/// add an edge with given properties between vertices v1-v2\nEdge add_edge( Vertex v1, Vertex  v2, const TEdgeProperties& prop ) { return boost::add_edge( v1, v2, prop, g).first; }\n/// return begin/edge iterators for out-edges of Vertex \\a v\nstd::pair<OutEdgeItr, OutEdgeItr> out_edge_itr( Vertex v ) { return boost::out_edges( v, g ); } // FIXME: change name to out_edges!!\n/// return true if v1-v2 edge exists\ninline bool has_edge( Vertex v1, Vertex v2) { return boost::edge( v1, v2, g ).second; }\n/// return v1-v2 Edge\nEdge edge( Vertex v1, Vertex v2) { assert(has_edge(v1,v2)); return boost::edge( v1, v2, g ).first; }\n/// clear given vertex. this removes all edges connecting to the vertex.\nvoid clear_vertex( Vertex v ) { boost::clear_vertex( v, g ); }\n/// remove given vertex. call clear_vertex() before this!\nvoid remove_vertex( Vertex v ) { boost::remove_vertex( v , g ); }\n/// remove given edge\nvoid remove_edge( Edge e ) { boost::remove_edge( e , g ); }\n/// delete a vertex. clear and remove.\nvoid delete_vertex(Vertex v) { clear_vertex(v); remove_vertex(v); }\n\n/// insert Vertex \\a v into the middle of Edge \\a e\nvoid add_vertex_in_edge( Vertex v, Edge e) {\n    // the vertex v is inserted into the middle of edge e\n    // edge e and its twin are replaced by four new edges: e1,e2 and their twins te2,te1\n    // before:             face\n    //                      e\n    // previous-> source  ------> target -> next\n    //  tw_next<- tw_trg  <-----  tw_src <- tw_previous\n    //                      twin \n    //                    twin_face\n    //\n    // after:               face\n    //                    e1   e2\n    // previous-> source  -> v -> target -> next\n    //  tw_next<- tw_trg  <- v <- tw_src <- tw_previous\n    //                    te2  te1\n    //                    twin_face\n    //\n\n    Edge e_twin = g[e].twin;\n    assert( e_twin != Edge() );\n    Vertex esource = boost::source(e,g); \n    Vertex etarget = boost::target(e,g); \n    Face face = g[e].face;\n    Face twin_face = g[e_twin].face;\n    Edge previous = previous_edge(e);\n    Edge twin_previous = previous_edge(e_twin);\n    \n    assert( g[previous].face == g[e].face );\n    assert( g[twin_previous].face == g[e_twin].face );\n    \n    Edge e1 = boost::add_edge( esource, v, g).first;\n    Edge te2 = boost::add_edge( v, esource,  g).first;\n    g[e1].twin = te2; g[te2].twin = e1;\n    //boost::tie(e1,te2) = add_twin_edges( esource, v ); \n    //Edge e2, te1;\n    //boost::tie(e2,te1) = add_twin_edges( v, etarget );    \n    Edge e2 = boost::add_edge( v, etarget, g).first;\n    Edge te1 = boost::add_edge( etarget, v,  g).first;\n    g[e2].twin = te1; g[te1].twin = e2;\n\n\n    // next-pointers\n    g[previous].next = e1; g[e1].next=e2; g[e2].next = g[e].next;\n    //set_next_chain( boost::assign::list_of(previous)(e1)(e2)(g[e].next) );\n    //set_next_chain( boost::assign::list_of(twin_previous)(te1)(te2)(g[e_twin].next) );\n    g[twin_previous].next = te1; g[te1].next=te2; g[te2].next = g[e_twin].next;    \n    // this copies params, face, k, type\n    g[e1] = g[e];       g[e2] = g[e];       // NOTE: we use EdgeProperties::operator= here to copy !\n    g[te1] = g[e_twin]; g[te2] = g[e_twin];\n    // update the faces \n    faces[face].edge = e1;\n    faces[twin_face].edge = te1;\n    // finally, remove the old edge\n    //remove_twin_edges(esource, etarget);\n    boost::remove_edge( e , g );\n    boost::remove_edge( e_twin , g );\n}\n/// ad two edges, one from \\a v1 to \\a v2 and one from \\a v2 to \\a v1\nstd::pair<Edge,Edge> add_twin_edges(Vertex v1, Vertex v2) {\n    //Edge e1,e2;\n    //bool b;\n    //boost::tie( e1 , b ) = boost::add_edge( v1, v2, g);\n    //boost::tie( e2 , b ) = boost::add_edge( v2, v1, g);\n    Edge e1 = boost::add_edge( v1, v2, g).first;\n    Edge e2 = boost::add_edge( v2, v1, g).first;\n    //twin_edges(e1,e2);\n    g[e1].twin = e2;\n    g[e2].twin = e1;\n    return std::make_pair(e1,e2);\n}\n\n/// make e1 the twin of e2 (and vice versa)\nvoid twin_edges( Edge e1, Edge e2 ) {\n    if (target(e1) != source(e2)) {\n        std::cout << \" error target(e1)= \" << g[target(e1)].index << \" != \" << g[source(e2)].index << \" = source(e2) \\n\";\n        std::cout << \"target(e1) = \" << target(e1) << \"\\n\";\n        std::cout << \"source(e2) = \" << source(e2) << \"\\n\";\n    }\n    assert( target(e1) == source(e2) );\n    assert( source(e1) == target(e2) );\n    \n    g[e1].twin = e2;\n    g[e2].twin = e1;\n}\n\n/// add a face \nFace add_face() {\n    TFaceProperties f_prop;\n    faces.push_back( f_prop); \n    Face index = faces.size()-1;\n    faces[index].idx = index;\n    return index;    \n}\n\n/// add a face, with given properties\nFace add_face(const TFaceProperties& prop) {\n    faces.push_back( prop ); \n    Face index = faces.size()-1;\n    faces[index].idx = index;\n    return index;    \n}\n\n/// return all vertices in a vector of vertex descriptors\nVertexVector vertices()  const {\n    VertexVector vv;\n    VertexItr it_begin, it_end, itr;\n    boost::tie( it_begin, it_end ) = boost::vertices( g );\n    for ( itr=it_begin ; itr != it_end ; ++itr ) {\n        vv.push_back( *itr );\n    }\n    return vv;\n}\n\n/// return all vertices adjecent to given vertex\nVertexVector adjacent_vertices(  Vertex v) {\n    VertexVector vv;\n    BOOST_FOREACH( Edge e, out_edges( v ) ) {\n        vv.push_back( target( e ) );\n    }\n    return vv;\n}\n\n/// return all vertices of given face\nVertexVector face_vertices(Face face_idx) const {\n    VertexVector verts;\n    Edge startedge = faces[face_idx].edge; // the edge where we start\n    Vertex start_target = boost::target( startedge, g ); \n    verts.push_back(start_target);\n    Edge current = g[startedge].next;\n    int count=0;\n    EdgeVector f_edges; // for debug.\n    f_edges.push_back(current);\n    do {\n        Vertex current_target = boost::target( current, g ); \n        //assert( current_target != start_target );\n        verts.push_back(current_target);\n        f_edges.push_back(current);\n        assert( g[current].face == g[ g[current].next ].face );\n        current = g[current].next;\n        \n        if (count >= 3000000 ) {\n            std::cout << \" ERROR too many vertices on face! count=\" << count << \"\\n\";\n            std::cout << \" verts.size() = \" << verts.size();\n            std::cout << \" edges.size()=\" << f_edges.size() <<\"\\n\";\n            for (unsigned int n=0;n<verts.size()-10;n++) {\n                std::cout << n << \"   : \" << g[ verts[n] ].index << \"\\n\"; \n            }\n        }\n        assert( count < 3000000 ); // stop at some max limit\n        count++;\n    } while ( current != startedge );\n    return verts;\n}\n\n/// return edges of face f as a vector\n/// NOTE: it is faster to write a do-while loop in client code than to call this function!\nEdgeVector face_edges( Face f) {\n    Edge start_edge = faces[f].edge;\n    Edge current_edge = start_edge;\n    EdgeVector out;\n    std::cout << \" edges on face \" << f << \" :\\n \";\n    do {\n        Vertex src = source(current_edge);\n        Vertex trg = target(current_edge);\n           std::cout << out.size() << \" \" << g[src].index << \"[\" << g[src].type <<\"]\";\n           std::cout << \" - \" << g[trg].index << \"[\" << g[trg].type <<\"]\" <<\"\\n \";\n        out.push_back(current_edge);\n        current_edge = g[current_edge].next;\n    } while( current_edge != start_edge );\n    return out;\n}\n\n/// return out_edges of given vertex\nEdgeVector out_edges( Vertex v) { \n    EdgeVector ev;\n    OutEdgeItr it, it_end;\n    boost::tie( it, it_end ) = boost::out_edges( v, g );\n    for ( ; it != it_end ; ++it ) {\n        ev.push_back(*it);\n    }\n    return ev;\n}\n\n/// return all edges as a vector\n// FIXME: provide std::pair<edge_iterator,edge_iterator> version of this function also?\nEdgeVector edges() {\n    EdgeVector ev;\n    EdgeItr it, it_end;\n    boost::tie( it, it_end ) = boost::edges( g );\n    for ( ; it != it_end ; ++it ) {\n        ev.push_back(*it);\n    }\n    return ev;\n}\n\n/// return the previous edge. traverses all edges in face until previous found.\nEdge previous_edge( Edge e ) {\n    Edge previous = g[e].next;\n    while ( g[previous].next != e ) {\n        previous = g[previous].next;\n    }\n    return previous;\n}\n\n/// return adjacent faces to the given vertex\nFaceVector adjacent_faces( Vertex q ) {\n    std::set<Face> face_set;\n    OutEdgeItr itr, itr_end;\n    boost::tie( itr, itr_end) = boost::out_edges(q, g);\n    for ( ; itr!=itr_end ; ++itr ) {\n        face_set.insert( g[*itr].face );\n    }\n    //assert( face_set.size() == 3); // true for normal vertices, but SPLIT/APEX are degree 2..\n    FaceVector fv(face_set.begin(), face_set.end());\n    return fv;\n}\n\n/// inserts given vertex into edge e, and into the twin edge e_twin\n/// maintain next-pointers, face-assignment, and k-values\nvoid insert_vertex_in_edge(Vertex v, Edge e ) {\n    // the vertex v is in the middle of edge e\n    //                    face\n    //                    e1   e2\n    // previous-> source  -> v -> target -> next\n    //            tw_trg  <- v <- tw_src <- tw_previous\n    //                    te2  te1\n    //                    twin_face\n    \n    Edge twin = g[e].twin;\n    Vertex src = boost::source( e , g);\n    Vertex trg = boost::target( e , g);\n    Vertex twin_source = boost::source( twin , g);\n    Vertex twin_target = boost::target( twin , g);\n    assert( src == twin_target );    \n    assert( trg == twin_source );\n    \n    Face face = g[e].face;\n    Face twin_face = g[twin].face;\n    Edge previous = previous_edge(e);\n    assert( g[previous].face == g[e].face );\n    Edge twin_previous = previous_edge(twin);\n    assert( g[twin_previous].face == g[twin].face );\n    \n    Edge e1 = add_edge( src, v ); // these replace e\n    Edge e2 = add_edge( v, trg );\n    \n    // preserve the left/right face link\n    g[e1].face = face;\n    g[e2].face = face;\n    // next-pointers\n    g[previous].next = e1;\n    g[e1].next = e2;\n    g[e2].next = g[e].next;\n    \n    Edge te1 = add_edge( twin_source, v  ); // these replace twin\n    Edge te2 = add_edge( v, twin_target  );\n    \n    g[te1].face = twin_face;\n    g[te2].face = twin_face;\n    \n    g[twin_previous].next = te1;\n    g[te1].next = te2;\n    g[te2].next = g[twin].next;\n    \n    // TWINNING (note indices 'cross', see ASCII art above)\n    g[e1].twin = te2;\n    g[te2].twin = e1;\n    g[e2].twin = te1;\n    g[te1].twin = e2;\n    \n    // update the faces \n    faces[face].edge = e1;\n    faces[twin_face].edge = te1;\n    \n    // finally, remove the old edge\n    boost::remove_edge( e   , g);\n    boost::remove_edge( twin, g);\n}\n\n/// remove given v1-v2 edge\nvoid remove_edge( Vertex v1, Vertex v2) { \n    assert( has_edge(v1,v2) );\n    typedef typename std::pair<Edge, bool> EdgeBool;\n    EdgeBool result = boost::edge(v1, v2, g );    \n    boost::remove_edge( result.first , g );\n}\n\n/// remove given v1-v2 edge and its twin\nvoid remove_twin_edges( Vertex v1, Vertex v2) { \n    assert( has_edge(v1,v2) );\n    assert( has_edge(v2,v1) );\n    typedef typename std::pair<Edge, bool> EdgeBool;\n    EdgeBool result1 = boost::edge(v1, v2, g ); \n    EdgeBool result2 = boost::edge(v2, v1, g );    \n    boost::remove_edge( result1.first , g );\n    boost::remove_edge( result2.first , g );\n}\n\n/// remove a degree-two Vertex from the middle of an Edge\n// preserve edge-properties (next, face, k)\nvoid remove_deg2_vertex( Vertex v ) {\n    //                    face1 e[1]\n    //    v1_prev -> v1 -> SPLIT -> v2 -> v2_next\n    //    v1_next <- v1 <- SPLIT <- v2 <- v2_prev\n    //                  e[0]  face2\n    //\n    // is replaced with a single edge:\n    //                    face1\n    //    v1_prev -> v1 ----------> v2 -> v2_next\n    //    v1_next <- v1 <---------- v2 <- v2_prev\n    //                     face2\n    \n    EdgeVector v_edges = out_edges(v);\n    assert( v_edges.size() == 2);\n    assert( source(v_edges[0]) == v && source(v_edges[1]) == v );\n     \n    Vertex v1 = target( v_edges[0] );\n    Vertex v2 = target( v_edges[1] );\n    Edge v1_next = g[ v_edges[0] ].next;\n    Edge v1_prev = previous_edge( g[ v_edges[0] ].twin );\n    Edge v2_next = g[ v_edges[1] ].next;\n    Edge v2_prev = previous_edge( g[ v_edges[1] ].twin );\n    Face face1 = g[ v_edges[1] ].face;\n    Face face2 = g[ v_edges[0] ].face;\n    \n    Edge new1, new2;\n    boost::tie(new1,new2) = add_twin_edges(v1,v2);\n    set_next(new1,v2_next);\n    set_next(new2,v1_next);\n    set_next(v2_prev,new2);\n    set_next(v1_prev,new1);\n    faces[face1].edge = new1;\n    faces[face2].edge = new2;\n    g[new1] = g[ v_edges[1] ]; // NOTE: uses EdgeProperties::operator= to copy edge properties\n    g[new2] = g[ v_edges[0] ]; //  this sets: params, type, k, face\n    remove_twin_edges(v,v1);\n    remove_twin_edges(v,v2);\n    remove_vertex(v);\n}\n/// set next-pointer of e1 to e2\nvoid set_next(Edge e1, Edge e2) {\n    if (target(e1) != source(e2) ){\n        std::cout << \" ERROR target(e1) = \" << g[target(e1)].index << \" source(e2)= \" << g[source(e2)].index << \"\\n\"; \n    }\n    assert( target(e1) == source(e2) );\n    g[e1].next = e2;\n}\n\n/// form a face from the edge-list:\n/// e1->e2->...->e1\n/// for all edges, set edge.face=f, and edge.k=k\nvoid set_next_cycle( std::list<Edge> list, Face f, double k) {\n    typename std::list<Edge>::iterator begin,it,nxt,end;\n    it= list.begin();\n    begin = it;\n    faces[f].edge = *it;\n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n        else\n            set_next(*it,*begin);\n            \n        g[*it].face = f;\n        g[*it].k = k;\n    }\n}\n\n/// set next-pointers for the given list (but don't close to form a cycle)\n// also set face and k properties for edge\nvoid set_next_chain( std::list<Edge> list, Face f, double k) {\n    typename std::list<Edge>::iterator it,nxt,end;\n    it= list.begin();\n    faces[f].edge = *it;\n    //set_next_chain(list);\n    //begin = it;    \n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n            \n        g[*it].face = f;\n        g[*it].k = k;\n    }\n}\n\n/// set next-pointers for the list\nvoid set_next_chain( std::list<Edge> list ) {\n    typename std::list<Edge>::iterator it,nxt,end;\n    it= list.begin();\n    end= list.end();\n    for( ; it!=end ; it++ ) {\n        nxt = it;\n        nxt++;\n        if ( nxt != end )\n            set_next(*it,*nxt);\n    }\n}\n\n/// on a face, search and return the left/right edge from endp\nstd::pair<Edge,Edge> find_next_prev(Face f, Vertex endp) {\n    Edge current = faces[f].edge;\n    Edge start_edge = current;\n    Edge next_edge = current; // this causes unintialized warning: Edge next_edge = Edge();\n    Edge prev_edge = current; // uninitialized warning on ubuntu 11.04 ?\n    do {\n        Vertex src = source(current);\n        Vertex trg = target(current);\n        if (src==endp)\n            next_edge = current;\n        if (trg==endp)\n            prev_edge = current;\n        current = g[current].next;\n    } while (current!=start_edge);\n    assert( next_edge != Edge() );\n    assert( prev_edge != Edge() );\n    //if (debug) {\n    //    std::cout << \" find_next_prev() next_edge = \"; g.print_edge(next_edge); \n    //    std::cout << \" find_next_prev() prev_edge = \"; g.print_edge(prev_edge);\n    //}\n    return std::make_pair(next_edge, prev_edge);\n}\n\n/// print all faces of graph\nvoid print_faces() {\n    for( Face f=0;f<g.num_faces();f++) {\n        print_face(f);\n    }\n}\n\n/// print out vertices on given Face\nvoid print_face(Face f) {\n    std::cout << \" Face \" << f << \": \";\n    Edge current = faces[f].edge;\n    Edge start=current;\n    int num_e=0;\n    do {\n        Vertex v = source(current);\n        std::cout << g[v].index  << \"(\" << g[v].status  << \")-f\"<< g[current].face << \"-\";\n        num_e++;\n        assert(num_e<300);\n        current = g[current].next;\n    } while ( current!=start );\n    std::cout << \"\\n\";\n}\n\n/// print given edges\nvoid print_edges(EdgeVector& q) {\n    BOOST_FOREACH( Edge e, q ) {\n        Vertex src = source(e);\n        Vertex trg = target(e);\n        std::cout << g[src].index << \"-\" << g[trg].index << \"\\n\";\n    }\n}\n\n/// print edge\nvoid print_edge(Edge e) {\n    Vertex src = source(e);\n    Vertex trg = target(e);\n    std::cout << g[src].index << \"-f\" << g[e].face << \"-\" << g[trg].index << \"\\n\";\n}\n\n/// print given vertices\nvoid print_vertices(VertexVector& q) {\n    BOOST_FOREACH( Vertex v, q) {\n        std::cout << g[v].index << \"[\"<< g[v].type << \"]\" << \" \";\n    }\n    std::cout << std::endl;\n}\n\n}; // end HEDIGraph class definition\n\n\n} // end hedi namespace\n// end halfedgediagram.hpp\n","// -*- C++ -*-\n//===----------------------------- map ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MAP\n#define _LIBCPP_MAP\n\n/*\n\n    map synopsis\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass map\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    map()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit map(const key_compare& comp);\n    map(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp = key_compare());\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last,\n            const key_compare& comp, const allocator_type& a);\n    map(const map& m);\n    map(map&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit map(const allocator_type& a);\n    map(const map& m, const allocator_type& a);\n    map(map&& m, const allocator_type& a);\n    map(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        map(InputIterator first, InputIterator last, const allocator_type& a)\n            : map(first, last, Compare(), a) {}  // C++14\n    map(initializer_list<value_type> il, const allocator_type& a)\n        : map(il, Compare(), a) {}  // C++14\n   ~map();\n\n    map& operator=(const map& m);\n    map& operator=(map&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    map& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // element access:\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n          mapped_type& at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    // modifiers:\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& v);\n    template <class P>\n        pair<iterator, bool> insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(map& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const map<Key, T, Compare, Allocator>& x,\n           const map<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Compare = less<Key>,\n          class Allocator = allocator<pair<const Key, T>>>\nclass multimap\n{\npublic:\n    // types:\n    typedef Key                                      key_type;\n    typedef T                                        mapped_type;\n    typedef pair<const key_type,mapped_type>         value_type;\n    typedef Compare                                  key_compare;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class value_compare\n        : public binary_function<value_type,value_type,bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n        value_compare(key_compare c);\n    public:\n        bool operator()(const value_type& x, const value_type& y) const;\n    };\n\n    // construct/copy/destroy:\n    multimap()\n        noexcept(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value);\n    explicit multimap(const key_compare& comp);\n    multimap(const key_compare& comp, const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const key_compare& comp,\n                 const allocator_type& a);\n    multimap(const multimap& m);\n    multimap(multimap&& m)\n        noexcept(\n            is_nothrow_move_constructible<allocator_type>::value &&\n            is_nothrow_move_constructible<key_compare>::value);\n    explicit multimap(const allocator_type& a);\n    multimap(const multimap& m, const allocator_type& a);\n    multimap(multimap&& m, const allocator_type& a);\n    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());\n    multimap(initializer_list<value_type> il, const key_compare& comp,\n             const allocator_type& a);\n    template <class InputIterator>\n        multimap(InputIterator first, InputIterator last, const allocator_type& a)\n            : multimap(first, last, Compare(), a) {} // C++14\n    multimap(initializer_list<value_type> il, const allocator_type& a)\n        : multimap(il, Compare(), a) {} // C++14\n    ~multimap();\n\n    multimap& operator=(const multimap& m);\n    multimap& operator=(multimap&& m)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<key_compare>::value);\n    multimap& operator=(initializer_list<value_type> il);\n\n    // iterators:\n          iterator begin() noexcept;\n    const_iterator begin() const noexcept;\n          iterator end() noexcept;\n    const_iterator end()   const noexcept;\n\n          reverse_iterator rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n          reverse_iterator rend() noexcept;\n    const_reverse_iterator rend()   const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    // capacity:\n    bool      empty()    const noexcept;\n    size_type size()     const noexcept;\n    size_type max_size() const noexcept;\n\n    // modifiers:\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& v);\n    template <class P>\n        iterator insert(P&& p);\n    iterator insert(const_iterator position, const value_type& v);\n    template <class P>\n        iterator insert(const_iterator position, P&& p);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type> il);\n\n    iterator  erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator  erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(multimap& m)\n        noexcept(\n            __is_nothrow_swappable<key_compare>::value &&\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value));\n\n    // observers:\n    allocator_type get_allocator() const noexcept;\n    key_compare    key_comp()      const;\n    value_compare  value_comp()    const;\n\n    // map operations:\n          iterator find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    template<typename K>\n        iterator find(const K& x);              // C++14\n    template<typename K>\n        const_iterator find(const K& x) const;  // C++14\n    template<typename K>\n      size_type count(const K& x) const;\n\n    size_type      count(const key_type& k) const;\n          iterator lower_bound(const key_type& k);\n    const_iterator lower_bound(const key_type& k) const;\n    template<typename K>\n        iterator lower_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator lower_bound(const K& x) const;  // C++14\n\n          iterator upper_bound(const key_type& k);\n    const_iterator upper_bound(const key_type& k) const;\n    template<typename K>\n        iterator upper_bound(const K& x);              // C++14\n    template<typename K>\n        const_iterator upper_bound(const K& x) const;  // C++14\n\n    pair<iterator,iterator>             equal_range(const key_type& k);\n    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;\n    template<typename K>\n        pair<iterator,iterator>             equal_range(const K& x);        // C++14\n    template<typename K>\n        pair<const_iterator,const_iterator> equal_range(const K& x) const;  // C++14\n};\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator==(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator< (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator!=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator> (const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator>=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\ntemplate <class Key, class T, class Compare, class Allocator>\nbool\noperator<=(const multimap<Key, T, Compare, Allocator>& x,\n           const multimap<Key, T, Compare, Allocator>& y);\n\n// specialized algorithms:\ntemplate <class Key, class T, class Compare, class Allocator>\nvoid\nswap(multimap<Key, T, Compare, Allocator>& x,\n     multimap<Key, T, Compare, Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__tree>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <functional>\n#include <initializer_list>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _CP, class _Compare, bool = is_empty<_Compare>::value\n#if __has_feature(is_final)\n                                                        && !__is_final(_Compare)\n#endif\n         >\nclass __map_value_compare\n    : private _Compare\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : _Compare() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : _Compare(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return static_cast<const _Compare&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return static_cast<const _Compare&>(*this)(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return static_cast<const _Compare&>(*this) (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return static_cast<const _Compare&>(*this) (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Key, class _CP, class _Compare>\nclass __map_value_compare<_Key, _CP, _Compare, false>\n{\n    _Compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Compare>::value)\n        : comp() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_value_compare(_Compare c)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Compare>::value)\n        : comp(c) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Compare& key_comp() const _NOEXCEPT {return comp;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _CP& __y) const\n        {return comp(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _CP& __x, const _Key& __y) const\n        {return comp(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _CP& __y) const\n        {return comp(__x, __y.__cc.first);}\n\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () ( const _K2& __x, const _CP& __y ) const\n        {return comp (__x, __y.__cc.first);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type\n    operator () (const _CP& __x, const _K2& __y) const\n        {return comp (__x.__cc.first, __y);}\n#endif\n};\n\ntemplate <class _Allocator>\nclass __map_node_destructor\n{\n    typedef _Allocator                          allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __map_node_destructor& operator=(const __map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class map;\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n    class multimap;\ntemplate <class _TreeIterator> class __map_const_iterator;\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const __value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(__value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(const __value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type& operator=(__value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator++(int)\n    {\n        __map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_iterator operator--(int)\n    {\n        __map_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend \n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __map_const_iterator;\n};\n\ntemplate <class _TreeIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __map_const_iterator\n{\n    _TreeIterator __i_;\n\n    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;\n    typedef const typename _TreeIterator::value_type::value_type::first_type __key_type;\n    typedef typename _TreeIterator::value_type::value_type::second_type      __mapped_type;\npublic:\n    typedef bidirectional_iterator_tag                           iterator_category;\n    typedef pair<__key_type, __mapped_type>                      value_type;\n    typedef typename _TreeIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(_TreeIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator(\n            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)\n                _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator++(int)\n    {\n        __map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator& operator--() {--__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __map_const_iterator operator--(int)\n    {\n        __map_const_iterator __t(*this);\n        --(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY map;\n    template <class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY multimap;\n    template <class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY __tree_const_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY map\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class map;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>   __base;\n    typedef typename __base::__node_traits                 __node_traits;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n        map(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : map(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m)\n        : __tree_(__m.__tree_)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(const map& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    map(map&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(map&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    map(initializer_list<value_type> __il, const allocator_type& __a)\n        : map(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    map& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_unique(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit map(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    map(const map& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT\n            {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n          mapped_type& at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        pair<iterator, bool>\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __p)\n            {return __tree_.__insert_unique(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_unique(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool>\n        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator\n        insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_unique(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                insert(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k)\n        {return __tree_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(map& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n        {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n        {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n        {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator> equal_range(const key_type& __k)\n        {return __tree_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n        {return __tree_.__equal_range_unique(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_unique(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_unique(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef typename __base::__node_base_pointer       __node_base_pointer;\n    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif\n    __node_holder __construct_node_with_key(const key_type& __k);\n\n    __node_base_pointer&\n        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);\n    __node_base_const_pointer\n        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;\n};\n\n// Find place to insert if __k doesn't exist\n// Set __parent to parent of null leaf\n// Return reference to null leaf\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,\n                                                       const key_type& __k)\n{\n    __node_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__left_;\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return __parent->__right_;\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return __parent->__left_;\n}\n\n// Find __k\n// Set __parent to parent of null leaf and\n//    return reference to null leaf iv __k does not exist.\n// If __k exists, set parent to node of __k and return reference to node of __k\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer\nmap<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,\n                                                       const key_type& __k) const\n{\n    __node_const_pointer __nd = __tree_.__root();\n    if (__nd != nullptr)\n    {\n        while (true)\n        {\n            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.__cc.first))\n            {\n                if (__nd->__left_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__left_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n                }\n            }\n            else if (__tree_.value_comp().key_comp()(__nd->__value_.__cc.first, __k))\n            {\n                if (__nd->__right_ != nullptr)\n                    __nd = static_cast<__node_pointer>(__nd->__right_);\n                else\n                {\n                    __parent = static_cast<__node_base_pointer>(__nd);\n                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);\n                }\n            }\n            else\n            {\n                __parent = static_cast<__node_base_pointer>(__nd);\n                return __parent;\n            }\n        }\n    }\n    __parent = static_cast<__node_base_pointer>(__tree_.__end_node());\n    return const_cast<const __node_base_const_pointer&>(__parent->__left_);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmap<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_unique(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename map<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmap<_Key, _Tp, _Compare, _Allocator>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(__k);\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n    __node_pointer __r = static_cast<__node_pointer>(__child);\n    if (__child == nullptr)\n    {\n        __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n        __tree_.__insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));\n        __r = __h.release();\n    }\n    return __r->__value_.__cc.second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\n_Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)\n{\n    __node_base_pointer __parent;\n    __node_base_pointer& __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_pointer>(__child)->__value_.__cc.second;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nconst _Tp&\nmap<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const\n{\n    __node_base_const_pointer __parent;\n    __node_base_const_pointer __child = __find_equal_key(__parent, __k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__child == nullptr)\n        throw out_of_range(\"map::at:  key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return static_cast<__node_const_pointer>(__child)->__value_.__cc.second;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\npair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>\nmap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename map<_Key, _Tp, _Compare, _Allocator>::iterator\nmap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                   _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());\n    if (__r.__i_.__ptr_ == __h.get())\n        __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,\n           const map<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(map<_Key, _Tp, _Compare, _Allocator>& __x,\n     map<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare = less<_Key>,\n          class _Allocator = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY multimap\n{\npublic:\n    // types:\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n    typedef _Compare                                 key_compare;\n    typedef _Allocator                               allocator_type;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n\n    class _LIBCPP_TYPE_VIS_ONLY value_compare\n        : public binary_function<value_type, value_type, bool>\n    {\n        friend class multimap;\n    protected:\n        key_compare comp;\n\n        _LIBCPP_INLINE_VISIBILITY\n        value_compare(key_compare c) : comp(c) {}\n    public:\n        _LIBCPP_INLINE_VISIBILITY\n        bool operator()(const value_type& __x, const value_type& __y) const\n            {return comp(__x.first, __y.first);}\n    };\n\nprivate:\n\n    typedef _VSTD::__value_type<key_type, mapped_type>             __value_type;\n    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                                    __allocator_type;\n    typedef __tree<__value_type, __vc, __allocator_type>            __base;\n    typedef typename __base::__node_traits                          __node_traits;\n    typedef allocator_traits<allocator_type>                        __alloc_traits;\n\n    __base __tree_;\n\npublic:\n    typedef typename __alloc_traits::pointer               pointer;\n    typedef typename __alloc_traits::const_pointer         const_pointer;\n    typedef typename __alloc_traits::size_type             size_type;\n    typedef typename __alloc_traits::difference_type       difference_type;\n    typedef __map_iterator<typename __base::iterator>      iterator;\n    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>               reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>         const_reverse_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp = key_compare())\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<allocator_type>::value &&\n            is_nothrow_default_constructible<key_compare>::value &&\n            is_nothrow_copy_constructible<key_compare>::value)\n        : __tree_(__vc(__comp)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a) {}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__f, __l);\n        }\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        multimap(_InputIterator __f, _InputIterator __l,\n            const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__f, __l);\n        }\n\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)\n        : multimap(__f, __l, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m)\n        : __tree_(__m.__tree_.value_comp(),\n          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(const multimap& __m)\n        {\n#if __cplusplus >= 201103L\n            __tree_ = __m.__tree_;\n#else\n            __tree_.clear();\n            __tree_.value_comp() = __m.__tree_.value_comp();\n            __tree_.__copy_assign_alloc(__m.__tree_);\n            insert(__m.begin(), __m.end());\n#endif\n            return *this;\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n        : __tree_(_VSTD::move(__m.__tree_))\n        {\n        }\n\n    multimap(multimap&& __m, const allocator_type& __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(multimap&& __m)\n        _NOEXCEPT_(is_nothrow_move_assignable<__base>::value)\n        {\n            __tree_ = _VSTD::move(__m.__tree_);\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())\n        : __tree_(__vc(__comp))\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)\n        : __tree_(__vc(__comp), __a)\n        {\n            insert(__il.begin(), __il.end());\n        }\n\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY \n    multimap(initializer_list<value_type> __il, const allocator_type& __a)\n        : multimap(__il, key_compare(), __a) {}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap& operator=(initializer_list<value_type> __il)\n        {\n            __tree_.__assign_multi(__il.begin(), __il.end());\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit multimap(const allocator_type& __a)\n        : __tree_(__a)\n        {\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    multimap(const multimap& __m, const allocator_type& __a)\n        : __tree_(__m.__tree_.value_comp(), __a)\n        {\n            insert(__m.begin(), __m.end());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n          iterator begin() _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __tree_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n          iterator end() _NOEXCEPT {return __tree_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT {return __tree_.end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rbegin() _NOEXCEPT {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n          reverse_iterator rend() _NOEXCEPT {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin()  const _NOEXCEPT {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __tree_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __tree_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __tree_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __tree_.__alloc();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_compare    key_comp() const {return __tree_.value_comp().key_comp();}\n    _LIBCPP_INLINE_VISIBILITY\n    value_compare  value_comp() const\n        {return value_compare(__tree_.value_comp().key_comp());}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class ..._Args>\n        iterator\n        emplace(_Args&& ...__args);\n\n    template <class ..._Args>\n        iterator\n        emplace_hint(const_iterator __p, _Args&& ...__args);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __p)\n            {return __tree_.__insert_multi(_VSTD::forward<_Pp>(__p));}\n\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __pos, _Pp&& __p)\n            {return __tree_.__insert_multi(__pos.__i_, _VSTD::forward<_Pp>(__p));}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __v)\n            {return __tree_.__insert_multi(__p.__i_, __v);}\n\n    template <class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        void insert(_InputIterator __f, _InputIterator __l)\n        {\n            for (const_iterator __e = cend(); __f != __l; ++__f)\n                __tree_.__insert_multi(__e.__i_, *__f);\n        }\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator  erase(const_iterator __f, const_iterator __l)\n        {return __tree_.erase(__f.__i_, __l.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() {__tree_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(multimap& __m)\n        _NOEXCEPT_(__is_nothrow_swappable<__base>::value)\n        {__tree_.swap(__m.__tree_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator find(const key_type& __k)             {return __tree_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    find(const _K2& __k)                           {return __tree_.find(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    find(const _K2& __k) const                     {return __tree_.find(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type      count(const key_type& __k) const\n        {return __tree_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator lower_bound(const key_type& __k)\n        {return __tree_.lower_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator lower_bound(const key_type& __k) const\n            {return __tree_.lower_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    lower_bound(const _K2& __k)       {return __tree_.lower_bound(__k);}\n\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator upper_bound(const key_type& __k)\n            {return __tree_.upper_bound(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator upper_bound(const key_type& __k) const\n            {return __tree_.upper_bound(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type\n    upper_bound(const _K2& __k)       {return __tree_.upper_bound(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type\n    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator,iterator>             equal_range(const key_type& __k)\n            {return __tree_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const\n            {return __tree_.__equal_range_multi(__k);}\n#if _LIBCPP_STD_VER > 11\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type\n    equal_range(const _K2& __k)       {return __tree_.__equal_range_multi(__k);}\n    template <typename _K2>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type\n    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}\n#endif\n\nprivate:\n    typedef typename __base::__node                    __node;\n    typedef typename __base::__node_allocator          __node_allocator;\n    typedef typename __base::__node_pointer            __node_pointer;\n    typedef typename __base::__node_const_pointer      __node_const_pointer;\n    typedef __map_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\nmultimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)\n    : __tree_(_VSTD::move(__m.__tree_), __a)\n{\n    if (__a != __m.get_allocator())\n    {\n        const_iterator __e = cend();\n        while (!__m.empty())\n            __tree_.__insert_multi(__e.__i_,\n                    _VSTD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));\n    }\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder\nmultimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args)\n{\n    __node_allocator& __na = __tree_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace(_Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ntemplate <class ..._Args>\ntypename multimap<_Key, _Tp, _Compare, _Allocator>::iterator\nmultimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,\n                                                        _Args&& ...__args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __x.size() == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Key, class _Tp, class _Compare, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,\n     multimap<_Key, _Tp, _Compare, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MAP\n","//  (C) Copyright John Maddock 2006.\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_MATH_TOOLS_SOLVE_ROOT_HPP\n#define BOOST_MATH_TOOLS_SOLVE_ROOT_HPP\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include <boost/math/tools/precision.hpp>\n#include <boost/math/policies/error_handling.hpp>\n#include <boost/math/tools/config.hpp>\n#include <boost/math/special_functions/sign.hpp>\n#include <boost/cstdint.hpp>\n#include <limits>\n\nnamespace boost{ namespace math{ namespace tools{\n\ntemplate <class T>\nclass eps_tolerance\n{\npublic:\n   eps_tolerance(unsigned bits)\n   {\n      BOOST_MATH_STD_USING\n      eps = (std::max)(T(ldexp(1.0F, 1-bits)), T(4 * tools::epsilon<T>()));\n   }\n   bool operator()(const T& a, const T& b)\n   {\n      BOOST_MATH_STD_USING\n      return fabs(a - b) <= (eps * (std::min)(fabs(a), fabs(b)));\n   }\nprivate:\n   T eps;\n};\n\nstruct equal_floor\n{\n   equal_floor(){}\n   template <class T>\n   bool operator()(const T& a, const T& b)\n   {\n      BOOST_MATH_STD_USING\n      return floor(a) == floor(b);\n   }\n};\n\nstruct equal_ceil\n{\n   equal_ceil(){}\n   template <class T>\n   bool operator()(const T& a, const T& b)\n   {\n      BOOST_MATH_STD_USING\n      return ceil(a) == ceil(b);\n   }\n};\n\nstruct equal_nearest_integer\n{\n   equal_nearest_integer(){}\n   template <class T>\n   bool operator()(const T& a, const T& b)\n   {\n      BOOST_MATH_STD_USING\n      return floor(a + 0.5f) == floor(b + 0.5f);\n   }\n};\n\nnamespace detail{\n\ntemplate <class F, class T>\nvoid bracket(F f, T& a, T& b, T c, T& fa, T& fb, T& d, T& fd)\n{\n   //\n   // Given a point c inside the existing enclosing interval\n   // [a, b] sets a = c if f(c) == 0, otherwise finds the new \n   // enclosing interval: either [a, c] or [c, b] and sets\n   // d and fd to the point that has just been removed from\n   // the interval.  In other words d is the third best guess\n   // to the root.\n   //\n   BOOST_MATH_STD_USING  // For ADL of std math functions\n   T tol = tools::epsilon<T>() * 2;\n   //\n   // If the interval [a,b] is very small, or if c is too close \n   // to one end of the interval then we need to adjust the\n   // location of c accordingly:\n   //\n   if((b - a) < 2 * tol * a)\n   {\n      c = a + (b - a) / 2;\n   }\n   else if(c <= a + fabs(a) * tol)\n   {\n      c = a + fabs(a) * tol;\n   }\n   else if(c >= b - fabs(b) * tol)\n   {\n      c = b - fabs(a) * tol;\n   }\n   //\n   // OK, lets invoke f(c):\n   //\n   T fc = f(c);\n   //\n   // if we have a zero then we have an exact solution to the root:\n   //\n   if(fc == 0)\n   {\n      a = c;\n      fa = 0;\n      d = 0;\n      fd = 0;\n      return;\n   }\n   //\n   // Non-zero fc, update the interval:\n   //\n   if(boost::math::sign(fa) * boost::math::sign(fc) < 0)\n   {\n      d = b;\n      fd = fb;\n      b = c;\n      fb = fc;\n   }\n   else\n   {\n      d = a;\n      fd = fa;\n      a = c;\n      fa= fc;\n   }\n}\n\ntemplate <class T>\ninline T safe_div(T num, T denom, T r)\n{\n   //\n   // return num / denom without overflow,\n   // return r if overflow would occur.\n   //\n   BOOST_MATH_STD_USING  // For ADL of std math functions\n\n   if(fabs(denom) < 1)\n   {\n      if(fabs(denom * tools::max_value<T>()) <= fabs(num))\n         return r;\n   }\n   return num / denom;\n}\n\ntemplate <class T>\ninline T secant_interpolate(const T& a, const T& b, const T& fa, const T& fb)\n{\n   //\n   // Performs standard secant interpolation of [a,b] given\n   // function evaluations f(a) and f(b).  Performs a bisection\n   // if secant interpolation would leave us very close to either\n   // a or b.  Rationale: we only call this function when at least\n   // one other form of interpolation has already failed, so we know\n   // that the function is unlikely to be smooth with a root very\n   // close to a or b.\n   //\n   BOOST_MATH_STD_USING  // For ADL of std math functions\n\n   T tol = tools::epsilon<T>() * 5;\n   T c = a - (fa / (fb - fa)) * (b - a);\n   if((c <= a + fabs(a) * tol) || (c >= b - fabs(b) * tol))\n      return (a + b) / 2;\n   return c;\n}\n\ntemplate <class T>\nT quadratic_interpolate(const T& a, const T& b, T const& d,\n                           const T& fa, const T& fb, T const& fd, \n                           unsigned count)\n{\n   //\n   // Performs quadratic interpolation to determine the next point,\n   // takes count Newton steps to find the location of the\n   // quadratic polynomial.\n   //\n   // Point d must lie outside of the interval [a,b], it is the third\n   // best approximation to the root, after a and b.\n   //\n   // Note: this does not guarentee to find a root\n   // inside [a, b], so we fall back to a secant step should\n   // the result be out of range.\n   //\n   // Start by obtaining the coefficients of the quadratic polynomial:\n   //\n   T B = safe_div(T(fb - fa), T(b - a), tools::max_value<T>());\n   T A = safe_div(T(fd - fb), T(d - b), tools::max_value<T>());\n   A = safe_div(T(A - B), T(d - a), T(0));\n\n   if(A == 0)\n   {\n      // failure to determine coefficients, try a secant step:\n      return secant_interpolate(a, b, fa, fb);\n   }\n   //\n   // Determine the starting point of the Newton steps:\n   //\n   T c;\n   if(boost::math::sign(A) * boost::math::sign(fa) > 0)\n   {\n      c = a;\n   }\n   else\n   {\n      c = b;\n   }\n   //\n   // Take the Newton steps:\n   //\n   for(unsigned i = 1; i <= count; ++i)\n   {\n      //c -= safe_div(B * c, (B + A * (2 * c - a - b)), 1 + c - a);\n      c -= safe_div(T(fa+(B+A*(c-b))*(c-a)), T(B + A * (2 * c - a - b)), T(1 + c - a));\n   }\n   if((c <= a) || (c >= b))\n   {\n      // Oops, failure, try a secant step:\n      c = secant_interpolate(a, b, fa, fb);\n   }\n   return c;\n}\n\ntemplate <class T>\nT cubic_interpolate(const T& a, const T& b, const T& d, \n                    const T& e, const T& fa, const T& fb, \n                    const T& fd, const T& fe)\n{\n   //\n   // Uses inverse cubic interpolation of f(x) at points \n   // [a,b,d,e] to obtain an approximate root of f(x).\n   // Points d and e lie outside the interval [a,b]\n   // and are the third and forth best approximations\n   // to the root that we have found so far.\n   //\n   // Note: this does not guarentee to find a root\n   // inside [a, b], so we fall back to quadratic\n   // interpolation in case of an erroneous result.\n   //\n   BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b\n      << \" d = \" << d << \" e = \" << e << \" fa = \" << fa << \" fb = \" << fb \n      << \" fd = \" << fd << \" fe = \" << fe);\n   T q11 = (d - e) * fd / (fe - fd);\n   T q21 = (b - d) * fb / (fd - fb);\n   T q31 = (a - b) * fa / (fb - fa);\n   T d21 = (b - d) * fd / (fd - fb);\n   T d31 = (a - b) * fb / (fb - fa);\n   BOOST_MATH_INSTRUMENT_CODE(\n      \"q11 = \" << q11 << \" q21 = \" << q21 << \" q31 = \" << q31\n      << \" d21 = \" << d21 << \" d31 = \" << d31);\n   T q22 = (d21 - q11) * fb / (fe - fb);\n   T q32 = (d31 - q21) * fa / (fd - fa);\n   T d32 = (d31 - q21) * fd / (fd - fa);\n   T q33 = (d32 - q22) * fa / (fe - fa);\n   T c = q31 + q32 + q33 + a;\n   BOOST_MATH_INSTRUMENT_CODE(\n      \"q22 = \" << q22 << \" q32 = \" << q32 << \" d32 = \" << d32\n      << \" q33 = \" << q33 << \" c = \" << c);\n\n   if((c <= a) || (c >= b))\n   {\n      // Out of bounds step, fall back to quadratic interpolation:\n      c = quadratic_interpolate(a, b, d, fa, fb, fd, 3);\n   BOOST_MATH_INSTRUMENT_CODE(\n      \"Out of bounds interpolation, falling back to quadratic interpolation. c = \" << c);\n   }\n\n   return c;\n}\n\n} // namespace detail\n\ntemplate <class F, class T, class Tol, class Policy>\nstd::pair<T, T> toms748_solve(F f, const T& ax, const T& bx, const T& fax, const T& fbx, Tol tol, boost::uintmax_t& max_iter, const Policy& pol)\n{\n   //\n   // Main entry point and logic for Toms Algorithm 748\n   // root finder.\n   //\n   BOOST_MATH_STD_USING  // For ADL of std math functions\n\n   static const char* function = \"boost::math::tools::toms748_solve<%1%>\";\n\n   boost::uintmax_t count = max_iter;\n   T a, b, fa, fb, c, u, fu, a0, b0, d, fd, e, fe;\n   static const T mu = 0.5f;\n\n   // initialise a, b and fa, fb:\n   a = ax;\n   b = bx;\n   if(a >= b)\n      policies::raise_domain_error(\n         function, \n         \"Parameters a and b out of order: a=%1%\", a, pol);\n   fa = fax;\n   fb = fbx;\n\n   if(tol(a, b) || (fa == 0) || (fb == 0))\n   {\n      max_iter = 0;\n      if(fa == 0)\n         b = a;\n      else if(fb == 0)\n         a = b;\n      return std::make_pair(a, b);\n   }\n\n   if(boost::math::sign(fa) * boost::math::sign(fb) > 0)\n      policies::raise_domain_error(\n         function, \n         \"Parameters a and b do not bracket the root: a=%1%\", a, pol);\n   // dummy value for fd, e and fe:\n   fe = e = fd = 1e5F;\n\n   if(fa != 0)\n   {\n      //\n      // On the first step we take a secant step:\n      //\n      c = detail::secant_interpolate(a, b, fa, fb);\n      detail::bracket(f, a, b, c, fa, fb, d, fd);\n      --count;\n      BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n\n      if(count && (fa != 0) && !tol(a, b))\n      {\n         //\n         // On the second step we take a quadratic interpolation:\n         //\n         c = detail::quadratic_interpolate(a, b, d, fa, fb, fd, 2);\n         e = d;\n         fe = fd;\n         detail::bracket(f, a, b, c, fa, fb, d, fd);\n         --count;\n         BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n      }\n   }\n\n   while(count && (fa != 0) && !tol(a, b))\n   {\n      // save our brackets:\n      a0 = a;\n      b0 = b;\n      //\n      // Starting with the third step taken\n      // we can use either quadratic or cubic interpolation.\n      // Cubic interpolation requires that all four function values\n      // fa, fb, fd, and fe are distinct, should that not be the case\n      // then variable prof will get set to true, and we'll end up\n      // taking a quadratic step instead.\n      //\n      T min_diff = tools::min_value<T>() * 32;\n      bool prof = (fabs(fa - fb) < min_diff) || (fabs(fa - fd) < min_diff) || (fabs(fa - fe) < min_diff) || (fabs(fb - fd) < min_diff) || (fabs(fb - fe) < min_diff) || (fabs(fd - fe) < min_diff);\n      if(prof)\n      {\n         c = detail::quadratic_interpolate(a, b, d, fa, fb, fd, 2);\n         BOOST_MATH_INSTRUMENT_CODE(\"Can't take cubic step!!!!\");\n      }\n      else\n      {\n         c = detail::cubic_interpolate(a, b, d, e, fa, fb, fd, fe);\n      }\n      //\n      // re-bracket, and check for termination:\n      //\n      e = d;\n      fe = fd;\n      detail::bracket(f, a, b, c, fa, fb, d, fd);\n      if((0 == --count) || (fa == 0) || tol(a, b))\n         break;\n      BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n      //\n      // Now another interpolated step:\n      //\n      prof = (fabs(fa - fb) < min_diff) || (fabs(fa - fd) < min_diff) || (fabs(fa - fe) < min_diff) || (fabs(fb - fd) < min_diff) || (fabs(fb - fe) < min_diff) || (fabs(fd - fe) < min_diff);\n      if(prof)\n      {\n         c = detail::quadratic_interpolate(a, b, d, fa, fb, fd, 3);\n         BOOST_MATH_INSTRUMENT_CODE(\"Can't take cubic step!!!!\");\n      }\n      else\n      {\n         c = detail::cubic_interpolate(a, b, d, e, fa, fb, fd, fe);\n      }\n      //\n      // Bracket again, and check termination condition, update e:\n      //\n      detail::bracket(f, a, b, c, fa, fb, d, fd);\n      if((0 == --count) || (fa == 0) || tol(a, b))\n         break;\n      BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n      //\n      // Now we take a double-length secant step:\n      //\n      if(fabs(fa) < fabs(fb))\n      {\n         u = a;\n         fu = fa;\n      }\n      else\n      {\n         u = b;\n         fu = fb;\n      }\n      c = u - 2 * (fu / (fb - fa)) * (b - a);\n      if(fabs(c - u) > (b - a) / 2)\n      {\n         c = a + (b - a) / 2;\n      }\n      //\n      // Bracket again, and check termination condition:\n      //\n      e = d;\n      fe = fd;\n      detail::bracket(f, a, b, c, fa, fb, d, fd);\n      BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n      BOOST_MATH_INSTRUMENT_CODE(\" tol = \" << T((fabs(a) - fabs(b)) / fabs(a)));\n      if((0 == --count) || (fa == 0) || tol(a, b))\n         break;\n      //\n      // And finally... check to see if an additional bisection step is \n      // to be taken, we do this if we're not converging fast enough:\n      //\n      if((b - a) < mu * (b0 - a0))\n         continue;\n      //\n      // bracket again on a bisection:\n      //\n      e = d;\n      fe = fd;\n      detail::bracket(f, a, b, T(a + (b - a) / 2), fa, fb, d, fd);\n      --count;\n      BOOST_MATH_INSTRUMENT_CODE(\"Not converging: Taking a bisection!!!!\");\n      BOOST_MATH_INSTRUMENT_CODE(\" a = \" << a << \" b = \" << b);\n   } // while loop\n\n   max_iter -= count;\n   if(fa == 0)\n   {\n      b = a;\n   }\n   else if(fb == 0)\n   {\n      a = b;\n   }\n   return std::make_pair(a, b);\n}\n\ntemplate <class F, class T, class Tol>\ninline std::pair<T, T> toms748_solve(F f, const T& ax, const T& bx, const T& fax, const T& fbx, Tol tol, boost::uintmax_t& max_iter)\n{\n   return toms748_solve(f, ax, bx, fax, fbx, tol, max_iter, policies::policy<>());\n}\n\ntemplate <class F, class T, class Tol, class Policy>\ninline std::pair<T, T> toms748_solve(F f, const T& ax, const T& bx, Tol tol, boost::uintmax_t& max_iter, const Policy& pol)\n{\n   max_iter -= 2;\n   std::pair<T, T> r = toms748_solve(f, ax, bx, f(ax), f(bx), tol, max_iter, pol);\n   max_iter += 2;\n   return r;\n}\n\ntemplate <class F, class T, class Tol>\ninline std::pair<T, T> toms748_solve(F f, const T& ax, const T& bx, Tol tol, boost::uintmax_t& max_iter)\n{\n   return toms748_solve(f, ax, bx, tol, max_iter, policies::policy<>());\n}\n\ntemplate <class F, class T, class Tol, class Policy>\nstd::pair<T, T> bracket_and_solve_root(F f, const T& guess, T factor, bool rising, Tol tol, boost::uintmax_t& max_iter, const Policy& pol)\n{\n   BOOST_MATH_STD_USING\n   static const char* function = \"boost::math::tools::bracket_and_solve_root<%1%>\";\n   //\n   // Set up inital brackets:\n   //\n   T a = guess;\n   T b = a;\n   T fa = f(a);\n   T fb = fa;\n   //\n   // Set up invocation count:\n   //\n   boost::uintmax_t count = max_iter - 1;\n\n   if((fa < 0) == (guess < 0 ? !rising : rising))\n   {\n      //\n      // Zero is to the right of b, so walk upwards\n      // until we find it:\n      //\n      while((boost::math::sign)(fb) == (boost::math::sign)(fa))\n      {\n         if(count == 0)\n            policies::raise_evaluation_error(function, \"Unable to bracket root, last nearest value was %1%\", b, pol);\n         //\n         // Heuristic: every 20 iterations we double the growth factor in case the\n         // initial guess was *really* bad !\n         //\n         if((max_iter - count) % 20 == 0)\n            factor *= 2;\n         //\n         // Now go ahead and move our guess by \"factor\":\n         //\n         a = b;\n         fa = fb;\n         b *= factor;\n         fb = f(b);\n         --count;\n         BOOST_MATH_INSTRUMENT_CODE(\"a = \" << a << \" b = \" << b << \" fa = \" << fa << \" fb = \" << fb << \" count = \" << count);\n      }\n   }\n   else\n   {\n      //\n      // Zero is to the left of a, so walk downwards\n      // until we find it:\n      //\n      while((boost::math::sign)(fb) == (boost::math::sign)(fa))\n      {\n         if(fabs(a) < tools::min_value<T>())\n         {\n            // Escape route just in case the answer is zero!\n            max_iter -= count;\n            max_iter += 1;\n            return a > 0 ? std::make_pair(T(0), T(a)) : std::make_pair(T(a), T(0)); \n         }\n         if(count == 0)\n            policies::raise_evaluation_error(function, \"Unable to bracket root, last nearest value was %1%\", a, pol);\n         //\n         // Heuristic: every 20 iterations we double the growth factor in case the\n         // initial guess was *really* bad !\n         //\n         if((max_iter - count) % 20 == 0)\n            factor *= 2;\n         //\n         // Now go ahead and move are guess by \"factor\":\n         //\n         b = a;\n         fb = fa;\n         a /= factor;\n         fa = f(a);\n         --count;\n         BOOST_MATH_INSTRUMENT_CODE(\"a = \" << a << \" b = \" << b << \" fa = \" << fa << \" fb = \" << fb << \" count = \" << count);\n      }\n   }\n   max_iter -= count;\n   max_iter += 1;\n   std::pair<T, T> r = toms748_solve(\n      f, \n      (a < 0 ? b : a), \n      (a < 0 ? a : b), \n      (a < 0 ? fb : fa), \n      (a < 0 ? fa : fb), \n      tol, \n      count, \n      pol);\n   max_iter += count;\n   BOOST_MATH_INSTRUMENT_CODE(\"max_iter = \" << max_iter << \" count = \" << count);\n   return r;\n}\n\ntemplate <class F, class T, class Tol>\ninline std::pair<T, T> bracket_and_solve_root(F f, const T& guess, const T& factor, bool rising, Tol tol, boost::uintmax_t& max_iter)\n{\n   return bracket_and_solve_root(f, guess, factor, rising, tol, max_iter, policies::policy<>());\n}\n\n} // namespace tools\n} // namespace math\n} // namespace boost\n\n\n#endif // BOOST_MATH_TOOLS_SOLVE_ROOT_HPP\n\n","//  Copyright John Maddock 2007.\n//  Copyright Paul A. Bristow 2007.\n\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_MATH_POLICY_ERROR_HANDLING_HPP\n#define BOOST_MATH_POLICY_ERROR_HANDLING_HPP\n\n#include <stdexcept>\n#include <iomanip>\n#include <string>\n#include <cerrno>\n#include <boost/config/no_tr1/complex.hpp>\n#include <boost/config/no_tr1/cmath.hpp>\n#include <stdexcept>\n#include <boost/math/tools/config.hpp>\n#include <boost/math/policies/policy.hpp>\n#include <boost/math/tools/precision.hpp>\n#include <boost/cstdint.hpp>\n#ifdef BOOST_MSVC\n#  pragma warning(push) // Quiet warnings in boost/format.hpp\n#  pragma warning(disable: 4996) // _SCL_SECURE_NO_DEPRECATE\n#  pragma warning(disable: 4512) // assignment operator could not be generated.\n// And warnings in error handling:\n#  pragma warning(disable: 4702) // unreachable code.\n// Note that this only occurs when the compiler can deduce code is unreachable,\n// for example when policy macros are used to ignore errors rather than throw.\n#endif\n#include <boost/format.hpp>\n\nnamespace boost{ namespace math{\n\nclass evaluation_error : public std::runtime_error\n{\npublic:\n   evaluation_error(const std::string& s) : std::runtime_error(s){}\n};\n\nclass rounding_error : public std::runtime_error\n{\npublic:\n   rounding_error(const std::string& s) : std::runtime_error(s){}\n};\n\nnamespace policies{\n//\n// Forward declarations of user error handlers,\n// it's up to the user to provide the definition of these:\n//\ntemplate <class T>\nT user_domain_error(const char* function, const char* message, const T& val);\ntemplate <class T>\nT user_pole_error(const char* function, const char* message, const T& val);\ntemplate <class T>\nT user_overflow_error(const char* function, const char* message, const T& val);\ntemplate <class T>\nT user_underflow_error(const char* function, const char* message, const T& val);\ntemplate <class T>\nT user_denorm_error(const char* function, const char* message, const T& val);\ntemplate <class T>\nT user_evaluation_error(const char* function, const char* message, const T& val);\ntemplate <class T, class TargetType>\nT user_rounding_error(const char* function, const char* message, const T& val, const TargetType& t);\ntemplate <class T>\nT user_indeterminate_result_error(const char* function, const char* message, const T& val);\n\nnamespace detail\n{\n//\n// Helper function to avoid binding rvalue to non-const-reference,\n// in other words a warning suppression mechanism:\n//\ntemplate <class Formatter, class Group>\ninline std::string do_format(Formatter f, const Group& g)\n{\n   return (f % g).str();\n}\n\ntemplate <class E, class T>\nvoid raise_error(const char* function, const char* message)\n{\n  if(function == 0)\n       function = \"Unknown function operating on type %1%\";\n  if(message == 0)\n       message = \"Cause unknown\";\n\n  std::string msg(\"Error in function \");\n  msg += (boost::format(function) % typeid(T).name()).str();\n  msg += \": \";\n  msg += message;\n\n  E e(msg);\n  boost::throw_exception(e);\n}\n\ntemplate <class E, class T>\nvoid raise_error(const char* function, const char* message, const T& val)\n{\n  if(function == 0)\n     function = \"Unknown function operating on type %1%\";\n  if(message == 0)\n     message = \"Cause unknown: error caused by bad argument with value %1%\";\n\n  std::string msg(\"Error in function \");\n  msg += (boost::format(function) % typeid(T).name()).str();\n  msg += \": \";\n  msg += message;\n\n  int prec = 2 + (boost::math::policies::digits<T, boost::math::policies::policy<> >() * 30103UL) / 100000UL;\n  msg = do_format(boost::format(msg), boost::io::group(std::setprecision(prec), val));\n\n  E e(msg);\n  boost::throw_exception(e);\n}\n\ntemplate <class T>\ninline T raise_domain_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const ::boost::math::policies::domain_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::domain_error, T>(function, message, val);\n   // we never get here:\n   return std::numeric_limits<T>::quiet_NaN();\n}\n\ntemplate <class T>\ninline T raise_domain_error(\n           const char* ,\n           const char* ,\n           const T& ,\n           const ::boost::math::policies::domain_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return std::numeric_limits<T>::quiet_NaN();\n}\n\ntemplate <class T>\ninline T raise_domain_error(\n           const char* ,\n           const char* ,\n           const T& ,\n           const ::boost::math::policies::domain_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = EDOM;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return std::numeric_limits<T>::quiet_NaN();\n}\n\ntemplate <class T>\ninline T raise_domain_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::domain_error< ::boost::math::policies::user_error>&)\n{\n   return user_domain_error(function, message, val);\n}\n\ntemplate <class T>\ninline T raise_pole_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::pole_error< ::boost::math::policies::throw_on_error>&)\n{\n   return boost::math::policies::detail::raise_domain_error(function, message, val,  ::boost::math::policies::domain_error< ::boost::math::policies::throw_on_error>());\n}\n\ntemplate <class T>\ninline T raise_pole_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::pole_error< ::boost::math::policies::ignore_error>&)\n{\n   return  ::boost::math::policies::detail::raise_domain_error(function, message, val,  ::boost::math::policies::domain_error< ::boost::math::policies::ignore_error>());\n}\n\ntemplate <class T>\ninline T raise_pole_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::pole_error< ::boost::math::policies::errno_on_error>&)\n{\n   return  ::boost::math::policies::detail::raise_domain_error(function, message, val,  ::boost::math::policies::domain_error< ::boost::math::policies::errno_on_error>());\n}\n\ntemplate <class T>\ninline T raise_pole_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::pole_error< ::boost::math::policies::user_error>&)\n{\n   return user_pole_error(function, message, val);\n}\n\n\ntemplate <class T>\ninline T raise_overflow_error(\n           const char* function,\n           const char* message,\n           const  ::boost::math::policies::overflow_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::overflow_error, T>(function, message ? message : \"numeric overflow\");\n   // We should never get here:\n   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();\n}\n\ntemplate <class T>\ninline T raise_overflow_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const ::boost::math::policies::overflow_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::overflow_error, T>(function, message ? message : \"numeric overflow\", val);\n   // We should never get here:\n   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();\n}\n\ntemplate <class T>\ninline T raise_overflow_error(\n           const char* ,\n           const char* ,\n           const  ::boost::math::policies::overflow_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();\n}\n\ntemplate <class T>\ninline T raise_overflow_error(\n           const char* ,\n           const char* ,\n           const  ::boost::math::policies::overflow_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = ERANGE;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return std::numeric_limits<T>::has_infinity ? std::numeric_limits<T>::infinity() : boost::math::tools::max_value<T>();\n}\n\ntemplate <class T>\ninline T raise_overflow_error(\n           const char* function,\n           const char* message,\n           const  ::boost::math::policies::overflow_error< ::boost::math::policies::user_error>&)\n{\n   return user_overflow_error(function, message, std::numeric_limits<T>::infinity());\n}\n\n\ntemplate <class T>\ninline T raise_underflow_error(\n           const char* function,\n           const char* message,\n           const  ::boost::math::policies::underflow_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::underflow_error, T>(function, message ? message : \"numeric underflow\");\n   // We should never get here:\n   return 0;\n}\n\ntemplate <class T>\ninline T raise_underflow_error(\n           const char* ,\n           const char* ,\n           const  ::boost::math::policies::underflow_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return T(0);\n}\n\ntemplate <class T>\ninline T raise_underflow_error(\n           const char* /* function */,\n           const char* /* message */,\n           const  ::boost::math::policies::underflow_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = ERANGE;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return T(0);\n}\n\ntemplate <class T>\ninline T raise_underflow_error(\n           const char* function,\n           const char* message,\n           const  ::boost::math::policies::underflow_error< ::boost::math::policies::user_error>&)\n{\n   return user_underflow_error(function, message, T(0));\n}\n\ntemplate <class T>\ninline T raise_denorm_error(\n           const char* function,\n           const char* message,\n           const T& /* val */,\n           const  ::boost::math::policies::denorm_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::underflow_error, T>(function, message ? message : \"denormalised result\");\n   // we never get here:\n   return T(0);\n}\n\ntemplate <class T>\ninline T raise_denorm_error(\n           const char* ,\n           const char* ,\n           const T&  val,\n           const  ::boost::math::policies::denorm_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return val;\n}\n\ntemplate <class T>\ninline T raise_denorm_error(\n           const char* ,\n           const char* ,\n           const T& val,\n           const  ::boost::math::policies::denorm_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = ERANGE;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return val;\n}\n\ntemplate <class T>\ninline T raise_denorm_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::denorm_error< ::boost::math::policies::user_error>&)\n{\n   return user_denorm_error(function, message, val);\n}\n\ntemplate <class T>\ninline T raise_evaluation_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::evaluation_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<boost::math::evaluation_error, T>(function, message, val);\n   // we never get here:\n   return T(0);\n}\n\ntemplate <class T>\ninline T raise_evaluation_error(\n           const char* ,\n           const char* ,\n           const T& val,\n           const  ::boost::math::policies::evaluation_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return val;\n}\n\ntemplate <class T>\ninline T raise_evaluation_error(\n           const char* ,\n           const char* ,\n           const T& val,\n           const  ::boost::math::policies::evaluation_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = EDOM;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return val;\n}\n\ntemplate <class T>\ninline T raise_evaluation_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const  ::boost::math::policies::evaluation_error< ::boost::math::policies::user_error>&)\n{\n   return user_evaluation_error(function, message, val);\n}\n\ntemplate <class T, class TargetType>\ninline TargetType raise_rounding_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const TargetType&,\n           const  ::boost::math::policies::rounding_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<boost::math::rounding_error, T>(function, message, val);\n   // we never get here:\n   return TargetType(0);\n}\n\ntemplate <class T, class TargetType>\ninline TargetType raise_rounding_error(\n           const char* ,\n           const char* ,\n           const T& val,\n           const TargetType&,\n           const  ::boost::math::policies::rounding_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   BOOST_STATIC_ASSERT(std::numeric_limits<TargetType>::is_specialized);\n   return  val > 0 ? (std::numeric_limits<TargetType>::max)() : (std::numeric_limits<TargetType>::is_integer ? (std::numeric_limits<TargetType>::min)() : -(std::numeric_limits<TargetType>::max)());\n}\n\ntemplate <class T, class TargetType>\ninline TargetType raise_rounding_error(\n           const char* ,\n           const char* ,\n           const T& val,\n           const TargetType&,\n           const  ::boost::math::policies::rounding_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = ERANGE;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   BOOST_STATIC_ASSERT(std::numeric_limits<TargetType>::is_specialized);\n   return  val > 0 ? (std::numeric_limits<TargetType>::max)() : (std::numeric_limits<TargetType>::is_integer ? (std::numeric_limits<TargetType>::min)() : -(std::numeric_limits<TargetType>::max)());\n}\n\ntemplate <class T, class TargetType>\ninline TargetType raise_rounding_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const TargetType& t,\n           const  ::boost::math::policies::rounding_error< ::boost::math::policies::user_error>&)\n{\n   return user_rounding_error(function, message, val, t);\n}\n\ntemplate <class T, class R>\ninline T raise_indeterminate_result_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const R& ,\n           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::throw_on_error>&)\n{\n   raise_error<std::domain_error, T>(function, message, val);\n   // we never get here:\n   return std::numeric_limits<T>::quiet_NaN();\n}\n\ntemplate <class T, class R>\ninline T raise_indeterminate_result_error(\n           const char* ,\n           const char* ,\n           const T& ,\n           const R& result,\n           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::ignore_error>&)\n{\n   // This may or may not do the right thing, but the user asked for the error\n   // to be ignored so here we go anyway:\n   return result;\n}\n\ntemplate <class T, class R>\ninline T raise_indeterminate_result_error(\n           const char* ,\n           const char* ,\n           const T& ,\n           const R& result,\n           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::errno_on_error>&)\n{\n   errno = EDOM;\n   // This may or may not do the right thing, but the user asked for the error\n   // to be silent so here we go anyway:\n   return result;\n}\n\ntemplate <class T, class R>\ninline T raise_indeterminate_result_error(\n           const char* function,\n           const char* message,\n           const T& val,\n           const R& ,\n           const ::boost::math::policies::indeterminate_result_error< ::boost::math::policies::user_error>&)\n{\n   return user_indeterminate_result_error(function, message, val);\n}\n\n}  // namespace detail\n\ntemplate <class T, class Policy>\ninline T raise_domain_error(const char* function, const char* message, const T& val, const Policy&)\n{\n   typedef typename Policy::domain_error_type policy_type;\n   return detail::raise_domain_error(\n      function, message ? message : \"Domain Error evaluating function at %1%\",\n      val, policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_pole_error(const char* function, const char* message, const T& val, const Policy&)\n{\n   typedef typename Policy::pole_error_type policy_type;\n   return detail::raise_pole_error(\n      function, message ? message : \"Evaluation of function at pole %1%\",\n      val, policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_overflow_error(const char* function, const char* message, const Policy&)\n{\n   typedef typename Policy::overflow_error_type policy_type;\n   return detail::raise_overflow_error<T>(\n      function, message ? message : \"Overflow Error\",\n      policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_overflow_error(const char* function, const char* message, const T& val, const Policy&)\n{\n   typedef typename Policy::overflow_error_type policy_type;\n   return detail::raise_overflow_error(\n      function, message ? message : \"Overflow evaluating function at %1%\",\n      val, policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_underflow_error(const char* function, const char* message, const Policy&)\n{\n   typedef typename Policy::underflow_error_type policy_type;\n   return detail::raise_underflow_error<T>(\n      function, message ? message : \"Underflow Error\",\n      policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_denorm_error(const char* function, const char* message, const T& val, const Policy&)\n{\n   typedef typename Policy::denorm_error_type policy_type;\n   return detail::raise_denorm_error<T>(\n      function, message ? message : \"Denorm Error\",\n      val,\n      policy_type());\n}\n\ntemplate <class T, class Policy>\ninline T raise_evaluation_error(const char* function, const char* message, const T& val, const Policy&)\n{\n   typedef typename Policy::evaluation_error_type policy_type;\n   return detail::raise_evaluation_error(\n      function, message ? message : \"Internal Evaluation Error, best value so far was %1%\",\n      val, policy_type());\n}\n\ntemplate <class T, class TargetType, class Policy>\ninline TargetType raise_rounding_error(const char* function, const char* message, const T& val, const TargetType& t, const Policy&)\n{\n   typedef typename Policy::rounding_error_type policy_type;\n   return detail::raise_rounding_error(\n      function, message ? message : \"Value %1% can not be represented in the target integer type.\",\n      val, t, policy_type());\n}\n\ntemplate <class T, class R, class Policy>\ninline T raise_indeterminate_result_error(const char* function, const char* message, const T& val, const R& result, const Policy&)\n{\n   typedef typename Policy::indeterminate_result_error_type policy_type;\n   return detail::raise_indeterminate_result_error(\n      function, message ? message : \"Indeterminate result with value %1%\",\n      val, result, policy_type());\n}\n\n//\n// checked_narrowing_cast:\n//\nnamespace detail\n{\n\ntemplate <class R, class T, class Policy>\ninline bool check_overflow(T val, R* result, const char* function, const Policy& pol)\n{\n   BOOST_MATH_STD_USING\n   if(fabs(val) > tools::max_value<R>())\n   {\n      *result = static_cast<R>(boost::math::policies::detail::raise_overflow_error<R>(function, 0, pol));\n      return true;\n   }\n   return false;\n}\ntemplate <class R, class T, class Policy>\ninline bool check_overflow(std::complex<T> val, R* result, const char* function, const Policy& pol)\n{\n   typedef typename R::value_type r_type;\n   r_type re, im;\n   bool r = check_overflow<r_type>(val.real(), &re, function, pol);\n   r = check_overflow<r_type>(val.imag(), &im, function, pol) || r;\n   *result = R(re, im);\n   return r;\n}\ntemplate <class R, class T, class Policy>\ninline bool check_underflow(T val, R* result, const char* function, const Policy& pol)\n{\n   if((val != 0) && (static_cast<R>(val) == 0))\n   {\n      *result = static_cast<R>(boost::math::policies::detail::raise_underflow_error<R>(function, 0, pol));\n      return true;\n   }\n   return false;\n}\ntemplate <class R, class T, class Policy>\ninline bool check_underflow(std::complex<T> val, R* result, const char* function, const Policy& pol)\n{\n   typedef typename R::value_type r_type;\n   r_type re, im;\n   bool r = check_underflow<r_type>(val.real(), &re, function, pol);\n   r = check_underflow<r_type>(val.imag(), &im, function, pol) || r;\n   *result = R(re, im);\n   return r;\n}\ntemplate <class R, class T, class Policy>\ninline bool check_denorm(T val, R* result, const char* function, const Policy& pol)\n{\n   BOOST_MATH_STD_USING\n   if((fabs(val) < static_cast<T>(tools::min_value<R>())) && (static_cast<R>(val) != 0))\n   {\n      *result = static_cast<R>(boost::math::policies::detail::raise_denorm_error<R>(function, 0, static_cast<R>(val), pol));\n      return true;\n   }\n   return false;\n}\ntemplate <class R, class T, class Policy>\ninline bool check_denorm(std::complex<T> val, R* result, const char* function, const Policy& pol)\n{\n   typedef typename R::value_type r_type;\n   r_type re, im;\n   bool r = check_denorm<r_type>(val.real(), &re, function, pol);\n   r = check_denorm<r_type>(val.imag(), &im, function, pol) || r;\n   *result = R(re, im);\n   return r;\n}\n\n// Default instantiations with ignore_error policy.\ntemplate <class R, class T>\ninline bool check_overflow(T /* val */, R* /* result */, const char* /* function */, const overflow_error<ignore_error>&){ return false; }\ntemplate <class R, class T>\ninline bool check_overflow(std::complex<T> /* val */, R* /* result */, const char* /* function */, const overflow_error<ignore_error>&){ return false; }\ntemplate <class R, class T>\ninline bool check_underflow(T /* val */, R* /* result */, const char* /* function */, const underflow_error<ignore_error>&){ return false; }\ntemplate <class R, class T>\ninline bool check_underflow(std::complex<T> /* val */, R* /* result */, const char* /* function */, const underflow_error<ignore_error>&){ return false; }\ntemplate <class R, class T>\ninline bool check_denorm(T /* val */, R* /* result*/, const char* /* function */, const denorm_error<ignore_error>&){ return false; }\ntemplate <class R, class T>\ninline bool check_denorm(std::complex<T> /* val */, R* /* result*/, const char* /* function */, const denorm_error<ignore_error>&){ return false; }\n\n} // namespace detail\n\ntemplate <class R, class Policy, class T>\ninline R checked_narrowing_cast(T val, const char* function)\n{\n   typedef typename Policy::overflow_error_type overflow_type;\n   typedef typename Policy::underflow_error_type underflow_type;\n   typedef typename Policy::denorm_error_type denorm_type;\n   //\n   // Most of what follows will evaluate to a no-op:\n   //\n   R result = 0;\n   if(detail::check_overflow<R>(val, &result, function, overflow_type()))\n      return result;\n   if(detail::check_underflow<R>(val, &result, function, underflow_type()))\n      return result;\n   if(detail::check_denorm<R>(val, &result, function, denorm_type()))\n      return result;\n\n   return static_cast<R>(val);\n}\n\ntemplate <class T, class Policy>\ninline void check_series_iterations(const char* function, boost::uintmax_t max_iter, const Policy& pol)\n{\n   if(max_iter >= policies::get_max_series_iterations<Policy>())\n      raise_evaluation_error<T>(\n         function,\n         \"Series evaluation exceeded %1% iterations, giving up now.\", static_cast<T>(static_cast<double>(max_iter)), pol);\n}\n\ntemplate <class T, class Policy>\ninline void check_root_iterations(const char* function, boost::uintmax_t max_iter, const Policy& pol)\n{\n   if(max_iter >= policies::get_max_root_iterations<Policy>())\n      raise_evaluation_error<T>(\n         function,\n         \"Root finding evaluation exceeded %1% iterations, giving up now.\", static_cast<T>(static_cast<double>(max_iter)), pol);\n}\n\n} //namespace policies\n\n#ifdef BOOST_MSVC\n#  pragma warning(pop)\n#endif\n\n}} // namespaces boost/math\n\n#endif // BOOST_MATH_POLICY_ERROR_HANDLING_HPP\n\n","//  (C) Copyright John Maddock 2006.\n//  (C) Copyright Johan Rade 2006.\n//  (C) Copyright Paul A. Bristow 2011 (added changesign).\n\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_MATH_TOOLS_SIGN_HPP\n#define BOOST_MATH_TOOLS_SIGN_HPP\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include <boost/math/tools/config.hpp>\n#include <boost/math/special_functions/math_fwd.hpp>\n#include <boost/math/special_functions/detail/fp_traits.hpp>\n\nnamespace boost{ namespace math{ \n\nnamespace detail {\n\n  // signbit\n\n#ifdef BOOST_MATH_USE_STD_FPCLASSIFY\n    template<class T> \n    inline int signbit_impl(T x, native_tag const&)\n    {\n        return (std::signbit)(x);\n    }\n#endif\n\n    template<class T> \n    inline int signbit_impl(T x, generic_tag<true> const&)\n    {\n        return x < 0;\n    }\n\n    template<class T> \n    inline int signbit_impl(T x, generic_tag<false> const&)\n    {\n        return x < 0;\n    }\n\n    template<class T> \n    inline int signbit_impl(T x, ieee_copy_all_bits_tag const&)\n    {\n        typedef BOOST_DEDUCED_TYPENAME fp_traits<T>::type traits;\n\n        BOOST_DEDUCED_TYPENAME traits::bits a;\n        traits::get_bits(x,a);\n        return a & traits::sign ? 1 : 0;\n    }\n\n    template<class T> \n    inline int signbit_impl(T x, ieee_copy_leading_bits_tag const&)\n    {\n        typedef BOOST_DEDUCED_TYPENAME fp_traits<T>::type traits;\n\n        BOOST_DEDUCED_TYPENAME traits::bits a;\n        traits::get_bits(x,a);\n\n        return a & traits::sign ? 1 : 0;\n    }\n\n    // Changesign\n\n    template<class T>\n    inline T (changesign_impl)(T x, generic_tag<true> const&)\n    {\n        return -x;\n    }\n\n    template<class T>\n    inline T (changesign_impl)(T x, generic_tag<false> const&)\n    {\n        return -x;\n    }\n\n\n    template<class T>\n    inline T changesign_impl(T x, ieee_copy_all_bits_tag const&)\n    {\n        typedef BOOST_DEDUCED_TYPENAME fp_traits<T>::sign_change_type traits;\n\n        BOOST_DEDUCED_TYPENAME traits::bits a;\n        traits::get_bits(x,a);\n        a ^= traits::sign;\n        traits::set_bits(x,a);\n        return x;\n    }\n\n    template<class T>\n    inline T (changesign_impl)(T x, ieee_copy_leading_bits_tag const&)\n    {\n        typedef BOOST_DEDUCED_TYPENAME fp_traits<T>::sign_change_type traits;\n\n        BOOST_DEDUCED_TYPENAME traits::bits a;\n        traits::get_bits(x,a);\n        a ^= traits::sign;\n        traits::set_bits(x,a);\n        return x;\n    }\n\n\n}   // namespace detail\n\ntemplate<class T> int (signbit)(T x)\n{ \n   typedef typename detail::fp_traits<T>::type traits;\n   typedef typename traits::method method;\n   // typedef typename boost::is_floating_point<T>::type fp_tag;\n   typedef typename tools::promote_args_permissive<T>::type result_type;\n   return detail::signbit_impl(static_cast<result_type>(x), method());\n}\n\ntemplate <class T>\ninline int sign BOOST_NO_MACRO_EXPAND(const T& z)\n{\n   return (z == 0) ? 0 : (boost::math::signbit)(z) ? -1 : 1;\n}\n\ntemplate <class T> typename tools::promote_args_permissive<T>::type (changesign)(const T& x)\n{ //!< \\brief return unchanged binary pattern of x, except for change of sign bit. \n   typedef typename detail::fp_traits<T>::sign_change_type traits;\n   typedef typename traits::method method;\n   // typedef typename boost::is_floating_point<T>::type fp_tag;\n   typedef typename tools::promote_args_permissive<T>::type result_type;\n\n   return detail::changesign_impl(static_cast<result_type>(x), method());\n}\n\ntemplate <class T, class U>\ninline typename tools::promote_args_permissive<T, U>::type \n   copysign BOOST_NO_MACRO_EXPAND(const T& x, const U& y)\n{\n   BOOST_MATH_STD_USING\n   typedef typename tools::promote_args_permissive<T, U>::type result_type;\n   return (boost::math::signbit)(static_cast<result_type>(x)) != (boost::math::signbit)(static_cast<result_type>(y)) \n      ? (boost::math::changesign)(static_cast<result_type>(x)) : static_cast<result_type>(x);\n}\n\n} // namespace math\n} // namespace boost\n\n\n#endif // BOOST_MATH_TOOLS_SIGN_HPP\n\n\n","//  Copyright John Maddock 2005-2006.\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_MATH_TOOLS_PRECISION_INCLUDED\n#define BOOST_MATH_TOOLS_PRECISION_INCLUDED\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include <boost/limits.hpp>\n#include <boost/assert.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/mpl/int.hpp>\n#include <boost/mpl/bool.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/math/policies/policy.hpp>\n\n// These two are for LDBL_MAN_DIG:\n#include <limits.h>\n#include <math.h>\n\nnamespace boost{ namespace math\n{\nnamespace tools\n{\n// If T is not specialized, the functions digits, max_value and min_value,\n// all get synthesised automatically from std::numeric_limits.\n// However, if numeric_limits is not specialised for type RealType,\n// for example with NTL::RR type, then you will get a compiler error\n// when code tries to use these functions, unless you explicitly specialise them.\n\n// For example if the precision of RealType varies at runtime,\n// then numeric_limits support may not be appropriate,\n// see boost/math/tools/ntl.hpp  for examples like\n// template <> NTL::RR max_value<NTL::RR> ...\n// See  Conceptual Requirements for Real Number Types.\n\ntemplate <class T>\ninline int digits(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::radix == 2 || ::std::numeric_limits<T>::radix == 10);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n   BOOST_ASSERT(::std::numeric_limits<T>::radix == 2 || ::std::numeric_limits<T>::radix == 10);\n#endif\n   return std::numeric_limits<T>::radix == 2 \n      ? std::numeric_limits<T>::digits\n      : ((std::numeric_limits<T>::digits + 1) * 1000L) / 301L;\n}\n\ntemplate <class T>\ninline T max_value(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n#endif\n   return (std::numeric_limits<T>::max)();\n} // Also used as a finite 'infinite' value for - and +infinity, for example:\n// -max_value<double> = -1.79769e+308, max_value<double> = 1.79769e+308.\n\ntemplate <class T>\ninline T min_value(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n#endif\n   return (std::numeric_limits<T>::min)();\n}\n\nnamespace detail{\n//\n// Logarithmic limits come next, note that although\n// we can compute these from the log of the max value\n// that is not in general thread safe (if we cache the value)\n// so it's better to specialise these:\n//\n// For type float first:\n//\ntemplate <class T>\ninline T log_max_value(const mpl::int_<128>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return 88.0f;\n}\n\ntemplate <class T>\ninline T log_min_value(const mpl::int_<128>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return -87.0f;\n}\n//\n// Now double:\n//\ntemplate <class T>\ninline T log_max_value(const mpl::int_<1024>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return 709.0;\n}\n\ntemplate <class T>\ninline T log_min_value(const mpl::int_<1024>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return -708.0;\n}\n//\n// 80 and 128-bit long doubles:\n//\ntemplate <class T>\ninline T log_max_value(const mpl::int_<16384>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return 11356.0L;\n}\n\ntemplate <class T>\ninline T log_min_value(const mpl::int_<16384>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return -11355.0L;\n}\n\ntemplate <class T>\ninline T log_max_value(const mpl::int_<0>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n#endif\n   BOOST_MATH_STD_USING\n   static const T val = log((std::numeric_limits<T>::max)());\n   return val;\n}\n\ntemplate <class T>\ninline T log_min_value(const mpl::int_<0>& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n#endif\n   BOOST_MATH_STD_USING\n   static const T val = log((std::numeric_limits<T>::min)());\n   return val;\n}\n\ntemplate <class T>\ninline T epsilon(const mpl::true_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   return std::numeric_limits<T>::epsilon();\n}\n\n#if (defined(macintosh) || defined(__APPLE__) || defined(__APPLE_CC__)) && ((LDBL_MANT_DIG == 106) || (__LDBL_MANT_DIG__ == 106))\ntemplate <>\ninline long double epsilon<long double>(const mpl::true_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(long double))\n{\n   // numeric_limits on Darwin tells lies here.\n   // This static assert fails for some unknown reason, so\n   // disabled for now...\n   // BOOST_STATIC_ASSERT(std::numeric_limits<long double>::digits == 106);\n   return 2.4651903288156618919116517665087e-32L;\n}\n#endif\n\ntemplate <class T>\ninline T epsilon(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   BOOST_MATH_STD_USING  // for ADL of std names\n   static const T eps = ldexp(static_cast<T>(1), 1-policies::digits<T, policies::policy<> >());\n   return eps;\n}\n\n} // namespace detail\n\n#ifdef BOOST_MSVC\n#pragma warning(push)\n#pragma warning(disable:4309)\n#endif\n\ntemplate <class T>\ninline T log_max_value(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   typedef typename mpl::if_c<\n      (std::numeric_limits<T>::radix == 2) &&\n      (std::numeric_limits<T>::max_exponent == 128\n      || std::numeric_limits<T>::max_exponent == 1024\n      || std::numeric_limits<T>::max_exponent == 16384),\n      mpl::int_<(std::numeric_limits<T>::max_exponent > INT_MAX ? INT_MAX : static_cast<int>(std::numeric_limits<T>::max_exponent))>,\n      mpl::int_<0>\n   >::type tag_type;\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n   return detail::log_max_value<T>(tag_type());\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n   BOOST_MATH_STD_USING\n   static const T val = log((std::numeric_limits<T>::max)());\n   return val;\n#endif\n}\n\ntemplate <class T>\ninline T log_min_value(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   typedef typename mpl::if_c<\n      (std::numeric_limits<T>::radix == 2) &&\n      (std::numeric_limits<T>::max_exponent == 128\n      || std::numeric_limits<T>::max_exponent == 1024\n      || std::numeric_limits<T>::max_exponent == 16384),\n      mpl::int_<(std::numeric_limits<T>::max_exponent > INT_MAX ? INT_MAX : static_cast<int>(std::numeric_limits<T>::max_exponent))>,\n      mpl::int_<0>\n   >::type tag_type;\n\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n   return detail::log_min_value<T>(tag_type());\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n   BOOST_MATH_STD_USING\n   static const T val = log((std::numeric_limits<T>::min)());\n   return val;\n#endif\n}\n\n#ifdef BOOST_MSVC\n#pragma warning(pop)\n#endif\n\ntemplate <class T>\ninline T epsilon(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T))\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   return detail::epsilon<T>(mpl::bool_< ::std::numeric_limits<T>::is_specialized>());\n#else\n   return ::std::numeric_limits<T>::is_specialized ?\n      detail::epsilon<T>(mpl::true_()) :\n      detail::epsilon<T>(mpl::false_());\n#endif\n}\n\nnamespace detail{\n\ntemplate <class T>\ninline T root_epsilon_imp(const mpl::int_<24>&)\n{\n   return static_cast<T>(0.00034526698300124390839884978618400831996329879769945L);\n}\n\ntemplate <class T>\ninline T root_epsilon_imp(const T*, const mpl::int_<53>&)\n{\n   return static_cast<T>(0.1490116119384765625e-7L);\n}\n\ntemplate <class T>\ninline T root_epsilon_imp(const T*, const mpl::int_<64>&)\n{\n   return static_cast<T>(0.32927225399135962333569506281281311031656150598474e-9L);\n}\n\ntemplate <class T>\ninline T root_epsilon_imp(const T*, const mpl::int_<113>&)\n{\n   return static_cast<T>(0.1387778780781445675529539585113525390625e-16L);\n}\n\ntemplate <class T, class Tag>\ninline T root_epsilon_imp(const T*, const Tag&)\n{\n   BOOST_MATH_STD_USING\n   static const T r_eps = sqrt(tools::epsilon<T>());\n   return r_eps;\n}\n\ntemplate <class T>\ninline T forth_root_epsilon_imp(const T*, const mpl::int_<24>&)\n{\n   return static_cast<T>(0.018581361171917516667460937040007436176452688944747L);\n}\n\ntemplate <class T>\ninline T forth_root_epsilon_imp(const T*, const mpl::int_<53>&)\n{\n   return static_cast<T>(0.0001220703125L);\n}\n\ntemplate <class T>\ninline T forth_root_epsilon_imp(const T*, const mpl::int_<64>&)\n{\n   return static_cast<T>(0.18145860519450699870567321328132261891067079047605e-4L);\n}\n\ntemplate <class T>\ninline T forth_root_epsilon_imp(const T*, const mpl::int_<113>&)\n{\n   return static_cast<T>(0.37252902984619140625e-8L);\n}\n\ntemplate <class T, class Tag>\ninline T forth_root_epsilon_imp(const T*, const Tag&)\n{\n   BOOST_MATH_STD_USING\n   static const T r_eps = sqrt(sqrt(tools::epsilon<T>()));\n   return r_eps;\n}\n\n}\n\ntemplate <class T>\ninline T root_epsilon()\n{\n   typedef mpl::int_< (::std::numeric_limits<T>::radix == 2) ? std::numeric_limits<T>::digits : 0> tag_type;\n   return detail::root_epsilon_imp(static_cast<T const*>(0), tag_type());\n}\n\ntemplate <class T>\ninline T forth_root_epsilon()\n{\n   typedef mpl::int_< (::std::numeric_limits<T>::radix == 2) ? std::numeric_limits<T>::digits : 0> tag_type;\n   return detail::forth_root_epsilon_imp(static_cast<T const*>(0), tag_type());\n}\n\n} // namespace tools\n} // namespace math\n} // namespace boost\n\n#endif // BOOST_MATH_TOOLS_PRECISION_INCLUDED\n\n","// -*- C++ -*-\n//===---------------------------- cmath -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CMATH\n#define _LIBCPP_CMATH\n\n/*\n    cmath synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nnamespace std\n{\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <math.h>\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __x) _NOEXCEPT\n{\n    return signbit(__x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __x) _NOEXCEPT\n{\n    return fpclassify(__x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __x) _NOEXCEPT\n{\n    return isfinite(__x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __x) _NOEXCEPT\n{\n    return isinf(__x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __x) _NOEXCEPT\n{\n    return isnan(__x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __x) _NOEXCEPT\n{\n    return isnormal(__x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return isgreater(__x, __y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__x, (type)__y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return isgreaterequal(__x, __y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__x, (type)__y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return isless(__x, __y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__x, (type)__y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return islessequal(__x, __y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__x, (type)__y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return islessgreater(__x, __y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__x, (type)__y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    return isunordered(__x, __y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__x, (type)__y);\n}\n\n#endif  // isunordered\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::signbit;\nusing ::fpclassify;\nusing ::isfinite;\nusing ::isinf;\nusing ::isnan;\nusing ::isnormal;\nusing ::isgreater;\nusing ::isgreaterequal;\nusing ::isless;\nusing ::islessequal;\nusing ::islessgreater;\nusing ::isunordered;\nusing ::isunordered;\n\nusing ::float_t;\nusing ::double_t;\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __x) _NOEXCEPT {return fabsf(__x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __x) _NOEXCEPT {return fabs(__x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __x) _NOEXCEPT {return fabsl(__x);}\n#endif // !defined(_AIX)\n\n#ifndef __sun__\n\n// acos\n\nusing ::acos;\nusing ::acosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __x) _NOEXCEPT       {return acosf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __x) _NOEXCEPT {return acosl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacos(_A1 __x) _NOEXCEPT {return acos((double)__x);}\n\n// asin\n\nusing ::asin;\nusing ::asinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __x) _NOEXCEPT       {return asinf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __x) _NOEXCEPT {return asinl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasin(_A1 __x) _NOEXCEPT {return asin((double)__x);}\n\n// atan\n\nusing ::atan;\nusing ::atanf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __x) _NOEXCEPT       {return atanf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __x) _NOEXCEPT {return atanl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natan(_A1 __x) _NOEXCEPT {return atan((double)__x);}\n\n// atan2\n\nusing ::atan2;\nusing ::atan2f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __y, float __x) _NOEXCEPT             {return atan2f(__y, __x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __y, long double __x) _NOEXCEPT {return atan2l(__y, __x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\natan2(_A1 __y, _A2 __x) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__y, (__result_type)__x);\n}\n\n// ceil\n\nusing ::ceil;\nusing ::ceilf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __x) _NOEXCEPT       {return ceilf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __x) _NOEXCEPT {return ceill(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nceil(_A1 __x) _NOEXCEPT {return ceil((double)__x);}\n\n// cos\n\nusing ::cos;\nusing ::cosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __x) _NOEXCEPT       {return cosf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __x) _NOEXCEPT {return cosl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncos(_A1 __x) _NOEXCEPT {return cos((double)__x);}\n\n// cosh\n\nusing ::cosh;\nusing ::coshf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __x) _NOEXCEPT       {return coshf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __x) _NOEXCEPT {return coshl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncosh(_A1 __x) _NOEXCEPT {return cosh((double)__x);}\n\n#endif // __sun__\n// exp\n\nusing ::exp;\nusing ::expf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __x) _NOEXCEPT       {return expf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __x) _NOEXCEPT {return expl(__x);}\n#endif\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp(_A1 __x) _NOEXCEPT {return exp((double)__x);}\n\n// fabs\n\nusing ::fabs;\nusing ::fabsf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __x) _NOEXCEPT       {return fabsf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __x) _NOEXCEPT {return fabsl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfabs(_A1 __x) _NOEXCEPT {return fabs((double)__x);}\n\n// floor\n\nusing ::floor;\nusing ::floorf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __x) _NOEXCEPT       {return floorf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __x) _NOEXCEPT {return floorl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfloor(_A1 __x) _NOEXCEPT {return floor((double)__x);}\n\n// fmod\n\n#endif //__sun__\nusing ::fmod;\nusing ::fmodf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __x, float __y) _NOEXCEPT             {return fmodf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __x, long double __y) _NOEXCEPT {return fmodl(__x, __y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmod(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__x, (__result_type)__y);\n}\n\n\n// frexp\n\nusing ::frexp;\nusing ::frexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __x, int* __e) _NOEXCEPT       {return frexpf(__x, __e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __x, int* __e) _NOEXCEPT {return frexpl(__x, __e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfrexp(_A1 __x, int* __e) _NOEXCEPT {return frexp((double)__x, __e);}\n\n// ldexp\n\nusing ::ldexp;\nusing ::ldexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __x, int __e) _NOEXCEPT       {return ldexpf(__x, __e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __x, int __e) _NOEXCEPT {return ldexpl(__x, __e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nldexp(_A1 __x, int __e) _NOEXCEPT {return ldexp((double)__x, __e);}\n\n// log\n\n#endif // __sun__\nusing ::log;\nusing ::logf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __x) _NOEXCEPT       {return logf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __x) _NOEXCEPT {return logl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog(_A1 __x) _NOEXCEPT {return log((double)__x);}\n\n\n// log10\n\nusing ::log10;\nusing ::log10f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __x) _NOEXCEPT       {return log10f(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __x) _NOEXCEPT {return log10l(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog10(_A1 __x) _NOEXCEPT {return log10((double)__x);}\n\n// modf\n\nusing ::modf;\nusing ::modff;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __x, float* __y) _NOEXCEPT             {return modff(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __x, long double* __y) _NOEXCEPT {return modfl(__x, __y);}\n#endif\n\n// pow\n\n#endif // __sun__ \nusing ::pow;\nusing ::powf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __x, float __y) _NOEXCEPT             {return powf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __x, long double __y) _NOEXCEPT {return powl(__x, __y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\npow(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__x, (__result_type)__y);\n}\n\n\n// sin\n\nusing ::sin;\nusing ::sinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __x) _NOEXCEPT       {return sinf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __x) _NOEXCEPT {return sinl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsin(_A1 __x) _NOEXCEPT {return sin((double)__x);}\n\n// sinh\n\nusing ::sinh;\nusing ::sinhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __x) _NOEXCEPT       {return sinhf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __x) _NOEXCEPT {return sinhl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsinh(_A1 __x) _NOEXCEPT {return sinh((double)__x);}\n\n// sqrt\n\n#endif // __sun__\nusing ::sqrt;\nusing ::sqrtf;\n\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(__sun__) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __x) _NOEXCEPT       {return sqrtf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __x) _NOEXCEPT {return sqrtl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsqrt(_A1 __x) _NOEXCEPT {return sqrt((double)__x);}\n\n// tan\n\nusing ::tan;\nusing ::tanf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __x) _NOEXCEPT       {return tanf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __x) _NOEXCEPT {return tanl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntan(_A1 __x) _NOEXCEPT {return tan((double)__x);}\n\n// tanh\n\nusing ::tanh;\nusing ::tanhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __x) _NOEXCEPT       {return tanhf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __x) _NOEXCEPT {return tanhl(__x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntanh(_A1 __x) _NOEXCEPT {return tanh((double)__x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::acosh;\nusing ::acoshf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __x) _NOEXCEPT       {return acoshf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __x) _NOEXCEPT {return acoshl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacosh(_A1 __x) _NOEXCEPT {return acosh((double)__x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::asinh;\nusing ::asinhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __x) _NOEXCEPT       {return asinhf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __x) _NOEXCEPT {return asinhl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasinh(_A1 __x) _NOEXCEPT {return asinh((double)__x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::atanh;\nusing ::atanhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __x) _NOEXCEPT       {return atanhf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __x) _NOEXCEPT {return atanhl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natanh(_A1 __x) _NOEXCEPT {return atanh((double)__x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\nusing ::cbrt;\nusing ::cbrtf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __x) _NOEXCEPT       {return cbrtf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __x) _NOEXCEPT {return cbrtl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncbrt(_A1 __x) _NOEXCEPT {return cbrt((double)__x);}\n#endif\n\n// copysign\n\nusing ::copysign;\nusing ::copysignf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       copysign(float __x, float __y) _NOEXCEPT             {return copysignf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double copysign(long double __x, long double __y) _NOEXCEPT {return copysignl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\ncopysign(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__x, (__result_type)__y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\nusing ::erf;\nusing ::erff;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __x) _NOEXCEPT       {return erff(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __x) _NOEXCEPT {return erfl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerf(_A1 __x) _NOEXCEPT {return erf((double)__x);}\n\n// erfc\n\nusing ::erfc;\nusing ::erfcf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __x) _NOEXCEPT       {return erfcf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __x) _NOEXCEPT {return erfcl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerfc(_A1 __x) _NOEXCEPT {return erfc((double)__x);}\n\n// exp2\n\nusing ::exp2;\nusing ::exp2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __x) _NOEXCEPT       {return exp2f(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __x) _NOEXCEPT {return exp2l(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp2(_A1 __x) _NOEXCEPT {return exp2((double)__x);}\n\n// expm1\n\nusing ::expm1;\nusing ::expm1f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __x) _NOEXCEPT       {return expm1f(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __x) _NOEXCEPT {return expm1l(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexpm1(_A1 __x) _NOEXCEPT {return expm1((double)__x);}\n\n// fdim\n\nusing ::fdim;\nusing ::fdimf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __x, float __y) _NOEXCEPT             {return fdimf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __x, long double __y) _NOEXCEPT {return fdiml(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfdim(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__x, (__result_type)__y);\n}\n\n// fma\n\ninline _LIBCPP_INLINE_VISIBILITY float fmaf(float __x, float __y, float __z) _NOEXCEPT {return (float)((double)__x*__y + __z);}\n#ifndef FP_FAST_FMAF\n#define FP_FAST_FMAF\n#endif\n\nusing ::fma;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __x, float __y, float __z) _NOEXCEPT                   {return fmaf(__x, __y, __z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __x, long double __y, long double __z) _NOEXCEPT {return fmal(__x, __y, __z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value &&\n    is_arithmetic<_A3>::value,\n    typename __promote<_A1, _A2, _A3>::type\n>::type\nfma(_A1 __x, _A2 __y, _A3 __z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value &&\n                      is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__x, (__result_type)__y, (__result_type)__z);\n}\n\n// fmax\n\nusing ::fmax;\nusing ::fmaxf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __x, float __y) _NOEXCEPT             {return fmaxf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __x, long double __y) _NOEXCEPT {return fmaxl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmax(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__x, (__result_type)__y);\n}\n\n// fmin\n\nusing ::fmin;\nusing ::fminf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __x, float __y) _NOEXCEPT             {return fminf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __x, long double __y) _NOEXCEPT {return fminl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmin(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__x, (__result_type)__y);\n}\n\n// hypot\n\nusing ::hypot;\nusing ::hypotf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __x, float __y) _NOEXCEPT             {return hypotf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __x, long double __y) _NOEXCEPT {return hypotl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nhypot(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__x, (__result_type)__y);\n}\n\n// ilogb\n\nusing ::ilogb;\nusing ::ilogbf;\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __x) _NOEXCEPT       {return ilogbf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __x) _NOEXCEPT {return ilogbl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, int>::type\nilogb(_A1 __x) _NOEXCEPT {return ilogb((double)__x);}\n\n// lgamma\n\nusing ::lgamma;\nusing ::lgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __x) _NOEXCEPT       {return lgammaf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __x) _NOEXCEPT {return lgammal(__x);}\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlgamma(_A1 __x) _NOEXCEPT {return lgamma((double)__x);}\n\n\n// llrint\n\nusing ::llrint;\nusing ::llrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __x) _NOEXCEPT       {return llrintf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __x) _NOEXCEPT {return llrintl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllrint(_A1 __x) _NOEXCEPT {return llrint((double)__x);}\n\n// llround\n\nusing ::llround;\nusing ::llroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __x) _NOEXCEPT       {return llroundf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __x) _NOEXCEPT {return llroundl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllround(_A1 __x) _NOEXCEPT {return llround((double)__x);}\n\n// log1p\n\nusing ::log1p;\nusing ::log1pf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __x) _NOEXCEPT       {return log1pf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __x) _NOEXCEPT {return log1pl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog1p(_A1 __x) _NOEXCEPT {return log1p((double)__x);}\n\n// log2\n\nusing ::log2;\nusing ::log2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __x) _NOEXCEPT       {return log2f(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __x) _NOEXCEPT {return log2l(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog2(_A1 __x) _NOEXCEPT {return log2((double)__x);}\n\n// logb\n\nusing ::logb;\nusing ::logbf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __x) _NOEXCEPT       {return logbf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __x) _NOEXCEPT {return logbl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlogb(_A1 __x) _NOEXCEPT {return logb((double)__x);}\n\n// lrint\n\nusing ::lrint;\nusing ::lrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __x) _NOEXCEPT       {return lrintf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __x) _NOEXCEPT {return lrintl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlrint(_A1 __x) _NOEXCEPT {return lrint((double)__x);}\n\n// lround\n\nusing ::lround;\nusing ::lroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __x) _NOEXCEPT       {return lroundf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __x) _NOEXCEPT {return lroundl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlround(_A1 __x) _NOEXCEPT {return lround((double)__x);}\n\n#endif // _LIBCPP_MSVCRT\n#endif // __sun__\n\n// nan\n\n#ifndef _LIBCPP_MSVCRT\nusing ::nan;\nusing ::nanf;\n#endif // _LIBCPP_MSVCRT\n\n#ifndef __sun__\n#ifndef _LIBCPP_MSVCRT\n\n// nearbyint\n\nusing ::nearbyint;\nusing ::nearbyintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __x) _NOEXCEPT       {return nearbyintf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __x) _NOEXCEPT {return nearbyintl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnearbyint(_A1 __x) _NOEXCEPT {return nearbyint((double)__x);}\n\n// nextafter\n\nusing ::nextafter;\nusing ::nextafterf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __x, float __y) _NOEXCEPT             {return nextafterf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __x, long double __y) _NOEXCEPT {return nextafterl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nnextafter(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__x, (__result_type)__y);\n}\n\n// nexttoward\n\nusing ::nexttoward;\nusing ::nexttowardf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __x, long double __y) _NOEXCEPT       {return nexttowardf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __x, long double __y) _NOEXCEPT {return nexttowardl(__x, __y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnexttoward(_A1 __x, long double __y) _NOEXCEPT {return nexttoward((double)__x, __y);}\n\n// remainder\n\nusing ::remainder;\nusing ::remainderf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __x, float __y) _NOEXCEPT             {return remainderf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __x, long double __y) _NOEXCEPT {return remainderl(__x, __y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremainder(_A1 __x, _A2 __y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__x, (__result_type)__y);\n}\n\n// remquo\n\nusing ::remquo;\nusing ::remquof;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __x, float __y, int* __z) _NOEXCEPT             {return remquof(__x, __y, __z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __x, long double __y, int* __z) _NOEXCEPT {return remquol(__x, __y, __z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremquo(_A1 __x, _A2 __y, int* __z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__x, (__result_type)__y, __z);\n}\n\n// rint\n\nusing ::rint;\nusing ::rintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __x) _NOEXCEPT       {return rintf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __x) _NOEXCEPT {return rintl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nrint(_A1 __x) _NOEXCEPT {return rint((double)__x);}\n\n// round\n\nusing ::round;\nusing ::roundf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __x) _NOEXCEPT       {return roundf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __x) _NOEXCEPT {return roundl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nround(_A1 __x) _NOEXCEPT {return round((double)__x);}\n\n// scalbln\n\nusing ::scalbln;\nusing ::scalblnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __x, long __y) _NOEXCEPT       {return scalblnf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __x, long __y) _NOEXCEPT {return scalblnl(__x, __y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbln(_A1 __x, long __y) _NOEXCEPT {return scalbln((double)__x, __y);}\n\n// scalbn\n\nusing ::scalbn;\nusing ::scalbnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __x, int __y) _NOEXCEPT       {return scalbnf(__x, __y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __x, int __y) _NOEXCEPT {return scalbnl(__x, __y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbn(_A1 __x, int __y) _NOEXCEPT {return scalbn((double)__x, __y);}\n\n// tgamma\n\nusing ::tgamma;\nusing ::tgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __x) _NOEXCEPT       {return tgammaf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __x) _NOEXCEPT {return tgammal(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntgamma(_A1 __x) _NOEXCEPT {return tgamma((double)__x);}\n\n// trunc\n\nusing ::trunc;\nusing ::truncf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __x) _NOEXCEPT       {return truncf(__x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __x) _NOEXCEPT {return truncl(__x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntrunc(_A1 __x) _NOEXCEPT {return trunc((double)__x);}\n\n#endif // !_LIBCPP_MSVCRT\n\nusing ::acosl;\nusing ::asinl;\nusing ::atanl;\nusing ::atan2l;\nusing ::ceill;\nusing ::cosl;\nusing ::coshl;\nusing ::expl;\nusing ::fabsl;\nusing ::floorl;\nusing ::fmodl;\nusing ::frexpl;\nusing ::ldexpl;\nusing ::logl;\nusing ::log10l;\nusing ::modfl;\nusing ::powl;\nusing ::sinl;\nusing ::sinhl;\nusing ::sqrtl;\nusing ::tanl;\n#ifndef _LIBCPP_MSVCRT\nusing ::tanhl;\nusing ::acoshl;\nusing ::asinhl;\nusing ::atanhl;\nusing ::cbrtl;\n#endif  // !_LIBCPP_MSVCRT\nusing ::copysignl;\n#ifndef _LIBCPP_MSVCRT\nusing ::erfl;\nusing ::erfcl;\nusing ::exp2l;\nusing ::expm1l;\nusing ::fdiml;\nusing ::fmal;\nusing ::fmaxl;\nusing ::fminl;\nusing ::hypotl;\nusing ::ilogbl;\nusing ::lgammal;\nusing ::llrintl;\nusing ::llroundl;\nusing ::log1pl;\nusing ::log2l;\nusing ::logbl;\nusing ::lrintl;\nusing ::lroundl;\nusing ::nanl;\nusing ::nearbyintl;\nusing ::nextafterl;\nusing ::nexttowardl;\nusing ::remainderl;\nusing ::remquol;\nusing ::rintl;\nusing ::roundl;\nusing ::scalblnl;\nusing ::scalbnl;\nusing ::tgammal;\nusing ::truncl;\n#endif // !_LIBCPP_MSVCRT\n\n#else \nusing ::lgamma;\nusing ::lgammaf;\n#endif // __sun__\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CMATH\n","#ifndef _MATH_H\n#define _MATH_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <features.h>\n\n#define __NEED_float_t\n#define __NEED_double_t\n#include <bits/alltypes.h>\n\n#if 100*__GNUC__+__GNUC_MINOR__ >= 303\n#define NAN       __builtin_nanf(\"\")\n#define INFINITY  __builtin_inff()\n#else\n#define NAN       (0.0f/0.0f)\n#define INFINITY  1e5000f\n#endif\n\n#define HUGE_VALF INFINITY\n#define HUGE_VAL  ((double)INFINITY)\n#define HUGE_VALL ((long double)INFINITY)\n\n#define MATH_ERRNO  1\n#define MATH_ERREXCEPT 2\n#define math_errhandling 2\n\n#define FP_ILOGBNAN (-1-(int)(((unsigned)-1)>>1))\n#define FP_ILOGB0 FP_ILOGBNAN\n\n#define FP_NAN       0\n#define FP_INFINITE  1\n#define FP_ZERO      2\n#define FP_SUBNORMAL 3\n#define FP_NORMAL    4\n\nint __fpclassify(double);\nint __fpclassifyf(float);\nint __fpclassifyl(long double);\n\nstatic __inline unsigned __FLOAT_BITS(float __f)\n{\n\tunion {float __f; unsigned __i;} __u;\n\t__u.__f = __f;\n\treturn __u.__i;\n}\nstatic __inline unsigned long long __DOUBLE_BITS(double __f)\n{\n\tunion {double __f; unsigned long long __i;} __u;\n\t__u.__f = __f;\n\treturn __u.__i;\n}\n\n#define fpclassify(x) ( \\\n\tsizeof(x) == sizeof(float) ? __fpclassifyf(x) : \\\n\tsizeof(x) == sizeof(double) ? __fpclassify(x) : \\\n\t__fpclassifyl(x) )\n\n#define isinf(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) == 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) == 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_INFINITE)\n\n#define isnan(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) > 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) > 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) == FP_NAN)\n\n#define isnormal(x) ( \\\n\tsizeof(x) == sizeof(float) ? ((__FLOAT_BITS(x)+0x00800000) & 0x7fffffff) >= 0x01000000 : \\\n\tsizeof(x) == sizeof(double) ? ((__DOUBLE_BITS(x)+(1ULL<<52)) & -1ULL>>1) >= 1ULL<<53 : \\\n\t__fpclassifyl(x) == FP_NORMAL)\n\n#define isfinite(x) ( \\\n\tsizeof(x) == sizeof(float) ? (__FLOAT_BITS(x) & 0x7fffffff) < 0x7f800000 : \\\n\tsizeof(x) == sizeof(double) ? (__DOUBLE_BITS(x) & -1ULL>>1) < 0x7ffULL<<52 : \\\n\t__fpclassifyl(x) > FP_INFINITE)\n\nint __signbit(double);\nint __signbitf(float);\nint __signbitl(long double);\n\n#define signbit(x) ( \\\n\tsizeof(x) == sizeof(float) ? (int)(__FLOAT_BITS(x)>>31) : \\\n\tsizeof(x) == sizeof(double) ? (int)(__DOUBLE_BITS(x)>>63) : \\\n\t__signbitl(x) )\n\n#define isunordered(x,y) (isnan((x)) ? ((void)(y),1) : isnan((y)))\n\n#define __ISREL_DEF(rel, op, type) \\\nstatic __inline int __is##rel(type __x, type __y) \\\n{ return !isunordered(__x,__y) && __x op __y; }\n\n__ISREL_DEF(lessf, <, float_t)\n__ISREL_DEF(less, <, double_t)\n__ISREL_DEF(lessl, <, long double)\n__ISREL_DEF(lessequalf, <=, float_t)\n__ISREL_DEF(lessequal, <=, double_t)\n__ISREL_DEF(lessequall, <=, long double)\n__ISREL_DEF(lessgreaterf, !=, float_t)\n__ISREL_DEF(lessgreater, !=, double_t)\n__ISREL_DEF(lessgreaterl, !=, long double)\n__ISREL_DEF(greaterf, >, float_t)\n__ISREL_DEF(greater, >, double_t)\n__ISREL_DEF(greaterl, >, long double)\n__ISREL_DEF(greaterequalf, >=, float_t)\n__ISREL_DEF(greaterequal, >=, double_t)\n__ISREL_DEF(greaterequall, >=, long double)\n\n#define __tg_pred_2(x, y, p) ( \\\n\tsizeof((x)+(y)) == sizeof(float) ? p##f(x, y) : \\\n\tsizeof((x)+(y)) == sizeof(double) ? p(x, y) : \\\n\tp##l(x, y) )\n\n#define isless(x, y)            __tg_pred_2(x, y, __isless)\n#define islessequal(x, y)       __tg_pred_2(x, y, __islessequal)\n#define islessgreater(x, y)     __tg_pred_2(x, y, __islessgreater)\n#define isgreater(x, y)         __tg_pred_2(x, y, __isgreater)\n#define isgreaterequal(x, y)    __tg_pred_2(x, y, __isgreaterequal)\n\ndouble      acos(double);\nfloat       acosf(float);\nlong double acosl(long double);\n\ndouble      acosh(double);\nfloat       acoshf(float);\nlong double acoshl(long double);\n\ndouble      asin(double);\nfloat       asinf(float);\nlong double asinl(long double);\n\ndouble      asinh(double);\nfloat       asinhf(float);\nlong double asinhl(long double);\n\ndouble      atan(double);\nfloat       atanf(float);\nlong double atanl(long double);\n\ndouble      atan2(double, double);\nfloat       atan2f(float, float);\nlong double atan2l(long double, long double);\n\ndouble      atanh(double);\nfloat       atanhf(float);\nlong double atanhl(long double);\n\ndouble      cbrt(double);\nfloat       cbrtf(float);\nlong double cbrtl(long double);\n\ndouble      ceil(double);\nfloat       ceilf(float);\nlong double ceill(long double);\n\ndouble      copysign(double, double);\nfloat       copysignf(float, float);\nlong double copysignl(long double, long double);\n\ndouble      cos(double);\nfloat       cosf(float);\nlong double cosl(long double);\n\ndouble      cosh(double);\nfloat       coshf(float);\nlong double coshl(long double);\n\ndouble      erf(double);\nfloat       erff(float);\nlong double erfl(long double);\n\ndouble      erfc(double);\nfloat       erfcf(float);\nlong double erfcl(long double);\n\ndouble      exp(double);\nfloat       expf(float);\nlong double expl(long double);\n\ndouble      exp2(double);\nfloat       exp2f(float);\nlong double exp2l(long double);\n\ndouble      expm1(double);\nfloat       expm1f(float);\nlong double expm1l(long double);\n\ndouble      fabs(double);\nfloat       fabsf(float);\nlong double fabsl(long double);\n\ndouble      fdim(double, double);\nfloat       fdimf(float, float);\nlong double fdiml(long double, long double);\n\ndouble      floor(double);\nfloat       floorf(float);\nlong double floorl(long double);\n\ndouble      fma(double, double, double);\nfloat       fmaf(float, float, float);\nlong double fmal(long double, long double, long double);\n\ndouble      fmax(double, double);\nfloat       fmaxf(float, float);\nlong double fmaxl(long double, long double);\n\ndouble      fmin(double, double);\nfloat       fminf(float, float);\nlong double fminl(long double, long double);\n\ndouble      fmod(double, double);\nfloat       fmodf(float, float);\nlong double fmodl(long double, long double);\n\ndouble      frexp(double, int *);\nfloat       frexpf(float, int *);\nlong double frexpl(long double, int *);\n\ndouble      hypot(double, double);\nfloat       hypotf(float, float);\nlong double hypotl(long double, long double);\n\nint         ilogb(double);\nint         ilogbf(float);\nint         ilogbl(long double);\n\ndouble      ldexp(double, int);\nfloat       ldexpf(float, int);\nlong double ldexpl(long double, int);\n\ndouble      lgamma(double);\nfloat       lgammaf(float);\nlong double lgammal(long double);\n\nlong long   llrint(double);\nlong long   llrintf(float);\nlong long   llrintl(long double);\n\nlong long   llround(double);\nlong long   llroundf(float);\nlong long   llroundl(long double);\n\ndouble      log(double);\nfloat       logf(float);\nlong double logl(long double);\n\ndouble      log10(double);\nfloat       log10f(float);\nlong double log10l(long double);\n\ndouble      log1p(double);\nfloat       log1pf(float);\nlong double log1pl(long double);\n\ndouble      log2(double);\nfloat       log2f(float);\nlong double log2l(long double);\n\ndouble      logb(double);\nfloat       logbf(float);\nlong double logbl(long double);\n\nlong        lrint(double);\nlong        lrintf(float);\nlong        lrintl(long double);\n\nlong        lround(double);\nlong        lroundf(float);\nlong        lroundl(long double);\n\ndouble      modf(double, double *);\nfloat       modff(float, float *);\nlong double modfl(long double, long double *);\n\ndouble      nan(const char *);\nfloat       nanf(const char *);\nlong double nanl(const char *);\n\ndouble      nearbyint(double);\nfloat       nearbyintf(float);\nlong double nearbyintl(long double);\n\ndouble      nextafter(double, double);\nfloat       nextafterf(float, float);\nlong double nextafterl(long double, long double);\n\ndouble      nexttoward(double, long double);\nfloat       nexttowardf(float, long double);\nlong double nexttowardl(long double, long double);\n\ndouble      pow(double, double);\nfloat       powf(float, float);\nlong double powl(long double, long double);\n\ndouble      remainder(double, double);\nfloat       remainderf(float, float);\nlong double remainderl(long double, long double);\n\ndouble      remquo(double, double, int *);\nfloat       remquof(float, float, int *);\nlong double remquol(long double, long double, int *);\n\ndouble      rint(double);\nfloat       rintf(float);\nlong double rintl(long double);\n\ndouble      round(double);\nfloat       roundf(float);\nlong double roundl(long double);\n\ndouble      scalbln(double, long);\nfloat       scalblnf(float, long);\nlong double scalblnl(long double, long);\n\ndouble      scalbn(double, int);\nfloat       scalbnf(float, int);\nlong double scalbnl(long double, int);\n\ndouble      sin(double);\nfloat       sinf(float);\nlong double sinl(long double);\n\ndouble      sinh(double);\nfloat       sinhf(float);\nlong double sinhl(long double);\n\ndouble      sqrt(double);\nfloat       sqrtf(float);\nlong double sqrtl(long double);\n\ndouble      tan(double);\nfloat       tanf(float);\nlong double tanl(long double);\n\ndouble      tanh(double);\nfloat       tanhf(float);\nlong double tanhl(long double);\n\ndouble      tgamma(double);\nfloat       tgammaf(float);\nlong double tgammal(long double);\n\ndouble      trunc(double);\nfloat       truncf(float);\nlong double truncl(long double);\n\n\n#if defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE)\n#undef  MAXFLOAT\n#define MAXFLOAT        3.40282346638528859812e+38F\n#endif\n\n#if defined(_XOPEN_SOURCE) || defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define M_E             2.7182818284590452354   /* e */\n#define M_LOG2E         1.4426950408889634074   /* log_2 e */\n#define M_LOG10E        0.43429448190325182765  /* log_10 e */\n#define M_LN2           0.69314718055994530942  /* log_e 2 */\n#define M_LN10          2.30258509299404568402  /* log_e 10 */\n#define M_PI            3.14159265358979323846  /* pi */\n#define M_PI_2          1.57079632679489661923  /* pi/2 */\n#define M_PI_4          0.78539816339744830962  /* pi/4 */\n#define M_1_PI          0.31830988618379067154  /* 1/pi */\n#define M_2_PI          0.63661977236758134308  /* 2/pi */\n#define M_2_SQRTPI      1.12837916709551257390  /* 2/sqrt(pi) */\n#define M_SQRT2         1.41421356237309504880  /* sqrt(2) */\n#define M_SQRT1_2       0.70710678118654752440  /* 1/sqrt(2) */\n\nextern int signgam;\n\ndouble      j0(double);\ndouble      j1(double);\ndouble      jn(int, double);\n\ndouble      y0(double);\ndouble      y1(double);\ndouble      yn(int, double);\n#endif\n\n#if defined(_GNU_SOURCE) || defined(_BSD_SOURCE)\n#define HUGE            3.40282346638528859812e+38F\n\ndouble      drem(double, double);\nfloat       dremf(float, float);\n\nint         finite(double);\nint         finitef(float);\n\ndouble      scalb(double, double);\nfloat       scalbf(float, float);\n\ndouble      significand(double);\nfloat       significandf(float);\n\ndouble      lgamma_r(double, int*);\nfloat       lgammaf_r(float, int*);\n\nfloat       j0f(float);\nfloat       j1f(float);\nfloat       jnf(int, float);\n\nfloat       y0f(float);\nfloat       y1f(float);\nfloat       ynf(int, float);\n#endif\n\n#ifdef _GNU_SOURCE\nlong double lgammal_r(long double, int*);\n\nvoid        sincos(double, double*, double*);\nvoid        sincosf(float, float*, float*);\nvoid        sincosl(long double, long double*, long double*);\n\ndouble      exp10(double);\nfloat       exp10f(float);\nlong double exp10l(long double);\n\ndouble      pow10(double);\nfloat       pow10f(float);\nlong double pow10l(long double);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n","// ----------------------------------------------------------------------------\n// format_implementation.hpp  Implementation of the basic_format class\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_IMPLEMENTATION_HPP\n#define BOOST_FORMAT_IMPLEMENTATION_HPP\n\n#include <boost/config.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/assert.hpp>\n#include <boost/format/format_class.hpp>\n#include <algorithm> // std::swap\n\nnamespace boost {\n\n// ---  basic_format implementation -----------------------------------------//\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s)\n        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),\n          exceptions_(io::all_error_bits)\n    {\n        if( s)\n            parse( s );\n    }\n\n#if !defined(BOOST_NO_STD_LOCALE)\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch, Tr, Alloc>:: basic_format(const Ch* s, const std::locale & loc)\n        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),\n          exceptions_(io::all_error_bits), loc_(loc)\n    {\n        if(s) parse( s );\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s, const std::locale & loc)\n        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),\n          exceptions_(io::all_error_bits), loc_(loc)\n    {\n        parse(s);  \n    }\n#endif // ! BOOST_NO_STD_LOCALE\n    template< class Ch, class Tr, class Alloc>\n    io::detail::locale_t basic_format<Ch, Tr, Alloc>:: \n    getloc() const {\n        return loc_ ? loc_.get() : io::detail::locale_t(); \n    }\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch, Tr, Alloc>:: basic_format(const string_type& s)\n        : style_(0), cur_arg_(0), num_args_(0), dumped_(false),\n          exceptions_(io::all_error_bits)\n    {\n        parse(s);  \n    }\n\n    template< class Ch, class Tr, class Alloc> // just don't copy the buf_ member\n    basic_format<Ch, Tr, Alloc>:: basic_format(const basic_format& x)\n        : items_(x.items_), bound_(x.bound_), style_(x.style_),\n          cur_arg_(x.cur_arg_), num_args_(x.num_args_), dumped_(x.dumped_),\n          prefix_(x.prefix_), exceptions_(x.exceptions_), loc_(x.loc_)\n    {\n    }\n\n    template< class Ch, class Tr, class Alloc>  // just don't copy the buf_ member\n    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>:: \n    operator= (const basic_format& x) {\n        if(this == &x)\n            return *this;\n        (basic_format<Ch, Tr, Alloc>(x)).swap(*this);\n        return *this;\n    }\n    template< class Ch, class Tr, class Alloc>\n    void  basic_format<Ch, Tr, Alloc>:: \n    swap (basic_format & x) {\n        std::swap(exceptions_, x.exceptions_);\n        std::swap(style_, x.style_); \n        std::swap(cur_arg_, x.cur_arg_); \n        std::swap(num_args_, x.num_args_);\n        std::swap(dumped_, x.dumped_);\n\n        items_.swap(x.items_);\n        prefix_.swap(x.prefix_);\n        bound_.swap(x.bound_);\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions() const {\n        return exceptions_; \n    }\n\n    template< class Ch, class Tr, class Alloc>\n    unsigned char basic_format<Ch,Tr, Alloc>:: exceptions(unsigned char newexcept) { \n        unsigned char swp = exceptions_; \n        exceptions_ = newexcept; \n        return swp; \n    }\n\n    template<class Ch, class Tr, class Alloc>\n    void basic_format<Ch, Tr, Alloc>:: \n    make_or_reuse_data (std::size_t nbitems) {\n#if !defined(BOOST_NO_STD_LOCALE)\n        Ch fill = ( BOOST_USE_FACET(std::ctype<Ch>, getloc()) ). widen(' ');\n#else\n        Ch fill = ' ';\n#endif\n        if(items_.size() == 0)\n            items_.assign( nbitems, format_item_t(fill) );\n        else {\n            if(nbitems>items_.size())\n                items_.resize(nbitems, format_item_t(fill));\n            bound_.resize(0);\n            for(std::size_t i=0; i < nbitems; ++i)\n                items_[i].reset(fill); //  strings are resized, instead of reallocated\n        }\n        prefix_.resize(0);\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>:: \n    clear () {\n        // empty the string buffers (except bound arguments)\n        // and make the format object ready for formatting a new set of arguments\n\n        BOOST_ASSERT( bound_.size()==0 || num_args_ == static_cast<int>(bound_.size()) );\n\n        for(unsigned long i=0; i<items_.size(); ++i) {\n            // clear converted strings only if the corresponding argument is not  bound :\n            if( bound_.size()==0 || items_[i].argN_<0 || !bound_[ items_[i].argN_ ] )\n                items_[i].res_.resize(0);\n        }\n        cur_arg_=0; dumped_=false;\n        // maybe first arg is bound:\n        if(bound_.size() != 0) {\n            for(; cur_arg_ < num_args_ && bound_[cur_arg_]; ++cur_arg_)\n                {}\n        }\n        return *this;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>:: \n    clear_binds () {\n        // remove all binds, then clear()\n        bound_.resize(0);\n        clear();\n        return *this;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    basic_format<Ch,Tr, Alloc>& basic_format<Ch,Tr, Alloc>:: \n    clear_bind (int argN) {\n        // remove the bind of ONE argument then clear()\n        if(argN<1 || argN > num_args_ || bound_.size()==0 || !bound_[argN-1] ) {\n            if( exceptions() & io::out_of_range_bit)\n                boost::throw_exception(io::out_of_range(argN, 1, num_args_+1 ) ); \n            else return *this;\n        }\n        bound_[argN-1]=false;\n        clear();\n        return *this;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    int basic_format<Ch,Tr, Alloc>::\n    bound_args() const {\n        if(bound_.size()==0)\n            return 0;\n        int n=0;\n        for(int i=0; i<num_args_ ; ++i)\n            if(bound_[i])\n                ++n;\n        return n;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    int basic_format<Ch,Tr, Alloc>::\n    fed_args() const {\n        if(bound_.size()==0)\n            return cur_arg_;\n        int n=0;\n        for(int i=0; i<cur_arg_ ; ++i)\n            if(!bound_[i])\n                ++n;\n        return n;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    int basic_format<Ch,Tr, Alloc>::\n    cur_arg() const {\n      return cur_arg_+1; }\n\n    template< class Ch, class Tr, class Alloc>\n    int basic_format<Ch,Tr, Alloc>::\n    remaining_args() const {\n        if(bound_.size()==0)\n            return num_args_-cur_arg_;\n        int n=0;\n        for(int i=cur_arg_; i<num_args_ ; ++i)\n            if(!bound_[i])\n                ++n;\n        return n;\n    }\n\n    template< class Ch, class Tr, class Alloc>\n    typename basic_format<Ch, Tr, Alloc>::string_type \n    basic_format<Ch,Tr, Alloc>:: \n    str () const {\n        if(items_.size()==0)\n            return prefix_;\n        if( cur_arg_ < num_args_)\n            if( exceptions() & io::too_few_args_bit )\n                // not enough variables supplied\n                boost::throw_exception(io::too_few_args(cur_arg_, num_args_)); \n\n        unsigned long i;\n        string_type res;\n        res.reserve(size());\n        res += prefix_;\n        for(i=0; i < items_.size(); ++i) {\n            const format_item_t& item = items_[i];\n            res += item.res_;\n            if( item.argN_ == format_item_t::argN_tabulation) { \n                BOOST_ASSERT( item.pad_scheme_ & format_item_t::tabulation);\n                if( static_cast<size_type>(item.fmtstate_.width_) > res.size() )\n                    res.append( static_cast<size_type>(item.fmtstate_.width_) - res.size(),\n                                        item.fmtstate_.fill_ );\n            }\n            res += item.appendix_;\n        }\n        dumped_=true;\n        return res;\n    }\n    template< class Ch, class Tr, class Alloc>\n    typename std::basic_string<Ch, Tr, Alloc>::size_type  basic_format<Ch,Tr, Alloc>:: \n    size () const {\n#ifdef BOOST_MSVC\n       // If std::min<unsigned> or std::max<unsigned> are already instantiated\n       // at this point then we get a blizzard of warning messages when we call\n       // those templates with std::size_t as arguments.  Weird and very annoyning...\n#pragma warning(push)\n#pragma warning(disable:4267)\n#endif\n        BOOST_USING_STD_MAX();\n        size_type sz = prefix_.size();\n        unsigned long i;\n        for(i=0; i < items_.size(); ++i) {\n            const format_item_t& item = items_[i];\n            sz += item.res_.size();\n            if( item.argN_ == format_item_t::argN_tabulation)\n                sz = max BOOST_PREVENT_MACRO_SUBSTITUTION (sz,\n                                        static_cast<size_type>(item.fmtstate_.width_) );\n            sz += item.appendix_.size();\n        }\n        return sz;\n#ifdef BOOST_MSVC\n#pragma warning(pop)\n#endif\n    }\n\nnamespace io {\nnamespace detail {\n\n    template<class Ch, class Tr, class Alloc, class T> \n    basic_format<Ch, Tr, Alloc>&  \n    bind_arg_body (basic_format<Ch, Tr, Alloc>& self, int argN, const T& val) {\n        // bind one argument to a fixed value\n        // this is persistent over clear() calls, thus also over str() and <<\n        if(self.dumped_) \n            self.clear(); // needed because we will modify cur_arg_\n        if(argN<1 || argN > self.num_args_) {\n            if( self.exceptions() & io::out_of_range_bit )\n                boost::throw_exception(io::out_of_range(argN, 1, self.num_args_+1 ) );\n            else return self;\n        }\n        if(self.bound_.size()==0) \n            self.bound_.assign(self.num_args_,false);\n        else \n            BOOST_ASSERT( self.num_args_ == static_cast<signed int>(self.bound_.size()) );\n        int o_cur_arg = self.cur_arg_;\n        self.cur_arg_ = argN-1; // arrays begin at 0\n\n        self.bound_[self.cur_arg_]=false; // if already set, we unset and re-sets..\n        self.operator%(val); // put val at the right place, because cur_arg is set\n    \n\n        // Now re-position cur_arg before leaving :\n        self.cur_arg_ = o_cur_arg; \n        self.bound_[argN-1]=true;\n        if(self.cur_arg_ == argN-1 ) {\n            // hum, now this arg is bound, so move to next free arg\n            while(self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_])   \n                ++self.cur_arg_;\n        }\n        // In any case, we either have all args, or are on an unbound arg :\n        BOOST_ASSERT( self.cur_arg_ >= self.num_args_ || ! self.bound_[self.cur_arg_]);\n        return self;\n    }\n\n    template<class Ch, class Tr, class Alloc, class T> basic_format<Ch, Tr, Alloc>&\n    modify_item_body (basic_format<Ch, Tr, Alloc>& self, int itemN, T manipulator) {\n        // applies a manipulator to the format_item describing a given directive.\n        // this is a permanent change, clear or reset won't cancel that.\n        if(itemN<1 || itemN > static_cast<signed int>(self.items_.size() )) {\n            if( self.exceptions() & io::out_of_range_bit ) \n                boost::throw_exception(io::out_of_range(itemN, 1, static_cast<int>(self.items_.size()) ));\n            else return self;\n        }\n        self.items_[itemN-1].fmtstate_. template apply_manip<T> ( manipulator );\n        return self;\n    }\n\n} // namespace detail\n} // namespace io\n} // namespace boost\n\n\n\n#endif  // BOOST_FORMAT_IMPLEMENTATION_HPP\n","// ----------------------------------------------------------------------------\n//  format_class.hpp :  class interface\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_CLASS_HPP\n#define BOOST_FORMAT_CLASS_HPP\n\n\n#include <vector>\n#include <string>\n\n#include <boost/optional.hpp> // to store locale when needed\n\n#include <boost/format/format_fwd.hpp>\n#include <boost/format/internals_fwd.hpp>\n#include <boost/format/internals.hpp>\n#include <boost/format/alt_sstream.hpp>\n\nnamespace boost {\n\n    template<class Ch, class Tr, class Alloc>\n    class basic_format \n    {\n        typedef typename io::CompatTraits<Tr>::compatible_type compat_traits;  \n    public:\n        typedef Ch  CharT;   // borland fails in operator% if we use Ch and Tr directly\n        typedef std::basic_string<Ch, Tr, Alloc>              string_type;\n        typedef typename string_type::size_type               size_type;\n        typedef io::detail::format_item<Ch, Tr, Alloc>        format_item_t;\n        typedef io::basic_altstringbuf<Ch, Tr, Alloc>         internal_streambuf_t;\n        \n\n        explicit basic_format(const Ch* str=NULL);\n        explicit basic_format(const string_type& s);\n        basic_format(const basic_format& x);\n        basic_format& operator= (const basic_format& x);\n        void swap(basic_format& x);\n\n#if !defined(BOOST_NO_STD_LOCALE)\n        explicit basic_format(const Ch* str, const std::locale & loc);\n        explicit basic_format(const string_type& s, const std::locale & loc);\n#endif\n        io::detail::locale_t  getloc() const;\n\n        basic_format& clear();       // empty all converted string buffers (except bound items)\n        basic_format& clear_binds(); // unbind all bound items, and call clear()\n        basic_format& parse(const string_type&); // resets buffers and parse a new format string\n\n        // ** formatted result ** //\n        size_type   size() const;    // sum of the current string pieces sizes\n        string_type str()  const;    // final string \n\n        // ** arguments passing ** //\n        template<class T>  \n        basic_format&   operator%(const T& x)\n            { return io::detail::feed<CharT, Tr, Alloc, const T&>(*this,x); }\n\n#ifndef BOOST_NO_OVERLOAD_FOR_NON_CONST\n        template<class T>  basic_format&   operator%(T& x) \n            { return io::detail::feed<CharT, Tr, Alloc, T&>(*this,x); }\n#endif\n\n#if defined(__GNUC__)\n        // GCC can't handle anonymous enums without some help\n        // ** arguments passing ** //\n        basic_format&   operator%(const int& x)\n            { return io::detail::feed<CharT, Tr, Alloc, const int&>(*this,x); }\n\n#ifndef BOOST_NO_OVERLOAD_FOR_NON_CONST\n        basic_format&   operator%(int& x)\n            { return io::detail::feed<CharT, Tr, Alloc, int&>(*this,x); }\n#endif\n#endif\n\n        // The total number of arguments expected to be passed to the format objectt\n        int expected_args() const\n            { return num_args_; }\n        // The number of arguments currently bound (see bind_arg(..) )\n        int bound_args() const;\n        // The number of arguments currently fed to the format object\n        int fed_args() const;\n        // The index (1-based) of the current argument (i.e. next to be formatted)\n        int cur_arg() const;\n        // The number of arguments still required to be fed\n        int remaining_args() const; // same as expected_args() - bound_args() - fed_args()\n\n\n        // ** object modifying **//\n        template<class T>\n        basic_format&  bind_arg(int argN, const T& val) \n            { return io::detail::bind_arg_body(*this, argN, val); }\n        basic_format&  clear_bind(int argN);\n        template<class T> \n        basic_format&  modify_item(int itemN, T manipulator) \n            { return io::detail::modify_item_body<Ch,Tr, Alloc, T> (*this, itemN, manipulator);}\n\n        // Choosing which errors will throw exceptions :\n        unsigned char exceptions() const;\n        unsigned char exceptions(unsigned char newexcept);\n\n#if !defined( BOOST_NO_MEMBER_TEMPLATE_FRIENDS )  \\\n    && !BOOST_WORKAROUND(__BORLANDC__, <= 0x570) \\\n    && !BOOST_WORKAROUND( _CRAYC, != 0) \\\n    && !BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590042))\n        // use friend templates and private members only if supported\n\n#ifndef  BOOST_NO_TEMPLATE_STD_STREAM\n        template<class Ch2, class Tr2, class Alloc2>\n        friend std::basic_ostream<Ch2, Tr2> & \n        operator<<( std::basic_ostream<Ch2, Tr2> & ,\n                    const basic_format<Ch2, Tr2, Alloc2>& );\n#else\n        template<class Ch2, class Tr2, class Alloc2>\n        friend std::ostream & \n        operator<<( std::ostream & ,\n                    const basic_format<Ch2, Tr2, Alloc2>& );\n#endif\n\n        template<class Ch2, class Tr2, class Alloc2, class T>  \n        friend basic_format<Ch2, Tr2, Alloc2>&  \n        io::detail::feed (basic_format<Ch2, Tr2, Alloc2>&, T);\n\n        template<class Ch2, class Tr2, class Alloc2, class T>  friend   \n        void io::detail::distribute (basic_format<Ch2, Tr2, Alloc2>&, T);\n        \n        template<class Ch2, class Tr2, class Alloc2, class T>  friend\n        basic_format<Ch2, Tr2, Alloc2>& \n        io::detail::modify_item_body (basic_format<Ch2, Tr2, Alloc2>&, int, T);\n        \n        template<class Ch2, class Tr2, class Alloc2, class T> friend\n        basic_format<Ch2, Tr2, Alloc2>&  \n        io::detail::bind_arg_body (basic_format<Ch2, Tr2, Alloc2>&, int, const T&);\n\n    private:\n#endif\n        typedef io::detail::stream_format_state<Ch, Tr>  stream_format_state;\n        // flag bits, used for style_\n        enum style_values  { ordered = 1, // set only if all directives are  positional\n                             special_needs = 4 };     \n\n        void make_or_reuse_data(std::size_t nbitems);// used for (re-)initialisation\n\n        // member data --------------------------------------------//\n        std::vector<format_item_t>  items_; // each '%..' directive leads to a format_item\n        std::vector<bool> bound_; // stores which arguments were bound. size() == 0 || num_args\n\n        int              style_; // style of format-string :  positional or not, etc\n        int             cur_arg_; // keep track of wich argument is current\n        int            num_args_; // number of expected arguments\n        mutable bool     dumped_; // true only after call to str() or <<\n        string_type      prefix_; // piece of string to insert before first item\n        unsigned char exceptions_;\n        internal_streambuf_t   buf_; // the internal stream buffer.\n        boost::optional<io::detail::locale_t>     loc_;\n    }; // class basic_format\n\n} // namespace boost\n\n\n#endif // BOOST_FORMAT_CLASS_HPP\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n    const char* __type_name;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n        : __type_name(__n) {}\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT {return __type_name;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n        {return __type_name < __arg.__type_name;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n        {return __type_name == __arg.__type_name;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n","// ----------------------------------------------------------------------------\n//  format_fwd.hpp :  forward declarations\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_FWD_HPP\n#define BOOST_FORMAT_FWD_HPP\n\n#include <string>\n#include <iosfwd>\n\n#include <boost/format/detail/compat_workarounds.hpp> \n\nnamespace boost {\n\n    template <class Ch, \n#if !( BOOST_WORKAROUND(__GNUC__, <3) && !defined(__SGI_STL_PORT) && !defined(_STLPORT_VERSION) )\n    // gcc-2.95's native  stdlid needs special treatment\n        class Tr = BOOST_IO_STD char_traits<Ch>, class Alloc = std::allocator<Ch> > \n#else\n        class Tr = std::string_char_traits<Ch>, class Alloc = std::alloc > \n#endif\n    class basic_format;\n\n    typedef basic_format<char >     format;\n\n#if !defined(BOOST_NO_STD_WSTRING)  && !defined(BOOST_NO_STD_WSTREAMBUF) \\\n    && !defined(BOOST_FORMAT_IGNORE_STRINGSTREAM)\n    typedef basic_format<wchar_t >  wformat;\n#endif\n\n    namespace io {\n        enum format_error_bits { bad_format_string_bit = 1, \n                                 too_few_args_bit = 2, too_many_args_bit = 4,\n                                 out_of_range_bit = 8,\n                                 all_error_bits = 255, no_error_bits=0 };\n                  \n    } // namespace io\n\n} // namespace boost\n\n#endif // BOOST_FORMAT_FWD_HPP\n","//  Copyright John Maddock 2007.\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_MATH_POLICY_HPP\n#define BOOST_MATH_POLICY_HPP\n\n#include <boost/mpl/list.hpp>\n#include <boost/mpl/contains.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/find_if.hpp>\n#include <boost/mpl/remove_if.hpp>\n#include <boost/mpl/vector.hpp>\n#include <boost/mpl/push_back.hpp>\n#include <boost/mpl/at.hpp>\n#include <boost/mpl/size.hpp>\n#include <boost/mpl/comparison.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/assert.hpp>\n#include <boost/math/tools/config.hpp>\n#include <limits>\n// Sadly we do need the .h versions of these to be sure of getting\n// FLT_MANT_DIG etc.\n#include <limits.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <math.h>\n\nnamespace boost{ namespace math{ \n\nnamespace tools{\n\ntemplate <class T>\nint digits(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T));\ntemplate <class T>\nT epsilon(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T));\n\n}\n\nnamespace policies{\n\n//\n// Define macros for our default policies, if they're not defined already:\n//\n#ifndef BOOST_MATH_DOMAIN_ERROR_POLICY\n#define BOOST_MATH_DOMAIN_ERROR_POLICY throw_on_error\n#endif\n#ifndef BOOST_MATH_POLE_ERROR_POLICY\n#define BOOST_MATH_POLE_ERROR_POLICY throw_on_error\n#endif\n#ifndef BOOST_MATH_OVERFLOW_ERROR_POLICY\n#define BOOST_MATH_OVERFLOW_ERROR_POLICY throw_on_error\n#endif\n#ifndef BOOST_MATH_EVALUATION_ERROR_POLICY\n#define BOOST_MATH_EVALUATION_ERROR_POLICY throw_on_error\n#endif\n#ifndef BOOST_MATH_ROUNDING_ERROR_POLICY\n#define BOOST_MATH_ROUNDING_ERROR_POLICY throw_on_error\n#endif\n#ifndef BOOST_MATH_UNDERFLOW_ERROR_POLICY\n#define BOOST_MATH_UNDERFLOW_ERROR_POLICY ignore_error\n#endif\n#ifndef BOOST_MATH_DENORM_ERROR_POLICY\n#define BOOST_MATH_DENORM_ERROR_POLICY ignore_error\n#endif\n#ifndef BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY\n#define BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY ignore_error\n#endif\n#ifndef BOOST_MATH_DIGITS10_POLICY\n#define BOOST_MATH_DIGITS10_POLICY 0\n#endif\n#ifndef BOOST_MATH_PROMOTE_FLOAT_POLICY\n#define BOOST_MATH_PROMOTE_FLOAT_POLICY true\n#endif\n#ifndef BOOST_MATH_PROMOTE_DOUBLE_POLICY\n#ifdef BOOST_MATH_NO_LONG_DOUBLE_MATH_FUNCTIONS\n#define BOOST_MATH_PROMOTE_DOUBLE_POLICY false\n#else\n#define BOOST_MATH_PROMOTE_DOUBLE_POLICY true\n#endif\n#endif\n#ifndef BOOST_MATH_DISCRETE_QUANTILE_POLICY\n#define BOOST_MATH_DISCRETE_QUANTILE_POLICY integer_round_outwards\n#endif\n#ifndef BOOST_MATH_ASSERT_UNDEFINED_POLICY\n#define BOOST_MATH_ASSERT_UNDEFINED_POLICY true\n#endif\n#ifndef BOOST_MATH_MAX_SERIES_ITERATION_POLICY\n#define BOOST_MATH_MAX_SERIES_ITERATION_POLICY 1000000\n#endif\n#ifndef BOOST_MATH_MAX_ROOT_ITERATION_POLICY\n#define BOOST_MATH_MAX_ROOT_ITERATION_POLICY 200\n#endif\n\n#if !defined(__BORLANDC__) \\\n   && !(defined(__GNUC__) && (__GNUC__ == 3) && (__GNUC_MINOR__ <= 2))\n#define BOOST_MATH_META_INT(type, name, Default)\\\n   template <type N = Default> struct name : public boost::mpl::int_<N>{};\\\n   namespace detail{\\\n   template <type N>\\\n   char test_is_valid_arg(const name<N>*);\\\n   char test_is_default_arg(const name<Default>*);\\\n   template <class T> struct is_##name##_imp\\\n   {\\\n      template <type N> static char test(const name<N>*);\\\n      static double test(...);\\\n      BOOST_STATIC_CONSTANT(bool, value = sizeof(test(static_cast<T*>(0))) == 1);\\\n   };\\\n   }\\\n   template <class T> struct is_##name : public boost::mpl::bool_< ::boost::math::policies::detail::is_##name##_imp<T>::value>{};\n\n#define BOOST_MATH_META_BOOL(name, Default)\\\n   template <bool N = Default> struct name : public boost::mpl::bool_<N>{};\\\n   namespace detail{\\\n   template <bool N>\\\n   char test_is_valid_arg(const name<N>*);\\\n   char test_is_default_arg(const name<Default>*);\\\n   template <class T> struct is_##name##_imp\\\n   {\\\n      template <bool N> static char test(const name<N>*);\\\n      static double test(...);\\\n      BOOST_STATIC_CONSTANT(bool, value = sizeof(test(static_cast<T*>(0))) == 1);\\\n   };\\\n   }\\\n   template <class T> struct is_##name : public boost::mpl::bool_< ::boost::math::policies::detail::is_##name##_imp<T>::value>{};\n#else\n#define BOOST_MATH_META_INT(Type, name, Default)\\\n   template <Type N = Default> struct name : public boost::mpl::int_<N>{};\\\n   namespace detail{\\\n   template <Type N>\\\n   char test_is_valid_arg(const name<N>*);\\\n   char test_is_default_arg(const name<Default>*);\\\n   template <class T> struct is_##name##_tester\\\n   {\\\n      template <Type N> static char test(const name<N>&);\\\n      static double test(...);\\\n   };\\\n   template <class T> struct is_##name##_imp\\\n   {\\\n      static T inst;\\\n      BOOST_STATIC_CONSTANT(bool, value = sizeof( ::boost::math::policies::detail::is_##name##_tester<T>::test(inst)) == 1);\\\n   };\\\n   }\\\n   template <class T> struct is_##name : public boost::mpl::bool_< ::boost::math::policies::detail::is_##name##_imp<T>::value>\\\n   {\\\n      template <class U> struct apply{ typedef is_##name<U> type; };\\\n   };\n\n#define BOOST_MATH_META_BOOL(name, Default)\\\n   template <bool N = Default> struct name : public boost::mpl::bool_<N>{};\\\n   namespace detail{\\\n   template <bool N>\\\n   char test_is_valid_arg(const name<N>*);\\\n   char test_is_default_arg(const name<Default>*);\\\n   template <class T> struct is_##name##_tester\\\n   {\\\n      template <bool N> static char test(const name<N>&);\\\n      static double test(...);\\\n   };\\\n   template <class T> struct is_##name##_imp\\\n   {\\\n      static T inst;\\\n      BOOST_STATIC_CONSTANT(bool, value = sizeof( ::boost::math::policies::detail::is_##name##_tester<T>::test(inst)) == 1);\\\n   };\\\n   }\\\n   template <class T> struct is_##name : public boost::mpl::bool_< ::boost::math::policies::detail::is_##name##_imp<T>::value>\\\n   {\\\n      template <class U> struct apply{ typedef is_##name<U> type;  };\\\n   };\n#endif\n//\n// Begin by defining policy types for error handling:\n//\nenum error_policy_type\n{\n   throw_on_error = 0,\n   errno_on_error = 1,\n   ignore_error = 2,\n   user_error = 3\n};\n\nBOOST_MATH_META_INT(error_policy_type, domain_error, BOOST_MATH_DOMAIN_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, pole_error, BOOST_MATH_POLE_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, overflow_error, BOOST_MATH_OVERFLOW_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, underflow_error, BOOST_MATH_UNDERFLOW_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, denorm_error, BOOST_MATH_DENORM_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, evaluation_error, BOOST_MATH_EVALUATION_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, rounding_error, BOOST_MATH_ROUNDING_ERROR_POLICY)\nBOOST_MATH_META_INT(error_policy_type, indeterminate_result_error, BOOST_MATH_INDETERMINATE_RESULT_ERROR_POLICY)\n\n//\n// Policy types for internal promotion:\n//\nBOOST_MATH_META_BOOL(promote_float, BOOST_MATH_PROMOTE_FLOAT_POLICY)\nBOOST_MATH_META_BOOL(promote_double, BOOST_MATH_PROMOTE_DOUBLE_POLICY)\nBOOST_MATH_META_BOOL(assert_undefined, BOOST_MATH_ASSERT_UNDEFINED_POLICY)\n//\n// Policy types for discrete quantiles:\n//\nenum discrete_quantile_policy_type\n{\n   real,\n   integer_round_outwards,\n   integer_round_inwards,\n   integer_round_down,\n   integer_round_up,\n   integer_round_nearest\n};\n\nBOOST_MATH_META_INT(discrete_quantile_policy_type, discrete_quantile, BOOST_MATH_DISCRETE_QUANTILE_POLICY)\n//\n// Precision:\n//\nBOOST_MATH_META_INT(int, digits10, BOOST_MATH_DIGITS10_POLICY)\nBOOST_MATH_META_INT(int, digits2, 0)\n//\n// Iterations:\n//\nBOOST_MATH_META_INT(unsigned long, max_series_iterations, BOOST_MATH_MAX_SERIES_ITERATION_POLICY)\nBOOST_MATH_META_INT(unsigned long, max_root_iterations, BOOST_MATH_MAX_ROOT_ITERATION_POLICY)\n//\n// Define the names for each possible policy:\n//\n#define BOOST_MATH_PARAMETER(name)\\\n   BOOST_PARAMETER_TEMPLATE_KEYWORD(name##_name)\\\n   BOOST_PARAMETER_NAME(name##_name)\n\nstruct default_policy{};\n\nnamespace detail{\n//\n// Trait to work out bits precision from digits10 and digits2:\n//\ntemplate <class Digits10, class Digits2>\nstruct precision\n{\n   //\n   // Now work out the precision:\n   //\n   typedef typename mpl::if_c<\n      (Digits10::value == 0),\n      digits2<0>,\n      digits2<((Digits10::value + 1) * 1000L) / 301L>\n   >::type digits2_type;\npublic:\n#ifdef __BORLANDC__\n   typedef typename mpl::if_c<\n      (Digits2::value > ::boost::math::policies::detail::precision<Digits10,Digits2>::digits2_type::value),\n      Digits2, digits2_type>::type type;\n#else\n   typedef typename mpl::if_c<\n      (Digits2::value > digits2_type::value),\n      Digits2, digits2_type>::type type;\n#endif\n};\n\ntemplate <class A, class B, bool b>\nstruct select_result\n{\n   typedef A type;\n};\ntemplate <class A, class B>\nstruct select_result<A, B, false>\n{\n   typedef typename mpl::deref<B>::type type;\n};\n\ntemplate <class Seq, class Pred, class DefaultType>\nstruct find_arg\n{\nprivate:\n   typedef typename mpl::find_if<Seq, Pred>::type iter;\n   typedef typename mpl::end<Seq>::type end_type;\npublic:\n   typedef typename select_result<\n      DefaultType, iter,\n      ::boost::is_same<iter, end_type>::value>::type type;\n};\n\ndouble test_is_valid_arg(...);\ndouble test_is_default_arg(...);\nchar test_is_valid_arg(const default_policy*);\nchar test_is_default_arg(const default_policy*);\n\ntemplate <class T>\nstruct is_valid_policy_imp \n{\n   BOOST_STATIC_CONSTANT(bool, value = sizeof(::boost::math::policies::detail::test_is_valid_arg(static_cast<T*>(0))) == 1);\n};\n\ntemplate <class T>\nstruct is_default_policy_imp\n{\n   BOOST_STATIC_CONSTANT(bool, value = sizeof(::boost::math::policies::detail::test_is_default_arg(static_cast<T*>(0))) == 1);\n};\n\ntemplate <class T> struct is_valid_policy \n: public mpl::bool_< \n   ::boost::math::policies::detail::is_valid_policy_imp<T>::value>\n{};\n\ntemplate <class T> struct is_default_policy \n: public mpl::bool_< \n   ::boost::math::policies::detail::is_default_policy_imp<T>::value>\n{\n   template <class U>\n   struct apply\n   {\n      typedef is_default_policy<U> type;\n   };\n};\n\ntemplate <class Seq, class T, int N>\nstruct append_N\n{\n   typedef typename mpl::push_back<Seq, T>::type new_seq;\n   typedef typename append_N<new_seq, T, N-1>::type type;\n};\n\ntemplate <class Seq, class T>\nstruct append_N<Seq, T, 0>\n{\n   typedef Seq type;\n};\n\n//\n// Traits class to work out what template parameters our default\n// policy<> class will have when modified for forwarding:\n//\ntemplate <bool f, bool d>\nstruct default_args\n{\n   typedef promote_float<false> arg1;\n   typedef promote_double<false> arg2;\n};\n\ntemplate <>\nstruct default_args<false, false>\n{\n   typedef default_policy arg1;\n   typedef default_policy arg2;\n};\n\ntemplate <>\nstruct default_args<true, false>\n{\n   typedef promote_float<false> arg1;\n   typedef default_policy arg2;\n};\n\ntemplate <>\nstruct default_args<false, true>\n{\n   typedef promote_double<false> arg1;\n   typedef default_policy arg2;\n};\n\ntypedef default_args<BOOST_MATH_PROMOTE_FLOAT_POLICY, BOOST_MATH_PROMOTE_DOUBLE_POLICY>::arg1 forwarding_arg1;\ntypedef default_args<BOOST_MATH_PROMOTE_FLOAT_POLICY, BOOST_MATH_PROMOTE_DOUBLE_POLICY>::arg2 forwarding_arg2;\n\n} // detail\n//\n// Now define the policy type with enough arguments to handle all\n// the policies:\n//\ntemplate <class A1 = default_policy, \n          class A2 = default_policy, \n          class A3 = default_policy,\n          class A4 = default_policy,\n          class A5 = default_policy,\n          class A6 = default_policy,\n          class A7 = default_policy,\n          class A8 = default_policy,\n          class A9 = default_policy,\n          class A10 = default_policy,\n          class A11 = default_policy,\n          class A12 = default_policy,\n          class A13 = default_policy>\nstruct policy\n{\nprivate:\n   //\n   // Validate all our arguments:\n   //\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A1>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A2>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A3>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A4>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A5>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A6>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A7>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A8>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A9>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A10>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A11>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A12>::value);\n   BOOST_STATIC_ASSERT(::boost::math::policies::detail::is_valid_policy<A13>::value);\n   //\n   // Typelist of the arguments:\n   //\n   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;\n\npublic:\n   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, domain_error<> >::type domain_error_type;\n   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, pole_error<> >::type pole_error_type;\n   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, overflow_error<> >::type overflow_error_type;\n   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, underflow_error<> >::type underflow_error_type;\n   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, denorm_error<> >::type denorm_error_type;\n   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, evaluation_error<> >::type evaluation_error_type;\n   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, rounding_error<> >::type rounding_error_type;\n   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, indeterminate_result_error<> >::type indeterminate_result_error_type;\nprivate:\n   //\n   // Now work out the precision:\n   //\n   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;\n   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, digits2<> >::type bits_precision_type;\npublic:\n   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;\n   //\n   // Internal promotion:\n   //\n   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, promote_float<> >::type promote_float_type;\n   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, promote_double<> >::type promote_double_type;\n   //\n   // Discrete quantiles:\n   //\n   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, discrete_quantile<> >::type discrete_quantile_type;\n   //\n   // Mathematically undefined properties:\n   //\n   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, assert_undefined<> >::type assert_undefined_type;\n   //\n   // Max iterations:\n   //\n   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, max_series_iterations<> >::type max_series_iterations_type;\n   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, max_root_iterations<> >::type max_root_iterations_type;\n};\n//\n// These full specializations are defined to reduce the amount of\n// template instantiations that have to take place when using the default\n// policies, they have quite a large impact on compile times:\n//\ntemplate <>\nstruct policy<default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>\n{\npublic:\n   typedef domain_error<> domain_error_type;\n   typedef pole_error<> pole_error_type;\n   typedef overflow_error<> overflow_error_type;\n   typedef underflow_error<> underflow_error_type;\n   typedef denorm_error<> denorm_error_type;\n   typedef evaluation_error<> evaluation_error_type;\n   typedef rounding_error<> rounding_error_type;\n   typedef indeterminate_result_error<> indeterminate_result_error_type;\n#if BOOST_MATH_DIGITS10_POLICY == 0\n   typedef digits2<> precision_type;\n#else\n   typedef detail::precision<digits10<>, digits2<> >::type precision_type;\n#endif\n   typedef promote_float<> promote_float_type;\n   typedef promote_double<> promote_double_type;\n   typedef discrete_quantile<> discrete_quantile_type;\n   typedef assert_undefined<> assert_undefined_type;\n   typedef max_series_iterations<> max_series_iterations_type;\n   typedef max_root_iterations<> max_root_iterations_type;\n};\n\ntemplate <>\nstruct policy<detail::forwarding_arg1, detail::forwarding_arg2, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy, default_policy>\n{\npublic:\n   typedef domain_error<> domain_error_type;\n   typedef pole_error<> pole_error_type;\n   typedef overflow_error<> overflow_error_type;\n   typedef underflow_error<> underflow_error_type;\n   typedef denorm_error<> denorm_error_type;\n   typedef evaluation_error<> evaluation_error_type;\n   typedef rounding_error<> rounding_error_type;\n   typedef indeterminate_result_error<> indeterminate_result_error_type;\n#if BOOST_MATH_DIGITS10_POLICY == 0\n   typedef digits2<> precision_type;\n#else\n   typedef detail::precision<digits10<>, digits2<> >::type precision_type;\n#endif\n   typedef promote_float<false> promote_float_type;\n   typedef promote_double<false> promote_double_type;\n   typedef discrete_quantile<> discrete_quantile_type;\n   typedef assert_undefined<> assert_undefined_type;\n   typedef max_series_iterations<> max_series_iterations_type;\n   typedef max_root_iterations<> max_root_iterations_type;\n};\n\ntemplate <class Policy, \n          class A1 = default_policy, \n          class A2 = default_policy, \n          class A3 = default_policy,\n          class A4 = default_policy,\n          class A5 = default_policy,\n          class A6 = default_policy,\n          class A7 = default_policy,\n          class A8 = default_policy,\n          class A9 = default_policy,\n          class A10 = default_policy,\n          class A11 = default_policy,\n          class A12 = default_policy,\n          class A13 = default_policy>\nstruct normalise\n{\nprivate:\n   typedef mpl::list<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11,A12,A13> arg_list;\n   typedef typename detail::find_arg<arg_list, is_domain_error<mpl::_1>, typename Policy::domain_error_type >::type domain_error_type;\n   typedef typename detail::find_arg<arg_list, is_pole_error<mpl::_1>, typename Policy::pole_error_type >::type pole_error_type;\n   typedef typename detail::find_arg<arg_list, is_overflow_error<mpl::_1>, typename Policy::overflow_error_type >::type overflow_error_type;\n   typedef typename detail::find_arg<arg_list, is_underflow_error<mpl::_1>, typename Policy::underflow_error_type >::type underflow_error_type;\n   typedef typename detail::find_arg<arg_list, is_denorm_error<mpl::_1>, typename Policy::denorm_error_type >::type denorm_error_type;\n   typedef typename detail::find_arg<arg_list, is_evaluation_error<mpl::_1>, typename Policy::evaluation_error_type >::type evaluation_error_type;\n   typedef typename detail::find_arg<arg_list, is_rounding_error<mpl::_1>, typename Policy::rounding_error_type >::type rounding_error_type;\n   typedef typename detail::find_arg<arg_list, is_indeterminate_result_error<mpl::_1>, typename Policy::indeterminate_result_error_type >::type indeterminate_result_error_type;\n   //\n   // Now work out the precision:\n   //\n   typedef typename detail::find_arg<arg_list, is_digits10<mpl::_1>, digits10<> >::type digits10_type;\n   typedef typename detail::find_arg<arg_list, is_digits2<mpl::_1>, typename Policy::precision_type >::type bits_precision_type;\n   typedef typename detail::precision<digits10_type, bits_precision_type>::type precision_type;\n   //\n   // Internal promotion:\n   //\n   typedef typename detail::find_arg<arg_list, is_promote_float<mpl::_1>, typename Policy::promote_float_type >::type promote_float_type;\n   typedef typename detail::find_arg<arg_list, is_promote_double<mpl::_1>, typename Policy::promote_double_type >::type promote_double_type;\n   //\n   // Discrete quantiles:\n   //\n   typedef typename detail::find_arg<arg_list, is_discrete_quantile<mpl::_1>, typename Policy::discrete_quantile_type >::type discrete_quantile_type;\n   //\n   // Mathematically undefined properties:\n   //\n   typedef typename detail::find_arg<arg_list, is_assert_undefined<mpl::_1>, typename Policy::assert_undefined_type >::type assert_undefined_type;\n   //\n   // Max iterations:\n   //\n   typedef typename detail::find_arg<arg_list, is_max_series_iterations<mpl::_1>, typename Policy::max_series_iterations_type>::type max_series_iterations_type;\n   typedef typename detail::find_arg<arg_list, is_max_root_iterations<mpl::_1>, typename Policy::max_root_iterations_type>::type max_root_iterations_type;\n   //\n   // Define a typelist of the policies:\n   //\n   typedef mpl::vector<\n      domain_error_type,\n      pole_error_type,\n      overflow_error_type,\n      underflow_error_type,\n      denorm_error_type,\n      evaluation_error_type,\n      rounding_error_type,\n      indeterminate_result_error_type,\n      precision_type,\n      promote_float_type,\n      promote_double_type,\n      discrete_quantile_type,\n      assert_undefined_type,\n      max_series_iterations_type,\n      max_root_iterations_type> result_list;\n   //\n   // Remove all the policies that are the same as the default:\n   //\n   typedef typename mpl::remove_if<result_list, detail::is_default_policy<mpl::_> >::type reduced_list;\n   //\n   // Pad out the list with defaults:\n   //\n   typedef typename detail::append_N<reduced_list, default_policy, (14 - ::boost::mpl::size<reduced_list>::value)>::type result_type;\npublic:\n   typedef policy<\n      typename mpl::at<result_type, mpl::int_<0> >::type,\n      typename mpl::at<result_type, mpl::int_<1> >::type,\n      typename mpl::at<result_type, mpl::int_<2> >::type,\n      typename mpl::at<result_type, mpl::int_<3> >::type,\n      typename mpl::at<result_type, mpl::int_<4> >::type,\n      typename mpl::at<result_type, mpl::int_<5> >::type,\n      typename mpl::at<result_type, mpl::int_<6> >::type,\n      typename mpl::at<result_type, mpl::int_<7> >::type,\n      typename mpl::at<result_type, mpl::int_<8> >::type,\n      typename mpl::at<result_type, mpl::int_<9> >::type,\n      typename mpl::at<result_type, mpl::int_<10> >::type,\n      typename mpl::at<result_type, mpl::int_<11> >::type,\n      typename mpl::at<result_type, mpl::int_<12> >::type > type;\n};\n//\n// Full specialisation to speed up compilation of the common case:\n//\ntemplate <>\nstruct normalise<policy<>, \n          promote_float<false>, \n          promote_double<false>, \n          discrete_quantile<>,\n          assert_undefined<>,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy>\n{\n   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;\n};\n\ntemplate <>\nstruct normalise<policy<detail::forwarding_arg1, detail::forwarding_arg2>,\n          promote_float<false>,\n          promote_double<false>,\n          discrete_quantile<>,\n          assert_undefined<>,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy,\n          default_policy>\n{\n   typedef policy<detail::forwarding_arg1, detail::forwarding_arg2> type;\n};\n\ninline policy<> make_policy()\n{ return policy<>(); }\n\ntemplate <class A1>\ninline typename normalise<policy<>, A1>::type make_policy(const A1&)\n{ \n   typedef typename normalise<policy<>, A1>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2>\ninline typename normalise<policy<>, A1, A2>::type make_policy(const A1&, const A2&)\n{ \n   typedef typename normalise<policy<>, A1, A2>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3>\ninline typename normalise<policy<>, A1, A2, A3>::type make_policy(const A1&, const A2&, const A3&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4>\ninline typename normalise<policy<>, A1, A2, A3, A4>::type make_policy(const A1&, const A2&, const A3&, const A4&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6, class A7>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&)\n{ \n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10>::type result_type;\n   return result_type(); \n}\n\ntemplate <class A1, class A2, class A3, class A4, class A5, class A6, class A7, class A8, class A9, class A10, class A11>\ninline typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type make_policy(const A1&, const A2&, const A3&, const A4&, const A5&, const A6&, const A7&, const A8&, const A9&, const A10&, const A11&)\n{\n   typedef typename normalise<policy<>, A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11>::type result_type;\n   return result_type();\n}\n\n//\n// Traits class to handle internal promotion:\n//\ntemplate <class Real, class Policy>\nstruct evaluation\n{\n   typedef Real type;\n};\n\ntemplate <class Policy>\nstruct evaluation<float, Policy>\n{\n   typedef typename mpl::if_<typename Policy::promote_float_type, double, float>::type type;\n};\n\ntemplate <class Policy>\nstruct evaluation<double, Policy>\n{\n   typedef typename mpl::if_<typename Policy::promote_double_type, long double, double>::type type;\n};\n\n#ifdef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n\ntemplate <class Real>\nstruct basic_digits : public mpl::int_<0>{ };\ntemplate <>\nstruct basic_digits<float> : public mpl::int_<FLT_MANT_DIG>{ };\ntemplate <>\nstruct basic_digits<double> : public mpl::int_<DBL_MANT_DIG>{ };\ntemplate <>\nstruct basic_digits<long double> : public mpl::int_<LDBL_MANT_DIG>{ };\n\ntemplate <class Real, class Policy>\nstruct precision\n{\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<Real>::radix == 2);\n   typedef typename Policy::precision_type precision_type;\n   typedef basic_digits<Real> digits_t;\n   typedef typename mpl::if_<\n      mpl::equal_to<digits_t, mpl::int_<0> >,\n      // Possibly unknown precision:\n      precision_type,\n      typename mpl::if_<\n         mpl::or_<mpl::less_equal<digits_t, precision_type>, mpl::less_equal<precision_type, mpl::int_<0> > >,\n         // Default case, full precision for RealType:\n         digits2< ::std::numeric_limits<Real>::digits>,\n         // User customised precision:\n         precision_type\n      >::type\n   >::type type;\n};\n\ntemplate <class Policy>\nstruct precision<float, Policy>\n{\n   typedef digits2<FLT_MANT_DIG> type;\n};\ntemplate <class Policy>\nstruct precision<double, Policy>\n{\n   typedef digits2<DBL_MANT_DIG> type;\n};\ntemplate <class Policy>\nstruct precision<long double, Policy>\n{\n   typedef digits2<LDBL_MANT_DIG> type;\n};\n\n#else\n\ntemplate <class Real, class Policy>\nstruct precision\n{\n   BOOST_STATIC_ASSERT((::std::numeric_limits<Real>::radix == 2) || ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)));\n#ifndef __BORLANDC__\n   typedef typename Policy::precision_type precision_type;\n   typedef typename mpl::if_c<\n      ((::std::numeric_limits<Real>::is_specialized == 0) || (::std::numeric_limits<Real>::digits == 0)),\n      // Possibly unknown precision:\n      precision_type,\n      typename mpl::if_c<\n         ((::std::numeric_limits<Real>::digits <= precision_type::value) \n         || (Policy::precision_type::value <= 0)),\n         // Default case, full precision for RealType:\n         digits2< ::std::numeric_limits<Real>::digits>,\n         // User customised precision:\n         precision_type\n      >::type\n   >::type type;\n#else\n   typedef typename Policy::precision_type precision_type;\n   typedef mpl::int_< ::std::numeric_limits<Real>::digits> digits_t;\n   typedef mpl::bool_< ::std::numeric_limits<Real>::is_specialized> spec_t;\n   typedef typename mpl::if_<\n      mpl::or_<mpl::equal_to<spec_t, mpl::false_>, mpl::equal_to<digits_t, mpl::int_<0> > >,\n      // Possibly unknown precision:\n      precision_type,\n      typename mpl::if_<\n         mpl::or_<mpl::less_equal<digits_t, precision_type>, mpl::less_equal<precision_type, mpl::int_<0> > >,\n         // Default case, full precision for RealType:\n         digits2< ::std::numeric_limits<Real>::digits>,\n         // User customised precision:\n         precision_type\n      >::type\n   >::type type;\n#endif\n};\n\n#endif\n\n#ifdef BOOST_MATH_USE_FLOAT128\n\ntemplate <class Policy>\nstruct precision<__float128, Policy>\n{\n   typedef mpl::int_<113> type;\n};\n\n#endif\n\nnamespace detail{\n\ntemplate <class T, class Policy>\ninline int digits_imp(mpl::true_ const&)\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n#endif\n   typedef typename boost::math::policies::precision<T, Policy>::type p_t;\n   return p_t::value;\n}\n\ntemplate <class T, class Policy>\ninline int digits_imp(mpl::false_ const&)\n{\n   return tools::digits<T>();\n}\n\n} // namespace detail\n\ntemplate <class T, class Policy>\ninline int digits(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   typedef mpl::bool_< std::numeric_limits<T>::is_specialized > tag_type;\n   return detail::digits_imp<T, Policy>(tag_type());\n}\n\ntemplate <class Policy>\ninline unsigned long get_max_series_iterations()\n{\n   typedef typename Policy::max_series_iterations_type iter_type;\n   return iter_type::value;\n}\n\ntemplate <class Policy>\ninline unsigned long get_max_root_iterations()\n{\n   typedef typename Policy::max_root_iterations_type iter_type;\n   return iter_type::value;\n}\n\nnamespace detail{\n\ntemplate <class T, class Digits, class Small, class Default>\nstruct series_factor_calc\n{\n   static T get()\n   {\n      return ldexp(T(1.0), 1 - Digits::value);\n   }\n};\n\ntemplate <class T, class Digits>\nstruct series_factor_calc<T, Digits, mpl::true_, mpl::true_>\n{\n   static T get()\n   {\n      return boost::math::tools::epsilon<T>();\n   }\n};\ntemplate <class T, class Digits>\nstruct series_factor_calc<T, Digits, mpl::true_, mpl::false_>\n{\n   static T get()\n   {\n      static const boost::uintmax_t v = static_cast<boost::uintmax_t>(1u) << (Digits::value - 1);\n      return 1 / static_cast<T>(v);\n   }\n};\ntemplate <class T, class Digits>\nstruct series_factor_calc<T, Digits, mpl::false_, mpl::true_>\n{\n   static T get()\n   {\n      return boost::math::tools::epsilon<T>();\n   }\n};\n\ntemplate <class T, class Policy>\ninline T get_epsilon_imp(mpl::true_ const&)\n{\n#ifndef BOOST_NO_LIMITS_COMPILE_TIME_CONSTANTS\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::is_specialized);\n   BOOST_STATIC_ASSERT( ::std::numeric_limits<T>::radix == 2);\n#else\n   BOOST_ASSERT(::std::numeric_limits<T>::is_specialized);\n   BOOST_ASSERT(::std::numeric_limits<T>::radix == 2);\n#endif\n   typedef typename boost::math::policies::precision<T, Policy>::type p_t;\n   typedef mpl::bool_<p_t::value <= std::numeric_limits<boost::uintmax_t>::digits> is_small_int;\n   typedef mpl::bool_<p_t::value >= std::numeric_limits<T>::digits> is_default_value;\n   return series_factor_calc<T, p_t, is_small_int, is_default_value>::get();\n}\n\ntemplate <class T, class Policy>\ninline T get_epsilon_imp(mpl::false_ const&)\n{\n   return tools::epsilon<T>();\n}\n\n} // namespace detail\n\ntemplate <class T, class Policy>\ninline T get_epsilon(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE(T))\n{\n   typedef mpl::bool_< (std::numeric_limits<T>::is_specialized && (std::numeric_limits<T>::radix == 2)) > tag_type;\n   return detail::get_epsilon_imp<T, Policy>(tag_type());\n}\n\nnamespace detail{\n\ntemplate <class A1, \n          class A2, \n          class A3,\n          class A4,\n          class A5,\n          class A6,\n          class A7,\n          class A8,\n          class A9,\n          class A10,\n          class A11>\nchar test_is_policy(const policy<A1,A2,A3,A4,A5,A6,A7,A8,A9,A10,A11>*);\ndouble test_is_policy(...);\n\ntemplate <class P>\nstruct is_policy_imp\n{\n   BOOST_STATIC_CONSTANT(bool, value = (sizeof(::boost::math::policies::detail::test_is_policy(static_cast<P*>(0))) == 1));\n};\n\n}\n\ntemplate <class P>\nstruct is_policy : public mpl::bool_< ::boost::math::policies::detail::is_policy_imp<P>::value> {};\n\n//\n// Helper traits class for distribution error handling:\n//\ntemplate <class Policy>\nstruct constructor_error_check\n{\n   typedef typename Policy::domain_error_type domain_error_type;\n   typedef typename mpl::if_c<\n      (domain_error_type::value == throw_on_error) || (domain_error_type::value == user_error),\n      mpl::true_,\n      mpl::false_>::type type;\n};\n\ntemplate <class Policy>\nstruct method_error_check\n{\n   typedef typename Policy::domain_error_type domain_error_type;\n   typedef typename mpl::if_c<\n      (domain_error_type::value == throw_on_error) && (domain_error_type::value != user_error),\n      mpl::false_,\n      mpl::true_>::type type;\n};\n\n}}} // namespaces\n\n#endif // BOOST_MATH_POLICY_HPP\n\n\n\n","\n// ----------------------------------------------------------------------------\n// group.hpp :  encapsulates a group of manipulators along with an argument\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n                      \n// group_head : cut the last element of a group out.\n// (is overloaded below on each type of group)\n\n// group_last : returns the last element of a group\n// (is overloaded below on each type of group)\n// ----------------------------------------------------------------------------\n\n\n#ifndef BOOST_FORMAT_GROUP_HPP\n#define BOOST_FORMAT_GROUP_HPP\n\n#include <boost/config.hpp>\n\n\nnamespace boost {\nnamespace io {\n\n\nnamespace detail {\n\n\n// empty group, but useful even though.\nstruct group0 \n{\n    group0()      {}\n};\n\ntemplate <class Ch, class Tr>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << ( BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group0& )\n{ \n   return os; \n}\n\ntemplate <class T1>\nstruct group1\n{\n    T1 a1_;\n    group1(T1 a1)\n      : a1_(a1)\n      {}\nprivate:\n   group1& operator=(const group1&);\n};\n\ntemplate <class Ch, class Tr, class T1>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group1<T1>& x)\n{ \n   os << x.a1_;  \n   return os; \n}\n\n\n\n\ntemplate <class T1,class T2>\nstruct group2\n{\n    T1 a1_;\n    T2 a2_;\n    group2(T1 a1,T2 a2)\n      : a1_(a1),a2_(a2)\n      {}\nprivate:\n   group2& operator=(const group2&);\n};\n\ntemplate <class Ch, class Tr, class T1,class T2>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group2<T1,T2>& x)\n{ \n   os << x.a1_<< x.a2_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3>\nstruct group3\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    group3(T1 a1,T2 a2,T3 a3)\n      : a1_(a1),a2_(a2),a3_(a3)\n      {}\nprivate:\n   group3& operator=(const group3&);\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group3<T1,T2,T3>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4>\nstruct group4\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    group4(T1 a1,T2 a2,T3 a3,T4 a4)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4)\n      {}\nprivate:\n   group4& operator=(const group4&);\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group4<T1,T2,T3,T4>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5>\nstruct group5\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    group5(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group5<T1,T2,T3,T4,T5>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6>\nstruct group6\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    T6 a6_;\n    group6(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group6<T1,T2,T3,T4,T5,T6>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7>\nstruct group7\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    T6 a6_;\n    T7 a7_;\n    group7(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group7<T1,T2,T3,T4,T5,T6,T7>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>\nstruct group8\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    T6 a6_;\n    T7 a7_;\n    T8 a8_;\n    group8(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group8<T1,T2,T3,T4,T5,T6,T7,T8>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>\nstruct group9\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    T6 a6_;\n    T7 a7_;\n    T8 a8_;\n    T9 a9_;\n    group9(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group9<T1,T2,T3,T4,T5,T6,T7,T8,T9>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_;  \n   return os; \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>\nstruct group10\n{\n    T1 a1_;\n    T2 a2_;\n    T3 a3_;\n    T4 a4_;\n    T5 a5_;\n    T6 a6_;\n    T7 a7_;\n    T8 a8_;\n    T9 a9_;\n    T10 a10_;\n    group10(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9,T10 a10)\n      : a1_(a1),a2_(a2),a3_(a3),a4_(a4),a5_(a5),a6_(a6),a7_(a7),a8_(a8),a9_(a9),a10_(a10)\n      {}\n};\n\ntemplate <class Ch, class Tr, class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>\ninline\nBOOST_IO_STD basic_ostream<Ch, Tr>&\noperator << (BOOST_IO_STD basic_ostream<Ch, Tr>& os,\n             const group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10>& x)\n{ \n   os << x.a1_<< x.a2_<< x.a3_<< x.a4_<< x.a5_<< x.a6_<< x.a7_<< x.a8_<< x.a9_<< x.a10_;  \n   return os; \n}\n\n\n\n\ntemplate <class T1,class T2>\ninline\ngroup1<T1> \ngroup_head( group2<T1,T2> const& x)\n{\n   return group1<T1> (x.a1_); \n}\n\ntemplate <class T1,class T2>\ninline\ngroup1<T2> \ngroup_last( group2<T1,T2> const& x)\n{\n   return group1<T2> (x.a2_); \n}\n\n\n\ntemplate <class T1,class T2,class T3>\ninline\ngroup2<T1,T2> \ngroup_head( group3<T1,T2,T3> const& x)\n{\n   return group2<T1,T2> (x.a1_,x.a2_); \n}\n\ntemplate <class T1,class T2,class T3>\ninline\ngroup1<T3> \ngroup_last( group3<T1,T2,T3> const& x)\n{\n   return group1<T3> (x.a3_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4>\ninline\ngroup3<T1,T2,T3> \ngroup_head( group4<T1,T2,T3,T4> const& x)\n{\n   return group3<T1,T2,T3> (x.a1_,x.a2_,x.a3_); \n}\n\ntemplate <class T1,class T2,class T3,class T4>\ninline\ngroup1<T4> \ngroup_last( group4<T1,T2,T3,T4> const& x)\n{\n   return group1<T4> (x.a4_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5>\ninline\ngroup4<T1,T2,T3,T4> \ngroup_head( group5<T1,T2,T3,T4,T5> const& x)\n{\n   return group4<T1,T2,T3,T4> (x.a1_,x.a2_,x.a3_,x.a4_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5>\ninline\ngroup1<T5> \ngroup_last( group5<T1,T2,T3,T4,T5> const& x)\n{\n   return group1<T5> (x.a5_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6>\ninline\ngroup5<T1,T2,T3,T4,T5> \ngroup_head( group6<T1,T2,T3,T4,T5,T6> const& x)\n{\n   return group5<T1,T2,T3,T4,T5> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6>\ninline\ngroup1<T6> \ngroup_last( group6<T1,T2,T3,T4,T5,T6> const& x)\n{\n   return group1<T6> (x.a6_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7>\ninline\ngroup6<T1,T2,T3,T4,T5,T6> \ngroup_head( group7<T1,T2,T3,T4,T5,T6,T7> const& x)\n{\n   return group6<T1,T2,T3,T4,T5,T6> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7>\ninline\ngroup1<T7> \ngroup_last( group7<T1,T2,T3,T4,T5,T6,T7> const& x)\n{\n   return group1<T7> (x.a7_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>\ninline\ngroup7<T1,T2,T3,T4,T5,T6,T7> \ngroup_head( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)\n{\n   return group7<T1,T2,T3,T4,T5,T6,T7> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8>\ninline\ngroup1<T8> \ngroup_last( group8<T1,T2,T3,T4,T5,T6,T7,T8> const& x)\n{\n   return group1<T8> (x.a8_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>\ninline\ngroup8<T1,T2,T3,T4,T5,T6,T7,T8> \ngroup_head( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)\n{\n   return group8<T1,T2,T3,T4,T5,T6,T7,T8> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9>\ninline\ngroup1<T9> \ngroup_last( group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> const& x)\n{\n   return group1<T9> (x.a9_); \n}\n\n\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>\ninline\ngroup9<T1,T2,T3,T4,T5,T6,T7,T8,T9> \ngroup_head( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)\n{\n   return group9<T1,T2,T3,T4,T5,T6,T7,T8,T9> (x.a1_,x.a2_,x.a3_,x.a4_,x.a5_,x.a6_,x.a7_,x.a8_,x.a9_); \n}\n\ntemplate <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9,class T10>\ninline\ngroup1<T10> \ngroup_last( group10<T1,T2,T3,T4,T5,T6,T7,T8,T9,T10> const& x)\n{\n   return group1<T10> (x.a10_); \n}\n\n\n\n\n\n} // namespace detail\n\n\n\n// helper functions\n\n\ninline detail::group1< detail::group0 >  \ngroup() { return detail::group1< detail::group0 > ( detail::group0() ); }\n\ntemplate  <class T1, class Var> \ninline\ndetail::group1< detail::group2<T1, Var const&> >\n  group(T1 a1, Var const& var)\n{ \n   return detail::group1< detail::group2<T1, Var const&> >\n                   ( detail::group2<T1, Var const&> \n                        (a1, var) \n                  );\n}\n\ntemplate  <class T1,class T2, class Var> \ninline\ndetail::group1< detail::group3<T1,T2, Var const&> >\n  group(T1 a1,T2 a2, Var const& var)\n{ \n   return detail::group1< detail::group3<T1,T2, Var const&> >\n                   ( detail::group3<T1,T2, Var const&> \n                        (a1,a2, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3, class Var> \ninline\ndetail::group1< detail::group4<T1,T2,T3, Var const&> >\n  group(T1 a1,T2 a2,T3 a3, Var const& var)\n{ \n   return detail::group1< detail::group4<T1,T2,T3, Var const&> >\n                   ( detail::group4<T1,T2,T3, Var const&> \n                        (a1,a2,a3, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4, class Var> \ninline\ndetail::group1< detail::group5<T1,T2,T3,T4, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4, Var const& var)\n{ \n   return detail::group1< detail::group5<T1,T2,T3,T4, Var const&> >\n                   ( detail::group5<T1,T2,T3,T4, Var const&> \n                        (a1,a2,a3,a4, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5, class Var> \ninline\ndetail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var const& var)\n{ \n   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var const&> >\n                   ( detail::group6<T1,T2,T3,T4,T5, Var const&> \n                        (a1,a2,a3,a4,a5, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6, class Var> \ninline\ndetail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var const& var)\n{ \n   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var const&> >\n                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var const&> \n                        (a1,a2,a3,a4,a5,a6, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var> \ninline\ndetail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var const& var)\n{ \n   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> >\n                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var const&> \n                        (a1,a2,a3,a4,a5,a6,a7, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var> \ninline\ndetail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var const& var)\n{ \n   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> >\n                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var const&> \n                        (a1,a2,a3,a4,a5,a6,a7,a8, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var> \ninline\ndetail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var const& var)\n{ \n   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> >\n                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var const&> \n                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var) \n                  );\n}\n\n\n#ifndef BOOST_NO_OVERLOAD_FOR_NON_CONST\n\ntemplate  <class T1, class Var> \ninline\ndetail::group1< detail::group2<T1, Var&> >\n  group(T1 a1, Var& var)\n{ \n   return detail::group1< detail::group2<T1, Var&> >\n                   ( detail::group2<T1, Var&> \n                        (a1, var) \n                  );\n}\n\ntemplate  <class T1,class T2, class Var> \ninline\ndetail::group1< detail::group3<T1,T2, Var&> >\n  group(T1 a1,T2 a2, Var& var)\n{ \n   return detail::group1< detail::group3<T1,T2, Var&> >\n                   ( detail::group3<T1,T2, Var&> \n                        (a1,a2, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3, class Var> \ninline\ndetail::group1< detail::group4<T1,T2,T3, Var&> >\n  group(T1 a1,T2 a2,T3 a3, Var& var)\n{ \n   return detail::group1< detail::group4<T1,T2,T3, Var&> >\n                   ( detail::group4<T1,T2,T3, Var&> \n                        (a1,a2,a3, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4, class Var> \ninline\ndetail::group1< detail::group5<T1,T2,T3,T4, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4, Var& var)\n{ \n   return detail::group1< detail::group5<T1,T2,T3,T4, Var&> >\n                   ( detail::group5<T1,T2,T3,T4, Var&> \n                        (a1,a2,a3,a4, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5, class Var> \ninline\ndetail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5, Var& var)\n{ \n   return detail::group1< detail::group6<T1,T2,T3,T4,T5, Var&> >\n                   ( detail::group6<T1,T2,T3,T4,T5, Var&> \n                        (a1,a2,a3,a4,a5, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6, class Var> \ninline\ndetail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6, Var& var)\n{ \n   return detail::group1< detail::group7<T1,T2,T3,T4,T5,T6, Var&> >\n                   ( detail::group7<T1,T2,T3,T4,T5,T6, Var&> \n                        (a1,a2,a3,a4,a5,a6, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7, class Var> \ninline\ndetail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7, Var& var)\n{ \n   return detail::group1< detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> >\n                   ( detail::group8<T1,T2,T3,T4,T5,T6,T7, Var&> \n                        (a1,a2,a3,a4,a5,a6,a7, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8, class Var> \ninline\ndetail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8, Var& var)\n{ \n   return detail::group1< detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> >\n                   ( detail::group9<T1,T2,T3,T4,T5,T6,T7,T8, Var&> \n                        (a1,a2,a3,a4,a5,a6,a7,a8, var) \n                  );\n}\n\ntemplate  <class T1,class T2,class T3,class T4,class T5,class T6,class T7,class T8,class T9, class Var> \ninline\ndetail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >\n  group(T1 a1,T2 a2,T3 a3,T4 a4,T5 a5,T6 a6,T7 a7,T8 a8,T9 a9, Var& var)\n{ \n   return detail::group1< detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> >\n                   ( detail::group10<T1,T2,T3,T4,T5,T6,T7,T8,T9, Var&> \n                        (a1,a2,a3,a4,a5,a6,a7,a8,a9, var) \n                  );\n}\n\n\n#endif  // - BOOST_NO_OVERLOAD_FOR_NON_CONST\n\n\n} // namespace io\n\n} // namespace boost\n\n\n#endif   // BOOST_FORMAT_GROUP_HPP\n","// -*- C++ -*-\n//===--------------------------- iomanip ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOMANIP\n#define _LIBCPP_IOMANIP\n\n/*\n    iomanip synopsis\n\nnamespace std {\n\n// types T1, T2, ... are unspecified implementation types\nT1 resetiosflags(ios_base::fmtflags mask);\nT2 setiosflags (ios_base::fmtflags mask);\nT3 setbase(int base);\ntemplate<charT> T4 setfill(charT c);\nT5 setprecision(int n);\nT6 setw(int n);\ntemplate <class moneyT> T7 get_money(moneyT& mon, bool intl = false);\ntemplate <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);\ntemplate <class charT> T9 get_time(struct tm* tmb, const charT* fmt);\ntemplate <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);\n\ntemplate <class charT>\n  T11 quoted(const charT* s, charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T12 quoted(const basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T13 quoted(basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <istream>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// resetiosflags\n\nclass __iom_t1\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)\n    {\n        __is.unsetf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)\n    {\n        __os.unsetf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t1\nresetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t1(__mask);\n}\n\n// setiosflags\n\nclass __iom_t2\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)\n    {\n        __is.setf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)\n    {\n        __os.setf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t2\nsetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t2(__mask);\n}\n\n// setbase\n\nclass __iom_t3\n{\n    int __base_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t3(int __b) : __base_(__b) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)\n    {\n        __is.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)\n    {\n        __os.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t3\nsetbase(int __base)\n{\n    return __iom_t3(__base);\n}\n\n// setfill\n\ntemplate<class _CharT>\nclass __iom_t4\n{\n    _CharT __fill_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t4(_CharT __c) : __fill_(__c) {}\n\n    template <class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)\n    {\n        __os.fill(__x.__fill_);\n        return __os;\n    }\n};\n\ntemplate<class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t4<_CharT>\nsetfill(_CharT __c)\n{\n    return __iom_t4<_CharT>(__c);\n}\n\n// setprecision\n\nclass __iom_t5\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t5(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)\n    {\n        __is.precision(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)\n    {\n        __os.precision(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t5\nsetprecision(int __n)\n{\n    return __iom_t5(__n);\n}\n\n// setw\n\nclass __iom_t6\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t6(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)\n    {\n        __is.width(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)\n    {\n        __os.width(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t6\nsetw(int __n)\n{\n    return __iom_t6(__n);\n}\n\n// get_money\n\ntemplate <class _MoneyT> class __iom_t7;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t7\n{\n    _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t7(_MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef money_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __mf = use_facet<_Fp>(__is.getloc());\n            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t7<_MoneyT>\nget_money(_MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t7<_MoneyT>(__mon, __intl);\n}\n\n// put_money\n\ntemplate <class _MoneyT> class __iom_t8;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t8\n{\n    const _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t8(const _MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef money_put<_CharT, _Op> _Fp;\n            const _Fp& __mf = use_facet<_Fp>(__os.getloc());\n            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t8<_MoneyT>\nput_money(const _MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t8<_MoneyT>(__mon, __intl);\n}\n\n// get_time\n\ntemplate <class _CharT> class __iom_t9;\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t9\n{\n    tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t9(tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_istream<_Cp, _Traits>&\n    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef time_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __tf = use_facet<_Fp>(__is.getloc());\n            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,\n                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t9<_CharT>\nget_time(tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t9<_CharT>(__tm, __fmt);\n}\n\n// put_time\n\ntemplate <class _CharT> class __iom_t10;\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t10\n{\n    const tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t10(const tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_ostream<_Cp, _Traits>&\n    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef time_put<_CharT, _Op> _Fp;\n            const _Fp& __tf = use_facet<_Fp>(__os.getloc());\n            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,\n                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t10<_CharT>\nput_time(const tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t10<_CharT>(__tm, __fmt);\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _CharT, class _Traits, class _ForwardIterator>\nstd::basic_ostream<_CharT, _Traits> &\n__quoted_output ( basic_ostream<_CharT, _Traits> &__os, \n        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )\n{\n    __os << __delim;\n    for ( ; __first != __last; ++ __first )\n    {\n        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))\n            __os << __escape;\n        __os << *__first;\n    }\n    __os << __delim;\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits, class _String>\nbasic_istream<_CharT, _Traits> &\n__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )\n{\n    __string.clear ();\n    _CharT __c;\n    __is >> __c;\n    if ( __is.fail ())\n        return __is;\n\n    if (!_Traits::eq (__c, __delim))    // no delimiter, read the whole string\n    {\n        __is.unget ();\n        __is >> __string;\n        return __is;\n    }\n\n    __save_flags<_CharT, _Traits> sf(__is);\n    noskipws (__is);\n    while (true)\n        {\n        __is >> __c;\n        if ( __is.fail ())\n            break;\n        if (_Traits::eq (__c, __escape))\n        {\n            __is >> __c;\n            if ( __is.fail ())\n                break;\n        }\n        else if (_Traits::eq (__c, __delim))\n            break;\n        __string.push_back ( __c );\n        }\n    return __is;\n}\n\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT>>\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\ntemplate <class _CharT, class _Traits, class _Iter>\nbasic_ostream<_CharT, _Traits>& operator<<(\n         basic_ostream<_CharT, _Traits>& __os, \n         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nstruct __quoted_proxy\n{\n    basic_string<_CharT, _Traits, _Allocator> &__string;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)\n    : __string(__s), __delim(__d), __escape(__e) {}\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>& operator<<(\n        basic_ostream<_CharT, _Traits>& __os, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);\n}\n\n//  extractor for non-const basic_string& proxies\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>& operator>>(\n        basic_istream<_CharT, _Traits>& __is, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );\n}\n\n\ntemplate <class _CharT>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, const _CharT *>\nquoted ( const _CharT *__s, _CharT __delim = _CharT('\"'), _CharT __escape =_CharT('\\\\'))\n{\n    const _CharT *__end = __s;\n    while ( *__end ) ++__end;\n    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\nquoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_output_proxy<_CharT, \n            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator> \n                    ( __s.cbegin(), __s.cend (), __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n__quoted_proxy<_CharT, _Traits, _Allocator>\nquoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOMANIP\n","// -*- C++ -*-\n//===--------------------------- stdexcept --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STDEXCEPT\n#define _LIBCPP_STDEXCEPT\n\n/*\n    stdexcept synopsis\n\nnamespace std\n{\n\nclass logic_error;\n    class domain_error;\n    class invalid_argument;\n    class length_error;\n    class out_of_range;\nclass runtime_error;\n    class range_error;\n    class overflow_error;\n    class underflow_error;\n\nfor each class xxx_error:\n\nclass xxx_error : public exception // at least indirectly\n{\npublic:\n    explicit xxx_error(const string& what_arg);\n    explicit xxx_error(const char*   what_arg);\n\n    virtual const char* what() const noexcept // returns what_arg\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <iosfwd>  // for string forward decl\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI logic_error\n    : public exception\n{\nprivate:\n    void* __imp_;\npublic:\n    explicit logic_error(const string&);\n    explicit logic_error(const char*);\n\n    logic_error(const logic_error&) _NOEXCEPT;\n    logic_error& operator=(const logic_error&) _NOEXCEPT;\n\n    virtual ~logic_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI runtime_error\n    : public exception\n{\nprivate:\n    void* __imp_;\npublic:\n    explicit runtime_error(const string&);\n    explicit runtime_error(const char*);\n\n    runtime_error(const runtime_error&) _NOEXCEPT;\n    runtime_error& operator=(const runtime_error&) _NOEXCEPT;\n\n    virtual ~runtime_error() _NOEXCEPT;\n\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI domain_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit domain_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~domain_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI invalid_argument\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit invalid_argument(const char* __s)   : logic_error(__s) {}\n\n    virtual ~invalid_argument() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI length_error\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit length_error(const char* __s)   : logic_error(__s) {}\n\n    virtual ~length_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI out_of_range\n    : public logic_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const string& __s) : logic_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit out_of_range(const char* __s)   : logic_error(__s) {}\n\n    virtual ~out_of_range() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI range_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit range_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~range_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI overflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit overflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~overflow_error() _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI underflow_error\n    : public runtime_error\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const string& __s) : runtime_error(__s) {}\n    _LIBCPP_INLINE_VISIBILITY explicit underflow_error(const char* __s)   : runtime_error(__s) {}\n\n    virtual ~underflow_error() _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // _LIBCPP_STDEXCEPT\n","#ifndef UUID_AA15E74A856F11E08B8D93F24824019B\n#define UUID_AA15E74A856F11E08B8D93F24824019B\n#if (__GNUC__*100+__GNUC_MINOR__>301) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma GCC system_header\n#endif\n#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma warning(push,1)\n#endif\n\n// MS compatible compilers support #pragma once\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n//\n//  boost/throw_exception.hpp\n//\n//  Copyright (c) 2002 Peter Dimov and Multi Media Ltd.\n//  Copyright (c) 2008-2009 Emil Dotchevski and Reverge Studios, Inc.\n//\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n//  http://www.boost.org/libs/utility/throw_exception.html\n//\n\n#include <boost/exception/detail/attribute_noreturn.hpp>\n#include <boost/detail/workaround.hpp>\n#include <boost/config.hpp>\n#include <exception>\n\n#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( __BORLANDC__ ) && BOOST_WORKAROUND( __BORLANDC__, BOOST_TESTED_AT(0x593) )\n# define BOOST_EXCEPTION_DISABLE\n#endif\n\n#if !defined( BOOST_EXCEPTION_DISABLE ) && defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, < 1310 )\n# define BOOST_EXCEPTION_DISABLE\n#endif\n\n#if !defined( BOOST_EXCEPTION_DISABLE )\n# include <boost/exception/exception.hpp>\n#if !defined(BOOST_THROW_EXCEPTION_CURRENT_FUNCTION)\n# include <boost/current_function.hpp>\n# define BOOST_THROW_EXCEPTION_CURRENT_FUNCTION BOOST_CURRENT_FUNCTION\n#endif\n# define BOOST_THROW_EXCEPTION(x) ::boost::exception_detail::throw_exception_(x,BOOST_THROW_EXCEPTION_CURRENT_FUNCTION,__FILE__,__LINE__)\n#else\n# define BOOST_THROW_EXCEPTION(x) ::boost::throw_exception(x)\n#endif\n\nnamespace boost\n{\n#ifdef BOOST_NO_EXCEPTIONS\n\nvoid throw_exception( std::exception const & e ); // user defined\n\n#else\n\ninline void throw_exception_assert_compatibility( std::exception const & ) { }\n\ntemplate<class E> BOOST_ATTRIBUTE_NORETURN inline void throw_exception( E const & e )\n{\n    //All boost exceptions are required to derive from std::exception,\n    //to ensure compatibility with BOOST_NO_EXCEPTIONS.\n    throw_exception_assert_compatibility(e);\n\n#ifndef BOOST_EXCEPTION_DISABLE\n    throw enable_current_exception(enable_error_info(e));\n#else\n    throw e;\n#endif\n}\n\n#endif\n\n#if !defined( BOOST_EXCEPTION_DISABLE )\n    namespace\n    exception_detail\n    {\n        template <class E>\n        BOOST_ATTRIBUTE_NORETURN\n        void\n        throw_exception_( E const & x, char const * current_function, char const * file, int line )\n        {\n            boost::throw_exception(\n                set_info(\n                    set_info(\n                        set_info(\n                            enable_error_info(x),\n                            throw_function(current_function)),\n                        throw_file(file)),\n                    throw_line(line)));\n        }\n    }\n#endif\n} // namespace boost\n\n#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma warning(pop)\n#endif\n#endif\n","//Copyright (c) 2006-2009 Emil Dotchevski and Reverge Studios, Inc.\n\n//Distributed under the Boost Software License, Version 1.0. (See accompanying\n//file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef UUID_274DA366004E11DCB1DDFE2E56D89593\n#define UUID_274DA366004E11DCB1DDFE2E56D89593\n#if (__GNUC__*100+__GNUC_MINOR__>301) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma GCC system_header\n#endif\n#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma warning(push,1)\n#endif\n\nnamespace\nboost\n    {\n    namespace\n    exception_detail\n        {\n        template <class T>\n        class\n        refcount_ptr\n            {\n            public:\n\n            refcount_ptr():\n                px_(0)\n                {\n                }\n\n            ~refcount_ptr()\n                {\n                release();\n                }\n\n            refcount_ptr( refcount_ptr const & x ):\n                px_(x.px_)\n                {\n                add_ref();\n                }\n\n            refcount_ptr &\n            operator=( refcount_ptr const & x )\n                {\n                adopt(x.px_);\n                return *this;\n                }\n\n            void\n            adopt( T * px )\n                {\n                release();\n                px_=px;\n                add_ref();\n                }\n\n            T *\n            get() const\n                {\n                return px_;\n                }\n\n            private:\n\n            T * px_;\n\n            void\n            add_ref()\n                {\n                if( px_ )\n                    px_->add_ref();\n                }\n\n            void\n            release()\n                {\n                if( px_ && px_->release() )\n                    px_=0;\n                }\n            };\n        }\n\n    ////////////////////////////////////////////////////////////////////////\n\n    template <class Tag,class T>\n    class error_info;\n\n    typedef error_info<struct throw_function_,char const *> throw_function;\n    typedef error_info<struct throw_file_,char const *> throw_file;\n    typedef error_info<struct throw_line_,int> throw_line;\n\n    template <>\n    class\n    error_info<throw_function_,char const *>\n        {\n        public:\n        typedef char const * value_type;\n        value_type v_;\n        explicit\n        error_info( value_type v ):\n            v_(v)\n            {\n            }\n        };\n\n    template <>\n    class\n    error_info<throw_file_,char const *>\n        {\n        public:\n        typedef char const * value_type;\n        value_type v_;\n        explicit\n        error_info( value_type v ):\n            v_(v)\n            {\n            }\n        };\n\n    template <>\n    class\n    error_info<throw_line_,int>\n        {\n        public:\n        typedef int value_type;\n        value_type v_;\n        explicit\n        error_info( value_type v ):\n            v_(v)\n            {\n            }\n        };\n\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility push (default)\n# endif\n#endif\n    class exception;\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility pop\n# endif\n#endif\n\n    template <class T>\n    class shared_ptr;\n\n    namespace\n    exception_detail\n        {\n        class error_info_base;\n        struct type_info_;\n\n        struct\n        error_info_container\n            {\n            virtual char const * diagnostic_information( char const * ) const = 0;\n            virtual shared_ptr<error_info_base> get( type_info_ const & ) const = 0;\n            virtual void set( shared_ptr<error_info_base> const &, type_info_ const & ) = 0;\n            virtual void add_ref() const = 0;\n            virtual bool release() const = 0;\n            virtual refcount_ptr<exception_detail::error_info_container> clone() const = 0;\n\n            protected:\n\n            ~error_info_container() throw()\n                {\n                }\n            };\n\n        template <class>\n        struct get_info;\n\n        template <>\n        struct get_info<throw_function>;\n\n        template <>\n        struct get_info<throw_file>;\n\n        template <>\n        struct get_info<throw_line>;\n\n        char const * get_diagnostic_information( exception const &, char const * );\n\n        void copy_boost_exception( exception *, exception const * );\n\n        template <class E,class Tag,class T>\n        E const & set_info( E const &, error_info<Tag,T> const & );\n\n        template <class E>\n        E const & set_info( E const &, throw_function const & );\n\n        template <class E>\n        E const & set_info( E const &, throw_file const & );\n\n        template <class E>\n        E const & set_info( E const &, throw_line const & );\n        }\n\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility push (default)\n# endif\n#endif\n    class\n    exception\n        {\n        protected:\n\n        exception():\n            throw_function_(0),\n            throw_file_(0),\n            throw_line_(-1)\n            {\n            }\n\n#ifdef __HP_aCC\n        //On HP aCC, this protected copy constructor prevents throwing boost::exception.\n        //On all other platforms, the same effect is achieved by the pure virtual destructor.\n        exception( exception const & x ) throw():\n            data_(x.data_),\n            throw_function_(x.throw_function_),\n            throw_file_(x.throw_file_),\n            throw_line_(x.throw_line_)\n            {\n            }\n#endif\n\n        virtual ~exception() throw()\n#ifndef __HP_aCC\n            = 0 //Workaround for HP aCC, =0 incorrectly leads to link errors.\n#endif\n            ;\n\n#if (defined(__MWERKS__) && __MWERKS__<=0x3207) || (defined(_MSC_VER) && _MSC_VER<=1310)\n        public:\n#else\n        private:\n\n        template <class E>\n        friend E const & exception_detail::set_info( E const &, throw_function const & );\n\n        template <class E>\n        friend E const & exception_detail::set_info( E const &, throw_file const & );\n\n        template <class E>\n        friend E const & exception_detail::set_info( E const &, throw_line const & );\n\n        template <class E,class Tag,class T>\n        friend E const & exception_detail::set_info( E const &, error_info<Tag,T> const & );\n\n        friend char const * exception_detail::get_diagnostic_information( exception const &, char const * );\n\n        template <class>\n        friend struct exception_detail::get_info;\n        friend struct exception_detail::get_info<throw_function>;\n        friend struct exception_detail::get_info<throw_file>;\n        friend struct exception_detail::get_info<throw_line>;\n        friend void exception_detail::copy_boost_exception( exception *, exception const * );\n#endif\n        mutable exception_detail::refcount_ptr<exception_detail::error_info_container> data_;\n        mutable char const * throw_function_;\n        mutable char const * throw_file_;\n        mutable int throw_line_;\n        };\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility pop\n# endif\n#endif\n\n    inline\n    exception::\n    ~exception() throw()\n        {\n        }\n\n    namespace\n    exception_detail\n        {\n        template <class E>\n        E const &\n        set_info( E const & x, throw_function const & y )\n            {\n            x.throw_function_=y.v_;\n            return x;\n            }\n\n        template <class E>\n        E const &\n        set_info( E const & x, throw_file const & y )\n            {\n            x.throw_file_=y.v_;\n            return x;\n            }\n\n        template <class E>\n        E const &\n        set_info( E const & x, throw_line const & y )\n            {\n            x.throw_line_=y.v_;\n            return x;\n            }\n        }\n\n    ////////////////////////////////////////////////////////////////////////\n\n    namespace\n    exception_detail\n        {\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility push (default)\n# endif\n#endif\n        template <class T>\n        struct\n        error_info_injector:\n            public T,\n            public exception\n            {\n            explicit\n            error_info_injector( T const & x ):\n                T(x)\n                {\n                }\n\n            ~error_info_injector() throw()\n                {\n                }\n            };\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility pop\n# endif\n#endif\n\n        struct large_size { char c[256]; };\n        large_size dispatch_boost_exception( exception const * );\n\n        struct small_size { };\n        small_size dispatch_boost_exception( void const * );\n\n        template <class,int>\n        struct enable_error_info_helper;\n\n        template <class T>\n        struct\n        enable_error_info_helper<T,sizeof(large_size)>\n            {\n            typedef T type;\n            };\n\n        template <class T>\n        struct\n        enable_error_info_helper<T,sizeof(small_size)>\n            {\n            typedef error_info_injector<T> type;\n            };\n\n        template <class T>\n        struct\n        enable_error_info_return_type\n            {\n            typedef typename enable_error_info_helper<T,sizeof(exception_detail::dispatch_boost_exception(static_cast<T *>(0)))>::type type;\n            };\n        }\n\n    template <class T>\n    inline\n    typename\n    exception_detail::enable_error_info_return_type<T>::type\n    enable_error_info( T const & x )\n        {\n        typedef typename exception_detail::enable_error_info_return_type<T>::type rt;\n        return rt(x);\n        }\n\n    ////////////////////////////////////////////////////////////////////////\n\n    namespace\n    exception_detail\n        {\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility push (default)\n# endif\n#endif\n        class\n        clone_base\n            {\n            public:\n\n            virtual clone_base const * clone() const = 0;\n            virtual void rethrow() const = 0;\n\n            virtual\n            ~clone_base() throw()\n                {\n                }\n            };\n#if defined(__GNUC__)\n# if (__GNUC__ == 4 && __GNUC_MINOR__ >= 1) || (__GNUC__ > 4)\n#  pragma GCC visibility pop\n# endif\n#endif\n\n        inline\n        void\n        copy_boost_exception( exception * a, exception const * b )\n            {\n            refcount_ptr<error_info_container> data;\n            if( error_info_container * d=b->data_.get() )\n                data = d->clone();\n            a->throw_file_ = b->throw_file_;\n            a->throw_line_ = b->throw_line_;\n            a->throw_function_ = b->throw_function_;\n            a->data_ = data;\n            }\n\n        inline\n        void\n        copy_boost_exception( void *, void const * )\n            {\n            }\n\n        template <class T>\n        class\n        clone_impl:\n            public T,\n            public virtual clone_base\n            {\n            struct clone_tag { };\n            clone_impl( clone_impl const & x, clone_tag ):\n                T(x)\n                {\n                copy_boost_exception(this,&x);\n                }\n\n            public:\n\n            explicit\n            clone_impl( T const & x ):\n                T(x)\n                {\n                copy_boost_exception(this,&x);\n                }\n\n            ~clone_impl() throw()\n                {\n                }\n\n            private:\n\n            clone_base const *\n            clone() const\n                {\n                return new clone_impl(*this,clone_tag());\n                }\n\n            void\n            rethrow() const\n                {\n                throw*this;\n                }\n            };\n        }\n\n    template <class T>\n    inline\n    exception_detail::clone_impl<T>\n    enable_current_exception( T const & x )\n        {\n        return exception_detail::clone_impl<T>(x);\n        }\n    }\n\n#if defined(_MSC_VER) && !defined(BOOST_EXCEPTION_ENABLE_WARNINGS)\n#pragma warning(pop)\n#endif\n#endif\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"medial_axis_pocket.hpp\"\n\nnamespace ovd\n{\n\n/// the input graph should be a voronoi diagram passed through medial_axis_filter\nmedial_axis_pocket::medial_axis_pocket(HEGraph& gi): g(gi) {\n    BOOST_FOREACH( HEEdge e, g.edges() ) {\n        if ( g[e].valid && \n             g[e].type != LINESITE && \n             g[e].type != NULLEDGE && \n             g[e].type != OUTEDGE   ) {\n            ma_edges.push_back(e);\n            edata ed;\n            edge_data.insert( std::make_pair(e, ed ) );\n        }\n    }\n    current_edge = HEEdge();\n    max_width = 0.05;\n    debug = false;\n    //max_mic_count=300; // limit output size in debug mode\n}\n\n/// set the maximum cut width\nvoid medial_axis_pocket::set_width(double w) {max_width=w;}\n/// set debug mode\nvoid medial_axis_pocket::set_debug(bool b) {debug=b;}\n/// return output\n//medial_axis_pocket::MICList medial_axis_pocket::get_mic_list() {return mic_list;}\n/// return the algorithm output\nstd::vector<medial_axis_pocket::MICList> medial_axis_pocket::get_mic_components() {return ma_components;}\n\n/*\n/// run the algorithm (single connected component)\nvoid medial_axis_pocket::run() {\n    find_initial_mic();\n    while (find_next_mic()) {}\n    if (debug) std::cout << \"medial_axis_pocket::run() done. generated \" << mic_list.size() << \" MICs \\n\";\n}*/\n\n/// many component run\nvoid medial_axis_pocket::run() {\n    mic_list.clear();\n    while ( find_initial_mic() ) {\n        while (find_next_mic()) {}\n        if (debug) std::cout << \"medial_axis_pocket::run() component done. generated \" << mic_list.size() << \" MICs \\n\";\n        ma_components.push_back(mic_list);\n        mic_list.clear();\n    }\n    //if (debug) std::cout << \"medial_axis_pocket::run() component done. generated \" << mic_list.size() << \" MICs \\n\";\n    \n    if (debug) std::cout << \"medial_axis_pocket::run() all done. generated \" << ma_components.size() << \" components \\n\";\n\n}\n\n    \n/// find the largest MIC and add it to the output\nbool medial_axis_pocket::find_initial_mic() {\n    MIC mic;\n    // find the vertex with the maximum radius mic\n    double max_mic_radius(-1);\n    Point max_mic_pos(0,0);\n    HEVertex max_mic_vertex = HEVertex();\n    bool found(false);\n    BOOST_FOREACH( HEEdge e, ma_edges ) {\n        HEVertex src = g.source(e);\n        if ( !edge_data[e].done && g[src].dist() > max_mic_radius ) {\n            max_mic_radius = g[src].dist();\n            max_mic_pos = g[src].position; \n            max_mic_vertex = src;\n            found = true;\n        }\n    }\n    if (!found)\n        return false;\n        \n    if (debug) { std::cout << \"find_initial_mic() max mic is c=\"<< max_mic_pos << \" r=\" << max_mic_radius << \"\\n\"; }\n\n    mic.c2 = max_mic_pos;\n    mic.r2 = max_mic_radius;\n    mic.c1 = mic.c2;\n    mic.r1 = mic.r1;\n    current_u = 0;\n    current_radius = max_mic_radius;\n    current_center = max_mic_pos;\n    previous_branch_center = max_mic_pos;\n    previous_branch_radius = max_mic_radius;\n    mic.c_prev = max_mic_pos;\n    mic.r_prev = max_mic_radius;\n    // find the edge on which we start machining.\n    double max_adj_radius(-1);\n    BOOST_FOREACH( HEEdge e, g.out_edge_itr(max_mic_vertex) ) {\n        if ( (g[ g.target(e) ].dist() > max_adj_radius) && g[e].valid && g[e].type != OUTEDGE ) {\n            max_adj_radius = g[ g.target(e) ].dist();\n            current_edge = e;\n        }\n    }\n    // stash the other out-edges for visiting later\n    BOOST_FOREACH( HEEdge e, g.out_edge_itr(max_mic_vertex) ) {\n        if ( e != current_edge ) {\n            unvisited.push( branch_point(current_center, current_radius, e ) );\n        }\n    }\n    if (debug) { std::cout << \"find_initial_mic() start edge is: \"; g.print_edge(current_edge); }\n    new_branch=false;\n    mic.new_branch = new_branch;\n    mic_list.push_back(mic);\n    return true;\n}\n\n/// \\param p position of degree-3 branch\n/// \\param r clearance-disk radius\n/// \\param e edge on which to start machining\nmedial_axis_pocket::branch_point::branch_point(Point p, double r, HEEdge e) {\n    current_center = p;\n    current_radius = r;\n    next_edge = e;\n}\n        \n/// return true if next mic was found and added to list.\n/// false means end-of-operation\nbool medial_axis_pocket::find_next_mic() {\n    if ( current_edge == HEEdge() ) {\n        if (debug) std::cout << \"find_next_mic() end of operation. Nothing to do.\\n\";\n        return false;\n    }\n    //if ( debug && mic_list.size() > max_mic_count ) {\n    //    std::cout << \" max_mic_count reached. stopping.\\n\";\n    //    return false;\n    //}\n    // find a point on current-edge so that we get the desired \n    // cut-width\n    //  w_max = | c2 - c1 | + r2 - r1\n    \n    Point c2;\n    double r2;\n    boost::tie(c2,r2) = edge_point(current_edge, 1.0 );\n    double w_target = cut_width(current_center, current_radius, c2, r2); //( c2-c1 ).norm() + r2 - r1;\n\n    if ( w_target > max_width ) {\n        // since moving to the target vertex would give too large cut-width\n        // we search on the current edge for the next MIC\n        if (debug) {  std::cout << \" searching on the current edge \"; g.print_edge(current_edge); }\n        // find a point on the current edge\n        double next_u;\n        double next_radius; // = find_next_radius();\n        boost::tie(next_u,next_radius) = find_next_u();\n        if (debug) {  std::cout << \" next_radius = \" << next_radius << \"\\n\"; }\n        output_next_mic(next_u, next_radius, new_branch);\n        return true;\n    } else {\n        // moving to the target edge does not give a cut-width that is large enough\n        // we need to find a new edge for the next MIC\n        \n        // mark edge DONE. this means we have machined all MICs on this edge.\n        mark_done(current_edge);\n        if (debug) std::cout << \"find_next_mic() Finding new edge !\\n\";\n        \n        bool end_branch_mic;\n        boost::tie( current_edge, end_branch_mic) = find_next_edge(); // move to the next edge\n        if ( current_edge == HEEdge() ) { // invalid edge marks end of operation\n            if (debug)  std::cout << \"find_next_mic() end of operation.\\n\";\n            return false;\n        }\n        \n        if ( end_branch_mic ) {\n            if (debug)  std::cout << \"find_next_mic() end-of-branch MIC.\\n\";\n            // this is unreliable, so comment out for now\n            //output_next_mic(current_radius, false);\n            return true;\n        }\n        \n        double next_u;\n        double next_radius;\n        boost::tie(next_u,next_radius) = find_next_u();\n        if (new_branch) {\n            new_branch=false;\n            output_next_mic(next_u, next_radius, true);\n            return true;\n        } else {\n            output_next_mic(next_u, next_radius, false);\n            return true;\n        }\n    }\n}\n\n/// pop an unvisited edge from the stack\n/// or end-of-operation if the stack is empty\nHEEdge medial_axis_pocket::find_next_branch() {\n    if (unvisited.empty() ) {\n        if (debug) std::cout << \"find_next_branch(): no un-machined branches. end operation.\\n\";\n        return HEEdge();\n    } else {\n        branch_point out = unvisited.top();\n        if (debug) { std::cout << \"find_next_branch(): next branch is \"; g.print_edge(out.next_edge); }\n        unvisited.pop();\n        previous_branch_center = current_center;\n        previous_branch_radius = current_radius;            \n        current_center = out.current_center;\n        current_radius = out.current_radius;\n        new_branch = true;\n        if ( !edge_data[ out.next_edge ].done )\n            return out.next_edge;\n        else\n            return find_next_branch();\n    }\n}\n/// find out-edges of current_edge\nEdgeVector medial_axis_pocket::find_out_edges() {\n    HEVertex trg = g.target(current_edge);\n    EdgeVector out_edges;\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr(trg) ) {\n        if ( e != g[current_edge].twin && \n             g[e].valid && !edge_data[e].done && \n             g[e].type != NULLEDGE && \n             g[e].type != OUTEDGE ) {\n            out_edges.push_back(e);\n        }\n    }\n    return out_edges;\n}\n\n/// find the next edge\n// return true if we need a final MIC at the end of a branch\nstd::pair<HEEdge,bool> medial_axis_pocket::find_next_edge() {\n    EdgeVector out_edges = find_out_edges();\n    if (out_edges.empty() ) {\n        if (debug) std::cout << \"find_next_edge(): no out_edges. end of branch.\\n\";\n        \n        if ( current_radius > g[ g.target(current_edge) ].dist() ) {\n            current_radius = g[ g.target(current_edge) ].dist();\n            current_center = g[ g.target(current_edge) ].position; //point(current_radius);\n            return std::make_pair(current_edge,true); // this outputs a final MIC at the end of a branch\n        }\n        \n        HEEdge e = find_next_branch();\n        if (e==HEEdge())\n            return std::make_pair(e,false); // this is end-of-operation.\n            \n        if (has_next_radius(e)) {\n            if (debug) { std::cout << \"find_next_edge(): next-branch is: \"; g.print_edge(e); }\n            current_u = 0;\n            return std::make_pair(e,false);\n        } else {\n            if (debug) { std::cout << \"find_next_edge(): next-branch, but not valid\\n\"; }\n            mark_done( e );\n            current_edge = e; // jump to the next edge\n            return find_next_edge(); // and try to see if that edge is valid.\n        } \n    } else if ( out_edges.size() == 1 ) {\n        // only one choice for the next edge\n        if (has_next_radius(out_edges[0])) {\n            if (debug) { std::cout << \"find_next_edge(): only one out-edge: \"; g.print_edge(out_edges[0]); }\n            current_u = 0;\n            return std::make_pair(out_edges[0],false);\n        } else {\n            if (debug) std::cout << \"find_next_edge(): one out-edge, but not valid\\n\"; \n            mark_done( out_edges[0] );\n            current_edge = out_edges[0]; // jump to the next edge\n            return find_next_edge(); // and try to see if that edge is valid.\n        } \n    } else if (out_edges.size() == 2 ) {\n        // two choices for the next edge\n        // FIXME: some smarter way of selecting next-edge\n        unvisited.push( branch_point(current_center, current_radius, out_edges[1] ) );\n        \n        if (has_next_radius(out_edges[0])) {\n            if (debug) { std::cout << \"find_next_edge(): two out-edges, returning first: \"; g.print_edge(out_edges[0]); }\n            current_u=0;\n            return std::make_pair(out_edges[0],false);\n        } else {\n            mark_done( out_edges[0] ); \n            current_edge = out_edges[0]; // jump to the next edge\n            return find_next_edge(); // and try to see if that edge is valid.\n        }\n    } else {\n        if (debug) std::cout << \"find_next_edge(): too many out-edges. ERROR.\\n\";\n        exit(-1);\n        return std::make_pair(HEEdge(),false);\n    }\n}\n\n/// mark edge and its twin done\nvoid medial_axis_pocket::mark_done(HEEdge e) {\n    edge_data[ e ].done = true;\n    edge_data[ g[e].twin ].done = true;\n}\n\n/// does HEEdge e have the next MIC we want ?\nbool medial_axis_pocket::has_next_radius(HEEdge e) {\n    // check if the edge e is one where we continue\n    double r2;\n    Point  c2;\n    boost::tie(c2,r2) = edge_point(e,1.0);\n\n    double w_target = cut_width(current_center, current_radius, c2, r2);\n    if (debug) {\n        CutWidthError t(this, e,max_width, current_center, current_radius);\n        std::cout << \"has_next_radius() ?\"<< ( w_target > max_width ) <<\" \"; g.print_edge(e);\n        std::cout << \"has_next_radius() err src \"<< t(0) <<\"\\n\";\n        std::cout << \"has_next_radius() err trg \"<< t(1) <<\"\\n\";\n    }\n    if (w_target<=0)\n        return false;\n        \n    if ( w_target > max_width )\n        return true;\n    else\n        return false;\n}\n\n/// find the next u-value that produces the desired cut-width\nstd::pair<double,double> medial_axis_pocket::find_next_u() {\n    CutWidthError t(this, current_edge, max_width, current_center, current_radius);\n    typedef std::pair<double, double> Result;\n    boost::uintmax_t max_iter=500;\n    boost::math::tools::eps_tolerance<double> tol(30);\n    double trg_err = t(1.0);\n    double cur_err = t(current_u);\n    if ( debug ||  ( !(trg_err*cur_err < 0) ) ) {\n        std::cout << \"find_next_u():\\n\";\n        std::cout << \" current edge: \"; g.print_edge(current_edge);// << current_radius << \"\\n\";\n        std::cout << \"    edge type: \" << g[current_edge].type_str() << \"\\n\";\n        std::cout << \" source c= \"<< g[ g.source(current_edge) ].position << \" r= \" << g[ g.source(current_edge) ].dist() << \" err= \" <<  t(0.0) <<\"\\n\";\n        std::cout << \" target c= \"<< g[ g.target(current_edge) ].position << \" r= \" << g[ g.target(current_edge) ].dist() << \" err= \" <<  t(1.0) <<\"\\n\";\n        std::cout << \" current c1=\" << current_center << \" r1=\" << current_radius << \"\\n\";\n        std::cout << \" current u = \" << current_u << \"\\n\";\n        std::cout << \" error at current = \" << t(current_u) << \"\\n\";\n        std::cout << \" error at target = \" << t(1.0) << \"\\n\";\n    }\n    //double min_r = std::min(current_radius, target_radius);\n    //double max_r = std::max(current_radius, target_radius);\n    Result r1 = boost::math::tools::toms748_solve(t, current_u, 1.0, tol, max_iter);\n    double rnext;\n    Point pnext;\n    boost::tie( pnext, rnext ) = edge_point( current_edge, r1.first );\n    return std::make_pair( r1.first, rnext );\n}\n    \n/// \\brief output the next MIC\n///\n/// based on the output here a downstream algorithm\n/// will lay out the pattern: lead-out, rapid, lead-in, bi-tangent, cut-arc, bi-tangent\nvoid medial_axis_pocket::output_next_mic(double next_u, double next_radius, bool branch) {\n    MIC mic;\n    Point c1 = current_center;\n    double r1 = current_radius;\n    Point c2;\n    double r2;\n    boost::tie(c2,r2) = edge_point(current_edge, next_u); //g[current_edge].point(next_radius);\n    //double r2 = next_radius;\n    if (debug) {\n        std::cout << \"output_next_mic(): \\n\";\n        std::cout << \" next_u = \" << next_u << \"\\n\";\n        std::cout << \" next_radius = \" << next_radius << \"\\n\";\n        std::cout << \" c= \" << c2 << \" r= \" << r2 << \"\\n\";\n    }\n    \n    mic.c1 = c1;\n    mic.r1 = r1;\n    mic.c2 = c2;\n    mic.r2 = r2;\n\n    if (c1 != c2) {\n        std::vector<Point> tangents = bitangent_points(c1,r1,c2,r2);\n        mic.t1 = tangents[0]; //tang1; //2\n        mic.t2 = tangents[1]; //3\n        mic.t3 = tangents[2]; //4\n        mic.t4 = tangents[3]; //5\n    }\n    mic.new_branch = branch;\n    mic.c_prev = previous_branch_center;\n    mic.r_prev = previous_branch_radius;\n    mic_list.push_back(mic);\n    current_radius = r2; //next_radius;\n    current_center = c2; //g[current_edge].point(next_radius);\n    current_u = next_u;\n}\n\n/// bi-tangent points to c1-c2\nstd::vector<Point> medial_axis_pocket::bitangent_points(Point c1, double r1, Point c2, double r2) {\n    std::vector<Point> out;\n    Point bd1,bd2;\n    if ( r1 == r2 ) {\n        Point c1c2 = c2-c1;\n        c1c2.normalize();\n        bd1 = -1*c1c2.xy_perp();\n        bd2 = c1c2.xy_perp();\n    } else {\n        double c1c2_dist = (c1-c2).norm();\n        double dr = fabs(r1-r2);\n        double bitang_length = sqrt( c1c2_dist*c1c2_dist + dr*dr );\n        double area = dr*bitang_length;\n        double height = area / c1c2_dist;\n        double bitang_c1c2 = sqrt( bitang_length*bitang_length - height*height );\n        Point cdir =  c2-c1;\n        if (r1>r2)\n            cdir = c1-c2;\n        cdir.normalize(); \n        // the bitangents\n        Point bit1 = bitang_c1c2*cdir + height*cdir.xy_perp();\n        Point bit2 = bitang_c1c2*cdir - height*cdir.xy_perp();\n        \n        if (r1>r2) {\n            bd1 = bit1.xy_perp(); \n            bd2 = -1*bit2.xy_perp(); \n        } else {\n            bd1 = -1*bit2.xy_perp(); \n            bd2 = bit1.xy_perp(); \n        }\n        bd1.normalize();\n        bd2.normalize();\n    }\n    out.push_back( c1 + r1*bd1 );\n    out.push_back( c1 + r1*bd2 );\n    out.push_back( c2 + r2*bd1 );\n    out.push_back( c2 + r2*bd2 );\n    return out;\n}\n\n\n/// \\return cut-width from c1/r1 to c2/r2\n///\n/// - (c1,r1) is the previously machined MIC\n/// - (c2,r2) is the new MIC\n/// the maximum cut-width when cutting c2 is\n///  w_max = | c2 - c1 | + r2 - r1\ndouble medial_axis_pocket::cut_width(Point c1, double r1, Point c2, double r2) {\n    return ( c2-c1 ).norm() + r2 - r1;\n}\n\n/// find a point on current_edge at u [0,1]\nstd::pair<Point,double> medial_axis_pocket::edge_point(HEEdge e, double u) {\n    Point p;\n    double r;\n    // on line-type edges return\n    // p = p1 + u ( p2 - p1 )\n    /*\n    enum VoronoiEdgeType {\n    LINE,          // PontSite PointSite\n    LINELINE,      // LineSite LineSite\n    PARA_LINELINE, // LineSite LineSite\n    OUTEDGE, \n    PARABOLA,      // LineSite PointSite\n    ELLIPSE, \n    HYPERBOLA, \n    SEPARATOR,     // LineSite PointSite(endpoint) \n    NULLEDGE, \n    LINESITE\n    };\n    */\n    if ( g[e].type == LINE ||\n        g[e].type == LINELINE ||\n        g[e].type == PARA_LINELINE ) // note SEPARATOR shouldn't occur in the medial-axis\n        {\n        Point src = g[ g.source(e) ].position;\n        Point trg = g[ g.target(e) ].position;\n        p = src + u * (trg-src);\n        HEFace f = g[e].face;\n        Site* s = g[f].site;\n        Point pa = s->apex_point(p);\n        r = (p-pa).norm();\n    } else if ( g[e].type == PARABOLA ) {\n        // use the existing t-parametrisation (?)\n        HEVertex src_v = g.source(e);\n        HEVertex trg_v = g.target(e);\n        double src_t = g[src_v].dist();\n        double trg_t = g[trg_v].dist();\n        double u_t = src_t + u*(trg_t-src_t);\n        p = g[e].point(u_t);\n        r=u_t;\n    } else {\n        std::cout << \"ERROR medial_axis_pocket::edge_point() unsuppoerted edge type.\\n\";\n        std::cout << \" type= \" << g[e].type_str() << \"\\n\";\n        exit(-1);\n    }\n    \n    return std::make_pair(p,r);\n}\n\n/// \\param ma calling medial_axis_pocket object\n/// \\param ed edge on which to position MIC\n/// \\param wmax maximum cut width\n/// \\param cen1 previous MIC center\n/// \\param rad1 previous MIC radius\nmedial_axis_pocket::CutWidthError::CutWidthError(medial_axis_pocket* ma, \n                            HEEdge ed, double wmax, Point cen1, double rad1) \n: m(ma), e(ed), w_max(wmax),  c1(cen1), r1(rad1) {}\n\n/// cut-width if next MIC positioned at \\a x\ndouble medial_axis_pocket::CutWidthError::operator()(const double x) {\n    // w_max = | c2 - c1 | + r2 - r1\n    Point c2; // = m->edge_point(x); //g[e].point(x); // current MIC center\n    double r2; // = x; // current MIC radius\n    boost::tie(c2,r2) = m->edge_point(e,x);\n    double w = (c2-c1).norm() + r2 - r1; // this is the cut-width\n    return w-w_max; // error compared to desired cut-width\n}\n\nmedial_axis_pocket::edata::edata() { done = false; }\n\n} // end namespace\n\n// end file \n","// ----------------------------------------------------------------------------\n//  alt_sstream.hpp : alternative stringstream \n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n\n\n#ifndef BOOST_SK_ALT_SSTREAM_HPP\n#define BOOST_SK_ALT_SSTREAM_HPP\n\n#include <string>\n#include <boost/format/detail/compat_workarounds.hpp>\n#include <boost/utility/base_from_member.hpp>\n#include <boost/shared_ptr.hpp>\n#include <boost/assert.hpp>\n\nnamespace boost {\n    namespace io {\n\n        template<class Ch, class Tr=::std::char_traits<Ch>, \n                 class Alloc=::std::allocator<Ch> >\n        class basic_altstringbuf;\n\n        template<class Ch, class Tr =::std::char_traits<Ch>, \n                 class Alloc=::std::allocator<Ch> >\n        class basic_oaltstringstream;\n\n\n        template<class Ch, class Tr, class Alloc>\n        class basic_altstringbuf \n            : public ::std::basic_streambuf<Ch, Tr>\n        {\n            typedef ::std::basic_streambuf<Ch, Tr>  streambuf_t;\n            typedef typename CompatAlloc<Alloc>::compatible_type compat_allocator_type;\n            typedef typename CompatTraits<Tr>::compatible_type   compat_traits_type;\n        public:\n            typedef Ch     char_type;\n            typedef Tr     traits_type;\n            typedef typename compat_traits_type::int_type     int_type;\n            typedef typename compat_traits_type::pos_type     pos_type;\n            typedef typename compat_traits_type::off_type     off_type;\n            typedef Alloc                     allocator_type;\n            typedef ::std::basic_string<Ch, Tr, Alloc> string_type;\n            typedef typename string_type::size_type    size_type;\n\n            typedef ::std::streamsize streamsize;\n\n\n            explicit basic_altstringbuf(std::ios_base::openmode mode\n                                        = std::ios_base::in | std::ios_base::out)\n                : putend_(NULL), is_allocated_(false), mode_(mode) \n                {}\n            explicit basic_altstringbuf(const string_type& s,\n                                        ::std::ios_base::openmode mode\n                                        = ::std::ios_base::in | ::std::ios_base::out)\n                : putend_(NULL), is_allocated_(false), mode_(mode) \n                { dealloc(); str(s); }\n            virtual ~basic_altstringbuf() \n                { dealloc(); }\n            using streambuf_t::pbase;\n            using streambuf_t::pptr;\n            using streambuf_t::epptr;\n            using streambuf_t::eback;\n            using streambuf_t::gptr;\n            using streambuf_t::egptr;\n    \n            void clear_buffer();\n            void str(const string_type& s);\n\n            // 0-copy access :\n            Ch * begin() const; \n            size_type size() const;\n            size_type cur_size() const; // stop at current pointer\n            Ch * pend() const // the highest position reached by pptr() since creation\n                { return ((putend_ < pptr()) ? pptr() : putend_); }\n            size_type pcount() const \n                { return static_cast<size_type>( pptr() - pbase()) ;}\n\n            // copy buffer to string :\n            string_type str() const \n                { return string_type(begin(), size()); }\n            string_type cur_str() const \n                { return string_type(begin(), cur_size()); }\n        protected:\n            explicit basic_altstringbuf (basic_altstringbuf * s,\n                                         ::std::ios_base::openmode mode \n                                         = ::std::ios_base::in | ::std::ios_base::out)\n                : putend_(NULL), is_allocated_(false), mode_(mode) \n                { dealloc(); str(s); }\n\n            virtual pos_type seekoff(off_type off, ::std::ios_base::seekdir way, \n                                     ::std::ios_base::openmode which \n                                     = ::std::ios_base::in | ::std::ios_base::out);\n            virtual pos_type seekpos (pos_type pos, \n                                      ::std::ios_base::openmode which \n                                      = ::std::ios_base::in | ::std::ios_base::out);\n            virtual int_type underflow();\n            virtual int_type pbackfail(int_type meta = compat_traits_type::eof());\n            virtual int_type overflow(int_type meta = compat_traits_type::eof());\n            void dealloc();\n        private:\n            enum { alloc_min = 256}; // minimum size of allocations\n\n            Ch *putend_;  // remembers (over seeks) the highest value of pptr()\n            bool is_allocated_;\n            ::std::ios_base::openmode mode_;\n            compat_allocator_type alloc_;  // the allocator object\n        };\n\n\n// ---   class basic_oaltstringstream ----------------------------------------\n        template <class Ch, class Tr, class Alloc>\n        class basic_oaltstringstream \n            : private base_from_member< shared_ptr< basic_altstringbuf< Ch, Tr, Alloc> > >,\n              public ::std::basic_ostream<Ch, Tr>\n        {\n            class No_Op { \n                // used as no-op deleter for (not-owner) shared_pointers\n            public: \n                template<class T>\n                const T & operator()(const T & arg) { return arg; }\n            };\n            typedef ::std::basic_ostream<Ch, Tr> stream_t;\n            typedef boost::base_from_member<boost::shared_ptr<\n                basic_altstringbuf<Ch,Tr, Alloc> > > \n                pbase_type;\n            typedef ::std::basic_string<Ch, Tr, Alloc>  string_type;\n            typedef typename string_type::size_type     size_type;\n            typedef basic_altstringbuf<Ch, Tr, Alloc>   stringbuf_t;\n        public:\n            typedef Alloc  allocator_type;\n            basic_oaltstringstream() \n                : pbase_type(new stringbuf_t), stream_t(rdbuf()) \n                { }\n            basic_oaltstringstream(::boost::shared_ptr<stringbuf_t> buf) \n                : pbase_type(buf), stream_t(rdbuf()) \n                { }\n            basic_oaltstringstream(stringbuf_t * buf) \n                : pbase_type(buf, No_Op() ), stream_t(rdbuf()) \n                { }\n            stringbuf_t * rdbuf() const \n                { return pbase_type::member.get(); }\n            void clear_buffer() \n                { rdbuf()->clear_buffer(); }\n\n            // 0-copy access :\n            Ch * begin() const \n                { return rdbuf()->begin(); }\n            size_type size() const \n                { return rdbuf()->size(); }\n            size_type cur_size() const // stops at current position\n                { return rdbuf()->cur_size(); }\n\n            // copy buffer to string :\n            string_type str()     const   // [pbase, epptr[\n                { return rdbuf()->str(); } \n            string_type cur_str() const   // [pbase, pptr[\n                { return rdbuf()->cur_str(); }\n            void str(const string_type& s) \n                { rdbuf()->str(s); }\n        };\n\n    } // N.S. io\n} // N.S. boost\n\n#include <boost/format/alt_sstream_impl.hpp>\n\n#endif // include guard\n\n","// Copyright (C) 2003, 2008 Fernando Luis Cacciola Carballal.\n//\n// Use, modification, and distribution is subject to the Boost Software\n// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n// See http://www.boost.org/libs/optional for documentation.\n//\n// You are welcome to contact the author at:\n//  fernando_cacciola@hotmail.com\n//\n// Revisions:\n// 27 Apr 2008 (improved swap) Fernando Cacciola, Niels Dekker, Thorsten Ottosen\n//\n#ifndef BOOST_OPTIONAL_OPTIONAL_FLC_19NOV2002_HPP\n#define BOOST_OPTIONAL_OPTIONAL_FLC_19NOV2002_HPP\n\n#include <new>\n#include <algorithm>\n\n#include <boost/config.hpp>\n#include <boost/assert.hpp>\n#include <boost/type.hpp>\n#include <boost/type_traits/alignment_of.hpp>\n#include <boost/type_traits/has_nothrow_constructor.hpp>\n#include <boost/type_traits/type_with_alignment.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/type_traits/is_reference.hpp>\n#include <boost/mpl/if.hpp>\n#include <boost/mpl/bool.hpp>\n#include <boost/mpl/not.hpp>\n#include <boost/detail/reference_content.hpp>\n#include <boost/none.hpp>\n#include <boost/utility/swap.hpp>\n#include <boost/utility/addressof.hpp>\n#include <boost/utility/compare_pointees.hpp>\n#include <boost/utility/in_place_factory.hpp>\n\n#include <boost/optional/optional_fwd.hpp>\n\n#if BOOST_WORKAROUND(BOOST_MSVC, == 1200)\n// VC6.0 has the following bug:\n//   When a templated assignment operator exist, an implicit conversion\n//   constructing an optional<T> is used when assigment of the form:\n//     optional<T> opt ; opt = T(...);\n//   is compiled.\n//   However, optional's ctor is _explicit_ and the assignemt shouldn't compile.\n//   Therefore, for VC6.0 templated assignment is disabled.\n//\n#define BOOST_OPTIONAL_NO_CONVERTING_ASSIGNMENT\n#endif\n\n#if BOOST_WORKAROUND(BOOST_MSVC, == 1300)\n// VC7.0 has the following bug:\n//   When both a non-template and a template copy-ctor exist\n//   and the templated version is made 'explicit', the explicit is also\n//   given to the non-templated version, making the class non-implicitely-copyable.\n//\n#define BOOST_OPTIONAL_NO_CONVERTING_COPY_CTOR\n#endif\n\n#if BOOST_WORKAROUND(BOOST_MSVC, <= 1300) || BOOST_WORKAROUND(BOOST_INTEL_CXX_VERSION,<=700)\n// AFAICT only VC7.1 correctly resolves the overload set\n// that includes the in-place factory taking functions,\n// so for the other VC versions, in-place factory support\n// is disabled\n#define BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT\n#endif\n\n#if BOOST_WORKAROUND(__BORLANDC__, <= 0x551)\n// BCB (5.5.1) cannot parse the nested template struct in an inplace factory.\n#define BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT\n#endif\n\n#if !defined(BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT) \\\n    && BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581) )\n// BCB (up to 5.64) has the following bug:\n//   If there is a member function/operator template of the form\n//     template<class Expr> mfunc( Expr expr ) ;\n//   some calls are resolved to this even if there are other better matches.\n//   The effect of this bug is that calls to converting ctors and assignments\n//   are incrorrectly sink to this general catch-all member function template as shown above.\n#define BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION\n#endif\n\n#if defined(__GNUC__) && (__GNUC__ * 100 + __GNUC_MINOR__) > 302 \\\n    && !defined(__INTEL_COMPILER)\n// GCC since 3.3 has may_alias attribute that helps to alleviate optimizer issues with\n// regard to violation of the strict aliasing rules. The optional< T > storage type is marked\n// with this attribute in order to let the compiler know that it will alias objects of type T\n// and silence compilation warnings.\n#define BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS\n#endif\n\n// Daniel Wallin discovered that bind/apply.hpp badly interacts with the apply<>\n// member template of a factory as used in the optional<> implementation.\n// He proposed this simple fix which is to move the call to apply<> outside\n// namespace boost.\nnamespace boost_optional_detail\n{\n  template <class T, class Factory>\n  inline void construct(Factory const& factory, void* address)\n  {\n    factory.BOOST_NESTED_TEMPLATE apply<T>(address);\n  }\n}\n\n\nnamespace boost {\n\nclass in_place_factory_base ;\nclass typed_in_place_factory_base ;\n\n// This forward is needed to refer to namespace scope swap from the member swap\ntemplate<class T> void swap ( optional<T>& x, optional<T>& y );\n\nnamespace optional_detail {\n\n// This local class is used instead of that in \"aligned_storage.hpp\"\n// because I've found the 'official' class to ICE BCB5.5\n// when some types are used with optional<>\n// (due to sizeof() passed down as a non-type template parameter)\ntemplate <class T>\nclass aligned_storage\n{\n    // Borland ICEs if unnamed unions are used for this!\n    union\n    // This works around GCC warnings about breaking strict aliasing rules when casting storage address to T*\n#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)\n    __attribute__((may_alias))\n#endif\n    dummy_u\n    {\n        char data[ sizeof(T) ];\n        BOOST_DEDUCED_TYPENAME type_with_alignment<\n          ::boost::alignment_of<T>::value >::type aligner_;\n    } dummy_ ;\n\n  public:\n\n#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)\n    void const* address() const { return &dummy_; }\n    void      * address()       { return &dummy_; }\n#else\n    void const* address() const { return dummy_.data; }\n    void      * address()       { return dummy_.data; }\n#endif\n} ;\n\ntemplate<class T>\nstruct types_when_isnt_ref\n{\n  typedef T const& reference_const_type ;\n  typedef T &      reference_type ;\n  typedef T const* pointer_const_type ;\n  typedef T *      pointer_type ;\n  typedef T const& argument_type ;\n} ;\ntemplate<class T>\nstruct types_when_is_ref\n{\n  typedef BOOST_DEDUCED_TYPENAME remove_reference<T>::type raw_type ;\n\n  typedef raw_type& reference_const_type ;\n  typedef raw_type& reference_type ;\n  typedef raw_type* pointer_const_type ;\n  typedef raw_type* pointer_type ;\n  typedef raw_type& argument_type ;\n} ;\n\nstruct optional_tag {} ;\n\ntemplate<class T>\nclass optional_base : public optional_tag\n{\n  private :\n\n    typedef\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    BOOST_DEDUCED_TYPENAME\n#endif\n    ::boost::detail::make_reference_content<T>::type internal_type ;\n\n    typedef aligned_storage<internal_type> storage_type ;\n\n    typedef types_when_isnt_ref<T> types_when_not_ref ;\n    typedef types_when_is_ref<T>   types_when_ref   ;\n\n    typedef optional_base<T> this_type ;\n\n  protected :\n\n    typedef T value_type ;\n\n    typedef mpl::true_  is_reference_tag ;\n    typedef mpl::false_ is_not_reference_tag ;\n\n    typedef BOOST_DEDUCED_TYPENAME is_reference<T>::type is_reference_predicate ;\n\n  public:\n    typedef BOOST_DEDUCED_TYPENAME mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;\n\n  protected:\n    typedef bool (this_type::*unspecified_bool_type)() const;\n\n    typedef BOOST_DEDUCED_TYPENAME types::reference_type       reference_type ;\n    typedef BOOST_DEDUCED_TYPENAME types::reference_const_type reference_const_type ;\n    typedef BOOST_DEDUCED_TYPENAME types::pointer_type         pointer_type ;\n    typedef BOOST_DEDUCED_TYPENAME types::pointer_const_type   pointer_const_type ;\n    typedef BOOST_DEDUCED_TYPENAME types::argument_type        argument_type ;\n\n    // Creates an optional<T> uninitialized.\n    // No-throw\n    optional_base()\n      :\n      m_initialized(false) {}\n\n    // Creates an optional<T> uninitialized.\n    // No-throw\n    optional_base ( none_t )\n      :\n      m_initialized(false) {}\n\n    // Creates an optional<T> initialized with 'val'.\n    // Can throw if T::T(T const&) does\n    optional_base ( argument_type val )\n      :\n      m_initialized(false)\n    {\n      construct(val);\n    }\n\n    // Creates an optional<T> initialized with 'val' IFF cond is true, otherwise creates an uninitialzed optional<T>.\n    // Can throw if T::T(T const&) does\n    optional_base ( bool cond, argument_type val )\n      :\n      m_initialized(false)\n    {\n      if ( cond )\n        construct(val);\n    }\n\n    // Creates a deep copy of another optional<T>\n    // Can throw if T::T(T const&) does\n    optional_base ( optional_base const& rhs )\n      :\n      m_initialized(false)\n    {\n      if ( rhs.is_initialized() )\n        construct(rhs.get_impl());\n    }\n\n\n    // This is used for both converting and in-place constructions.\n    // Derived classes use the 'tag' to select the appropriate\n    // implementation (the correct 'construct()' overload)\n    template<class Expr>\n    explicit optional_base ( Expr const& expr, Expr const* tag )\n      :\n      m_initialized(false)\n    {\n      construct(expr,tag);\n    }\n\n\n\n    // No-throw (assuming T::~T() doesn't)\n    ~optional_base() { destroy() ; }\n\n    // Assigns from another optional<T> (deep-copies the rhs value)\n    void assign ( optional_base const& rhs )\n    {\n      if (is_initialized())\n      {\n        if ( rhs.is_initialized() )\n             assign_value(rhs.get_impl(), is_reference_predicate() );\n        else destroy();\n      }\n      else\n      {\n        if ( rhs.is_initialized() )\n          construct(rhs.get_impl());\n      }\n    }\n\n    // Assigns from another _convertible_ optional<U> (deep-copies the rhs value)\n    template<class U>\n    void assign ( optional<U> const& rhs )\n    {\n      if (is_initialized())\n      {\n        if ( rhs.is_initialized() )\n             assign_value(static_cast<value_type>(rhs.get()), is_reference_predicate() );\n        else destroy();\n      }\n      else\n      {\n        if ( rhs.is_initialized() )\n          construct(static_cast<value_type>(rhs.get()));\n      }\n    }\n\n    // Assigns from a T (deep-copies the rhs value)\n    void assign ( argument_type val )\n    {\n      if (is_initialized())\n           assign_value(val, is_reference_predicate() );\n      else construct(val);\n    }\n\n    // Assigns from \"none\", destroying the current value, if any, leaving this UNINITIALIZED\n    // No-throw (assuming T::~T() doesn't)\n    void assign ( none_t ) { destroy(); }\n\n#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT\n    template<class Expr>\n    void assign_expr ( Expr const& expr, Expr const* tag )\n      {\n        if (is_initialized())\n             assign_expr_to_initialized(expr,tag);\n        else construct(expr,tag);\n      }\n#endif\n\n  public :\n\n    // Destroys the current value, if any, leaving this UNINITIALIZED\n    // No-throw (assuming T::~T() doesn't)\n    void reset() { destroy(); }\n\n    // Replaces the current value -if any- with 'val'\n    void reset ( argument_type val ) { assign(val); }\n\n    // Returns a pointer to the value if this is initialized, otherwise,\n    // returns NULL.\n    // No-throw\n    pointer_const_type get_ptr() const { return m_initialized ? get_ptr_impl() : 0 ; }\n    pointer_type       get_ptr()       { return m_initialized ? get_ptr_impl() : 0 ; }\n\n    bool is_initialized() const { return m_initialized ; }\n\n  protected :\n\n    void construct ( argument_type val )\n     {\n       new (m_storage.address()) internal_type(val) ;\n       m_initialized = true ;\n     }\n\n#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT\n    // Constructs in-place using the given factory\n    template<class Expr>\n    void construct ( Expr const& factory, in_place_factory_base const* )\n     {\n       BOOST_STATIC_ASSERT ( ::boost::mpl::not_<is_reference_predicate>::value ) ;\n       boost_optional_detail::construct<value_type>(factory, m_storage.address());\n       m_initialized = true ;\n     }\n\n    // Constructs in-place using the given typed factory\n    template<class Expr>\n    void construct ( Expr const& factory, typed_in_place_factory_base const* )\n     {\n       BOOST_STATIC_ASSERT ( ::boost::mpl::not_<is_reference_predicate>::value ) ;\n       factory.apply(m_storage.address()) ;\n       m_initialized = true ;\n     }\n\n    template<class Expr>\n    void assign_expr_to_initialized ( Expr const& factory, in_place_factory_base const* tag )\n     {\n       destroy();\n       construct(factory,tag);\n     }\n\n    // Constructs in-place using the given typed factory\n    template<class Expr>\n    void assign_expr_to_initialized ( Expr const& factory, typed_in_place_factory_base const* tag )\n     {\n       destroy();\n       construct(factory,tag);\n     }\n#endif\n\n    // Constructs using any expression implicitely convertible to the single argument\n    // of a one-argument T constructor.\n    // Converting constructions of optional<T> from optional<U> uses this function with\n    // 'Expr' being of type 'U' and relying on a converting constructor of T from U.\n    template<class Expr>\n    void construct ( Expr const& expr, void const* )\n     {\n       new (m_storage.address()) internal_type(expr) ;\n       m_initialized = true ;\n     }\n\n    // Assigns using a form any expression implicitely convertible to the single argument\n    // of a T's assignment operator.\n    // Converting assignments of optional<T> from optional<U> uses this function with\n    // 'Expr' being of type 'U' and relying on a converting assignment of T from U.\n    template<class Expr>\n    void assign_expr_to_initialized ( Expr const& expr, void const* )\n     {\n       assign_value(expr, is_reference_predicate());\n     }\n\n#ifdef BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION\n    // BCB5.64 (and probably lower versions) workaround.\n    //   The in-place factories are supported by means of catch-all constructors\n    //   and assignment operators (the functions are parameterized in terms of\n    //   an arbitrary 'Expr' type)\n    //   This compiler incorrectly resolves the overload set and sinks optional<T> and optional<U>\n    //   to the 'Expr'-taking functions even though explicit overloads are present for them.\n    //   Thus, the following overload is needed to properly handle the case when the 'lhs'\n    //   is another optional.\n    //\n    // For VC<=70 compilers this workaround dosen't work becasue the comnpiler issues and error\n    // instead of choosing the wrong overload\n    //\n    // Notice that 'Expr' will be optional<T> or optional<U> (but not optional_base<..>)\n    template<class Expr>\n    void construct ( Expr const& expr, optional_tag const* )\n     {\n       if ( expr.is_initialized() )\n       {\n         // An exception can be thrown here.\n         // It it happens, THIS will be left uninitialized.\n         new (m_storage.address()) internal_type(expr.get()) ;\n         m_initialized = true ;\n       }\n     }\n#endif\n\n    void assign_value ( argument_type val, is_not_reference_tag ) { get_impl() = val; }\n    void assign_value ( argument_type val, is_reference_tag     ) { construct(val); }\n\n    void destroy()\n    {\n      if ( m_initialized )\n        destroy_impl(is_reference_predicate()) ;\n    }\n\n    unspecified_bool_type safe_bool() const { return m_initialized ? &this_type::is_initialized : 0 ; }\n\n    reference_const_type get_impl() const { return dereference(get_object(), is_reference_predicate() ) ; }\n    reference_type       get_impl()       { return dereference(get_object(), is_reference_predicate() ) ; }\n\n    pointer_const_type get_ptr_impl() const { return cast_ptr(get_object(), is_reference_predicate() ) ; }\n    pointer_type       get_ptr_impl()       { return cast_ptr(get_object(), is_reference_predicate() ) ; }\n\n  private :\n\n    // internal_type can be either T or reference_content<T>\n#if defined(BOOST_OPTIONAL_DETAIL_USE_ATTRIBUTE_MAY_ALIAS)\n    // This workaround is supposed to silence GCC warnings about broken strict aliasing rules\n    internal_type const* get_object() const\n    {\n        union { void const* ap_pvoid; internal_type const* as_ptype; } caster = { m_storage.address() };\n        return caster.as_ptype;\n    }\n    internal_type *      get_object()\n    {\n        union { void* ap_pvoid; internal_type* as_ptype; } caster = { m_storage.address() };\n        return caster.as_ptype;\n    }\n#else\n    internal_type const* get_object() const { return static_cast<internal_type const*>(m_storage.address()); }\n    internal_type *      get_object()       { return static_cast<internal_type *>     (m_storage.address()); }\n#endif\n\n    // reference_content<T> lacks an implicit conversion to T&, so the following is needed to obtain a proper reference.\n    reference_const_type dereference( internal_type const* p, is_not_reference_tag ) const { return *p ; }\n    reference_type       dereference( internal_type*       p, is_not_reference_tag )       { return *p ; }\n    reference_const_type dereference( internal_type const* p, is_reference_tag     ) const { return p->get() ; }\n    reference_type       dereference( internal_type*       p, is_reference_tag     )       { return p->get() ; }\n\n#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x581))\n    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->internal_type::~internal_type() ; m_initialized = false ; }\n#else\n    void destroy_impl ( is_not_reference_tag ) { get_ptr_impl()->T::~T() ; m_initialized = false ; }\n#endif\n\n    void destroy_impl ( is_reference_tag     ) { m_initialized = false ; }\n\n    // If T is of reference type, trying to get a pointer to the held value must result in a compile-time error.\n    // Decent compilers should disallow conversions from reference_content<T>* to T*, but just in case,\n    // the following olverloads are used to filter out the case and guarantee an error in case of T being a reference.\n    pointer_const_type cast_ptr( internal_type const* p, is_not_reference_tag ) const { return p ; }\n    pointer_type       cast_ptr( internal_type *      p, is_not_reference_tag )       { return p ; }\n    pointer_const_type cast_ptr( internal_type const* p, is_reference_tag     ) const { return &p->get() ; }\n    pointer_type       cast_ptr( internal_type *      p, is_reference_tag     )       { return &p->get() ; }\n\n    bool m_initialized ;\n    storage_type m_storage ;\n} ;\n\n} // namespace optional_detail\n\ntemplate<class T>\nclass optional : public optional_detail::optional_base<T>\n{\n    typedef optional_detail::optional_base<T> base ;\n\n    typedef BOOST_DEDUCED_TYPENAME base::unspecified_bool_type  unspecified_bool_type ;\n\n  public :\n\n    typedef optional<T> this_type ;\n\n    typedef BOOST_DEDUCED_TYPENAME base::value_type           value_type ;\n    typedef BOOST_DEDUCED_TYPENAME base::reference_type       reference_type ;\n    typedef BOOST_DEDUCED_TYPENAME base::reference_const_type reference_const_type ;\n    typedef BOOST_DEDUCED_TYPENAME base::pointer_type         pointer_type ;\n    typedef BOOST_DEDUCED_TYPENAME base::pointer_const_type   pointer_const_type ;\n    typedef BOOST_DEDUCED_TYPENAME base::argument_type        argument_type ;\n\n    // Creates an optional<T> uninitialized.\n    // No-throw\n    optional() : base() {}\n\n    // Creates an optional<T> uninitialized.\n    // No-throw\n    optional( none_t none_ ) : base(none_) {}\n\n    // Creates an optional<T> initialized with 'val'.\n    // Can throw if T::T(T const&) does\n    optional ( argument_type val ) : base(val) {}\n\n    // Creates an optional<T> initialized with 'val' IFF cond is true, otherwise creates an uninitialized optional.\n    // Can throw if T::T(T const&) does\n    optional ( bool cond, argument_type val ) : base(cond,val) {}\n\n#ifndef BOOST_OPTIONAL_NO_CONVERTING_COPY_CTOR\n    // NOTE: MSVC needs templated versions first\n\n    // Creates a deep copy of another convertible optional<U>\n    // Requires a valid conversion from U to T.\n    // Can throw if T::T(U const&) does\n    template<class U>\n    explicit optional ( optional<U> const& rhs )\n      :\n      base()\n    {\n      if ( rhs.is_initialized() )\n        this->construct(rhs.get());\n    }\n#endif\n\n#ifndef BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT\n    // Creates an optional<T> with an expression which can be either\n    //  (a) An instance of InPlaceFactory (i.e. in_place(a,b,...,n);\n    //  (b) An instance of TypedInPlaceFactory ( i.e. in_place<T>(a,b,...,n);\n    //  (c) Any expression implicitely convertible to the single type\n    //      of a one-argument T's constructor.\n    //  (d*) Weak compilers (BCB) might also resolved Expr as optional<T> and optional<U>\n    //       even though explicit overloads are present for these.\n    // Depending on the above some T ctor is called.\n    // Can throw is the resolved T ctor throws.\n    template<class Expr>\n    explicit optional ( Expr const& expr ) : base(expr,boost::addressof(expr)) {}\n#endif\n\n    // Creates a deep copy of another optional<T>\n    // Can throw if T::T(T const&) does\n    optional ( optional const& rhs ) : base( static_cast<base const&>(rhs) ) {}\n\n   // No-throw (assuming T::~T() doesn't)\n    ~optional() {}\n\n#if !defined(BOOST_OPTIONAL_NO_INPLACE_FACTORY_SUPPORT) && !defined(BOOST_OPTIONAL_WEAK_OVERLOAD_RESOLUTION)\n    // Assigns from an expression. See corresponding constructor.\n    // Basic Guarantee: If the resolved T ctor throws, this is left UNINITIALIZED\n    template<class Expr>\n    optional& operator= ( Expr const& expr )\n      {\n        this->assign_expr(expr,boost::addressof(expr));\n        return *this ;\n      }\n#endif\n\n\n#ifndef BOOST_OPTIONAL_NO_CONVERTING_ASSIGNMENT\n    // Assigns from another convertible optional<U> (converts && deep-copies the rhs value)\n    // Requires a valid conversion from U to T.\n    // Basic Guarantee: If T::T( U const& ) throws, this is left UNINITIALIZED\n    template<class U>\n    optional& operator= ( optional<U> const& rhs )\n      {\n        this->assign(rhs);\n        return *this ;\n      }\n#endif\n\n    // Assigns from another optional<T> (deep-copies the rhs value)\n    // Basic Guarantee: If T::T( T const& ) throws, this is left UNINITIALIZED\n    //  (NOTE: On BCB, this operator is not actually called and left is left UNMODIFIED in case of a throw)\n    optional& operator= ( optional const& rhs )\n      {\n        this->assign( static_cast<base const&>(rhs) ) ;\n        return *this ;\n      }\n\n    // Assigns from a T (deep-copies the rhs value)\n    // Basic Guarantee: If T::( T const& ) throws, this is left UNINITIALIZED\n    optional& operator= ( argument_type val )\n      {\n        this->assign( val ) ;\n        return *this ;\n      }\n\n    // Assigns from a \"none\"\n    // Which destroys the current value, if any, leaving this UNINITIALIZED\n    // No-throw (assuming T::~T() doesn't)\n    optional& operator= ( none_t none_ )\n      {\n        this->assign( none_ ) ;\n        return *this ;\n      }\n\n    void swap( optional & arg )\n      {\n        // allow for Koenig lookup\n        using boost::swap;\n        swap(*this, arg);\n      }\n\n\n    // Returns a reference to the value if this is initialized, otherwise,\n    // the behaviour is UNDEFINED\n    // No-throw\n    reference_const_type get() const { BOOST_ASSERT(this->is_initialized()) ; return this->get_impl(); }\n    reference_type       get()       { BOOST_ASSERT(this->is_initialized()) ; return this->get_impl(); }\n\n    // Returns a copy of the value if this is initialized, 'v' otherwise\n    reference_const_type get_value_or ( reference_const_type v ) const { return this->is_initialized() ? get() : v ; }\n    reference_type       get_value_or ( reference_type       v )       { return this->is_initialized() ? get() : v ; }\n\n    // Returns a pointer to the value if this is initialized, otherwise,\n    // the behaviour is UNDEFINED\n    // No-throw\n    pointer_const_type operator->() const { BOOST_ASSERT(this->is_initialized()) ; return this->get_ptr_impl() ; }\n    pointer_type       operator->()       { BOOST_ASSERT(this->is_initialized()) ; return this->get_ptr_impl() ; }\n\n    // Returns a reference to the value if this is initialized, otherwise,\n    // the behaviour is UNDEFINED\n    // No-throw\n    reference_const_type operator *() const { return this->get() ; }\n    reference_type       operator *()       { return this->get() ; }\n\n    // implicit conversion to \"bool\"\n    // No-throw\n    operator unspecified_bool_type() const { return this->safe_bool() ; }\n\n    // This is provided for those compilers which don't like the conversion to bool\n    // on some contexts.\n    bool operator!() const { return !this->is_initialized() ; }\n} ;\n\n// Returns optional<T>(v)\ntemplate<class T>\ninline\noptional<T> make_optional ( T const& v  )\n{\n  return optional<T>(v);\n}\n\n// Returns optional<T>(cond,v)\ntemplate<class T>\ninline\noptional<T> make_optional ( bool cond, T const& v )\n{\n  return optional<T>(cond,v);\n}\n\n// Returns a reference to the value if this is initialized, otherwise, the behaviour is UNDEFINED.\n// No-throw\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::reference_const_type\nget ( optional<T> const& opt )\n{\n  return opt.get() ;\n}\n\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::reference_type\nget ( optional<T>& opt )\n{\n  return opt.get() ;\n}\n\n// Returns a pointer to the value if this is initialized, otherwise, returns NULL.\n// No-throw\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::pointer_const_type\nget ( optional<T> const* opt )\n{\n  return opt->get_ptr() ;\n}\n\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::pointer_type\nget ( optional<T>* opt )\n{\n  return opt->get_ptr() ;\n}\n\n// Returns a reference to the value if this is initialized, otherwise, the behaviour is UNDEFINED.\n// No-throw\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::reference_const_type\nget_optional_value_or ( optional<T> const& opt, BOOST_DEDUCED_TYPENAME optional<T>::reference_const_type v )\n{\n  return opt.get_value_or(v) ;\n}\n\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::reference_type\nget_optional_value_or ( optional<T>& opt, BOOST_DEDUCED_TYPENAME optional<T>::reference_type v )\n{\n  return opt.get_value_or(v) ;\n}\n\n// Returns a pointer to the value if this is initialized, otherwise, returns NULL.\n// No-throw\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::pointer_const_type\nget_pointer ( optional<T> const& opt )\n{\n  return opt.get_ptr() ;\n}\n\ntemplate<class T>\ninline\nBOOST_DEDUCED_TYPENAME optional<T>::pointer_type\nget_pointer ( optional<T>& opt )\n{\n  return opt.get_ptr() ;\n}\n\n// optional's relational operators ( ==, !=, <, >, <=, >= ) have deep-semantics (compare values).\n// WARNING: This is UNLIKE pointers. Use equal_pointees()/less_pointess() in generic code instead.\n\n\n//\n// optional<T> vs optional<T> cases\n//\n\ntemplate<class T>\ninline\nbool operator == ( optional<T> const& x, optional<T> const& y )\n{ return equal_pointees(x,y); }\n\ntemplate<class T>\ninline\nbool operator < ( optional<T> const& x, optional<T> const& y )\n{ return less_pointees(x,y); }\n\ntemplate<class T>\ninline\nbool operator != ( optional<T> const& x, optional<T> const& y )\n{ return !( x == y ) ; }\n\ntemplate<class T>\ninline\nbool operator > ( optional<T> const& x, optional<T> const& y )\n{ return y < x ; }\n\ntemplate<class T>\ninline\nbool operator <= ( optional<T> const& x, optional<T> const& y )\n{ return !( y < x ) ; }\n\ntemplate<class T>\ninline\nbool operator >= ( optional<T> const& x, optional<T> const& y )\n{ return !( x < y ) ; }\n\n\n//\n// optional<T> vs T cases\n//\ntemplate<class T>\ninline\nbool operator == ( optional<T> const& x, T const& y )\n{ return equal_pointees(x, optional<T>(y)); }\n\ntemplate<class T>\ninline\nbool operator < ( optional<T> const& x, T const& y )\n{ return less_pointees(x, optional<T>(y)); }\n\ntemplate<class T>\ninline\nbool operator != ( optional<T> const& x, T const& y )\n{ return !( x == y ) ; }\n\ntemplate<class T>\ninline\nbool operator > ( optional<T> const& x, T const& y )\n{ return y < x ; }\n\ntemplate<class T>\ninline\nbool operator <= ( optional<T> const& x, T const& y )\n{ return !( y < x ) ; }\n\ntemplate<class T>\ninline\nbool operator >= ( optional<T> const& x, T const& y )\n{ return !( x < y ) ; }\n\n//\n// T vs optional<T> cases\n//\n\ntemplate<class T>\ninline\nbool operator == ( T const& x, optional<T> const& y )\n{ return equal_pointees( optional<T>(x), y ); }\n\ntemplate<class T>\ninline\nbool operator < ( T const& x, optional<T> const& y )\n{ return less_pointees( optional<T>(x), y ); }\n\ntemplate<class T>\ninline\nbool operator != ( T const& x, optional<T> const& y )\n{ return !( x == y ) ; }\n\ntemplate<class T>\ninline\nbool operator > ( T const& x, optional<T> const& y )\n{ return y < x ; }\n\ntemplate<class T>\ninline\nbool operator <= ( T const& x, optional<T> const& y )\n{ return !( y < x ) ; }\n\ntemplate<class T>\ninline\nbool operator >= ( T const& x, optional<T> const& y )\n{ return !( x < y ) ; }\n\n\n//\n// optional<T> vs none cases\n//\n\ntemplate<class T>\ninline\nbool operator == ( optional<T> const& x, none_t )\n{ return equal_pointees(x, optional<T>() ); }\n\ntemplate<class T>\ninline\nbool operator < ( optional<T> const& x, none_t )\n{ return less_pointees(x,optional<T>() ); }\n\ntemplate<class T>\ninline\nbool operator != ( optional<T> const& x, none_t y )\n{ return !( x == y ) ; }\n\ntemplate<class T>\ninline\nbool operator > ( optional<T> const& x, none_t y )\n{ return y < x ; }\n\ntemplate<class T>\ninline\nbool operator <= ( optional<T> const& x, none_t y )\n{ return !( y < x ) ; }\n\ntemplate<class T>\ninline\nbool operator >= ( optional<T> const& x, none_t y )\n{ return !( x < y ) ; }\n\n//\n// none vs optional<T> cases\n//\n\ntemplate<class T>\ninline\nbool operator == ( none_t , optional<T> const& y )\n{ return equal_pointees(optional<T>() ,y); }\n\ntemplate<class T>\ninline\nbool operator < ( none_t , optional<T> const& y )\n{ return less_pointees(optional<T>() ,y); }\n\ntemplate<class T>\ninline\nbool operator != ( none_t x, optional<T> const& y )\n{ return !( x == y ) ; }\n\ntemplate<class T>\ninline\nbool operator > ( none_t x, optional<T> const& y )\n{ return y < x ; }\n\ntemplate<class T>\ninline\nbool operator <= ( none_t x, optional<T> const& y )\n{ return !( y < x ) ; }\n\ntemplate<class T>\ninline\nbool operator >= ( none_t x, optional<T> const& y )\n{ return !( x < y ) ; }\n\nnamespace optional_detail {\n\ntemplate<bool use_default_constructor> struct swap_selector;\n\ntemplate<>\nstruct swap_selector<true>\n{\n    template<class T>\n    static void optional_swap ( optional<T>& x, optional<T>& y )\n    {\n        const bool hasX = !!x;\n        const bool hasY = !!y;\n\n        if ( !hasX && !hasY )\n            return;\n\n        if( !hasX )\n            x = boost::in_place();\n        else if ( !hasY )\n            y = boost::in_place();\n\n        // Boost.Utility.Swap will take care of ADL and workarounds for broken compilers\n        boost::swap(x.get(),y.get());\n\n        if( !hasX )\n            y = boost::none ;\n        else if( !hasY )\n            x = boost::none ;\n    }\n};\n\ntemplate<>\nstruct swap_selector<false>\n{\n    template<class T>\n    static void optional_swap ( optional<T>& x, optional<T>& y )\n    {\n        const bool hasX = !!x;\n        const bool hasY = !!y;\n\n        if ( !hasX && hasY )\n        {\n            x = y.get();\n            y = boost::none ;\n        }\n        else if ( hasX && !hasY )\n        {\n            y = x.get();\n            x = boost::none ;\n        }\n        else if ( hasX && hasY )\n        {\n            // Boost.Utility.Swap will take care of ADL and workarounds for broken compilers\n            boost::swap(x.get(),y.get());\n        }\n    }\n};\n\n} // namespace optional_detail\n\ntemplate<class T>\nstruct optional_swap_should_use_default_constructor : has_nothrow_default_constructor<T> {} ;\n\ntemplate<class T> inline void swap ( optional<T>& x, optional<T>& y )\n{\n    optional_detail::swap_selector<optional_swap_should_use_default_constructor<T>::value>::optional_swap(x, y);\n}\n\n} // namespace boost\n\n#endif\n","// ----------------------------------------------------------------------------\n// parsing.hpp :  implementation of the parsing member functions\n//                      ( parse, parse_printf_directive)\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n// see http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_PARSING_HPP\n#define BOOST_FORMAT_PARSING_HPP\n\n\n#include <boost/format/format_class.hpp>\n#include <boost/format/exceptions.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/assert.hpp>\n\n\nnamespace boost {\nnamespace io {\nnamespace detail {\n\n#if defined(BOOST_NO_STD_LOCALE)\n    // streams will be used for narrow / widen. but these methods are not const\n    template<class T>\n    T& const_or_not(const T& x) { \n        return const_cast<T&> (x);\n    }\n#else\n    template<class T>\n    const T& const_or_not(const T& x) { \n        return x;\n    }\n#endif\n\n    template<class Ch, class Facet> inline\n    char wrap_narrow(const Facet& fac, Ch c, char deflt) {\n        return const_or_not(fac).narrow(c, deflt);\n    }\n\n    template<class Ch, class Facet> inline\n    bool wrap_isdigit(const Facet& fac, Ch c) {\n#if ! defined( BOOST_NO_LOCALE_ISDIGIT )\n        return fac.is(std::ctype<Ch>::digit, c);\n# else\n        (void) fac;     // remove \"unused parameter\" warning\n        using namespace std;\n        return isdigit(c); \n#endif \n    }\n \n    template<class Iter, class Facet> \n    Iter wrap_scan_notdigit(const Facet & fac, Iter beg, Iter end) {\n        using namespace std;\n        for( ; beg!=end && wrap_isdigit(fac, *beg); ++beg) ;\n        return beg;\n    }\n\n\n    // Input : [start, last) iterators range and a\n    //          a Facet to use its widen/narrow member function\n    // Effects : read sequence and convert digits into integral n, of type Res\n    // Returns : n\n    template<class Res, class Iter, class Facet>\n    Iter str2int (const Iter & start, const Iter & last, Res & res, \n                 const Facet& fac) \n    {\n        using namespace std;\n        Iter it;\n        res=0;\n        for(it=start; it != last && wrap_isdigit(fac, *it); ++it ) {\n            char cur_ch = wrap_narrow(fac, *it, 0); // cant fail.\n            res *= 10;\n            res += cur_ch - '0'; // 22.2.1.1.2.13 of the C++ standard\n        }\n        return it;\n    }\n\n    // skip printf's \"asterisk-fields\" directives in the format-string buf\n    // Input : char string, with starting index *pos_p\n    //         a Facet merely to use its widen/narrow member function\n    // Effects : advance *pos_p by skipping printf's asterisk fields.\n    // Returns : nothing\n    template<class Iter, class Facet>\n    Iter skip_asterisk(Iter start, Iter last, const Facet& fac) \n    {\n        using namespace std;\n        ++ start;\n        start = wrap_scan_notdigit(fac, start, last);\n        if(start!=last && *start== const_or_not(fac).widen( '$') )\n            ++start;\n        return start;\n    }\n\n\n    // auxiliary func called by parse_printf_directive\n    // for centralising error handling\n    // it either throws if user sets the corresponding flag, or does nothing.\n    inline void maybe_throw_exception(unsigned char exceptions, \n                                      std::size_t pos, std::size_t size)\n    {\n        if(exceptions & io::bad_format_string_bit)\n            boost::throw_exception(io::bad_format_string(pos, size) );\n    }\n    \n\n    // Input: the position of a printf-directive in the format-string\n    //    a basic_ios& merely to use its widen/narrow member function\n    //    a bitset'exceptions' telling whether to throw exceptions on errors.\n    // Returns:\n    //  true if parse succeeded (ignore some errors if exceptions disabled)\n    //  false if it failed so bad that the directive should be printed verbatim\n    // Effects:\n    //  start is incremented so that *start is the first char after\n    //     this directive\n    //  *fpar is set with the parameters read in the directive\n    template<class Ch, class Tr, class Alloc, class Iter, class Facet>\n    bool parse_printf_directive(Iter & start, const Iter& last, \n                                detail::format_item<Ch, Tr, Alloc> * fpar,\n                                const Facet& fac,\n                                std::size_t offset, unsigned char exceptions)\n    {\n        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;\n\n        fpar->argN_ = format_item_t::argN_no_posit;  // if no positional-directive\n        bool precision_set = false;\n        bool in_brackets=false;\n        Iter start0 = start;\n        std::size_t fstring_size = last-start0+offset;\n\n        if(start>= last) { // empty directive : this is a trailing %\n                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);\n                return false;\n        }          \n          \n        if(*start== const_or_not(fac).widen( '|')) {\n            in_brackets=true;\n            if( ++start >= last ) {\n                maybe_throw_exception(exceptions, start-start0 + offset, fstring_size);\n                return false;\n            }\n        }\n\n        // the flag '0' would be picked as a digit for argument order, but here it's a flag :\n        if(*start== const_or_not(fac).widen( '0')) \n            goto parse_flags;\n\n        // handle argument order (%2$d)  or possibly width specification: %2d\n        if(wrap_isdigit(fac, *start)) {\n            int n;\n            start = str2int(start, last, n, fac);\n            if( start >= last ) {\n                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n                return false;\n            }\n            \n            // %N% case : this is already the end of the directive\n            if( *start ==  const_or_not(fac).widen( '%') ) {\n                fpar->argN_ = n-1;\n                ++start;\n                if( in_brackets) \n                    maybe_throw_exception(exceptions, start-start0+offset, fstring_size); \n                // but don't return.  maybe \"%\" was used in lieu of '$', so we go on.\n                else\n                    return true;\n            }\n\n            if ( *start== const_or_not(fac).widen( '$') ) {\n                fpar->argN_ = n-1;\n                ++start;\n            } \n            else {\n                // non-positionnal directive\n                fpar->fmtstate_.width_ = n;\n                fpar->argN_  = format_item_t::argN_no_posit;\n                goto parse_precision;\n            }\n        }\n    \n      parse_flags: \n        // handle flags\n        while ( start != last) { // as long as char is one of + - = _ # 0 l h   or ' '\n            // misc switches\n            switch ( wrap_narrow(fac, *start, 0)) {\n            case '\\'' : break; // no effect yet. (painful to implement)\n            case 'l':\n            case 'h':  // short/long modifier : for printf-comaptibility (no action needed)\n                break;\n            case '-':\n                fpar->fmtstate_.flags_ |= std::ios_base::left;\n                break;\n            case '=':\n                fpar->pad_scheme_ |= format_item_t::centered;\n                break;\n            case '_':\n                fpar->fmtstate_.flags_ |= std::ios_base::internal;\n                break;\n            case ' ':\n                fpar->pad_scheme_ |= format_item_t::spacepad;\n                break;\n            case '+':\n                fpar->fmtstate_.flags_ |= std::ios_base::showpos;\n                break;\n            case '0':\n                fpar->pad_scheme_ |= format_item_t::zeropad;\n                // need to know alignment before really setting flags,\n                // so just add 'zeropad' flag for now, it will be processed later.\n                break;\n            case '#':\n                fpar->fmtstate_.flags_ |= std::ios_base::showpoint | std::ios_base::showbase;\n                break;\n            default:\n                goto parse_width;\n            }\n            ++start;\n        } // loop on flag.\n\n        if( start>=last) {\n            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n            return true; \n        }\n      parse_width:\n        // handle width spec\n        // first skip 'asterisk fields' :  *, or *N$\n        if(*start == const_or_not(fac).widen( '*') )\n            start = skip_asterisk(start, last, fac); \n        if(start!=last && wrap_isdigit(fac, *start))\n            start = str2int(start, last, fpar->fmtstate_.width_, fac);\n\n      parse_precision:\n        if( start>= last) { \n            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n            return true;\n        }\n        // handle precision spec\n        if (*start== const_or_not(fac).widen( '.')) {\n            ++start;\n            if(start != last && *start == const_or_not(fac).widen( '*') )\n                start = skip_asterisk(start, last, fac); \n            if(start != last && wrap_isdigit(fac, *start)) {\n                start = str2int(start, last, fpar->fmtstate_.precision_, fac);\n                precision_set = true;\n            }\n            else\n                fpar->fmtstate_.precision_ =0;\n        }\n    \n        // handle  formatting-type flags :\n        while( start != last && ( *start== const_or_not(fac).widen( 'l') \n                                  || *start== const_or_not(fac).widen( 'L') \n                                  || *start== const_or_not(fac).widen( 'h')) )\n            ++start;\n        if( start>=last) {\n            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n            return true;\n        }\n\n        if( in_brackets && *start== const_or_not(fac).widen( '|') ) {\n            ++start;\n            return true;\n        }\n        switch ( wrap_narrow(fac, *start, 0) ) {\n        case 'X':\n            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;\n        case 'p': // pointer => set hex.\n        case 'x':\n            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;\n            fpar->fmtstate_.flags_ |= std::ios_base::hex;\n            break;\n\n        case 'o':\n            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::oct;\n            break;\n\n        case 'E':\n            fpar->fmtstate_.flags_ |=  std::ios_base::uppercase;\n        case 'e':\n            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::scientific;\n\n            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::dec;\n            break;\n      \n        case 'f':\n            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::fixed;\n        case 'u':\n        case 'd':\n        case 'i':\n            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::dec;\n            break;\n\n        case 'T':\n            ++start;\n            if( start >= last)\n                maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n            else\n                fpar->fmtstate_.fill_ = *start;\n            fpar->pad_scheme_ |= format_item_t::tabulation;\n            fpar->argN_ = format_item_t::argN_tabulation; \n            break;\n        case 't': \n            fpar->fmtstate_.fill_ = const_or_not(fac).widen( ' ');\n            fpar->pad_scheme_ |= format_item_t::tabulation;\n            fpar->argN_ = format_item_t::argN_tabulation; \n            break;\n\n        case 'G':\n            fpar->fmtstate_.flags_ |= std::ios_base::uppercase;\n            break;\n        case 'g': // 'g' conversion is default for floats.\n            fpar->fmtstate_.flags_ &= ~std::ios_base::basefield;\n            fpar->fmtstate_.flags_ |=  std::ios_base::dec;\n\n            // CLEAR all floatield flags, so stream will CHOOSE\n            fpar->fmtstate_.flags_ &= ~std::ios_base::floatfield; \n            break;\n\n        case 'C':\n        case 'c': \n            fpar->truncate_ = 1;\n            break;\n        case 'S':\n        case 's': \n            if(precision_set) // handle truncation manually, with own parameter.\n                fpar->truncate_ = fpar->fmtstate_.precision_;\n            fpar->fmtstate_.precision_ = 6; // default stream precision.\n            break;\n        case 'n' :  \n            fpar->argN_ = format_item_t::argN_ignored;\n            break;\n        default: \n            maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n        }\n        ++start;\n\n        if( in_brackets ) {\n            if( start != last && *start== const_or_not(fac).widen( '|') ) {\n                ++start;\n                return true;\n            }\n            else  maybe_throw_exception(exceptions, start-start0+offset, fstring_size);\n        }\n        return true;\n    }\n    // -end parse_printf_directive()\n\n    template<class String, class Facet>\n    int upper_bound_from_fstring(const String& buf, \n                                 const typename String::value_type arg_mark,\n                                 const Facet& fac, \n                                 unsigned char exceptions) \n    {\n        // quick-parsing of the format-string to count arguments mark (arg_mark, '%')\n        // returns : upper bound on the number of format items in the format strings\n        using namespace boost::io;\n        typename String::size_type i1=0;\n        int num_items=0;\n        while( (i1=buf.find(arg_mark,i1)) != String::npos ) {\n            if( i1+1 >= buf.size() ) {\n                if(exceptions & bad_format_string_bit)\n                    boost::throw_exception(bad_format_string(i1, buf.size() )); // must not end in \".. %\"\n                else {\n                  ++num_items;\n                  break;\n                }\n            }\n            if(buf[i1+1] == buf[i1] ) {// escaped \"%%\"\n                i1+=2; continue; \n            }\n\n            ++i1;\n            // in case of %N% directives, dont count it double (wastes allocations..) :\n            i1 = detail::wrap_scan_notdigit(fac, buf.begin()+i1, buf.end()) - buf.begin();\n            if( i1 < buf.size() && buf[i1] == arg_mark )\n                ++i1;\n            ++num_items;\n        }\n        return num_items;\n    }\n    template<class String> inline\n    void append_string(String& dst, const String& src, \n                       const typename String::size_type beg, \n                       const typename String::size_type end) {\n#if !defined(BOOST_NO_STRING_APPEND)\n        dst.append(src.begin()+beg, src.begin()+end);\n#else\n        dst += src.substr(beg, end-beg);\n#endif\n    }\n\n} // detail namespace\n} // io namespace\n\n\n\n// -----------------------------------------------\n//  format :: parse(..)\n\n    template<class Ch, class Tr, class Alloc>\n    basic_format<Ch, Tr, Alloc>& basic_format<Ch, Tr, Alloc>:: \n    parse (const string_type& buf) {\n        // parse the format-string \n        using namespace std;\n#if !defined(BOOST_NO_STD_LOCALE)\n        const std::ctype<Ch> & fac = BOOST_USE_FACET( std::ctype<Ch>, getloc());\n#else\n        io::basic_oaltstringstream<Ch, Tr, Alloc> fac; \n        //has widen and narrow even on compilers without locale\n#endif\n\n        const Ch arg_mark = io::detail::const_or_not(fac).widen( '%');\n        bool ordered_args=true; \n        int max_argN=-1;\n\n        // A: find upper_bound on num_items and allocates arrays\n        int num_items = io::detail::upper_bound_from_fstring(buf, arg_mark, fac, exceptions());\n        make_or_reuse_data(num_items);\n\n        // B: Now the real parsing of the format string :\n        num_items=0;\n        typename string_type::size_type i0=0, i1=0;\n        typename string_type::const_iterator it;\n        bool special_things=false;\n        int cur_item=0;\n        while( (i1=buf.find(arg_mark,i1)) != string_type::npos ) {\n            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;\n            if( buf[i1+1] == buf[i1] ) { // escaped mark, '%%' \n                io::detail::append_string(piece, buf, i0, i1+1);\n                i1+=2; i0=i1;\n                continue; \n            }\n            BOOST_ASSERT(  static_cast<unsigned int>(cur_item) < items_.size() || cur_item==0);\n\n            if(i1!=i0) {\n                io::detail::append_string(piece, buf, i0, i1);\n                i0=i1;\n            }\n            ++i1;\n            it = buf.begin()+i1;\n            bool parse_ok = io::detail::parse_printf_directive(\n                it, buf.end(), &items_[cur_item], fac, i1, exceptions());\n            i1 = it - buf.begin();\n            if( ! parse_ok ) // the directive will be printed verbatim\n                continue; \n            i0=i1;\n            items_[cur_item].compute_states(); // process complex options, like zeropad, into params\n\n            int argN=items_[cur_item].argN_;\n            if(argN == format_item_t::argN_ignored)\n                continue;\n            if(argN ==format_item_t::argN_no_posit)\n                ordered_args=false;\n            else if(argN == format_item_t::argN_tabulation) special_things=true;\n            else if(argN > max_argN) max_argN = argN;\n            ++num_items;\n            ++cur_item;\n        } // loop on %'s\n        BOOST_ASSERT(cur_item == num_items);\n    \n        // store the final piece of string\n        {\n            string_type & piece = (cur_item==0) ? prefix_ : items_[cur_item-1].appendix_;\n            io::detail::append_string(piece, buf, i0, buf.size());\n        }\n    \n        if( !ordered_args) {\n            if(max_argN >= 0 ) {  // dont mix positional with non-positionnal directives\n                if(exceptions() & io::bad_format_string_bit)\n                    boost::throw_exception(io::bad_format_string(max_argN, 0));\n                // else do nothing. => positionnal arguments are processed as non-positionnal\n            }\n            // set things like it would have been with positional directives :\n            int non_ordered_items = 0;\n            for(int i=0; i< num_items; ++i)\n                if(items_[i].argN_ == format_item_t::argN_no_posit) {\n                    items_[i].argN_ = non_ordered_items;\n                    ++non_ordered_items;\n                }\n            max_argN = non_ordered_items-1;\n        }\n    \n        // C: set some member data :\n        items_.resize(num_items, format_item_t(io::detail::const_or_not(fac).widen( ' ')) );\n\n        if(special_things) style_ |= special_needs;\n        num_args_ = max_argN + 1;\n        if(ordered_args) style_ |=  ordered;\n        else style_ &= ~ordered;\n        return *this;\n    }\n\n} // namespace boost\n\n\n#endif //  BOOST_FORMAT_PARSING_HPP\n","// ----------------------------------------------------------------------------\n// internals.hpp :  internal structs : stream_format_state, format_item. \n//                  included by format.hpp\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_INTERNALS_HPP\n#define BOOST_FORMAT_INTERNALS_HPP\n\n\n#include <string>\n#include <boost/assert.hpp>\n#include <boost/optional.hpp>\n#include <boost/limits.hpp>\n#include <boost/format/detail/compat_workarounds.hpp>\n#include <boost/format/alt_sstream.hpp> // used as a dummy stream\n\nnamespace boost {\nnamespace io {\nnamespace detail {\n\n\n//---- stream_format_state --------------------------------------------------//\n\n//   set of params that define the format state of a stream\n    template<class Ch, class Tr> \n    struct stream_format_state \n    {\n        typedef BOOST_IO_STD basic_ios<Ch, Tr>   basic_ios;\n\n        stream_format_state(Ch fill)                 { reset(fill); }\n//        stream_format_state(const basic_ios& os)     { set_by_stream(os); }\n\n        void reset(Ch fill);                     //- sets to default state.\n        void set_by_stream(const basic_ios& os); //- sets to os's state.\n        void apply_on(basic_ios & os,            //- applies format_state to the stream\n                      boost::io::detail::locale_t * loc_default = 0) const;\n        template<class T> \n        void apply_manip(T manipulator)          //- modifies state by applying manipulator\n            { apply_manip_body<Ch, Tr, T>( *this, manipulator) ; }\n\n        // --- data ---\n        std::streamsize width_;\n        std::streamsize precision_;\n        Ch fill_; \n        std::ios_base::fmtflags flags_;\n        std::ios_base::iostate  rdstate_;\n        std::ios_base::iostate  exceptions_;\n        boost::optional<boost::io::detail::locale_t>  loc_;\n    };  \n\n\n//---- format_item  ---------------------------------------------------------//\n\n//   stores all parameters that can be specified in format strings\n    template<class Ch, class Tr, class Alloc>  \n    struct format_item \n    {     \n        enum pad_values { zeropad = 1, spacepad =2, centered=4, tabulation = 8 };\n                         // 1. if zeropad is set, all other bits are not, \n                         // 2. if tabulation is set, all others are not.\n                         // centered and spacepad can be mixed freely.\n        enum arg_values { argN_no_posit   = -1, // non-positional directive. will set argN later\n                          argN_tabulation = -2, // tabulation directive. (no argument read) \n                          argN_ignored    = -3  // ignored directive. (no argument read)\n        };\n        typedef BOOST_IO_STD basic_ios<Ch, Tr>                    basic_ios;\n        typedef detail::stream_format_state<Ch, Tr>               stream_format_state;\n        typedef ::std::basic_string<Ch, Tr, Alloc>                string_type;\n\n        format_item(Ch fill) :argN_(argN_no_posit), fmtstate_(fill), \n                              truncate_(max_streamsize()), pad_scheme_(0)  {}\n        void reset(Ch fill);\n        void compute_states(); // sets states  according to truncate and pad_scheme.\n\n        static std::streamsize max_streamsize() { \n            return (std::numeric_limits<std::streamsize>::max)();\n        }\n\n        // --- data ---\n        int         argN_;  //- argument number (starts at 0,  eg : %1 => argN=0)\n                            //  negative values for items that don't process an argument\n        string_type  res_;      //- result of the formatting of this item\n        string_type  appendix_; //- piece of string between this item and the next\n\n        stream_format_state fmtstate_;// set by parsing, is only affected by modify_item\n\n        std::streamsize truncate_;//- is set for directives like %.5s that ask truncation\n        unsigned int pad_scheme_;//- several possible padding schemes can mix. see pad_values\n    }; \n\n\n\n//--- Definitions  ------------------------------------------------------------\n\n// -   stream_format_state:: -------------------------------------------------\n    template<class Ch, class Tr>\n    void stream_format_state<Ch,Tr>:: apply_on (basic_ios & os,\n                      boost::io::detail::locale_t * loc_default) const {\n        // set the state of this stream according to our params\n        if(width_ != -1)\n            os.width(width_);\n        if(precision_ != -1)\n            os.precision(precision_);\n        if(fill_ != 0)\n            os.fill(fill_);\n        os.flags(flags_);\n        os.clear(rdstate_);\n        os.exceptions(exceptions_);\n#if !defined(BOOST_NO_STD_LOCALE)\n        if(loc_)\n            os.imbue(loc_.get());\n        else if(loc_default)\n            os.imbue(*loc_default);\n#else\n        (void) loc_default; // keep compiler quiet if we don't support locales\n#endif        \n    }\n\n    template<class Ch, class Tr>\n    void stream_format_state<Ch,Tr>:: set_by_stream(const basic_ios& os) {\n        // set our params according to the state of this stream\n        flags_ = os.flags();\n        width_ = os.width();\n        precision_ = os.precision();\n        fill_ = os.fill();\n        rdstate_ = os.rdstate();\n        exceptions_ = os.exceptions();\n    }\n\n\n    template<class Ch, class Tr, class T>\n    void apply_manip_body( stream_format_state<Ch, Tr>& self,\n                           T manipulator) {\n        // modify our params according to the manipulator\n        basic_oaltstringstream<Ch, Tr>  ss;\n        self.apply_on( ss );\n        ss << manipulator;\n        self.set_by_stream( ss );\n    }\n\n    template<class Ch, class Tr> inline\n    void stream_format_state<Ch,Tr>:: reset(Ch fill) {\n        // set our params to standard's default state.   cf 27.4.4.1 of the C++ norm\n        width_=0; precision_=6; \n        fill_=fill; // default is widen(' '), but we cant compute it without the locale\n        flags_ = std::ios_base::dec | std::ios_base::skipws; \n        // the adjust_field part is left equal to 0, which means right.\n        exceptions_ = std::ios_base::goodbit;\n        rdstate_ = std::ios_base::goodbit;\n    }\n\n\n// ---   format_item:: --------------------------------------------------------\n\n    template<class Ch, class Tr, class Alloc> \n    void format_item<Ch, Tr, Alloc>:: \n    reset (Ch fill) { \n        argN_=argN_no_posit; truncate_ = max_streamsize(); pad_scheme_ =0; \n        res_.resize(0); appendix_.resize(0);\n        fmtstate_.reset(fill);\n    }\n\n    template<class Ch, class Tr, class Alloc> \n    void format_item<Ch, Tr, Alloc>:: \n    compute_states() {\n        // reflect pad_scheme_   on  fmt_state_\n        //   because some pad_schemes has complex consequences on several state params.\n        if(pad_scheme_ & zeropad) {\n            // ignore zeropad in left alignment :\n            if(fmtstate_.flags_ & std::ios_base::left) {\n              BOOST_ASSERT(!(fmtstate_.flags_ &(std::ios_base::adjustfield ^std::ios_base::left)));\n              // only left bit might be set. (not right, nor internal)\n              pad_scheme_ = pad_scheme_ & (~zeropad); \n            }\n            else { \n                pad_scheme_ &= ~spacepad; // printf ignores spacepad when zeropadding\n                fmtstate_.fill_='0'; \n                fmtstate_.flags_ = (fmtstate_.flags_ & ~std::ios_base::adjustfield) \n                    | std::ios_base::internal;\n                // removes all adjustfield bits, and adds internal.\n            }\n        }\n        if(pad_scheme_ & spacepad) {\n            if(fmtstate_.flags_ & std::ios_base::showpos)\n                pad_scheme_ &= ~spacepad;\n        }\n    }\n\n\n} } } // namespaces boost :: io :: detail\n\n\n#endif // BOOST_FORMAT_INTERNALS_HPP\n","// ----------------------------------------------------------------------------\n//  alt_sstream_impl.hpp : alternative stringstream, templates implementation \n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_SK_ALT_SSTREAM_IMPL_HPP\n#define BOOST_SK_ALT_SSTREAM_IMPL_HPP\n\nnamespace boost {\n    namespace io {\n// --- Implementation  ------------------------------------------------------//\n\n        template<class Ch, class Tr, class Alloc>\n        void basic_altstringbuf<Ch, Tr, Alloc>:: \n        clear_buffer () {\n            const Ch * p = pptr();\n            const Ch * b = pbase();\n            if(p != NULL && p != b) {\n                seekpos(0, ::std::ios_base::out); \n            }\n            p = gptr();\n            b = eback();\n            if(p != NULL && p != b) {\n                seekpos(0, ::std::ios_base::in); \n            }\n        }\n\n        template<class Ch, class Tr, class Alloc>\n        void basic_altstringbuf<Ch, Tr, Alloc>:: \n        str (const string_type& s) {\n            size_type sz=s.size();\n            if(sz != 0 && mode_ & (::std::ios_base::in | ::std::ios_base::out) ) {\n#ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC\n                void *vd_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);\n                Ch *new_ptr = static_cast<Ch *>(vd_ptr);\n#else\n                Ch *new_ptr = alloc_.allocate(sz, is_allocated_? eback() : 0);\n#endif\n                // if this didnt throw, we're safe, update the buffer\n                dealloc();\n                sz = s.copy(new_ptr, sz);\n                putend_ = new_ptr + sz;\n                if(mode_ & ::std::ios_base::in)\n                    streambuf_t::setg(new_ptr, new_ptr, new_ptr + sz);\n                if(mode_ & ::std::ios_base::out) {\n                    streambuf_t::setp(new_ptr, new_ptr + sz);\n                    if(mode_ & (::std::ios_base::app | ::std::ios_base::ate))\n                        streambuf_t::pbump(static_cast<int>(sz));\n                    if(gptr() == NULL)\n                        streambuf_t::setg(new_ptr, NULL, new_ptr);\n                }\n                is_allocated_ = true;\n            }\n            else \n                dealloc();\n        }\n        template<class Ch, class Tr, class Alloc>\n        Ch*   basic_altstringbuf<Ch, Tr, Alloc>:: \n        begin () const {\n            if(mode_ & ::std::ios_base::out && pptr() != NULL)\n                return pbase();\n            else if(mode_ & ::std::ios_base::in && gptr() != NULL)\n                return eback();\n            return NULL;\n        }\n\n        template<class Ch, class Tr, class Alloc>\n        typename std::basic_string<Ch,Tr,Alloc>::size_type\n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        size () const { \n            if(mode_ & ::std::ios_base::out && pptr())\n                return static_cast<size_type>(pend() - pbase());\n            else if(mode_ & ::std::ios_base::in && gptr())\n                return static_cast<size_type>(egptr() - eback());\n            else \n                return 0;\n        }\n\n        template<class Ch, class Tr, class Alloc>\n        typename std::basic_string<Ch,Tr,Alloc>::size_type\n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        cur_size () const { \n            if(mode_ & ::std::ios_base::out && pptr())\n                return static_cast<streamsize>( pptr() - pbase());\n            else if(mode_ & ::std::ios_base::in && gptr())\n                return static_cast<streamsize>( gptr() - eback());\n            else \n                return 0;\n        }\n\n        template<class Ch, class Tr, class Alloc>\n        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type  \n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        seekoff (off_type off, ::std::ios_base::seekdir way, ::std::ios_base::openmode which) {\n            if(pptr() != NULL && putend_ < pptr())\n                putend_ = pptr();\n            if(which & ::std::ios_base::in && gptr() != NULL) {\n                // get area\n                if(way == ::std::ios_base::end)\n                    off += static_cast<off_type>(putend_ - gptr());\n                else if(way == ::std::ios_base::beg)\n                    off += static_cast<off_type>(eback() - gptr());\n                else if(way != ::std::ios_base::cur || (which & ::std::ios_base::out) )\n                    // (altering in&out is only supported if way is beg or end, not cur)\n                    return pos_type(off_type(-1));\n                if(eback() <= off+gptr() && off+gptr() <= putend_ ) {\n                    // set gptr\n                    streambuf_t::gbump(static_cast<int>(off));\n                    if(which & ::std::ios_base::out && pptr() != NULL)\n                        // update pptr to match gptr\n                        streambuf_t::pbump(static_cast<int>(gptr()-pptr()));\n                }\n                else\n                    off = off_type(-1);\n            }\n            else if(which & ::std::ios_base::out && pptr() != NULL) {\n                // put area\n                if(way == ::std::ios_base::end)\n                    off += static_cast<off_type>(putend_ - pptr());\n                else if(way == ::std::ios_base::beg)\n                    off += static_cast<off_type>(pbase() - pptr());\n                else if(way != ::std::ios_base::beg)\n                    return pos_type(off_type(-1));                    \n                if(pbase() <= off+pptr() && off+pptr() <= putend_)\n                    // set pptr\n                    streambuf_t::pbump(static_cast<int>(off)); \n                else\n                    off = off_type(-1);\n            }\n            else // neither in nor out\n                off = off_type(-1);\n            return (pos_type(off));\n        }\n        //- end seekoff(..)\n\n        \n        template<class Ch, class Tr, class Alloc>\n        typename basic_altstringbuf<Ch, Tr, Alloc>::pos_type \n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        seekpos (pos_type pos, ::std::ios_base::openmode which) {\n            off_type off = off_type(pos); // operation guaranteed by 27.4.3.2 table 88\n            if(pptr() != NULL && putend_ < pptr())\n                putend_ = pptr();\n            if(off != off_type(-1)) {\n                if(which & ::std::ios_base::in && gptr() != NULL) {\n                    // get area\n                    if(0 <= off && off <= putend_ - eback()) {\n                        streambuf_t::gbump(static_cast<int>(eback() - gptr() + off));\n                        if(which & ::std::ios_base::out && pptr() != NULL) {\n                            // update pptr to match gptr\n                            streambuf_t::pbump(static_cast<int>(gptr()-pptr()));\n                        }\n                    }\n                    else\n                        off = off_type(-1);\n                }\n                else if(which & ::std::ios_base::out && pptr() != NULL) {\n                    // put area\n                    if(0 <= off && off <= putend_ - eback())\n                        streambuf_t::pbump(static_cast<int>(eback() - pptr() + off));\n                    else\n                        off = off_type(-1);\n                }\n                else // neither in nor out\n                    off = off_type(-1);\n                return (pos_type(off));\n            }\n            else {\n                BOOST_ASSERT(0); // 27.4.3.2 allows undefined-behaviour here\n                return pos_type(off_type(-1));\n            }\n        }\n        // -end seekpos(..)\n\n\n        template<class Ch, class Tr, class Alloc>\n        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type\n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        underflow () {\n            if(gptr() == NULL) // no get area -> nothing to get.\n                return (compat_traits_type::eof()); \n            else if(gptr() < egptr())  // ok, in buffer\n                return (compat_traits_type::to_int_type(*gptr())); \n            else if(mode_ & ::std::ios_base::in && pptr() != NULL\n                    && (gptr() < pptr() || gptr() < putend_) )\n                {  // expand get area \n                    if(putend_ < pptr()) \n                        putend_ = pptr(); // remember pptr reached this far\n                    streambuf_t::setg(eback(), gptr(), putend_);\n                    return (compat_traits_type::to_int_type(*gptr()));\n                }\n            else // couldnt get anything. EOF.\n                return (compat_traits_type::eof());\n        }\n        // -end underflow(..)\n\n\n        template<class Ch, class Tr, class Alloc>\n        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type \n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        pbackfail (int_type meta) {\n            if(gptr() != NULL  &&  (eback() < gptr()) \n               && (mode_ & (::std::ios_base::out)\n                   || compat_traits_type::eq_int_type(compat_traits_type::eof(), meta)\n                   || compat_traits_type::eq(compat_traits_type::to_char_type(meta), gptr()[-1]) ) ) { \n                streambuf_t::gbump(-1); // back one character\n                if(!compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))\n                    //  put-back meta into get area\n                    *gptr() = compat_traits_type::to_char_type(meta);\n                return (compat_traits_type::not_eof(meta));\n            }\n            else\n                return (compat_traits_type::eof());  // failed putback\n        }\n        // -end pbackfail(..)\n\n\n        template<class Ch, class Tr, class Alloc>\n        typename basic_altstringbuf<Ch, Tr, Alloc>::int_type \n        basic_altstringbuf<Ch, Tr, Alloc>:: \n        overflow (int_type meta) {\n#ifdef BOOST_MSVC\n#pragma warning(push)\n#pragma warning(disable:4996)\n#endif\n            if(compat_traits_type::eq_int_type(compat_traits_type::eof(), meta))\n                return compat_traits_type::not_eof(meta); // nothing to do\n            else if(pptr() != NULL && pptr() < epptr()) {\n                streambuf_t::sputc(compat_traits_type::to_char_type(meta));\n                return meta;\n            }\n            else if(! (mode_ & ::std::ios_base::out)) \n                // no write position, and cant make one\n                return compat_traits_type::eof(); \n            else { // make a write position available\n                std::size_t prev_size = pptr() == NULL ? 0 : epptr() - eback();\n                std::size_t new_size = prev_size;\n                // exponential growth : size *= 1.5\n                std::size_t add_size = new_size / 2;\n                if(add_size < alloc_min)\n                    add_size = alloc_min;\n                Ch * newptr = NULL,  *oldptr = eback();\n\n                // make sure adding add_size wont overflow size_t\n                while (0 < add_size && ((std::numeric_limits<std::size_t>::max)()\n                                        - add_size < new_size) )\n                    add_size /= 2;\n                if(0 < add_size) {\n                    new_size += add_size;\n#ifdef _RWSTD_NO_CLASS_PARTIAL_SPEC\n                    void *vdptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);\n                    newptr = static_cast<Ch *>(vdptr);\n#else\n                    newptr = alloc_.allocate(new_size, is_allocated_? oldptr : 0);\n#endif\n                }\n\n                if(0 < prev_size)\n                    compat_traits_type::copy(newptr, oldptr, prev_size);\n                if(is_allocated_)\n                    alloc_.deallocate(oldptr, prev_size);\n                is_allocated_=true;\n\n                if(prev_size == 0) { // first allocation\n                    putend_ = newptr;\n                    streambuf_t::setp(newptr, newptr + new_size);\n                    if(mode_ & ::std::ios_base::in)\n                        streambuf_t::setg(newptr, newptr, newptr + 1);\n                    else\n                        streambuf_t::setg(newptr, 0, newptr);\n                }\n                else { // update pointers\n                    putend_ = putend_ - oldptr + newptr;\n                    int pptr_count = static_cast<int>(pptr()-pbase());\n                    int gptr_count = static_cast<int>(gptr()-eback());\n                    streambuf_t::setp(pbase() - oldptr + newptr, newptr + new_size);\n                    streambuf_t::pbump(pptr_count);\n                    if(mode_ & ::std::ios_base::in)\n                        streambuf_t::setg(newptr, newptr + gptr_count, pptr() + 1);\n                    else\n                        streambuf_t::setg(newptr, 0, newptr);\n                }\n                streambuf_t::sputc(compat_traits_type::to_char_type(meta));\n                return meta;\n            }\n#ifdef BOOST_MSVC\n#pragma warning(pop)\n#endif\n        }\n        // -end overflow(..)\n\n        template<class Ch, class Tr, class Alloc>\n        void basic_altstringbuf<Ch, Tr, Alloc>:: dealloc() {\n            if(is_allocated_)\n                alloc_.deallocate(eback(), (pptr() != NULL ? epptr() : egptr()) - eback());\n            is_allocated_ = false;\n            streambuf_t::setg(0, 0, 0);\n            streambuf_t::setp(0, 0);\n            putend_ = NULL;\n        }\n\n    }// N.S. io\n} // N.S. boost\n\n#endif // include guard\n\n","// ----------------------------------------------------------------------------\n// boost/format/exceptions.hpp \n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003.\n//\n// Distributed under the Boost Software License, Version 1.0.\n//    (See accompanying file LICENSE_1_0.txt or copy at\n//          http://www.boost.org/LICENSE_1_0.txt)\n//\n//\n//  See http://www.boost.org/libs/format/ for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_EXCEPTIONS_HPP\n#define BOOST_FORMAT_EXCEPTIONS_HPP\n\n\n#include <stdexcept>\n\n\nnamespace boost {\n\n    namespace io {\n\n// **** exceptions -----------------------------------------------\n\n        class format_error : public std::exception\n        {\n        public:\n            format_error()  {}\n            virtual const char *what() const throw() {\n                return \"boost::format_error: \"\n                    \"format generic failure\";\n            }\n        };\n\n        class bad_format_string : public format_error\n        {\n            std::size_t pos_, next_;\n        public:\n            bad_format_string(std::size_t pos, std::size_t size) \n                : pos_(pos), next_(size) {}\n            std::size_t get_pos() const { return pos_; }\n            std::size_t get_next() const { return next_; }\n            virtual const char *what() const throw() {\n                return \"boost::bad_format_string: format-string is ill-formed\";\n            }\n        };\n\n        class too_few_args : public format_error\n        {\n            std::size_t cur_, expected_;\n        public:\n            too_few_args(std::size_t cur, std::size_t expected) \n                : cur_(cur), expected_(expected) {}\n            std::size_t get_cur() const { return cur_; }\n            std::size_t get_expected() const { return expected_; }\n            virtual const char *what() const throw() {\n                return \"boost::too_few_args: \"\n                    \"format-string referred to more arguments than were passed\";\n            }\n        };\n\n        class too_many_args : public format_error\n        {\n            std::size_t cur_, expected_;\n        public:\n            too_many_args(std::size_t cur, std::size_t expected) \n                : cur_(cur), expected_(expected) {}\n            std::size_t get_cur() const { return cur_; }\n            std::size_t get_expected() const { return expected_; }\n            virtual const char *what() const throw() {\n                return \"boost::too_many_args: \"\n                    \"format-string referred to less arguments than were passed\";\n            }\n        };\n\n\n        class  out_of_range : public format_error\n        {\n            int index_, beg_, end_;    // range is [ beg, end [\n        public:\n            out_of_range(int index, int beg, int end) \n                : index_(index), beg_(beg), end_(end) {}\n            int get_index() const { return index_; }\n            int get_beg() const { return beg_; }\n            int get_end() const { return end_; }\n            virtual const char *what() const throw() {\n                return \"boost::out_of_range: \"\n                    \"tried to refer to an argument (or item) number which\"\n                    \" is out of range, according to the format string\";\n            }\n        };\n\n\n    } // namespace io\n\n} // namespace boost\n\n\n#endif // BOOST_FORMAT_EXCEPTIONS_HPP\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___BIT_REFERENCE\n#define _LIBCPP___BIT_REFERENCE\n\n#include <__config>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;\ntemplate <class _Cp> class __bit_const_reference;\n\ntemplate <class _Tp>\nstruct __has_storage_type\n{\n    static const bool value = false;\n};\n\ntemplate <class _Cp, bool = __has_storage_type<_Cp>::value>\nclass __bit_reference\n{\n    typedef typename _Cp::__storage_type    __storage_type;\n    typedef typename _Cp::__storage_pointer __storage_pointer;\n\n    __storage_pointer __seg_;\n    __storage_type    __mask_;\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_const_reference<_Cp>;\n    friend class __bit_iterator<_Cp, false>;\npublic:\n    _LIBCPP_INLINE_VISIBILITY operator bool() const _NOEXCEPT\n        {return static_cast<bool>(*__seg_ & __mask_);}\n    _LIBCPP_INLINE_VISIBILITY bool operator ~() const _NOEXCEPT\n        {return !static_cast<bool>(*this);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference& operator=(bool __x) _NOEXCEPT\n    {\n        if (__x)\n            *__seg_ |= __mask_;\n        else\n            *__seg_ &= ~__mask_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference& operator=(const __bit_reference& __x) _NOEXCEPT\n        {return operator=(static_cast<bool>(__x));}\n\n    _LIBCPP_INLINE_VISIBILITY void flip() _NOEXCEPT {*__seg_ ^= __mask_;}\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, false> operator&() const _NOEXCEPT\n        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT\n        : __seg_(__s), __mask_(__m) {}\n};\n\ntemplate <class _Cp>\nclass __bit_reference<_Cp, false>\n{\n};\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__bit_reference<_Cp> __x, bool& __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(bool& __x, __bit_reference<_Cp> __y) _NOEXCEPT\n{\n    bool __t = __x;\n    __x = __y;\n    __y = __t;\n}\n\ntemplate <class _Cp>\nclass __bit_const_reference\n{\n    typedef typename _Cp::__storage_type          __storage_type;\n    typedef typename _Cp::__const_storage_pointer __storage_pointer;\n\n    __storage_pointer        __seg_;\n    __storage_type __mask_;\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_iterator<_Cp, true>;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_const_reference(const __bit_reference<_Cp>& __x) _NOEXCEPT\n        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR operator bool() const _NOEXCEPT\n        {return static_cast<bool>(*__seg_ & __mask_);}\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator<_Cp, true> operator&() const _NOEXCEPT\n        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__ctz(__mask_)));}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_CONSTEXPR\n    __bit_const_reference(__storage_pointer __s, __storage_type __m) _NOEXCEPT\n        : __seg_(__s), __mask_(__m) {}\n\n    __bit_const_reference& operator=(const __bit_const_reference& __x);\n};\n\n// find\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, _IsConst>\n__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __storage_type __b = *__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n        if (__n == __dn)\n            return _It(__first.__seg_, __first.__ctz_ + __n);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        if (*__first.__seg_)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(*__first.__seg_)));\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    return _It(__first.__seg_, static_cast<unsigned>(__n));\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, _IsConst>\n__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __storage_type __b = ~*__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n        if (__n == __dn)\n            return _It(__first.__seg_, __first.__ctz_ + __n);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n    {\n        __storage_type __b = ~*__first.__seg_;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = ~*__first.__seg_ & __m;\n        if (__b)\n            return _It(__first.__seg_, static_cast<unsigned>(_VSTD::__ctz(__b)));\n    }\n    return _It(__first.__seg_, static_cast<unsigned>(__n));\n}\n\ntemplate <class _Cp, bool _IsConst, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, _IsConst>\nfind(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)\n{\n    if (static_cast<bool>(__value_))\n        return __find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));\n    return __find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));\n}\n\n// count\n\ntemplate <class _Cp, bool _IsConst>\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\n__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    typedef typename _It::difference_type difference_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __r = 0;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __r = _VSTD::__pop_count(*__first.__seg_ & __m);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        __r += _VSTD::__pop_count(*__first.__seg_);\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __r += _VSTD::__pop_count(*__first.__seg_ & __m);\n    }\n    return __r;\n}\n\ntemplate <class _Cp, bool _IsConst>\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\n__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _It;\n    typedef typename _It::__storage_type __storage_type;\n    typedef typename _It::difference_type difference_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __r = 0;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        __r = _VSTD::__pop_count(~*__first.__seg_ & __m);\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)\n        __r += _VSTD::__pop_count(~*__first.__seg_);\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __r += _VSTD::__pop_count(~*__first.__seg_ & __m);\n    }\n    return __r;\n}\n\ntemplate <class _Cp, bool _IsConst, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bit_iterator<_Cp, _IsConst>::difference_type\ncount(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)\n{\n    if (static_cast<bool>(__value_))\n        return __count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));\n    return __count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));\n}\n\n// fill_n\n\ntemplate <class _Cp>\nvoid\n__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, false> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        *__first.__seg_ &= ~__m;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    __storage_type __nw = __n / __bits_per_word;\n    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), 0, __nw * sizeof(__storage_type));\n    __n -= __nw * __bits_per_word;\n    // do last partial word\n    if (__n > 0)\n    {\n        __first.__seg_ += __nw;\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        *__first.__seg_ &= ~__m;\n    }\n}\n\ntemplate <class _Cp>\nvoid\n__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)\n{\n    typedef __bit_iterator<_Cp, false> _It;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    // do first partial word\n    if (__first.__ctz_ != 0)\n    {\n        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);\n        __storage_type __dn = _VSTD::min(__clz_f, __n);\n        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n        *__first.__seg_ |= __m;\n        __n -= __dn;\n        ++__first.__seg_;\n    }\n    // do middle whole words\n    __storage_type __nw = __n / __bits_per_word;\n    _VSTD::memset(_VSTD::__to_raw_pointer(__first.__seg_), -1, __nw * sizeof(__storage_type));\n    __n -= __nw * __bits_per_word;\n    // do last partial word\n    if (__n > 0)\n    {\n        __first.__seg_ += __nw;\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        *__first.__seg_ |= __m;\n    }\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)\n{\n    if (__n > 0)\n    {\n        if (__value_)\n            __fill_n_true(__first, __n);\n        else\n            __fill_n_false(__first, __n);\n    }\n}\n\n// fill\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)\n{\n    _VSTD::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);\n}\n\n// copy\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                     __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            __storage_type __b = *__first.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        __storage_type __nw = __n / __bits_per_word;\n        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),\n                       _VSTD::__to_raw_pointer(__first.__seg_),\n                       __nw * sizeof(__storage_type));\n        __n -= __nw * __bits_per_word;\n        __result.__seg_ += __nw;\n        // do last word\n        if (__n > 0)\n        {\n            __first.__seg_ += __nw;\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(__n);\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                       __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b = *__first.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            *__result.__seg_ &= ~__m;\n            if (__result.__ctz_ > __first.__ctz_)\n                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);\n            else\n                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);\n            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);\n                __result.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        __storage_type __m = ~__storage_type(0) << __result.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)\n        {\n            __storage_type __b = *__first.__seg_;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n            ++__result.__seg_;\n            *__result.__seg_ &= __m;\n            *__result.__seg_ |= __b >> __clz_r;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first.__seg_ & __m;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b >> __dn;\n                __result.__ctz_ = static_cast<unsigned>(__n);\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\ncopy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    if (__first.__ctz_ == __result.__ctz_)\n        return __copy_aligned(__first, __last, __result);\n    return __copy_unaligned(__first, __last, __result);\n}\n\n// copy_backward\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                     __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__last.__ctz_ != 0)\n        {\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);\n            __n -= __dn;\n            unsigned __clz = __bits_per_word - __last.__ctz_;\n            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);\n            __storage_type __b = *__last.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +\n                                                       __result.__ctz_)  % __bits_per_word);\n            // __last.__ctz_ = 0\n         }\n        // __last.__ctz_ == 0 || __n == 0\n        // __result.__ctz_ == 0 || __n == 0\n        // do middle words\n        __storage_type __nw = __n / __bits_per_word;\n        __result.__seg_ -= __nw;\n        __last.__seg_ -= __nw;\n        _VSTD::memmove(_VSTD::__to_raw_pointer(__result.__seg_),\n                       _VSTD::__to_raw_pointer(__last.__seg_),\n                       __nw * sizeof(__storage_type));\n        __n -= __nw * __bits_per_word;\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);\n            __storage_type __b = *--__last.__seg_ & __m;\n            *--__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b;\n            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\n__bit_iterator<_Cp, false>\n__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,\n                                                       __bit_iterator<_Cp, false> __result)\n{\n    typedef __bit_iterator<_Cp, _IsConst> _In;\n    typedef  typename _In::difference_type difference_type;\n    typedef typename _In::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _In::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__last.__ctz_ != 0)\n        {\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__last.__ctz_), __n);\n            __n -= __dn;\n            unsigned __clz_l = __bits_per_word - __last.__ctz_;\n            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);\n            __storage_type __b = *__last.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min(__dn, static_cast<difference_type>(__result.__ctz_));\n            if (__ddn > 0)\n            {\n                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);\n                *__result.__seg_ &= ~__m;\n                if (__result.__ctz_ > __last.__ctz_)\n                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);\n                else\n                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);\n                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +\n                                                         __result.__ctz_)  % __bits_per_word);\n                __dn -= __ddn;\n            }\n            if (__dn > 0)\n            {\n                // __result.__ctz_ == 0\n                --__result.__seg_;\n                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));\n                __m = ~__storage_type(0) << __result.__ctz_;\n                *__result.__seg_ &= ~__m;\n                __last.__ctz_ -= __dn + __ddn;\n                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);\n            }\n            // __last.__ctz_ = 0\n         }\n        // __last.__ctz_ == 0 || __n == 0\n        // __result.__ctz_ != 0 || __n == 0\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        __storage_type __m = ~__storage_type(0) >> __clz_r;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word)\n        {\n            __storage_type __b = *--__last.__seg_;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b >> __clz_r;\n            *--__result.__seg_ &= __m;\n            *__result.__seg_ |= __b << __result.__ctz_;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) << (__bits_per_word - __n);\n            __storage_type __b = *--__last.__seg_ & __m;\n            __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__result.__ctz_));\n            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);\n            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +\n                                                     __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                // __result.__ctz_ == 0\n                --__result.__seg_;\n                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));\n                __m = ~__storage_type(0) << __result.__ctz_;\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\ncopy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    if (__last.__ctz_ == __result.__ctz_)\n        return __copy_backward_aligned(__first, __last, __result);\n    return __copy_backward_unaligned(__first, __last, __result);\n}\n\n// move\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\nmove(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    return _VSTD::copy(__first, __last, __result);\n}\n\n// move_backward\n\ntemplate <class _Cp, bool _IsConst>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<_Cp, false>\nmove_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)\n{\n    return _VSTD::copy(__first, __last, __result);\n}\n\n// swap_ranges\n\ntemplate <class __C1, class __C2>\n__bit_iterator<__C2, false>\n__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,\n                      __bit_iterator<__C2, false> __result)\n{\n    typedef __bit_iterator<__C1, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    typedef typename _I1::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _I1::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1;\n            *__first.__seg_  |= __b2;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)\n            swap(*__first.__seg_, *__result.__seg_);\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1;\n            *__first.__seg_  |= __b2;\n            __result.__ctz_ = static_cast<unsigned>(__n);\n        }\n    }\n    return __result;\n}\n\ntemplate <class __C1, class __C2>\n__bit_iterator<__C2, false>\n__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,\n                        __bit_iterator<__C2, false> __result)\n{\n    typedef __bit_iterator<__C1, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    typedef typename _I1::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _I1::__bits_per_word;\n    difference_type __n = __last - __first;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            unsigned __clz_r = __bits_per_word - __result.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            if (__result.__ctz_ > __first.__ctz_)\n            {\n                unsigned __s = __result.__ctz_ - __first.__ctz_;\n                *__result.__seg_ |= __b1 << __s;\n                *__first.__seg_  |= __b2 >> __s;\n            }\n            else\n            {\n                unsigned __s = __first.__ctz_ - __result.__ctz_;\n                *__result.__seg_ |= __b1 >> __s;\n                *__first.__seg_  |= __b2 << __s;\n            }\n            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                __b2 = *__result.__seg_ & __m;\n                *__result.__seg_ &= ~__m;\n                unsigned __s = __first.__ctz_ + __ddn;\n                *__result.__seg_ |= __b1 >> __s;\n                *__first.__seg_  |= __b2 << __s;\n                __result.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first.__seg_;\n            // __first.__ctz_ = 0;\n        }\n        // __first.__ctz_ == 0;\n        // do middle words\n        __storage_type __m = ~__storage_type(0) << __result.__ctz_;\n        unsigned __clz_r = __bits_per_word - __result.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)\n        {\n            __storage_type __b1 = *__first.__seg_;\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1 << __result.__ctz_;\n            *__first.__seg_  = __b2 >> __result.__ctz_;\n            ++__result.__seg_;\n            __b2 = *__result.__seg_ & ~__m;\n            *__result.__seg_ &= __m;\n            *__result.__seg_ |= __b1 >> __clz_r;\n            *__first.__seg_  |= __b2 << __clz_r;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b1 = *__first.__seg_ & __m;\n            *__first.__seg_ &= ~__m;\n            __storage_type __dn = _VSTD::min<__storage_type>(__n, __clz_r);\n            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            __storage_type __b2 = *__result.__seg_ & __m;\n            *__result.__seg_ &= ~__m;\n            *__result.__seg_ |= __b1 << __result.__ctz_;\n            *__first.__seg_  |= __b2 >> __result.__ctz_;\n            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;\n            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                __b2 = *__result.__seg_ & __m;\n                *__result.__seg_ &= ~__m;\n                *__result.__seg_ |= __b1 >> __dn;\n                *__first.__seg_  |= __b2 << __dn;\n                __result.__ctz_ = static_cast<unsigned>(__n);\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class __C1, class __C2>\ninline _LIBCPP_INLINE_VISIBILITY\n__bit_iterator<__C2, false>\nswap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,\n            __bit_iterator<__C2, false> __first2)\n{\n    if (__first1.__ctz_ == __first2.__ctz_)\n        return __swap_ranges_aligned(__first1, __last1, __first2);\n    return __swap_ranges_unaligned(__first1, __last1, __first2);\n}\n\n// rotate\n\ntemplate <class _Cp>\nstruct __bit_array\n{\n    typedef typename _Cp::difference_type difference_type;\n    typedef typename _Cp::__storage_type  __storage_type;\n    typedef typename _Cp::__storage_pointer __storage_pointer;\n    typedef typename _Cp::iterator        iterator;\n    static const unsigned __bits_per_word = _Cp::__bits_per_word;\n    static const unsigned _Np = 4;\n\n    difference_type __size_;\n    __storage_type __word_[_Np];\n\n    _LIBCPP_INLINE_VISIBILITY static difference_type capacity()\n        {return static_cast<difference_type>(_Np * __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY explicit __bit_array(difference_type __s) : __size_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY iterator begin()\n    {\n        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);\n    }\n    _LIBCPP_INLINE_VISIBILITY iterator end()\n    {\n        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,\n                                                  static_cast<unsigned>(__size_ % __bits_per_word));\n    }\n};\n\ntemplate <class _Cp>\n__bit_iterator<_Cp, false>\nrotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)\n{\n    typedef __bit_iterator<_Cp, false> _I1;\n    typedef  typename _I1::difference_type difference_type;\n    typedef typename _I1::__storage_type __storage_type;\n    difference_type __d1 = __middle - __first;\n    difference_type __d2 = __last - __middle;\n    _I1 __r = __first + __d2;\n    while (__d1 != 0 && __d2 != 0)\n    {\n        if (__d1 <= __d2)\n        {\n            if (__d1 <= __bit_array<_Cp>::capacity())\n            {\n                __bit_array<_Cp> __b(__d1);\n                _VSTD::copy(__first, __middle, __b.begin());\n                _VSTD::copy(__b.begin(), __b.end(), _VSTD::copy(__middle, __last, __first));\n                break;\n            }\n            else\n            {\n                __bit_iterator<_Cp, false> __mp = _VSTD::swap_ranges(__first, __middle, __middle);\n                __first = __middle;\n                __middle = __mp;\n                __d2 -= __d1;\n            }\n        }\n        else\n        {\n            if (__d2 <= __bit_array<_Cp>::capacity())\n            {\n                __bit_array<_Cp> __b(__d2);\n                _VSTD::copy(__middle, __last, __b.begin());\n                _VSTD::copy_backward(__b.begin(), __b.end(), _VSTD::copy_backward(__first, __middle, __last));\n                break;\n            }\n            else\n            {\n                __bit_iterator<_Cp, false> __mp = __first + __d2;\n                _VSTD::swap_ranges(__first, __mp, __middle);\n                __first = __mp;\n                __d1 -= __d2;\n            }\n        }\n    }\n    return __r;\n}\n\n// equal\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\nbool\n__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,\n                  __bit_iterator<_Cp, _IC2> __first2)\n{\n    typedef __bit_iterator<_Cp, _IC1> _It;\n    typedef  typename _It::difference_type difference_type;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __n = __last1 - __first1;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first1.__ctz_ != 0)\n        {\n            unsigned __clz_f = __bits_per_word - __first1.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz_f), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));\n            __storage_type __b = *__first1.__seg_ & __m;\n            unsigned __clz_r = __bits_per_word - __first2.__ctz_;\n            __storage_type __ddn = _VSTD::min<__storage_type>(__dn, __clz_r);\n            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));\n            if (__first2.__ctz_ > __first1.__ctz_)\n            {\n                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))\n                    return false;\n            }\n            else\n            {\n                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))\n                    return false;\n            }\n            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;\n            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_)  % __bits_per_word);\n            __dn -= __ddn;\n            if (__dn > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __dn);\n                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))\n                    return false;\n                __first2.__ctz_ = static_cast<unsigned>(__dn);\n            }\n            ++__first1.__seg_;\n            // __first1.__ctz_ = 0;\n        }\n        // __first1.__ctz_ == 0;\n        // do middle words\n        unsigned __clz_r = __bits_per_word - __first2.__ctz_;\n        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)\n        {\n            __storage_type __b = *__first1.__seg_;\n            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))\n                return false;\n            ++__first2.__seg_;\n            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))\n                return false;\n        }\n        // do last word\n        if (__n > 0)\n        {\n            __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            __storage_type __b = *__first1.__seg_ & __m;\n            __storage_type __dn = _VSTD::min(__n, static_cast<difference_type>(__clz_r));\n            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));\n            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))\n                return false;\n            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;\n            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_)  % __bits_per_word);\n            __n -= __dn;\n            if (__n > 0)\n            {\n                __m = ~__storage_type(0) >> (__bits_per_word - __n);\n                if ((*__first2.__seg_ & __m) != (__b >> __dn))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\nbool\n__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,\n                __bit_iterator<_Cp, _IC2> __first2)\n{\n    typedef __bit_iterator<_Cp, _IC1> _It;\n    typedef  typename _It::difference_type difference_type;\n    typedef typename _It::__storage_type __storage_type;\n    static const unsigned __bits_per_word = _It::__bits_per_word;\n    difference_type __n = __last1 - __first1;\n    if (__n > 0)\n    {\n        // do first word\n        if (__first1.__ctz_ != 0)\n        {\n            unsigned __clz = __bits_per_word - __first1.__ctz_;\n            difference_type __dn = _VSTD::min(static_cast<difference_type>(__clz), __n);\n            __n -= __dn;\n            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));\n            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))\n                return false;\n            ++__first2.__seg_;\n            ++__first1.__seg_;\n            // __first1.__ctz_ = 0;\n            // __first2.__ctz_ = 0;\n        }\n        // __first1.__ctz_ == 0;\n        // __first2.__ctz_ == 0;\n        // do middle words\n        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)\n            if (*__first2.__seg_ != *__first1.__seg_)\n                return false;\n        // do last word\n        if (__n > 0)\n        {\n            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))\n                return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _Cp, bool _IC1, bool _IC2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)\n{\n    if (__first1.__ctz_ == __first2.__ctz_)\n        return __equal_aligned(__first1, __last1, __first2);\n    return __equal_unaligned(__first1, __last1, __first2);\n}\n\ntemplate <class _Cp, bool _IsConst,\n          typename _Cp::__storage_type>\nclass __bit_iterator\n{\npublic:\n    typedef typename _Cp::difference_type                                                          difference_type;\n    typedef bool                                                                                  value_type;\n    typedef __bit_iterator                                                                        pointer;\n    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;\n    typedef random_access_iterator_tag                                                            iterator_category;\n\nprivate:\n    typedef typename _Cp::__storage_type                                           __storage_type;\n    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,\n                                           typename _Cp::__storage_pointer>::type  __storage_pointer;\n    static const unsigned __bits_per_word = _Cp::__bits_per_word;\n\n    __storage_pointer __seg_;\n    unsigned          __ctz_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __seg_(nullptr), __ctz_(0)\n#endif\n    {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_iterator(const __bit_iterator<_Cp, false>& __it) _NOEXCEPT\n        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n        {return reference(__seg_, __storage_type(1) << __ctz_);}\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator++()\n    {\n        if (__ctz_ != __bits_per_word-1)\n            ++__ctz_;\n        else\n        {\n            __ctz_ = 0;\n            ++__seg_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator++(int)\n    {\n        __bit_iterator __tmp = *this;\n        ++(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator--()\n    {\n        if (__ctz_ != 0)\n            --__ctz_;\n        else\n        {\n            __ctz_ = __bits_per_word - 1;\n            --__seg_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator--(int)\n    {\n        __bit_iterator __tmp = *this;\n        --(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator+=(difference_type __n)\n    {\n        if (__n >= 0)\n            __seg_ += (__n + __ctz_) / __bits_per_word;\n        else\n            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)\n                    / static_cast<difference_type>(__bits_per_word);\n        __n &= (__bits_per_word - 1);\n        __ctz_ = static_cast<unsigned>((__n + __ctz_)  % __bits_per_word);\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator& operator-=(difference_type __n)\n    {\n        return *this += -__n;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator+(difference_type __n) const\n    {\n        __bit_iterator __t(*this);\n        __t += __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __bit_iterator operator-(difference_type __n) const\n    {\n        __bit_iterator __t(*this);\n        __t -= __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator[](difference_type __n) const {return *(*this + __n);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__x == __y);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return __y < __x;}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__y < __x);}\n\n    _LIBCPP_INLINE_VISIBILITY friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)\n        {return !(__x < __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    __bit_iterator(__storage_pointer __s, unsigned __ctz) _NOEXCEPT\n        : __seg_(__s), __ctz_(__ctz) {}\n\n#if defined(__clang__) || defined(__IBMCPP__) || defined(_LIBCPP_MSVC)\n    friend typename _Cp::__self;\n#else\n    friend class _Cp::__self;\n#endif\n    friend class __bit_reference<_Cp>;\n    friend class __bit_const_reference<_Cp>;\n    friend class __bit_iterator<_Cp, true>;\n    template <class _Dp> friend struct __bit_array;\n    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);\n    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                  __bit_iterator<_Dp, _IC> __last,\n                                                                                  __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                    __bit_iterator<_Dp, _IC> __last,\n                                                                                    __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,\n                                                                        __bit_iterator<_Dp, _IC> __last,\n                                                                        __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                           __bit_iterator<_Dp, _IC> __last,\n                                                                                           __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,\n                                                                                             __bit_iterator<_Dp, _IC> __last,\n                                                                                             __bit_iterator<_Dp, false> __result);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,\n                                                                                 __bit_iterator<_Dp, _IC> __last,\n                                                                                 __bit_iterator<_Dp, false> __result);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,\n                                                                                           __bit_iterator<__C1, false>,\n                                                                                           __bit_iterator<__C2, false>);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,\n                                                                                             __bit_iterator<__C1, false>,\n                                                                                             __bit_iterator<__C2, false>);\n    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,\n                                                                                 __bit_iterator<__C1, false>,\n                                                                                 __bit_iterator<__C2, false>);\n    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,\n                                                                __bit_iterator<_Dp, false>,\n                                                                __bit_iterator<_Dp, false>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,\n                                                    __bit_iterator<_Dp, _IC1>,\n                                                    __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,\n                                                      __bit_iterator<_Dp, _IC1>,\n                                                      __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,\n                                                                __bit_iterator<_Dp, _IC1>,\n                                                                __bit_iterator<_Dp, _IC2>);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,\n                                                                          typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,\n                                                                           typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type\n                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);\n    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type\n                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___BIT_REFERENCE\n","// ----------------------------------------------------------------------------\n//  feed_args.hpp :  functions for processing each argument \n//                      (feed, feed_manip, and distribute)\n// ----------------------------------------------------------------------------\n\n//  Copyright Samuel Krempp 2003. Use, modification, and distribution are\n//  subject to the Boost Software License, Version 1.0. (See accompanying\n//  file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/format for library home page\n\n// ----------------------------------------------------------------------------\n\n#ifndef BOOST_FORMAT_FEED_ARGS_HPP\n#define BOOST_FORMAT_FEED_ARGS_HPP\n\n#include <boost/config.hpp>\n#include <boost/assert.hpp>\n#include <boost/throw_exception.hpp>\n\n#include <boost/format/format_class.hpp>\n#include <boost/format/group.hpp>\n#include <boost/format/detail/msvc_disambiguater.hpp>\n\nnamespace boost {\nnamespace io {\nnamespace detail {\n\n    template<class Ch, class Tr, class Alloc>\n    void mk_str( std::basic_string<Ch,Tr, Alloc> & res, \n                 const Ch * beg,\n                 typename std::basic_string<Ch,Tr,Alloc>::size_type size,\n                 std::streamsize w, \n                 const Ch fill_char,\n                 std::ios_base::fmtflags f, \n                 const Ch prefix_space, // 0 if no space-padding\n                 bool center) \n    // applies centered/left/right  padding  to the string  [beg, beg+size[\n    // Effects : the result is placed in res.\n    {\n        typedef typename std::basic_string<Ch,Tr,Alloc>::size_type size_type;\n        res.resize(0);\n        if(w<=0 || static_cast<size_type>(w) <=size) {\n            // no need to pad.\n            res.reserve(size + !!prefix_space);\n            if(prefix_space) \n              res.append(1, prefix_space);\n            if (size)\n              res.append(beg, size);\n        }\n        else { \n            std::streamsize n=static_cast<std::streamsize>(w-size-!!prefix_space);\n            std::streamsize n_after = 0, n_before = 0; \n            res.reserve(static_cast<size_type>(w)); // allocate once for the 2 inserts\n            if(center) \n                n_after = n/2, n_before = n - n_after; \n            else \n                if(f & std::ios_base::left)\n                    n_after = n;\n                else\n                    n_before = n;\n            // now make the res string :\n            if(n_before) res.append(static_cast<size_type>(n_before), fill_char);\n            if(prefix_space) \n              res.append(1, prefix_space);\n            if (size)  \n              res.append(beg, size);\n            if(n_after) res.append(static_cast<size_type>(n_after), fill_char);\n        }\n    } // -mk_str(..) \n\n\n#if BOOST_WORKAROUND( BOOST_MSVC, <= 1300) || \\\n    BOOST_WORKAROUND(__DECCXX_VER, BOOST_TESTED_AT(60590042))\n// MSVC needs to be tricked to disambiguate this simple overload..\n// the trick is in \"boost/format/msvc_disambiguater.hpp\"\n  \n    template< class Ch, class Tr, class T> inline\n    void put_head (BOOST_IO_STD basic_ostream<Ch, Tr> & os, const T& x ) {\n        disambiguater<Ch, Tr, T>::put_head(os, x, 1L);\n    }\n    template< class Ch, class Tr, class T> inline\n    void put_last (BOOST_IO_STD basic_ostream<Ch, Tr> & os, const T& x ) {\n        disambiguater<Ch, Tr, T>::put_last(os, x, 1L);\n    }\n\n#else  \n\n    template< class Ch, class Tr, class T> inline\n    void put_head (BOOST_IO_STD basic_ostream<Ch, Tr> &, const T& ) {\n    }\n\n    template< class Ch, class Tr, class T> inline\n    void put_head( BOOST_IO_STD basic_ostream<Ch, Tr> & os, const group1<T>& x ) {\n        os << group_head(x.a1_); // send the first N-1 items, not the last\n    }\n\n    template< class Ch, class Tr, class T> inline\n    void put_last( BOOST_IO_STD basic_ostream<Ch, Tr> & os, const T& x ) {\n        os << x ;\n    }\n\n    template< class Ch, class Tr, class T> inline\n    void put_last( BOOST_IO_STD basic_ostream<Ch, Tr> & os, const group1<T>& x ) {\n        os << group_last(x.a1_); // this selects the last element\n    }\n\n#ifndef BOOST_NO_OVERLOAD_FOR_NON_CONST \n    template< class Ch, class Tr, class T> inline\n    void put_head( BOOST_IO_STD basic_ostream<Ch, Tr> &, T& ) {\n    }\n\n    template< class Ch, class Tr, class T> inline\n    void put_last( BOOST_IO_STD basic_ostream<Ch, Tr> & os, T& x) {\n        os << x ;\n    }\n#endif\n#endif  // -msvc workaround\n\n\n    template< class Ch, class Tr, class Alloc, class T> \n    void put( T x, \n              const format_item<Ch, Tr, Alloc>& specs, \n              typename basic_format<Ch, Tr, Alloc>::string_type& res, \n              typename basic_format<Ch, Tr, Alloc>::internal_streambuf_t & buf,\n              io::detail::locale_t *loc_p = NULL)\n    {\n#ifdef BOOST_MSVC\n       // If std::min<unsigned> or std::max<unsigned> are already instantiated\n       // at this point then we get a blizzard of warning messages when we call\n       // those templates with std::size_t as arguments.  Weird and very annoyning...\n#pragma warning(push)\n#pragma warning(disable:4267)\n#endif\n        // does the actual conversion of x, with given params, into a string\n        // using the supplied stringbuf.\n\n        typedef typename basic_format<Ch, Tr, Alloc>::string_type   string_type;\n        typedef typename basic_format<Ch, Tr, Alloc>::format_item_t format_item_t;\n        typedef typename string_type::size_type size_type;\n\n        basic_oaltstringstream<Ch, Tr, Alloc>  oss( &buf);\n        specs.fmtstate_.apply_on(oss, loc_p);\n\n        // the stream format state can be modified by manipulators in the argument :\n        put_head( oss, x );\n        // in case x is a group, apply the manip part of it, \n        // in order to find width\n\n        const std::ios_base::fmtflags fl=oss.flags();\n        const bool internal = (fl & std::ios_base::internal) != 0;\n        const std::streamsize w = oss.width();\n        const bool two_stepped_padding= internal && (w!=0);\n      \n        res.resize(0);\n        if(! two_stepped_padding) {\n            if(w>0) // handle padding via mk_str, not natively in stream \n                oss.width(0);\n            put_last( oss, x);\n            const Ch * res_beg = buf.pbase();\n            Ch prefix_space = 0;\n            if(specs.pad_scheme_ & format_item_t::spacepad)\n                if(buf.pcount()== 0 || \n                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-')  ))\n                    prefix_space = oss.widen(' ');\n            size_type res_size = (std::min)(\n                static_cast<size_type>(specs.truncate_ - !!prefix_space), \n                buf.pcount() );\n            mk_str(res, res_beg, res_size, w, oss.fill(), fl, \n                   prefix_space, (specs.pad_scheme_ & format_item_t::centered) !=0 );\n        }\n        else  { // 2-stepped padding\n            // internal can be implied by zeropad, or user-set.\n            // left, right, and centered alignment overrule internal,\n            // but spacepad or truncate might be mixed with internal (using manipulator)\n            put_last( oss, x); // may pad\n            const Ch * res_beg = buf.pbase();\n            size_type res_size = buf.pcount();\n            bool prefix_space=false;\n            if(specs.pad_scheme_ & format_item_t::spacepad)\n                if(buf.pcount()== 0 || \n                   (res_beg[0] !=oss.widen('+') && res_beg[0] !=oss.widen('-')  ))\n                    prefix_space = true;\n            if(res_size == static_cast<size_type>(w) && w<=specs.truncate_ && !prefix_space) {\n                // okay, only one thing was printed and padded, so res is fine\n                res.assign(res_beg, res_size);\n            }\n            else { //   length w exceeded\n                // either it was multi-output with first output padding up all width..\n                // either it was one big arg and we are fine.\n                // Note that res_size<w is possible  (in case of bad user-defined formatting)\n                res.assign(res_beg, res_size);\n                res_beg=NULL;  // invalidate pointers.\n                \n                // make a new stream, to start re-formatting from scratch :\n                buf.clear_buffer();\n                basic_oaltstringstream<Ch, Tr, Alloc>  oss2( &buf);\n                specs.fmtstate_.apply_on(oss2, loc_p);\n                put_head( oss2, x );\n\n                oss2.width(0);\n                if(prefix_space)\n                    oss2 << ' ';\n                put_last(oss2, x );\n                if(buf.pcount()==0 && specs.pad_scheme_ & format_item_t::spacepad) {\n                    prefix_space =true;\n                    oss2 << ' ';\n                }\n                // we now have the minimal-length output\n                const Ch * tmp_beg = buf.pbase();\n                size_type tmp_size = (std::min)(static_cast<size_type>(specs.truncate_),\n                                                buf.pcount() );\n                                                    \n                \n                if(static_cast<size_type>(w) <= tmp_size) { \n                    // minimal length is already >= w, so no padding (cool!)\n                        res.assign(tmp_beg, tmp_size);\n                }\n                else { // hum..  we need to pad (multi_output, or spacepad present)\n                    //find where we should pad\n                    size_type sz = (std::min)(res_size + (prefix_space ? 1 : 0), tmp_size);\n                    size_type i = prefix_space;\n                    for(; i<sz && tmp_beg[i] == res[i - (prefix_space ? 1 : 0)]; ++i) {}\n                    if(i>=tmp_size) i=prefix_space;\n                    res.assign(tmp_beg, i);\n                                        std::streamsize d = w - static_cast<std::streamsize>(tmp_size);\n                                        BOOST_ASSERT(d>0);\n                    res.append(static_cast<size_type>( d ), oss2.fill());\n                    res.append(tmp_beg+i, tmp_size-i);\n                    BOOST_ASSERT(i+(tmp_size-i)+(std::max)(d,(std::streamsize)0) \n                                 == static_cast<size_type>(w));\n                    BOOST_ASSERT(res.size() == static_cast<size_type>(w));\n                }\n            }\n        }\n        buf.clear_buffer();\n#ifdef BOOST_MSVC\n#pragma warning(pop)\n#endif\n    } // end- put(..)\n\n\n    template< class Ch, class Tr, class Alloc, class T> \n    void distribute (basic_format<Ch,Tr, Alloc>& self, T x) {\n        // call put(x, ..) on every occurence of the current argument :\n        if(self.cur_arg_ >= self.num_args_)  {\n            if( self.exceptions() & too_many_args_bit )\n                boost::throw_exception(too_many_args(self.cur_arg_, self.num_args_)); \n            else return;\n        }\n        for(unsigned long i=0; i < self.items_.size(); ++i) {\n            if(self.items_[i].argN_ == self.cur_arg_) {\n                put<Ch, Tr, Alloc, T> (x, self.items_[i], self.items_[i].res_, \n                                self.buf_, boost::get_pointer(self.loc_) );\n            }\n        }\n    }\n\n    template<class Ch, class Tr, class Alloc, class T> \n    basic_format<Ch, Tr, Alloc>&  \n    feed (basic_format<Ch,Tr, Alloc>& self, T x) {\n        if(self.dumped_) self.clear();\n        distribute<Ch, Tr, Alloc, T> (self, x);\n        ++self.cur_arg_;\n        if(self.bound_.size() != 0) {\n                while( self.cur_arg_ < self.num_args_ && self.bound_[self.cur_arg_] )\n                    ++self.cur_arg_;\n        }\n        return self;\n    }\n    \n} // namespace detail\n} // namespace io\n} // namespace boost\n\n\n#endif //  BOOST_FORMAT_FEED_ARGS_HPP\n","//  boost utility/base_from_member.hpp header file  --------------------------//\n\n//  Copyright 2001, 2003, 2004, 2012 Daryle Walker.  Use, modification, and\n//  distribution are subject to the Boost Software License, Version 1.0.  (See\n//  accompanying file LICENSE_1_0.txt or a copy at\n//  <http://www.boost.org/LICENSE_1_0.txt>.)\n\n//  See <http://www.boost.org/libs/utility/> for the library's home page.\n\n#ifndef BOOST_UTILITY_BASE_FROM_MEMBER_HPP\n#define BOOST_UTILITY_BASE_FROM_MEMBER_HPP\n\n#include <boost/config.hpp>\n#include <boost/preprocessor/arithmetic/inc.hpp>\n#include <boost/preprocessor/repetition/enum_binary_params.hpp>\n#include <boost/preprocessor/repetition/enum_params.hpp>\n#include <boost/preprocessor/repetition/repeat_from_to.hpp>\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/remove_cv.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/utility/enable_if.hpp>\n\n\n//  Base-from-member arity configuration macro  ------------------------------//\n\n// The following macro determines how many arguments will be in the largest\n// constructor template of base_from_member.  Constructor templates will be\n// generated from one argument to this maximum.  Code from other files can read\n// this number if they need to always match the exact maximum base_from_member\n// uses.  The maximum constructor length can be changed by overriding the\n// #defined constant.  Make sure to apply the override, if any, for all source\n// files during project compiling for consistency.\n\n// Contributed by Jonathan Turkanis\n\n#ifndef BOOST_BASE_FROM_MEMBER_MAX_ARITY\n#define BOOST_BASE_FROM_MEMBER_MAX_ARITY  10\n#endif\n\n\n//  An iteration of a constructor template for base_from_member  -------------//\n\n// A macro that should expand to:\n//     template < typename T1, ..., typename Tn >\n//     base_from_member( T1 x1, ..., Tn xn )\n//         : member( x1, ..., xn )\n//         {}\n// This macro should only persist within this file.\n\n#define BOOST_PRIVATE_CTR_DEF( z, n, data )                            \\\n    template < BOOST_PP_ENUM_PARAMS(n, typename T) >                   \\\n    explicit base_from_member( BOOST_PP_ENUM_BINARY_PARAMS(n, T, x) )  \\\n        : member( BOOST_PP_ENUM_PARAMS(n, x) )                         \\\n        {}                                                             \\\n    /**/\n\n\nnamespace boost\n{\n\nnamespace detail\n{\n\n//  Type-unmarking class template  -------------------------------------------//\n\n// Type-trait to get the raw type, i.e. the type without top-level reference nor\n// cv-qualification, from a type expression.  Mainly for function arguments, any\n// reference part is stripped first.\n\n// Contributed by Daryle Walker\n\ntemplate < typename T >\nstruct remove_cv_ref\n{\n    typedef typename ::boost::remove_cv<typename\n     ::boost::remove_reference<T>::type>::type  type;\n\n};  // boost::detail::remove_cv_ref\n\n//  Unmarked-type comparison class template  ---------------------------------//\n\n// Type-trait to check if two type expressions have the same raw type.\n\n// Contributed by Daryle Walker, based on a work-around by Luc Danton\n\ntemplate < typename T, typename U >\nstruct is_related\n    : public ::boost::is_same<\n     typename ::boost::detail::remove_cv_ref<T>::type,\n     typename ::boost::detail::remove_cv_ref<U>::type >\n{};\n\n//  Enable-if-on-unidentical-unmarked-type class template  -------------------//\n\n// Enable-if on the first two type expressions NOT having the same raw type.\n\n// Contributed by Daryle Walker, based on a work-around by Luc Danton\n\n#ifndef BOOST_NO_CXX11_VARIADIC_TEMPLATES\ntemplate<typename ...T>\nstruct enable_if_unrelated\n    : public ::boost::enable_if_c<true>\n{};\n\ntemplate<typename T, typename U, typename ...U2>\nstruct enable_if_unrelated<T, U, U2...>\n    : public ::boost::disable_if< ::boost::detail::is_related<T, U> >\n{};\n#endif\n\n}  // namespace boost::detail\n\n\n//  Base-from-member class template  -----------------------------------------//\n\n// Helper to initialize a base object so a derived class can use this\n// object in the initialization of another base class.  Used by\n// Dietmar Kuehl from ideas by Ron Klatcho to solve the problem of a\n// base class needing to be initialized by a member.\n\n// Contributed by Daryle Walker\n\ntemplate < typename MemberType, int UniqueID = 0 >\nclass base_from_member\n{\nprotected:\n    MemberType  member;\n\n#if !defined(BOOST_NO_CXX11_RVALUE_REFERENCES) && \\\n    !defined(BOOST_NO_CXX11_VARIADIC_TEMPLATES) && \\\n    !defined(BOOST_NO_CXX11_FUNCTION_TEMPLATE_DEFAULT_ARGS) && \\\n    !(defined(__GNUC__) && (__GNUC__ == 4) && (__GNUC_MINOR__ < 4))\n    template <typename ...T, typename EnableIf = typename\n     ::boost::detail::enable_if_unrelated<base_from_member, T...>::type>\n    explicit BOOST_CONSTEXPR base_from_member( T&& ...x )\n        BOOST_NOEXCEPT_IF( BOOST_NOEXCEPT_EXPR(::new ((void*) 0) MemberType(\n         static_cast<T&&>(x)... )) )  // no std::is_nothrow_constructible...\n        : member( static_cast<T&&>(x)... )     // ...nor std::forward needed\n        {}\n#else\n    base_from_member()\n        : member()\n        {}\n\n    BOOST_PP_REPEAT_FROM_TO( 1, BOOST_PP_INC(BOOST_BASE_FROM_MEMBER_MAX_ARITY),\n     BOOST_PRIVATE_CTR_DEF, _ )\n#endif\n\n};  // boost::base_from_member\n\n}  // namespace boost\n\n\n// Undo any private macros\n#undef BOOST_PRIVATE_CTR_DEF\n\n\n#endif  // BOOST_UTILITY_BASE_FROM_MEMBER_HPP\n","#ifndef BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED\n#define BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED\n\n//\n//  shared_ptr.hpp\n//\n//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.\n//  Copyright (c) 2001-2008 Peter Dimov\n//\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n//  See http://www.boost.org/libs/smart_ptr/shared_ptr.htm for documentation.\n//\n\n#include <boost/config.hpp>   // for broken compiler workarounds\n\n#if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)\n#include <boost/smart_ptr/detail/shared_ptr_nmt.hpp>\n#else\n\n// In order to avoid circular dependencies with Boost.TR1\n// we make sure that our include of <memory> doesn't try to\n// pull in the TR1 headers: that's why we use this header \n// rather than including <memory> directly:\n#include <boost/config/no_tr1/memory.hpp>  // std::auto_ptr\n\n#include <boost/assert.hpp>\n#include <boost/checked_delete.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/smart_ptr/detail/shared_count.hpp>\n#include <boost/detail/workaround.hpp>\n#include <boost/smart_ptr/detail/sp_convertible.hpp>\n#include <boost/smart_ptr/detail/sp_nullptr_t.hpp>\n\n#if !defined(BOOST_SP_NO_ATOMIC_ACCESS)\n#include <boost/smart_ptr/detail/spinlock_pool.hpp>\n#include <boost/memory_order.hpp>\n#endif\n\n#include <algorithm>            // for std::swap\n#include <functional>           // for std::less\n#include <typeinfo>             // for std::bad_cast\n#include <cstddef>              // for std::size_t\n\n#if !defined(BOOST_NO_IOSTREAM)\n#if !defined(BOOST_NO_IOSFWD)\n#include <iosfwd>               // for std::basic_ostream\n#else\n#include <ostream>\n#endif\n#endif\n\nnamespace boost\n{\n\ntemplate<class T> class shared_ptr;\ntemplate<class T> class weak_ptr;\ntemplate<class T> class enable_shared_from_this;\nclass enable_shared_from_raw;\n\nnamespace detail\n{\n\n// sp_element, element_type\n\ntemplate< class T > struct sp_element\n{\n    typedef T type;\n};\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T > struct sp_element< T[] >\n{\n    typedef T type;\n};\n\n#if !defined( __BORLANDC__ ) || !BOOST_WORKAROUND( __BORLANDC__, < 0x600 )\n\ntemplate< class T, std::size_t N > struct sp_element< T[N] >\n{\n    typedef T type;\n};\n\n#endif\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// sp_dereference, return type of operator*\n\ntemplate< class T > struct sp_dereference\n{\n    typedef T & type;\n};\n\ntemplate<> struct sp_dereference< void >\n{\n    typedef void type;\n};\n\n#if !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)\n\ntemplate<> struct sp_dereference< void const >\n{\n    typedef void type;\n};\n\ntemplate<> struct sp_dereference< void volatile >\n{\n    typedef void type;\n};\n\ntemplate<> struct sp_dereference< void const volatile >\n{\n    typedef void type;\n};\n\n#endif // !defined(BOOST_NO_CV_VOID_SPECIALIZATIONS)\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T > struct sp_dereference< T[] >\n{\n    typedef void type;\n};\n\n#if !defined( __BORLANDC__ ) || !BOOST_WORKAROUND( __BORLANDC__, < 0x600 )\n\ntemplate< class T, std::size_t N > struct sp_dereference< T[N] >\n{\n    typedef void type;\n};\n\n#endif\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// sp_member_access, return type of operator->\n\ntemplate< class T > struct sp_member_access\n{\n    typedef T * type;\n};\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T > struct sp_member_access< T[] >\n{\n    typedef void type;\n};\n\n#if !defined( __BORLANDC__ ) || !BOOST_WORKAROUND( __BORLANDC__, < 0x600 )\n\ntemplate< class T, std::size_t N > struct sp_member_access< T[N] >\n{\n    typedef void type;\n};\n\n#endif\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// sp_array_access, return type of operator[]\n\ntemplate< class T > struct sp_array_access\n{\n    typedef void type;\n};\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T > struct sp_array_access< T[] >\n{\n    typedef T & type;\n};\n\n#if !defined( __BORLANDC__ ) || !BOOST_WORKAROUND( __BORLANDC__, < 0x600 )\n\ntemplate< class T, std::size_t N > struct sp_array_access< T[N] >\n{\n    typedef T & type;\n};\n\n#endif\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// sp_extent, for operator[] index check\n\ntemplate< class T > struct sp_extent\n{\n    enum _vt { value = 0 };\n};\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T, std::size_t N > struct sp_extent< T[N] >\n{\n    enum _vt { value = N };\n};\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// enable_shared_from_this support\n\ntemplate< class X, class Y, class T > inline void sp_enable_shared_from_this( boost::shared_ptr<X> const * ppx, Y const * py, boost::enable_shared_from_this< T > const * pe )\n{\n    if( pe != 0 )\n    {\n        pe->_internal_accept_owner( ppx, const_cast< Y* >( py ) );\n    }\n}\n\ntemplate< class X, class Y > inline void sp_enable_shared_from_this( boost::shared_ptr<X> * ppx, Y const * py, boost::enable_shared_from_raw const * pe );\n\n#ifdef _MANAGED\n\n// Avoid C4793, ... causes native code generation\n\nstruct sp_any_pointer\n{\n    template<class T> sp_any_pointer( T* ) {}\n};\n\ninline void sp_enable_shared_from_this( sp_any_pointer, sp_any_pointer, sp_any_pointer )\n{\n}\n\n#else // _MANAGED\n\ninline void sp_enable_shared_from_this( ... )\n{\n}\n\n#endif // _MANAGED\n\n#if !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION ) && !defined( BOOST_NO_AUTO_PTR )\n\n// rvalue auto_ptr support based on a technique by Dave Abrahams\n\ntemplate< class T, class R > struct sp_enable_if_auto_ptr\n{\n};\n\ntemplate< class T, class R > struct sp_enable_if_auto_ptr< std::auto_ptr< T >, R >\n{\n    typedef R type;\n}; \n\n#endif\n\n// sp_assert_convertible\n\ntemplate< class Y, class T > inline void sp_assert_convertible()\n{\n#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )\n\n    // static_assert( sp_convertible< Y, T >::value );\n    typedef char tmp[ sp_convertible< Y, T >::value? 1: -1 ];\n    (void)sizeof( tmp );\n\n#else\n\n    T* p = static_cast< Y* >( 0 );\n    (void)p;\n\n#endif\n}\n\n// pointer constructor helper\n\ntemplate< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T > * ppx, Y * p, boost::detail::shared_count & pn )\n{\n    boost::detail::shared_count( p ).swap( pn );\n    boost::detail::sp_enable_shared_from_this( ppx, p, p );\n}\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[] > * /*ppx*/, Y * p, boost::detail::shared_count & pn )\n{\n    sp_assert_convertible< Y[], T[] >();\n    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );\n}\n\ntemplate< class T, std::size_t N, class Y > inline void sp_pointer_construct( boost::shared_ptr< T[N] > * /*ppx*/, Y * p, boost::detail::shared_count & pn )\n{\n    sp_assert_convertible< Y[N], T[N] >();\n    boost::detail::shared_count( p, boost::checked_array_deleter< T >() ).swap( pn );\n}\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n// deleter constructor helper\n\ntemplate< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T > * ppx, Y * p )\n{\n    boost::detail::sp_enable_shared_from_this( ppx, p, p );\n}\n\n#if !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\ntemplate< class T, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[] > * /*ppx*/, Y * /*p*/ )\n{\n    sp_assert_convertible< Y[], T[] >();\n}\n\ntemplate< class T, std::size_t N, class Y > inline void sp_deleter_construct( boost::shared_ptr< T[N] > * /*ppx*/, Y * /*p*/ )\n{\n    sp_assert_convertible< Y[N], T[N] >();\n}\n\n#endif // !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n} // namespace detail\n\n\n//\n//  shared_ptr\n//\n//  An enhanced relative of scoped_ptr with reference counted copy semantics.\n//  The object pointed to is deleted when the last shared_ptr pointing to it\n//  is destroyed or reset.\n//\n\ntemplate<class T> class shared_ptr\n{\nprivate:\n\n    // Borland 5.5.1 specific workaround\n    typedef shared_ptr<T> this_type;\n\npublic:\n\n    typedef typename boost::detail::sp_element< T >::type element_type;\n\n    shared_ptr() BOOST_NOEXCEPT : px( 0 ), pn() // never throws in 1.30+\n    {\n    }\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\n    shared_ptr( boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT : px( 0 ), pn() // never throws\n    {\n    }\n\n#endif\n\n    template<class Y>\n    explicit shared_ptr( Y * p ): px( p ), pn() // Y must be complete\n    {\n        boost::detail::sp_pointer_construct( this, p, pn );\n    }\n\n    //\n    // Requirements: D's copy constructor must not throw\n    //\n    // shared_ptr will release p by calling d(p)\n    //\n\n    template<class Y, class D> shared_ptr( Y * p, D d ): px( p ), pn( p, d )\n    {\n        boost::detail::sp_deleter_construct( this, p );\n    }\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\n    template<class D> shared_ptr( boost::detail::sp_nullptr_t p, D d ): px( p ), pn( p, d )\n    {\n    }\n\n#endif\n\n    // As above, but with allocator. A's copy constructor shall not throw.\n\n    template<class Y, class D, class A> shared_ptr( Y * p, D d, A a ): px( p ), pn( p, d, a )\n    {\n        boost::detail::sp_deleter_construct( this, p );\n    }\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\n    template<class D, class A> shared_ptr( boost::detail::sp_nullptr_t p, D d, A a ): px( p ), pn( p, d, a )\n    {\n    }\n\n#endif\n\n//  generated copy constructor, destructor are fine...\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n// ... except in C++0x, move disables the implicit copy\n\n    shared_ptr( shared_ptr const & r ) BOOST_NOEXCEPT : px( r.px ), pn( r.pn )\n    {\n    }\n\n#endif\n\n    template<class Y>\n    explicit shared_ptr( weak_ptr<Y> const & r ): pn( r.pn ) // may throw\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        // it is now safe to copy r.px, as pn(r.pn) did not throw\n        px = r.px;\n    }\n\n    template<class Y>\n    shared_ptr( weak_ptr<Y> const & r, boost::detail::sp_nothrow_tag )\n    BOOST_NOEXCEPT : px( 0 ), pn( r.pn, boost::detail::sp_nothrow_tag() )\n    {\n        if( !pn.empty() )\n        {\n            px = r.px;\n        }\n    }\n\n    template<class Y>\n#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )\n\n    shared_ptr( shared_ptr<Y> const & r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )\n\n#else\n\n    shared_ptr( shared_ptr<Y> const & r )\n\n#endif\n    BOOST_NOEXCEPT : px( r.px ), pn( r.pn )\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n    }\n\n    // aliasing\n    template< class Y >\n    shared_ptr( shared_ptr<Y> const & r, element_type * p ) BOOST_NOEXCEPT : px( p ), pn( r.pn )\n    {\n    }\n\n#ifndef BOOST_NO_AUTO_PTR\n\n    template<class Y>\n    explicit shared_ptr( std::auto_ptr<Y> & r ): px(r.get()), pn()\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        Y * tmp = r.get();\n        pn = boost::detail::shared_count( r );\n\n        boost::detail::sp_deleter_construct( this, tmp );\n    }\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    template<class Y>\n    shared_ptr( std::auto_ptr<Y> && r ): px(r.get()), pn()\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        Y * tmp = r.get();\n        pn = boost::detail::shared_count( r );\n\n        boost::detail::sp_deleter_construct( this, tmp );\n    }\n\n#elif !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n    template<class Ap>\n    explicit shared_ptr( Ap r, typename boost::detail::sp_enable_if_auto_ptr<Ap, int>::type = 0 ): px( r.get() ), pn()\n    {\n        typedef typename Ap::element_type Y;\n\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        Y * tmp = r.get();\n        pn = boost::detail::shared_count( r );\n\n        boost::detail::sp_deleter_construct( this, tmp );\n    }\n\n#endif // BOOST_NO_SFINAE, BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n\n#endif // BOOST_NO_AUTO_PTR\n\n#if !defined( BOOST_NO_CXX11_SMART_PTR ) && !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    template< class Y, class D >\n    shared_ptr( std::unique_ptr< Y, D > && r ): px( r.get() ), pn()\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        typename std::unique_ptr< Y, D >::pointer tmp = r.get();\n        pn = boost::detail::shared_count( r );\n\n        boost::detail::sp_deleter_construct( this, tmp );\n    }\n\n#endif\n\n    // assignment\n\n    shared_ptr & operator=( shared_ptr const & r ) BOOST_NOEXCEPT\n    {\n        this_type(r).swap(*this);\n        return *this;\n    }\n\n#if !defined(BOOST_MSVC) || (BOOST_MSVC >= 1400)\n\n    template<class Y>\n    shared_ptr & operator=(shared_ptr<Y> const & r) BOOST_NOEXCEPT\n    {\n        this_type(r).swap(*this);\n        return *this;\n    }\n\n#endif\n\n#ifndef BOOST_NO_AUTO_PTR\n\n    template<class Y>\n    shared_ptr & operator=( std::auto_ptr<Y> & r )\n    {\n        this_type( r ).swap( *this );\n        return *this;\n    }\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    template<class Y>\n    shared_ptr & operator=( std::auto_ptr<Y> && r )\n    {\n        this_type( static_cast< std::auto_ptr<Y> && >( r ) ).swap( *this );\n        return *this;\n    }\n\n#elif !defined( BOOST_NO_SFINAE ) && !defined( BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION )\n\n    template<class Ap>\n    typename boost::detail::sp_enable_if_auto_ptr< Ap, shared_ptr & >::type operator=( Ap r )\n    {\n        this_type( r ).swap( *this );\n        return *this;\n    }\n\n#endif // BOOST_NO_SFINAE, BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n\n#endif // BOOST_NO_AUTO_PTR\n\n#if !defined( BOOST_NO_CXX11_SMART_PTR ) && !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    template<class Y, class D>\n    shared_ptr & operator=( std::unique_ptr<Y, D> && r )\n    {\n        this_type( static_cast< std::unique_ptr<Y, D> && >( r ) ).swap(*this);\n        return *this;\n    }\n\n#endif\n\n// Move support\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    shared_ptr( shared_ptr && r ) BOOST_NOEXCEPT : px( r.px ), pn()\n    {\n        pn.swap( r.pn );\n        r.px = 0;\n    }\n\n    template<class Y>\n#if !defined( BOOST_SP_NO_SP_CONVERTIBLE )\n\n    shared_ptr( shared_ptr<Y> && r, typename boost::detail::sp_enable_if_convertible<Y,T>::type = boost::detail::sp_empty() )\n\n#else\n\n    shared_ptr( shared_ptr<Y> && r )\n\n#endif\n    BOOST_NOEXCEPT : px( r.px ), pn()\n    {\n        boost::detail::sp_assert_convertible< Y, T >();\n\n        pn.swap( r.pn );\n        r.px = 0;\n    }\n\n    shared_ptr & operator=( shared_ptr && r ) BOOST_NOEXCEPT\n    {\n        this_type( static_cast< shared_ptr && >( r ) ).swap( *this );\n        return *this;\n    }\n\n    template<class Y>\n    shared_ptr & operator=( shared_ptr<Y> && r ) BOOST_NOEXCEPT\n    {\n        this_type( static_cast< shared_ptr<Y> && >( r ) ).swap( *this );\n        return *this;\n    }\n\n#endif\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\n    shared_ptr & operator=( boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT // never throws\n    {\n        this_type().swap(*this);\n        return *this;\n    }\n\n#endif\n\n    void reset() BOOST_NOEXCEPT // never throws in 1.30+\n    {\n        this_type().swap(*this);\n    }\n\n    template<class Y> void reset( Y * p ) // Y must be complete\n    {\n        BOOST_ASSERT( p == 0 || p != px ); // catch self-reset errors\n        this_type( p ).swap( *this );\n    }\n\n    template<class Y, class D> void reset( Y * p, D d )\n    {\n        this_type( p, d ).swap( *this );\n    }\n\n    template<class Y, class D, class A> void reset( Y * p, D d, A a )\n    {\n        this_type( p, d, a ).swap( *this );\n    }\n\n    template<class Y> void reset( shared_ptr<Y> const & r, element_type * p )\n    {\n        this_type( r, p ).swap( *this );\n    }\n    \n    // never throws (but has a BOOST_ASSERT in it, so not marked with BOOST_NOEXCEPT)\n    typename boost::detail::sp_dereference< T >::type operator* () const\n    {\n        BOOST_ASSERT( px != 0 );\n        return *px;\n    }\n    \n    // never throws (but has a BOOST_ASSERT in it, so not marked with BOOST_NOEXCEPT)\n    typename boost::detail::sp_member_access< T >::type operator-> () const \n    {\n        BOOST_ASSERT( px != 0 );\n        return px;\n    }\n    \n    // never throws (but has a BOOST_ASSERT in it, so not marked with BOOST_NOEXCEPT)\n    typename boost::detail::sp_array_access< T >::type operator[] ( std::ptrdiff_t i ) const\n    {\n        BOOST_ASSERT( px != 0 );\n        BOOST_ASSERT( i >= 0 && ( i < boost::detail::sp_extent< T >::value || boost::detail::sp_extent< T >::value == 0 ) );\n\n        return px[ i ];\n    }\n\n    element_type * get() const BOOST_NOEXCEPT\n    {\n        return px;\n    }\n\n// implicit conversion to \"bool\"\n#include <boost/smart_ptr/detail/operator_bool.hpp>\n\n    bool unique() const BOOST_NOEXCEPT\n    {\n        return pn.unique();\n    }\n\n    long use_count() const BOOST_NOEXCEPT\n    {\n        return pn.use_count();\n    }\n\n    void swap( shared_ptr & other ) BOOST_NOEXCEPT\n    {\n        std::swap(px, other.px);\n        pn.swap(other.pn);\n    }\n\n    template<class Y> bool owner_before( shared_ptr<Y> const & rhs ) const BOOST_NOEXCEPT\n    {\n        return pn < rhs.pn;\n    }\n\n    template<class Y> bool owner_before( weak_ptr<Y> const & rhs ) const BOOST_NOEXCEPT\n    {\n        return pn < rhs.pn;\n    }\n\n    void * _internal_get_deleter( boost::detail::sp_typeinfo const & ti ) const BOOST_NOEXCEPT\n    {\n        return pn.get_deleter( ti );\n    }\n\n    void * _internal_get_untyped_deleter() const BOOST_NOEXCEPT\n    {\n        return pn.get_untyped_deleter();\n    }\n\n    bool _internal_equiv( shared_ptr const & r ) const BOOST_NOEXCEPT\n    {\n        return px == r.px && pn == r.pn;\n    }\n\n// Tasteless as this may seem, making all members public allows member templates\n// to work in the absence of member template friends. (Matthew Langston)\n\n#ifndef BOOST_NO_MEMBER_TEMPLATE_FRIENDS\n\nprivate:\n\n    template<class Y> friend class shared_ptr;\n    template<class Y> friend class weak_ptr;\n\n\n#endif\n\n    element_type * px;                 // contained pointer\n    boost::detail::shared_count pn;    // reference counter\n\n};  // shared_ptr\n\ntemplate<class T, class U> inline bool operator==(shared_ptr<T> const & a, shared_ptr<U> const & b) BOOST_NOEXCEPT\n{\n    return a.get() == b.get();\n}\n\ntemplate<class T, class U> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<U> const & b) BOOST_NOEXCEPT\n{\n    return a.get() != b.get();\n}\n\n#if __GNUC__ == 2 && __GNUC_MINOR__ <= 96\n\n// Resolve the ambiguity between our op!= and the one in rel_ops\n\ntemplate<class T> inline bool operator!=(shared_ptr<T> const & a, shared_ptr<T> const & b) BOOST_NOEXCEPT\n{\n    return a.get() != b.get();\n}\n\n#endif\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\ntemplate<class T> inline bool operator==( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT\n{\n    return p.get() == 0;\n}\n\ntemplate<class T> inline bool operator==( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return p.get() == 0;\n}\n\ntemplate<class T> inline bool operator!=( shared_ptr<T> const & p, boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT\n{\n    return p.get() != 0;\n}\n\ntemplate<class T> inline bool operator!=( boost::detail::sp_nullptr_t, shared_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return p.get() != 0;\n}\n\n#endif\n\ntemplate<class T, class U> inline bool operator<(shared_ptr<T> const & a, shared_ptr<U> const & b) BOOST_NOEXCEPT\n{\n    return a.owner_before( b );\n}\n\ntemplate<class T> inline void swap(shared_ptr<T> & a, shared_ptr<T> & b) BOOST_NOEXCEPT\n{\n    a.swap(b);\n}\n\ntemplate<class T, class U> shared_ptr<T> static_pointer_cast( shared_ptr<U> const & r ) BOOST_NOEXCEPT\n{\n    (void) static_cast< T* >( static_cast< U* >( 0 ) );\n\n    typedef typename shared_ptr<T>::element_type E;\n\n    E * p = static_cast< E* >( r.get() );\n    return shared_ptr<T>( r, p );\n}\n\ntemplate<class T, class U> shared_ptr<T> const_pointer_cast( shared_ptr<U> const & r ) BOOST_NOEXCEPT\n{\n    (void) const_cast< T* >( static_cast< U* >( 0 ) );\n\n    typedef typename shared_ptr<T>::element_type E;\n\n    E * p = const_cast< E* >( r.get() );\n    return shared_ptr<T>( r, p );\n}\n\ntemplate<class T, class U> shared_ptr<T> dynamic_pointer_cast( shared_ptr<U> const & r ) BOOST_NOEXCEPT\n{\n    (void) dynamic_cast< T* >( static_cast< U* >( 0 ) );\n\n    typedef typename shared_ptr<T>::element_type E;\n\n    E * p = dynamic_cast< E* >( r.get() );\n    return p? shared_ptr<T>( r, p ): shared_ptr<T>();\n}\n\ntemplate<class T, class U> shared_ptr<T> reinterpret_pointer_cast( shared_ptr<U> const & r ) BOOST_NOEXCEPT\n{\n    (void) reinterpret_cast< T* >( static_cast< U* >( 0 ) );\n\n    typedef typename shared_ptr<T>::element_type E;\n\n    E * p = reinterpret_cast< E* >( r.get() );\n    return shared_ptr<T>( r, p );\n}\n\n// get_pointer() enables boost::mem_fn to recognize shared_ptr\n\ntemplate<class T> inline typename shared_ptr<T>::element_type * get_pointer(shared_ptr<T> const & p) BOOST_NOEXCEPT\n{\n    return p.get();\n}\n\n// operator<<\n\n#if !defined(BOOST_NO_IOSTREAM)\n\n#if defined(BOOST_NO_TEMPLATED_IOSTREAMS) || ( defined(__GNUC__) &&  (__GNUC__ < 3) )\n\ntemplate<class Y> std::ostream & operator<< (std::ostream & os, shared_ptr<Y> const & p)\n{\n    os << p.get();\n    return os;\n}\n\n#else\n\n// in STLport's no-iostreams mode no iostream symbols can be used\n#ifndef _STLP_NO_IOSTREAMS\n\n# if defined(BOOST_MSVC) && BOOST_WORKAROUND(BOOST_MSVC, < 1300 && __SGI_STL_PORT)\n// MSVC6 has problems finding std::basic_ostream through the using declaration in namespace _STL\nusing std::basic_ostream;\ntemplate<class E, class T, class Y> basic_ostream<E, T> & operator<< (basic_ostream<E, T> & os, shared_ptr<Y> const & p)\n# else\ntemplate<class E, class T, class Y> std::basic_ostream<E, T> & operator<< (std::basic_ostream<E, T> & os, shared_ptr<Y> const & p)\n# endif\n{\n    os << p.get();\n    return os;\n}\n\n#endif // _STLP_NO_IOSTREAMS\n\n#endif // __GNUC__ < 3\n\n#endif // !defined(BOOST_NO_IOSTREAM)\n\n// get_deleter\n\nnamespace detail\n{\n\n#if ( defined(__GNUC__) && BOOST_WORKAROUND(__GNUC__, < 3) ) || \\\n    ( defined(__EDG_VERSION__) && BOOST_WORKAROUND(__EDG_VERSION__, <= 238) ) || \\\n    ( defined(__HP_aCC) && BOOST_WORKAROUND(__HP_aCC, <= 33500) )\n\n// g++ 2.9x doesn't allow static_cast<X const *>(void *)\n// apparently EDG 2.38 and HP aCC A.03.35 also don't accept it\n\ntemplate<class D, class T> D * basic_get_deleter(shared_ptr<T> const & p)\n{\n    void const * q = p._internal_get_deleter(BOOST_SP_TYPEID(D));\n    return const_cast<D *>(static_cast<D const *>(q));\n}\n\n#else\n\ntemplate<class D, class T> D * basic_get_deleter( shared_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return static_cast<D *>( p._internal_get_deleter(BOOST_SP_TYPEID(D)) );\n}\n\n#endif\n\nclass esft2_deleter_wrapper\n{\nprivate:\n\n    shared_ptr<void> deleter_;\n\npublic:\n\n    esft2_deleter_wrapper()\n    {\n    }\n\n    template< class T > void set_deleter( shared_ptr<T> const & deleter )\n    {\n        deleter_ = deleter;\n    }\n\n    template<typename D> D* get_deleter() const BOOST_NOEXCEPT\n    {\n        return boost::detail::basic_get_deleter<D>( deleter_ );\n    }\n\n    template< class T> void operator()( T* )\n    {\n        BOOST_ASSERT( deleter_.use_count() <= 1 );\n        deleter_.reset();\n    }\n};\n\n} // namespace detail\n\ntemplate<class D, class T> D * get_deleter( shared_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    D *del = boost::detail::basic_get_deleter<D>(p);\n\n    if(del == 0)\n    {\n        boost::detail::esft2_deleter_wrapper *del_wrapper = boost::detail::basic_get_deleter<boost::detail::esft2_deleter_wrapper>(p);\n// The following get_deleter method call is fully qualified because\n// older versions of gcc (2.95, 3.2.3) fail to compile it when written del_wrapper->get_deleter<D>()\n        if(del_wrapper) del = del_wrapper->::boost::detail::esft2_deleter_wrapper::get_deleter<D>();\n    }\n\n    return del;\n}\n\n// atomic access\n\n#if !defined(BOOST_SP_NO_ATOMIC_ACCESS)\n\ntemplate<class T> inline bool atomic_is_lock_free( shared_ptr<T> const * /*p*/ ) BOOST_NOEXCEPT\n{\n    return false;\n}\n\ntemplate<class T> shared_ptr<T> atomic_load( shared_ptr<T> const * p )\n{\n    boost::detail::spinlock_pool<2>::scoped_lock lock( p );\n    return *p;\n}\n\ntemplate<class T> inline shared_ptr<T> atomic_load_explicit( shared_ptr<T> const * p, memory_order /*mo*/ )\n{\n    return atomic_load( p );\n}\n\ntemplate<class T> void atomic_store( shared_ptr<T> * p, shared_ptr<T> r )\n{\n    boost::detail::spinlock_pool<2>::scoped_lock lock( p );\n    p->swap( r );\n}\n\ntemplate<class T> inline void atomic_store_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )\n{\n    atomic_store( p, r ); // std::move( r )\n}\n\ntemplate<class T> shared_ptr<T> atomic_exchange( shared_ptr<T> * p, shared_ptr<T> r )\n{\n    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );\n\n    sp.lock();\n    p->swap( r );\n    sp.unlock();\n\n    return r; // return std::move( r )\n}\n\ntemplate<class T> shared_ptr<T> atomic_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> r, memory_order /*mo*/ )\n{\n    return atomic_exchange( p, r ); // std::move( r )\n}\n\ntemplate<class T> bool atomic_compare_exchange( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w )\n{\n    boost::detail::spinlock & sp = boost::detail::spinlock_pool<2>::spinlock_for( p );\n\n    sp.lock();\n\n    if( p->_internal_equiv( *v ) )\n    {\n        p->swap( w );\n\n        sp.unlock();\n\n        return true;\n    }\n    else\n    {\n        shared_ptr<T> tmp( *p );\n\n        sp.unlock();\n\n        tmp.swap( *v );\n        return false;\n    }\n}\n\ntemplate<class T> inline bool atomic_compare_exchange_explicit( shared_ptr<T> * p, shared_ptr<T> * v, shared_ptr<T> w, memory_order /*success*/, memory_order /*failure*/ )\n{\n    return atomic_compare_exchange( p, v, w ); // std::move( w )\n}\n\n#endif // !defined(BOOST_SP_NO_ATOMIC_ACCESS)\n\n// hash_value\n\ntemplate< class T > struct hash;\n\ntemplate< class T > std::size_t hash_value( boost::shared_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return boost::hash< T* >()( p.get() );\n}\n\n} // namespace boost\n\n#endif  // #if defined(BOOST_NO_MEMBER_TEMPLATES) && !defined(BOOST_MSVC6_MEMBER_TEMPLATES)\n\n#endif  // #ifndef BOOST_SMART_PTR_SHARED_PTR_HPP_INCLUDED\n","#ifndef BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED\n#define BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED\n\n// MS compatible compilers support #pragma once\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n//\n//  detail/shared_count.hpp\n//\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n//  Copyright 2004-2005 Peter Dimov\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#ifdef __BORLANDC__\n# pragma warn -8027     // Functions containing try are not expanded inline\n#endif\n\n#include <boost/config.hpp>\n#include <boost/checked_delete.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/smart_ptr/bad_weak_ptr.hpp>\n#include <boost/smart_ptr/detail/sp_counted_base.hpp>\n#include <boost/smart_ptr/detail/sp_counted_impl.hpp>\n#include <boost/detail/workaround.hpp>\n// In order to avoid circular dependencies with Boost.TR1\n// we make sure that our include of <memory> doesn't try to\n// pull in the TR1 headers: that's why we use this header \n// rather than including <memory> directly:\n#include <boost/config/no_tr1/memory.hpp>  // std::auto_ptr\n#include <functional>       // std::less\n\n#ifdef BOOST_NO_EXCEPTIONS\n# include <new>              // std::bad_alloc\n#endif\n\n#if !defined( BOOST_NO_CXX11_SMART_PTR )\n# include <boost/utility/addressof.hpp>\n#endif\n\nnamespace boost\n{\n\nnamespace detail\n{\n\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n\nint const shared_count_id = 0x2C35F101;\nint const   weak_count_id = 0x298C38A4;\n\n#endif\n\nstruct sp_nothrow_tag {};\n\ntemplate< class D > struct sp_inplace_tag\n{\n};\n\n#if !defined( BOOST_NO_CXX11_SMART_PTR )\n\ntemplate< class T > class sp_reference_wrapper\n{ \npublic:\n\n    explicit sp_reference_wrapper( T & t): t_( boost::addressof( t ) )\n    {\n    }\n\n    template< class Y > void operator()( Y * p ) const\n    {\n        (*t_)( p );\n    }\n\nprivate:\n\n    T * t_;\n};\n\ntemplate< class D > struct sp_convert_reference\n{\n    typedef D type;\n};\n\ntemplate< class D > struct sp_convert_reference< D& >\n{\n    typedef sp_reference_wrapper< D > type;\n};\n\n#endif\n\nclass weak_count;\n\nclass shared_count\n{\nprivate:\n\n    sp_counted_base * pi_;\n\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n    int id_;\n#endif\n\n    friend class weak_count;\n\npublic:\n\n    shared_count(): pi_(0) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n    }\n\n    template<class Y> explicit shared_count( Y * p ): pi_( 0 )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n#ifndef BOOST_NO_EXCEPTIONS\n\n        try\n        {\n            pi_ = new sp_counted_impl_p<Y>( p );\n        }\n        catch(...)\n        {\n            boost::checked_delete( p );\n            throw;\n        }\n\n#else\n\n        pi_ = new sp_counted_impl_p<Y>( p );\n\n        if( pi_ == 0 )\n        {\n            boost::checked_delete( p );\n            boost::throw_exception( std::bad_alloc() );\n        }\n\n#endif\n    }\n\n#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, <= 1200 )\n    template<class Y, class D> shared_count( Y * p, D d ): pi_(0)\n#else\n    template<class P, class D> shared_count( P p, D d ): pi_(0)\n#endif\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n#if defined( BOOST_MSVC ) && BOOST_WORKAROUND( BOOST_MSVC, <= 1200 )\n        typedef Y* P;\n#endif\n#ifndef BOOST_NO_EXCEPTIONS\n\n        try\n        {\n            pi_ = new sp_counted_impl_pd<P, D>(p, d);\n        }\n        catch(...)\n        {\n            d(p); // delete p\n            throw;\n        }\n\n#else\n\n        pi_ = new sp_counted_impl_pd<P, D>(p, d);\n\n        if(pi_ == 0)\n        {\n            d(p); // delete p\n            boost::throw_exception(std::bad_alloc());\n        }\n\n#endif\n    }\n\n#if !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )\n\n    template< class P, class D > shared_count( P p, sp_inplace_tag<D> ): pi_( 0 )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n#ifndef BOOST_NO_EXCEPTIONS\n\n        try\n        {\n            pi_ = new sp_counted_impl_pd< P, D >( p );\n        }\n        catch( ... )\n        {\n            D::operator_fn( p ); // delete p\n            throw;\n        }\n\n#else\n\n        pi_ = new sp_counted_impl_pd< P, D >( p );\n\n        if( pi_ == 0 )\n        {\n            D::operator_fn( p ); // delete p\n            boost::throw_exception( std::bad_alloc() );\n        }\n\n#endif // #ifndef BOOST_NO_EXCEPTIONS\n    }\n\n#endif // !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )\n\n    template<class P, class D, class A> shared_count( P p, D d, A a ): pi_( 0 )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n        typedef sp_counted_impl_pda<P, D, A> impl_type;\n        typedef typename A::template rebind< impl_type >::other A2;\n\n        A2 a2( a );\n\n#ifndef BOOST_NO_EXCEPTIONS\n\n        try\n        {\n            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );\n            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );\n        }\n        catch(...)\n        {\n            d( p );\n\n            if( pi_ != 0 )\n            {\n                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );\n            }\n\n            throw;\n        }\n\n#else\n\n        pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );\n\n        if( pi_ != 0 )\n        {\n            new( static_cast< void* >( pi_ ) ) impl_type( p, d, a );\n        }\n        else\n        {\n            d( p );\n            boost::throw_exception( std::bad_alloc() );\n        }\n\n#endif\n    }\n\n#if !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )\n\n    template< class P, class D, class A > shared_count( P p, sp_inplace_tag< D >, A a ): pi_( 0 )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n        typedef sp_counted_impl_pda< P, D, A > impl_type;\n        typedef typename A::template rebind< impl_type >::other A2;\n\n        A2 a2( a );\n\n#ifndef BOOST_NO_EXCEPTIONS\n\n        try\n        {\n            pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );\n            new( static_cast< void* >( pi_ ) ) impl_type( p, a );\n        }\n        catch(...)\n        {\n            D::operator_fn( p );\n\n            if( pi_ != 0 )\n            {\n                a2.deallocate( static_cast< impl_type* >( pi_ ), 1 );\n            }\n\n            throw;\n        }\n\n#else\n\n        pi_ = a2.allocate( 1, static_cast< impl_type* >( 0 ) );\n\n        if( pi_ != 0 )\n        {\n            new( static_cast< void* >( pi_ ) ) impl_type( p, a );\n        }\n        else\n        {\n            D::operator_fn( p );\n            boost::throw_exception( std::bad_alloc() );\n        }\n\n#endif // #ifndef BOOST_NO_EXCEPTIONS\n    }\n\n#endif // !defined( BOOST_NO_FUNCTION_TEMPLATE_ORDERING )\n\n#ifndef BOOST_NO_AUTO_PTR\n\n    // auto_ptr<Y> is special cased to provide the strong guarantee\n\n    template<class Y>\n    explicit shared_count( std::auto_ptr<Y> & r ): pi_( new sp_counted_impl_p<Y>( r.get() ) )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n#ifdef BOOST_NO_EXCEPTIONS\n\n        if( pi_ == 0 )\n        {\n            boost::throw_exception(std::bad_alloc());\n        }\n\n#endif\n\n        r.release();\n    }\n\n#endif \n\n#if !defined( BOOST_NO_CXX11_SMART_PTR )\n\n    template<class Y, class D>\n    explicit shared_count( std::unique_ptr<Y, D> & r ): pi_( 0 )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n        typedef typename sp_convert_reference<D>::type D2;\n\n        D2 d2( r.get_deleter() );\n        pi_ = new sp_counted_impl_pd< typename std::unique_ptr<Y, D>::pointer, D2 >( r.get(), d2 );\n\n#ifdef BOOST_NO_EXCEPTIONS\n\n        if( pi_ == 0 )\n        {\n            boost::throw_exception( std::bad_alloc() );\n        }\n\n#endif\n\n        r.release();\n    }\n\n#endif\n\n    ~shared_count() // nothrow\n    {\n        if( pi_ != 0 ) pi_->release();\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        id_ = 0;\n#endif\n    }\n\n    shared_count(shared_count const & r): pi_(r.pi_) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n        if( pi_ != 0 ) pi_->add_ref_copy();\n    }\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    shared_count(shared_count && r): pi_(r.pi_) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n    {\n        r.pi_ = 0;\n    }\n\n#endif\n\n    explicit shared_count(weak_count const & r); // throws bad_weak_ptr when r.use_count() == 0\n    shared_count( weak_count const & r, sp_nothrow_tag ); // constructs an empty *this when r.use_count() == 0\n\n    shared_count & operator= (shared_count const & r) // nothrow\n    {\n        sp_counted_base * tmp = r.pi_;\n\n        if( tmp != pi_ )\n        {\n            if( tmp != 0 ) tmp->add_ref_copy();\n            if( pi_ != 0 ) pi_->release();\n            pi_ = tmp;\n        }\n\n        return *this;\n    }\n\n    void swap(shared_count & r) // nothrow\n    {\n        sp_counted_base * tmp = r.pi_;\n        r.pi_ = pi_;\n        pi_ = tmp;\n    }\n\n    long use_count() const // nothrow\n    {\n        return pi_ != 0? pi_->use_count(): 0;\n    }\n\n    bool unique() const // nothrow\n    {\n        return use_count() == 1;\n    }\n\n    bool empty() const // nothrow\n    {\n        return pi_ == 0;\n    }\n\n    friend inline bool operator==(shared_count const & a, shared_count const & b)\n    {\n        return a.pi_ == b.pi_;\n    }\n\n    friend inline bool operator<(shared_count const & a, shared_count const & b)\n    {\n        return std::less<sp_counted_base *>()( a.pi_, b.pi_ );\n    }\n\n    void * get_deleter( sp_typeinfo const & ti ) const\n    {\n        return pi_? pi_->get_deleter( ti ): 0;\n    }\n\n    void * get_untyped_deleter() const\n    {\n        return pi_? pi_->get_untyped_deleter(): 0;\n    }\n};\n\n\nclass weak_count\n{\nprivate:\n\n    sp_counted_base * pi_;\n\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n    int id_;\n#endif\n\n    friend class shared_count;\n\npublic:\n\n    weak_count(): pi_(0) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(weak_count_id)\n#endif\n    {\n    }\n\n    weak_count(shared_count const & r): pi_(r.pi_) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(weak_count_id)\n#endif\n    {\n        if(pi_ != 0) pi_->weak_add_ref();\n    }\n\n    weak_count(weak_count const & r): pi_(r.pi_) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(weak_count_id)\n#endif\n    {\n        if(pi_ != 0) pi_->weak_add_ref();\n    }\n\n// Move support\n\n#if !defined( BOOST_NO_CXX11_RVALUE_REFERENCES )\n\n    weak_count(weak_count && r): pi_(r.pi_) // nothrow\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(weak_count_id)\n#endif\n    {\n        r.pi_ = 0;\n    }\n\n#endif\n\n    ~weak_count() // nothrow\n    {\n        if(pi_ != 0) pi_->weak_release();\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        id_ = 0;\n#endif\n    }\n\n    weak_count & operator= (shared_count const & r) // nothrow\n    {\n        sp_counted_base * tmp = r.pi_;\n\n        if( tmp != pi_ )\n        {\n            if(tmp != 0) tmp->weak_add_ref();\n            if(pi_ != 0) pi_->weak_release();\n            pi_ = tmp;\n        }\n\n        return *this;\n    }\n\n    weak_count & operator= (weak_count const & r) // nothrow\n    {\n        sp_counted_base * tmp = r.pi_;\n\n        if( tmp != pi_ )\n        {\n            if(tmp != 0) tmp->weak_add_ref();\n            if(pi_ != 0) pi_->weak_release();\n            pi_ = tmp;\n        }\n\n        return *this;\n    }\n\n    void swap(weak_count & r) // nothrow\n    {\n        sp_counted_base * tmp = r.pi_;\n        r.pi_ = pi_;\n        pi_ = tmp;\n    }\n\n    long use_count() const // nothrow\n    {\n        return pi_ != 0? pi_->use_count(): 0;\n    }\n\n    bool empty() const // nothrow\n    {\n        return pi_ == 0;\n    }\n\n    friend inline bool operator==(weak_count const & a, weak_count const & b)\n    {\n        return a.pi_ == b.pi_;\n    }\n\n    friend inline bool operator<(weak_count const & a, weak_count const & b)\n    {\n        return std::less<sp_counted_base *>()(a.pi_, b.pi_);\n    }\n};\n\ninline shared_count::shared_count( weak_count const & r ): pi_( r.pi_ )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n{\n    if( pi_ == 0 || !pi_->add_ref_lock() )\n    {\n        boost::throw_exception( boost::bad_weak_ptr() );\n    }\n}\n\ninline shared_count::shared_count( weak_count const & r, sp_nothrow_tag ): pi_( r.pi_ )\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        , id_(shared_count_id)\n#endif\n{\n    if( pi_ != 0 && !pi_->add_ref_lock() )\n    {\n        pi_ = 0;\n    }\n}\n\n} // namespace detail\n\n} // namespace boost\n\n#ifdef __BORLANDC__\n# pragma warn .8027     // Functions containing try are not expanded inline\n#endif\n\n#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SHARED_COUNT_HPP_INCLUDED\n","#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_SYNC_HPP_INCLUDED\n#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_SYNC_HPP_INCLUDED\n\n// MS compatible compilers support #pragma once\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n//  detail/sp_counted_base_sync.hpp - g++ 4.1+ __sync intrinsics\n//\n//  Copyright (c) 2007 Peter Dimov\n//\n//  Distributed under the Boost Software License, Version 1.0.\n//  See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt\n\n#include <boost/detail/sp_typeinfo.hpp>\n#include <limits.h>\n\n#if defined( __ia64__ ) && defined( __INTEL_COMPILER )\n# include <ia64intrin.h>\n#endif\n\nnamespace boost\n{\n\nnamespace detail\n{\n\n#if INT_MAX >= 2147483647\n\ntypedef int sp_int32_t;\n\n#else\n\ntypedef long sp_int32_t;\n\n#endif\n\ninline void atomic_increment( sp_int32_t * pw )\n{\n    __sync_fetch_and_add( pw, 1 );\n}\n\ninline sp_int32_t atomic_decrement( sp_int32_t * pw )\n{\n    return __sync_fetch_and_add( pw, -1 );\n}\n\ninline sp_int32_t atomic_conditional_increment( sp_int32_t * pw )\n{\n    // long r = *pw;\n    // if( r != 0 ) ++*pw;\n    // return r;\n\n    sp_int32_t r = *pw;\n\n    for( ;; )\n    {\n        if( r == 0 )\n        {\n            return r;\n        }\n\n        sp_int32_t r2 = __sync_val_compare_and_swap( pw, r, r + 1 );\n\n        if( r2 == r )\n        {\n            return r;\n        }\n        else\n        {\n            r = r2;\n        }\n    }    \n}\n\nclass sp_counted_base\n{\nprivate:\n\n    sp_counted_base( sp_counted_base const & );\n    sp_counted_base & operator= ( sp_counted_base const & );\n\n    sp_int32_t use_count_;        // #shared\n    sp_int32_t weak_count_;       // #weak + (#shared != 0)\n\npublic:\n\n    sp_counted_base(): use_count_( 1 ), weak_count_( 1 )\n    {\n    }\n\n    virtual ~sp_counted_base() // nothrow\n    {\n    }\n\n    // dispose() is called when use_count_ drops to zero, to release\n    // the resources managed by *this.\n\n    virtual void dispose() = 0; // nothrow\n\n    // destroy() is called when weak_count_ drops to zero.\n\n    virtual void destroy() // nothrow\n    {\n        delete this;\n    }\n\n    virtual void * get_deleter( sp_typeinfo const & ti ) = 0;\n    virtual void * get_untyped_deleter() = 0;\n\n    void add_ref_copy()\n    {\n        atomic_increment( &use_count_ );\n    }\n\n    bool add_ref_lock() // true on success\n    {\n        return atomic_conditional_increment( &use_count_ ) != 0;\n    }\n\n    void release() // nothrow\n    {\n        if( atomic_decrement( &use_count_ ) == 1 )\n        {\n            dispose();\n            weak_release();\n        }\n    }\n\n    void weak_add_ref() // nothrow\n    {\n        atomic_increment( &weak_count_ );\n    }\n\n    void weak_release() // nothrow\n    {\n        if( atomic_decrement( &weak_count_ ) == 1 )\n        {\n            destroy();\n        }\n    }\n\n    long use_count() const // nothrow\n    {\n        return const_cast< sp_int32_t const volatile & >( use_count_ );\n    }\n};\n\n} // namespace detail\n\n} // namespace boost\n\n#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_BASE_SYNC_HPP_INCLUDED\n","#ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED\n#define BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED\n\n// MS compatible compilers support #pragma once\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n//\n//  detail/sp_counted_impl.hpp\n//\n//  Copyright (c) 2001, 2002, 2003 Peter Dimov and Multi Media Ltd.\n//  Copyright 2004-2005 Peter Dimov\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n\n#include <boost/config.hpp>\n\n#if defined(BOOST_SP_USE_STD_ALLOCATOR) && defined(BOOST_SP_USE_QUICK_ALLOCATOR)\n# error BOOST_SP_USE_STD_ALLOCATOR and BOOST_SP_USE_QUICK_ALLOCATOR are incompatible.\n#endif\n\n#include <boost/checked_delete.hpp>\n#include <boost/smart_ptr/detail/sp_counted_base.hpp>\n\n#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)\n#include <boost/smart_ptr/detail/quick_allocator.hpp>\n#endif\n\n#if defined(BOOST_SP_USE_STD_ALLOCATOR)\n#include <memory>           // std::allocator\n#endif\n\n#include <cstddef>          // std::size_t\n\nnamespace boost\n{\n\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n\nvoid sp_scalar_constructor_hook( void * px, std::size_t size, void * pn );\nvoid sp_scalar_destructor_hook( void * px, std::size_t size, void * pn );\n\n#endif\n\nnamespace detail\n{\n\ntemplate<class X> class sp_counted_impl_p: public sp_counted_base\n{\nprivate:\n\n    X * px_;\n\n    sp_counted_impl_p( sp_counted_impl_p const & );\n    sp_counted_impl_p & operator= ( sp_counted_impl_p const & );\n\n    typedef sp_counted_impl_p<X> this_type;\n\npublic:\n\n    explicit sp_counted_impl_p( X * px ): px_( px )\n    {\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        boost::sp_scalar_constructor_hook( px, sizeof(X), this );\n#endif\n    }\n\n    virtual void dispose() // nothrow\n    {\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        boost::sp_scalar_destructor_hook( px_, sizeof(X), this );\n#endif\n        boost::checked_delete( px_ );\n    }\n\n    virtual void * get_deleter( detail::sp_typeinfo const & )\n    {\n        return 0;\n    }\n\n    virtual void * get_untyped_deleter()\n    {\n        return 0;\n    }\n\n#if defined(BOOST_SP_USE_STD_ALLOCATOR)\n\n    void * operator new( std::size_t )\n    {\n        return std::allocator<this_type>().allocate( 1, static_cast<this_type *>(0) );\n    }\n\n    void operator delete( void * p )\n    {\n        std::allocator<this_type>().deallocate( static_cast<this_type *>(p), 1 );\n    }\n\n#endif\n\n#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)\n\n    void * operator new( std::size_t )\n    {\n        return quick_allocator<this_type>::alloc();\n    }\n\n    void operator delete( void * p )\n    {\n        quick_allocator<this_type>::dealloc( p );\n    }\n\n#endif\n};\n\n//\n// Borland's Codeguard trips up over the -Vx- option here:\n//\n#ifdef __CODEGUARD__\n# pragma option push -Vx-\n#endif\n\ntemplate<class P, class D> class sp_counted_impl_pd: public sp_counted_base\n{\nprivate:\n\n    P ptr; // copy constructor must not throw\n    D del; // copy constructor must not throw\n\n    sp_counted_impl_pd( sp_counted_impl_pd const & );\n    sp_counted_impl_pd & operator= ( sp_counted_impl_pd const & );\n\n    typedef sp_counted_impl_pd<P, D> this_type;\n\npublic:\n\n    // pre: d(p) must not throw\n\n    sp_counted_impl_pd( P p, D & d ): ptr( p ), del( d )\n    {\n    }\n\n    sp_counted_impl_pd( P p ): ptr( p ), del()\n    {\n    }\n\n    virtual void dispose() // nothrow\n    {\n        del( ptr );\n    }\n\n    virtual void * get_deleter( detail::sp_typeinfo const & ti )\n    {\n        return ti == BOOST_SP_TYPEID(D)? &reinterpret_cast<char&>( del ): 0;\n    }\n\n    virtual void * get_untyped_deleter()\n    {\n        return &reinterpret_cast<char&>( del );\n    }\n\n#if defined(BOOST_SP_USE_STD_ALLOCATOR)\n\n    void * operator new( std::size_t )\n    {\n        return std::allocator<this_type>().allocate( 1, static_cast<this_type *>(0) );\n    }\n\n    void operator delete( void * p )\n    {\n        std::allocator<this_type>().deallocate( static_cast<this_type *>(p), 1 );\n    }\n\n#endif\n\n#if defined(BOOST_SP_USE_QUICK_ALLOCATOR)\n\n    void * operator new( std::size_t )\n    {\n        return quick_allocator<this_type>::alloc();\n    }\n\n    void operator delete( void * p )\n    {\n        quick_allocator<this_type>::dealloc( p );\n    }\n\n#endif\n};\n\ntemplate<class P, class D, class A> class sp_counted_impl_pda: public sp_counted_base\n{\nprivate:\n\n    P p_; // copy constructor must not throw\n    D d_; // copy constructor must not throw\n    A a_; // copy constructor must not throw\n\n    sp_counted_impl_pda( sp_counted_impl_pda const & );\n    sp_counted_impl_pda & operator= ( sp_counted_impl_pda const & );\n\n    typedef sp_counted_impl_pda<P, D, A> this_type;\n\npublic:\n\n    // pre: d( p ) must not throw\n\n    sp_counted_impl_pda( P p, D & d, A a ): p_( p ), d_( d ), a_( a )\n    {\n    }\n\n    sp_counted_impl_pda( P p, A a ): p_( p ), d_(), a_( a )\n    {\n    }\n\n    virtual void dispose() // nothrow\n    {\n        d_( p_ );\n    }\n\n    virtual void destroy() // nothrow\n    {\n        typedef typename A::template rebind< this_type >::other A2;\n\n        A2 a2( a_ );\n\n        this->~this_type();\n        a2.deallocate( this, 1 );\n    }\n\n    virtual void * get_deleter( detail::sp_typeinfo const & ti )\n    {\n        return ti == BOOST_SP_TYPEID( D )? &reinterpret_cast<char&>( d_ ): 0;\n    }\n\n    virtual void * get_untyped_deleter()\n    {\n        return &reinterpret_cast<char&>( d_ );\n    }\n};\n\n#ifdef __CODEGUARD__\n# pragma option pop\n#endif\n\n} // namespace detail\n\n} // namespace boost\n\n#endif  // #ifndef BOOST_SMART_PTR_DETAIL_SP_COUNTED_IMPL_HPP_INCLUDED\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"offset.hpp\"\n\nnamespace ovd\n{\n\nvoid Offset::print() {\n    std::cout << \"Offset: verts: \" << g.num_vertices() << \"\\n\";\n    std::cout << \"Offset: edges: \" << g.num_edges() << \"\\n\";\n    std::cout << \"Offset: faces: \" << g.num_faces() << \"\\n\";\n}\n\n/// create offsets at offset distance \\a t\nOffsetLoops Offset::offset(double t) {\n    offset_list.clear();\n    set_flags(t);\n    HEFace start;\n    while (find_start_face(start)) // while there are faces that still require offsets\n        offset_loop_walk(start,t); // start on the face, and do an offset loop\n\n    return offset_list;\n}\n\n/// find a suitable start face\nbool Offset::find_start_face(HEFace& start) {\n    for(HEFace f=0; f<g.num_faces() ; f++) {\n        if (face_done[f]==0 ) {\n            start=f;\n            return true;\n        }\n    }\n    return false;\n}\n\n/// perform an offset walk at given distance \\a t,\n/// starting at the given face\nvoid Offset::offset_loop_walk(HEFace start, double t) {\n    //std::cout << \" offset_walk() starting on face \" << start << \"\\n\";\n    bool out_in_mode= false; \n    HEEdge start_edge =  find_next_offset_edge( g[start].edge , t, out_in_mode); // the first edge on the start-face\n    HEEdge current_edge = start_edge;\n    OffsetLoop loop; // store the output in this loop\n    loop.offset_distance = t;\n    OffsetVertex pt( g[current_edge].point(t) ); // add the first point to the loop.\n    loop.push_back( pt );\n    do {\n        out_in_mode = edge_mode(current_edge, t);\n        // find the next edge\n        HEEdge next_edge = find_next_offset_edge( g[current_edge].next, t, out_in_mode); \n        //std::cout << \"offset-output: \"; print_edge(current_edge); std::cout << \" to \"; print_edge(next_edge); std::cout << \"\\n\";\n        HEFace current_face = g[current_edge].face;\n        loop.push_back( offset_element_from_face(current_face, current_edge, next_edge, t) );\n        face_done[current_face]=1; // although we may revisit current_face (if it is non-convex), it seems safe to mark it \"done\" here.\n        current_edge = g[next_edge].twin;\n    } while (current_edge != start_edge);\n    offset_list.push_back( loop ); // append the created loop to the output\n}\n\n\n/// return an offset-element corresponding to the current face\nOffsetVertex Offset::offset_element_from_face(HEFace current_face, HEEdge current_edge, HEEdge next_edge, double t) {\n    Site* s = g[current_face].site;\n    Ofs* o = s->offset( g[current_edge].point(t), g[next_edge].point(t) ); // ask the Site for offset-geometry here.\n    bool cw(true);\n    if (!s->isLine() ) // point and arc-sites produce arc-offsets, for which cw must be set.\n        cw = find_cw( o->start(), o->center(), o->end() ); // figure out cw or ccw arcs?\n    // add offset to output\n    OffsetVertex offset_element( g[next_edge].point(t), o->radius(), o->center(), cw, current_face );\n    return offset_element;\n}\n    \n/// \\brief figure out mode (?)\nbool Offset::edge_mode(HEEdge e, double t) {\n    HEVertex src = g.source(e);\n    HEVertex trg = g.target(e);\n    double src_r = g[src].dist();\n    double trg_r = g[trg].dist();\n    if ( (src_r<t) && (t<trg_r) ) {\n        return true;\n    } else if ((trg_r<t) && (t<src_r) ) {\n        return false;\n    } else {\n        assert(0);\n        return false;\n    }\n}\n\n/// figure out cw or ccw for an arc\nbool Offset::find_cw(Point start, Point center, Point end) {\n    return center.is_right(start,end); // NOTE: this only works for arcs smaller than a half-circle !\n}\n    \n\n/// \\brief starting at e, find the next edge on the face that brackets t\n///\n/// we can be in one of two modes.\n/// if mode==false then we are looking for an edge where src_t < t < trg_t\n/// if mode==true we are looning for an edge where       trg_t < t < src_t\nHEEdge Offset::find_next_offset_edge(HEEdge e, double t, bool mode) {\n    HEEdge start=e;\n    HEEdge current=start;\n    HEEdge ofs_edge=e;\n    do {\n        HEVertex src = g.source(current);\n        HEVertex trg = g.target(current);\n        double src_r = g[src].dist();\n        double trg_r = g[trg].dist();\n        if ( !mode && (src_r<t) && (t<trg_r) ) {\n            ofs_edge = current;\n            break;\n        } else if (mode && (trg_r<t) && (t<src_r) ) {\n            ofs_edge = current;\n            break;\n        }\n        current =g[current].next;\n    } while( current!=start );\n    return ofs_edge;\n}\n\n/// go through all faces and set flag=0 if the face requires an offset.    \nvoid Offset::set_flags(double t) {\n    for(HEFace f=0; f<g.num_faces() ; f++) {\n        HEEdge start = g[f].edge;\n        HEEdge current = start;\n        do {\n            HEVertex src = g.source(current);\n            HEVertex trg = g.target(current);\n            double src_r = g[src].dist();\n            double trg_r = g[trg].dist();\n            if (t_bracket(src_r,trg_r,t)) {\n                if ( face_done[f] ) // if 1\n                    face_done[f] = 0; // , set to 0. this is a face that requires an offset!\n            }\n            current = g[current].next;\n        } while ( current!=start );\n    }\n        \n    // again go through faces again, and set flag=1 if any edge on the face is invalid\n    // this is required because an upstream filter will set valid=false on some edges, \n    // but not all, on a face where we do not want offsets.\n    for(HEFace f=0; f<g.num_faces() ; f++) {\n        HEEdge start = g[f].edge;\n        HEEdge current = start;\n        do {\n            if ( !g[current].valid ) {\n                face_done[f] = 1; // don't offset faces with invalid edges\n            }\n            current = g[current].next;\n        } while ( current!=start );\n    }\n        //print_status();\n}\n\n\n/// is t in (a,b) ?\nbool Offset::t_bracket(double a, double b, double t) {\n    double min_t = std::min(a,b);\n    double max_t = std::max(a,b);\n    return ( (min_t<t) && (t<max_t) );\n}\n\n/// print status of offsets on all faces\nvoid Offset::print_status() {\n    for(HEFace f=0; f<g.num_faces() ; f++) {\n        std::cout << (int)face_done[f];\n    }\n    std::cout << \"\\n\";\n}\n\n} // end ovd namespace\n// end file offset.cpp\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <string>\n#include <iostream>\n\n#include \"graph.hpp\"\n#include \"site.hpp\"\n\nnamespace ovd\n{\n\n/// \\brief Line- or arc-vertex of an offset curve.\n///\n/// \\todo this duplicates the idea of the Ofs class. Remove this or Ofs!\nstruct OffsetVertex {\n    Point p;  ///< position (start)\n    double r; ///< arc radius (line-vertex is indicated by radius of -1)\n    Point c;  ///< arc center\n    bool cw;  ///< clockwise (or not)\n    HEFace f; ///< corresponding face in the vd-graph\n    /// ctor\n    OffsetVertex(Point pi, double ri, Point ci, bool cwi, HEFace fi): p(pi), r(ri), c(ci), cw(cwi), f(fi) {}\n    /// ctor\n    OffsetVertex(Point pi): p(pi), r(-1.), cw(false), f(0) {}\n};\n\n/// a single offset loop\nstruct OffsetLoop {\n    std::list<OffsetVertex> vertices;   ///< list of offsetvertices in this loop\n    double offset_distance;             ///< offset distance for this loop\n    /// add an offsetvertex to this loop\n    void push_back(OffsetVertex v) { vertices.push_back(v); }\n};\n\n/// multiple loops. the output of the algorithm\ntypedef std::vector<OffsetLoop> OffsetLoops;\n\n/// \\brief From a voronoi-diagram, generate offsets.\n///\n/// an offset is allways a closed loop.\n/// the loop consists of offset-elements from each face that the loop visits.\n/// each face is associated with a Site, and the offset element from\n/// - a point-site is a circular arc\n/// - a line-site is a line\n/// - an arc is a circular arc\n///\n/// This class produces offsets at the given offset-distance on the entire\n/// voronoi-diagram. To produce offsets only inside or outside a given geometry,\n/// use a filter first. The filter sets the valid-property of edges, so that offsets\n/// are not produced on faces with one or more invalid edge.\nclass Offset {\npublic:\n    /// \\param gi vd-graph\n    Offset(HEGraph& gi): g(gi) {\n        face_done.clear();\n        face_done.assign( g.num_faces(), 1 );\n    }\n    /// print stats\n    void print();\n    /// create offsets at offset distance \\a t\n    OffsetLoops offset(double t);\nprotected:\n    bool find_start_face(HEFace& start);\n    void offset_loop_walk(HEFace start, double t);\n    OffsetVertex offset_element_from_face(HEFace current_face, HEEdge current_edge, HEEdge next_edge, double t);\n    bool edge_mode(HEEdge e, double t);\n    bool find_cw(Point start, Point center, Point end);\n    HEEdge find_next_offset_edge(HEEdge e, double t, bool mode);\n    void set_flags(double t);\n    bool t_bracket(double a, double b, double t);\n    void print_status();\n    \n    OffsetLoops offset_list; ///< list of output offsets\nprivate:\n    Offset(); // don't use.\n    HEGraph& g; ///< vd-graph\n    /// hold a 0/1 flag for each face, indicating if an offset for this face has been produced or not.\n    std::vector<unsigned char> face_done;\n};\n\n\n} // end ovd namespace\n// end file offset.hpp\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <algorithm> // std::erase()\n\n#include <boost/array.hpp>\n#include <boost/math/tools/minima.hpp> // brent_find_minima\n\n#include \"vertex_positioner.hpp\"\n#include \"voronoidiagram.hpp\"\n#include \"common/numeric.hpp\"\n\n#include \"solvers/solver_ppp.hpp\"\n#include \"solvers/solver_lll.hpp\"\n#include \"solvers/solver_lll_para.hpp\"\n\n#include \"solvers/solver_qll.hpp\"\n#include \"solvers/solver_sep.hpp\"\n#include \"solvers/solver_alt_sep.hpp\"\n\nusing namespace ovd::numeric; // sq() chop()\n\nnamespace ovd {\n\n/// create positioner, set graph.\nVertexPositioner::VertexPositioner(HEGraph& gi): g(gi) {\n    //ppp_solver = new solvers::PPPSolver<double>(); // faster, but inaccurate\n    ppp_solver =      new solvers::PPPSolver<qd_real>(); // slower, more accurate\n    lll_solver =      new solvers::LLLSolver();\n    qll_solver =      new solvers::QLLSolver();\n    sep_solver =      new solvers::SEPSolver();\n    alt_sep_solver =  new solvers::ALTSEPSolver();\n    lll_para_solver = new solvers::LLLPARASolver();\n    silent = false;\n    solver_debug(false);\n    errstat.clear();\n}\n\n/// delete all solvers\nVertexPositioner::~VertexPositioner() {\n    //std::cout << \"~VertexPositioner()..\";\n    delete ppp_solver;\n    delete lll_solver;\n    delete qll_solver;\n    delete sep_solver;\n    delete alt_sep_solver;\n    delete lll_para_solver;\n\n    errstat.clear();\n    //std::cout << \"DONE.\\n\";\n}\n\n/// \\brief position a new vertex on given HEEdge \\a e when inserting the new Site \\a s3\n///\n/// calculate the position of a new voronoi-vertex lying on the given edge.\n/// The new vertex is equidistant to the two sites that defined the edge\n/// and to the new site. \n// the edge e holds information about which face it belongs to.\n// each face holds information about which site created it\n// so the three sites defining the position of the vertex are:\n// - site to the left of HEEdge e\n// - site to the right of HEEdge e\n// - given new Site s\nsolvers::Solution VertexPositioner::position(HEEdge e, Site* s3) {\n    edge = e;\n    HEFace face = g[e].face;     \n    HEEdge twin = g[e].twin;\n    HEFace twin_face = g[twin].face;\n\n    HEVertex src = g.source(e);\n    HEVertex trg = g.target(e);\n    double t_src = g[src].dist();\n    double t_trg = g[trg].dist();\n    t_min = std::min( t_src, t_trg ); // the solution we seek must have t_min<t<t_max\n    t_max = std::max( t_src, t_trg );\n\n    Site* s1 =  g[face].site;\n    Site* s2 = g[twin_face].site;\n\n    solvers::Solution sl = position(  s1 , g[e].k, s2, g[twin].k, s3 );\n\n    assert( solution_on_edge(sl) );\n    //assert( check_far_circle(sl) );\n    assert( check_dist(edge, sl, s3) );\n    \n    // error logging (FIXME: make optional, for max performance?)\n    #ifndef NDEBUG\n    {\n        errstat.push_back( dist_error(edge, sl, s3) );\n        if ( dist_error(edge, sl, s3) > 1e-6 ) {\n            // 2012-02-04: 1e-9 passes 79/79 tests\n            //             1e-10 passes 79/79\n            //             1e-12 passes 79/79\n            //             1e-13  17 FAILED out of 79\n            //             1e-14  38 FAILED out of 79\n            std::cout << \" VertexPositioner::position() WARNING; large dist_error = \" << dist_error(edge,  sl, s3) << \"\\n\";\n            double s1_dist = (sl.p - s1->apex_point(sl.p)).norm();\n            double s2_dist = (sl.p - s2->apex_point(sl.p)).norm();\n            double s3_dist = (sl.p - s3->apex_point(sl.p)).norm();\n            std::cout << \" s1 dist = \" << s1_dist << \"\\n\";\n            std::cout << \" s2 dist = \" << s2_dist << \"\\n\";\n            std::cout << \" s3 dist = \" << s3_dist << \"\\n\";\n            std::cout << \" t       = \" << sl.t << \"\\n\";\n            exit(-1);\n            //return fabs(t-s3_dist);\n        }\n    }\n    #endif\n    \n    return sl;\n}\n\n/// position new vertex\n// find vertex that is equidistant from s1, s2, s3\n// should lie on the k1 side of s1, k2 side of s2\n// we try both k3=-1 and k3=+1 for s3\nsolvers::Solution VertexPositioner::position(Site* s1, double k1, Site* s2, double k2, Site* s3) {\n    assert( (k1==1) || (k1 == -1) );\n    assert( (k2==1) || (k2 == -1) );\n    std::vector<solvers::Solution> solutions;\n        \n    solver_dispatch(s1,k1,s2,k2,s3,+1, solutions); // a single k3=+1 call for s3->isPoint()\n    \n    if (!s3->isPoint()) \n        solver_dispatch(s1,k1,s2,k2,s3,-1, solutions); // for lineSite or ArcSite we try k3=-1 also    \n    \n    if ( solutions.size() == 1 && (t_min<=solutions[0].t) && (t_max>=solutions[0].t) && (s3->in_region( solutions[0].p)) )\n        return solutions[0];\n            \n    if (solutions.empty() && !silent ) \n        std::cout << \"WARNING empty solution set!!\\n\";\n    \n    // choose only in_region() solutions\n    solutions.erase( std::remove_if(solutions.begin(),solutions.end(), in_region_filter(s3) ), solutions.end() );\n    if (solutions.empty() && !silent ) \n        std::cout << \"WARNING in_region_filter() results in empty solution set!!\\n\";\n    \n    \n    // choose only t_min < t < t_max solutions \n    solutions.erase( std::remove_if(solutions.begin(),solutions.end(), t_filter(t_min,t_max) ), solutions.end() );\n    if (solutions.empty() && !silent ) \n        std::cout << \"WARNING t_filter() results in empty solution set!!\\n\";\n\n    if ( solutions.size() == 1) // if only one solution is found, return that.\n        return solutions[0];\n    else if (solutions.size()>1) {\n        // two or more points remain so we must further filter here!\n        // filter further using edge_error\n        double min_error=100;\n        solvers::Solution min_solution(Point(0,0),0,0);\n        //std::cout << \" edge_error filter: \\n\";\n        BOOST_FOREACH(solvers::Solution s, solutions) {\n            double err = edge_error(s); //g[edge].error(s);\n            //std::cout << s.p << \" k3=\" << s.k3 << \" t=\" <<  s.t << \" err=\" << err << \"\\n\";\n            if ( err < min_error) {\n                min_solution = s;\n                min_error = err;\n            }\n        }\n        if (min_error >= 1e-6) {\n            /*\n            std::cout << \"WARNING: EDGE ERROR TOO LARGE\\n\";\n            std::cout << \" s1 = \" << s1->str2() << \" k1= \" << k1 << \"\\n\";\n            std::cout << \" s2 = \" << s2->str2() << \" k2= \" << k2 << \"\\n\";\n            std::cout << \" s3 = \" << s3->str2() << \"\\n\";\n            std::cout << \" sln=\" << min_solution.p << \" err=\" << min_error << \"\\n\";\n            std::cout << \" edge: \" << g[ g.source(edge) ].position << \" - \" << g[ g.target(edge) ].position;\n            std::cout << \" edge-point(t=\"<<min_solution.t << \")= \" << g[edge].point(min_solution.t) << \"\\n\";\n            */\n            //assert(0);\n        }\n        //assert( min_error < 1e-6 );\n        return min_solution;\n    }\n    \n\n    // either 0, or >= 2 solutions found. This is an error.\n    // std::cout << \" None, or too many solutions found! solutions.size()=\" << solutions.size() << \"\\n\";\n     \n    if ( !silent) {\n        std::cout << \" solution edge: \" << g[ g.source(edge) ].position << \"[\" << g[ g.source(edge) ].type << \"](t=\" << g[ g.source(edge) ].dist() << \")\";\n        std::cout << \" - \" << g[ g.target(edge) ].position << \"[\" << g[ g.target(edge) ].type << \"](t=\" << g[ g.target(edge) ].dist() << \") \\n\";\n        std::cout << \" solution edge: \" << g[ g.source(edge) ].index << \"[\" << g[ g.source(edge) ].type<<\"]{\" << g[ g.source(edge) ].status<<\"}\";\n        std::cout << \" -[\" << g[edge].type << \"]- \";\n        std::cout << g[ g.target(edge) ].index << \"[\" << g[ g.target(edge) ].type << \"]{\" << g[ g.target(edge) ].status<<\"}\\n\";\n        //std::cout << \" t-vals t_min= \" << t_min << \" t_max= \" << t_max << \"\\n\";\n        //std::cout << \"  sites: \" << s1->str() << \"(k=\"<< k1<< \") \" << s2->str() << \"(k=\"<< k2 << \") new= \" << s3->str() << \"\\n\";\n        std::cout << \" s1= \" << s1->str2() << \"(k=\" << k1<< \")\\n\";\n        std::cout << \" s2= \" << s2->str2() << \"(k=\" << k2<< \")\\n\";\n        std::cout << \" s3= \" << s3->str2() << \"\\n\";\n        \n        std::cout << \"Running solvers again: \\n\";\n    }\n    solver_debug(true);\n    // run the solver(s) one more time in order to print out un-filtered solution points for debugging\n    std::vector<solvers::Solution> solutions2;\n    solver_dispatch(s1,k1,s2,k2,s3,+1, solutions2);\n    if (!s3->isPoint()) // for points k3=+1 allways\n        solver_dispatch(s1,k1,s2,k2,s3,-1, solutions2); // for lineSite or ArcSite we try k3=-1 also    \n    solver_debug(false);\n    \n    if ( !silent) { \n        if ( !solutions2.empty() ) {\n            std::cout << \"The failing \" << solutions2.size() << \" solutions are: \\n\";\n            BOOST_FOREACH(solvers::Solution s, solutions2 ) {\n                std::cout << s.p << \" t=\" << s.t << \" k3=\" << s.k3  << \" e_err=\" << edge_error(s) <<\"\\n\";\n                std::cout << \" min<t<max=\" << ((s.t>=t_min) && (s.t<=t_max));\n                std::cout << \" s3.in_region=\" << s3->in_region(s.p);\n                std::cout <<  \" region-t=\" << s3->in_region_t(s.p) << \"\\n\";\n                std::cout <<  \" t - t_min= \" << s.t - t_min << \"\\n\";\n                std::cout <<  \" t_max - t= \" << t_max - s.t << \"\\n\";\n                std::cout <<  \" edge type : \" << g[edge].type << \"\\n\"; //std::scientific;\n            }   \n        } else {\n            std::cout << \"No solutions found by solvers!\\n\";\n        }\n    }\n\n    //assert(0); // in Debug mode, stop here.\n    \n    solvers::Solution desp = desperate_solution(s3);  // ( p_mid, t_mid, desp_k3 ); \n    \n    VertexError s1_err_functor(g, edge, s1);\n    VertexError s2_err_functor(g, edge, s2);\n    VertexError s3_err_functor(g, edge, s3);\n    \n    if ( !silent) { \n        std::cout << \"WARNING: Returning desperate solution: \\n\";\n        std::cout << desp.p << \" t=\" << desp.t << \" k3=\" << desp.k3  << \" e_err=\" << edge_error(desp) <<\"\\n\";\n        std::cout << \"     s1_err= \" << s1_err_functor(desp.t) << \"\\n\";\n        std::cout << \"     s2_err= \" << s2_err_functor(desp.t) << \"\\n\";\n        std::cout << \"     s3_err= \" << s3_err_functor(desp.t) << \"\\n\";\n    }\n    //exit(-1);\n    return desp;\n}\n\n/// search numerically for a desperate solution along the solution-edge\nsolvers::Solution VertexPositioner::desperate_solution(Site* s3) {\n    VertexError err_functor(g, edge, s3);\n    //HEFace face = g[edge].face;     \n    //HEEdge twin = g[edge].twin;\n    //HEFace twin_face = g[twin].face;\n    //Site* s1 =  g[face].site;\n    //Site* s2 = g[twin_face].site;\n    HEVertex src = g.source(edge);\n    HEVertex trg = g.target(edge);\n    Point src_p = g[src].position;\n    Point trg_p = g[trg].position;\n    \n    if (!silent) {\n        std::cout << \"VertexPositioner::desperate_solution() \\n\";\n        std::cout << \" edge: \" << src_p << \" - \" << trg_p << \"\\n\";\n        std::cout << \" dist(): \" << g[src].dist() << \" - \" << g[trg].dist() << \"\\n\";\n    }\n    \n    /*\n    if (s1->isLine() && s2->isLine() ) {\n        std::cout << s1->str2() << \"\\n\";\n        std::cout << s2->str2() << \"\\n\";\n        std::cout << s3->str2() << \"\\n\";\n    }\n    boost::array<double,8> x = g[edge].x;\n    boost::array<double,8> y = g[edge].y;\n    for (unsigned int n=0 ; n < 8 ; n++ ) {\n        std::cout << n << \"  \" << x[n] << \"  \" << y[n] << \"\\n\";\n    }\n    \n    for (int n=0 ; n < 20 ; n++ ) {\n        VertexError s1_err_functor(g, edge, s1);\n        VertexError s2_err_functor(g, edge, s2);\n        double ts = t_min + ((t_max-t_min)/(20-1))*n;\n        std::cout << n << \" ts=\" << ts << \" s3_error= \" << err_functor(ts) << \" p=\"<< g[edge].point(ts) << \"\\n\";\n        std::cout << \"     s1_err=\" << s1_err_functor(ts) << \" s2_err=\" << s2_err_functor(ts) << \"\\n\";\n\n    }\n    */\n    \n    typedef std::pair<double, double> Result;\n    Result r = boost::math::tools::brent_find_minima( err_functor, t_min, t_max, 64);\n    double t_sln = r.first;\n    //Point p_sln = g[edge].point(t_sln);\n    Point p_sln = err_functor.edge_point(t_sln); //g[edge].point(t_sln);\n    double desp_k3(0);\n    if (s3->isPoint())\n        desp_k3 = 1;\n    else if ( s3->isLine() ) {\n        // find out on which side the desperate solution lies\n        Point src_se = s3->start();\n        Point trg_se = s3->end();\n        Point left = 0.5*(src_se+trg_se) + (trg_se-src_se).xy_perp(); \n        if (p_sln.is_right(src_se,trg_se)) {\n            desp_k3 = (s3->k()==1) ? -1 : 1;\n        } else {\n            desp_k3 = (s3->k()==1) ? 1 : -1;\n        }\n    }\n    solvers::Solution desp( p_sln, t_sln, desp_k3 ); \n    return desp;\n}\n\n/// set debug output true/false\nvoid VertexPositioner::solver_debug(bool b) {\n    ppp_solver->set_debug(b);\n    lll_solver->set_debug(b);\n    qll_solver->set_debug(b);\n    sep_solver->set_debug(b);\n    alt_sep_solver->set_debug(b);\n    lll_para_solver->set_debug(b);\n}\n\nvoid VertexPositioner::set_silent(bool b) {\n    silent=b;\n    ppp_solver->set_silent(b);\n    lll_solver->set_silent(b);\n    lll_para_solver->set_silent(b);\n    qll_solver->set_silent(b);\n    sep_solver->set_silent(b);\n    alt_sep_solver->set_silent(b);\n}\n    \n/// dispatch to the correct solver based on the sites\nint VertexPositioner::solver_dispatch(Site* s1, double k1, Site* s2, double k2, Site* s3, double k3, \n                                        std::vector<solvers::Solution>& solns) {\n\n\n    if ( g[edge].type == SEPARATOR ) {\n        // this is a SEPARATOR edge with two LineSites adjacent.\n        // find the PointSite that defines the SEPARATOR, so that one LineSite and one PointSite\n        // can be submitted to the Solver.\n        if ( s1->isLine() && s2->isLine() ) {\n            // the parallell lineseg case      v0 --s1 --> pt -- s2 --> v1\n            // find t\n            if ( g[edge].has_null_face ) {\n                s2 = g[ g[edge].null_face ].site;\n                assert( s2->isPoint() ); // the sites of null-faces are allwais PointSite\n                k2 = +1;\n            } else if ( g[ g[edge].twin ].has_null_face ) {\n                s2 = g[ g[ g[edge].twin ].null_face ].site;\n                assert( s2->isPoint() );\n                k2 = +1;\n            }\n        } else if ( s1->isPoint() && s2->isLine() ) {\n            // a normal SEPARATOR edge, defined by a PointSite and a LineSite \n            // swap sites, so SEPSolver can assume s1=line s2=point\n            Site* tmp = s1;\n            double k_tmp = k1;\n            s1 = s2;\n            s2 = tmp;\n            k1 = k2;\n            k2 = k_tmp;\n            assert( s1->isLine() );\n            assert( s2->isPoint() );\n        }\n        assert( s1->isLine() && s2->isPoint() ); // we have previously set s1(line) s2(point)\n        return sep_solver->solve(s1,k1,s2,k2,s3,k3,solns); \n    } else if ( g[edge].type == PARA_LINELINE  && s3->isLine() ) { // an edge betwee parallel LineSites\n        //std::cout << \" para lineline! \\n\";\n        return lll_para_solver->solve( s1,k1,s2,k2,s3,k3, solns );\n    } else if ( s1->isLine() && s2->isLine() && s3->isLine() ) \n        return lll_solver->solve( s1,k1,s2,k2,s3,k3, solns ); // all lines.\n    else if ( s1->isPoint() && s2->isPoint() && s3->isPoint() )\n        return ppp_solver->solve( s1,1,s2,1,s3,1, solns ); // all points, no need to specify k1,k2,k3, they are all +1\n    else if ( (s3->isLine() && s1->isPoint() ) || \n              (s1->isLine() && s3->isPoint() ) ||\n              (s3->isLine() && s2->isPoint() ) ||\n              (s2->isLine() && s3->isPoint() ) // bad coverage for this line?\n            ) {\n        // if s1/s2 form a SEPARATOR-edge, this is dispatched automatically to sep-solver\n        // here we detect for a separator case between\n        // s1/s3\n        // s2/s3\n        if (s3->isLine() && s1->isPoint() ) {\n            if ( detect_sep_case(s3,s1) ) {\n                alt_sep_solver->set_type(0);\n                return alt_sep_solver->solve(s1, k1, s2, k2, s3, k3, solns );\n            }\n        }\n        if (s3->isLine() && s2->isPoint() ) {\n            if ( detect_sep_case(s3,s2) ) {\n                alt_sep_solver->set_type(1);\n                return alt_sep_solver->solve(s1, k1, s2, k2, s3, k3, solns );\n            }\n        }\n    } \n    \n    // if we didn't dispatch to a solver above, we try the general solver\n    return qll_solver->solve( s1,k1,s2,k2,s3,k3, solns ); // general case solver\n    \n}\n\n/// detect separator-case, so we can dispatch to the correct Solver\nbool VertexPositioner::detect_sep_case(Site* lsite, Site* psite) {\n    HEEdge le = lsite->edge();\n    HEVertex src = g.source(le);\n    HEVertex trg = g.target(le);\n    //std::cout << \" detect_sep_case() Linesite from \" << g[src].index << \" to \" << g[trg].index << \"\\n\";\n    // now from segment end-points get the null-vertex\n    HEEdge src_out;\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr(src) ) {\n        if ( g[e].type == NULLEDGE )\n            src_out = e;\n    }\n    HEEdge trg_out;\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr(trg) ) {\n        if ( g[e].type == NULLEDGE )\n            trg_out = e;\n    }\n    //std::cout << \" detect_sep_case() src null-edge \"; g.print_edge(src_out); // << g[src].index << \" to \" << g[trg].index << \"\\n\";\n    //std::cout << \" detect_sep_case() trg null-edge \"; g.print_edge(trg_out);\n    \n    HEFace src_null_face = g[src_out].face;\n    if (g[src_null_face].null == false ) {\n        // take twin face instead\n        HEEdge src_out_twin = g[src_out].twin;\n        src_null_face = g[src_out_twin].face;\n    }\n    \n    HEFace trg_null_face = g[trg_out].face;\n    if ( g[trg_null_face].null == false ) {\n        HEEdge trg_out_twin = g[trg_out].twin;\n        trg_null_face = g[trg_out_twin].face;\n    }\n    assert( g[src_null_face].null && g[trg_null_face].null );\n        \n    // do we want src_out face??\n    // OR src_out_twin face??\n    // we want the null-face !\n        \n    //std::cout << \" detect_sep_case() src null-face \" << src_null_face << \"\\n\";\n    //g.print_face(src_null_face);\n    //std::cout << \" detect_sep_case() trg null-face \" << trg_null_face << \"\\n\";\n    //g.print_face(trg_null_face);\n    \n    Site* src_site = g[src_null_face].site;\n    Site* trg_site = g[trg_null_face].site;\n    if (src_site == NULL || trg_site == NULL ) {\n        exit(-1);\n    }\n    if ( !src_site->isPoint() || !trg_site->isPoint() ) {\n        exit(-1);\n    }\n    //std::cout << \" detect_sep_case() src PointSite is \"  << src_site->str() << \"\\n\"; // << src_site->vertex();\n    //std::cout << \" detect_sep_case() trg PointSite is \"  << trg_site->str() << \"\\n\";\n    HEVertex src_vertex = src_site->vertex();\n    HEVertex trg_vertex = trg_site->vertex();\n    //std::cout << \" detect_sep_case() 1st end-point vertex is \" << g[src_vertex].index << \"\\n\";\n    //std::cout << \" detect_sep_case() 2nd end-point vertex is \" << g[trg_vertex].index << \"\\n\";\n    //std::cout << \" detect_sep_case() psite is \" << psite->str() << \"\\n\";\n    //std::cout << \" detect_sep_case() psite is \" << g[psite->vertex()].index << \"\\n\"; // g[ psite->vertex()].index << \"\\n\";\n    if ( src_vertex == psite->vertex() ) {\n        //std::cout << \" detect_sep_case(): src separator case!\\n\";\n        //std::cout << \" detect_sep_case(): line is \" << g[src].index << \" - \" << g[trg].index << \" with psites \" << g[src_vertex].index << \" - \" << g[trg_vertex].index << \"\\n\";\n        //std::cout << \" detect_sep_case(): psite vertex is \" << g[ psite->vertex() ].index << \"\\n\";\n        return true;\n    }\n    if ( trg_vertex == psite->vertex() ) {\n        //std::cout << \" detect_sep_case(): trg separator case!\\n\";\n        //std::cout << \" detect_sep_case(): line is \" << g[src].index << \" - \" << g[trg].index << \" with psites \" << g[src_vertex].index << \" - \" << g[trg_vertex].index << \"\\n\";\n        //std::cout << \" detect_sep_case(): psite vertex is \" << g[ psite->vertex() ].index << \"\\n\";\n\n        return true;\n    }\n    //std::cout << \" detect_sep_case()   NOT a separator case.\\n\";\n    return false;\n}\n\n/// error from solution to corresponding point on the edge\ndouble VertexPositioner::edge_error(solvers::Solution& sl) {\n    Point p;\n    if (g[edge].type==PARA_LINELINE) {\n        p = projection_point( sl );\n    } else {\n        p = g[edge].point( sl.t );\n    }\n    return (p-sl.p).norm();\n}\n\n/// when the edge is not parametrized by t-value as normal edges\n/// so we need a projection of sl onto the edge instead\nPoint VertexPositioner::projection_point(solvers::Solution& sl) {\n    assert( g[edge].type == PARA_LINELINE );\n    // edge given by\n    // p = p0 + t * (p1-p0)   with t in [0,1]\n    Point p0( g[ g.source(edge) ].position );\n    Point p1( g[ g.target(edge) ].position ); \n    //std::cout << \" edge is  \" << p0 << \" - \" << p1 << \"\\n\";\n    //std::cout << \" edge direction: \" << v << \"\\n\";\n    Point v = p1-p0;\n    \n    double t = (sl.p - p0).dot(v) / v.dot(v);\n    // clamp to [0,1]\n    if ( t>1)\n        t=1;\n    else if (t<0)\n        t=0;\n    //std::cout << \" projection of solution \" << sl.p << \" is \" << (p0+v*t) << \"\\n\";\n    return (p0+v*t);\n}\n\n/// check that the new solution lies on the edge\nbool VertexPositioner::solution_on_edge(solvers::Solution& s) {\n    double err = edge_error(s);\n    double limit = 9E-4;\n    if ( err>=limit ) {\n        std::cout << \"solution_on_edge() ERROR err= \" << err << \"\\n\";\n        std::cout << \" solution edge: \" << g[ g.source(edge) ].index << \"[\" << g[ g.source(edge) ].type<<\"]{\" << g[ g.source(edge) ].status<<\"}\";\n        std::cout << \" -[\" << g[edge].type << \"]- \";\n        std::cout << g[ g.target(edge) ].index << \"[\" << g[ g.target(edge) ].type << \"]{\" << g[ g.target(edge) ].status<<\"}\\n\";\n\n\n        std::cout << \" edge: \" << g[ g.source(edge) ].index << \"(t=\" << g[ g.source(edge) ].dist() << \")\"; \n        std::cout << \" - \" << g[ g.target(edge) ].index << \"(t=\" << g[ g.target(edge) ].dist() << \")\\n\";\n        std::cout << \" edge: \" << g[ g.source(edge) ].position << \" - \" << g[ g.target(edge) ].position << \"\\n\";\n        std::cout << \" solution: \" << s.p << \" t=\" << s.t << \"\\n\";\n    }\n    return (err<limit);\n}\n\n// calculate the distance from the solution-point to the corresponding point on the edge.\n/*\ndouble VertexPositioner::edge_error(HEEdge e, Solution& s) {\n    Point ep = g[e].point( s.t, s );\n    return (ep-s.p).norm();\n}*/\n\n/// new vertices should lie within the far_radius\nbool VertexPositioner::check_far_circle(solvers::Solution& s) {\n    if (!(s.p.norm() < 18*1)) {\n        std::cout << \"WARNING check_far_circle() new vertex outside far_radius! \\n\";\n        std::cout << s.p << \" norm=\" << s.p.norm() << \" far_radius=\" << 1 << \"\\n\"; \n        return false;\n    }\n    return true;\n}\n\n/// distance sanity check\n// all vertices should be of degree three, i.e. three adjacent faces/sites\n// distance to the three adjacent sites should be equal\nbool VertexPositioner::check_dist(HEEdge e, const solvers::Solution& sl, Site* s3) {\n    HEFace face = g[e].face;     \n    HEEdge tw_edge = g[e].twin;\n    HEFace twin_face = g[tw_edge].face;      \n    \n    Site* s1 = g[face].site;\n    Site* s2 = g[twin_face].site;\n    \n    double d1 = (sl.p - s1->apex_point(sl.p) ).norm();\n    double d2 = (sl.p - s2->apex_point(sl.p) ).norm();  \n    double d3 = (sl.p - s3->apex_point(sl.p) ).norm(); \n    \n    double maxd = std::max( std::max( fabs(sl.t-d1),fabs(sl.t-d2)) , fabs(sl.t-d3));\n    errstat.push_back(maxd);\n        \n    if ( !equal(d1,d2) || !equal(d1,d3) || !equal(d2,d3) ||\n         !equal(sl.t,d1) || !equal(sl.t,d2) || !equal(sl.t,d3) ) {\n        std::cout << \"WARNING check_dist() ! \\n\";\n        std::cout << \"  sl.t= \" << sl.t << \"\\n\";\n        std::cout << \"  d1= \" << d1 << \"\\n\"; \n        std::cout << \"  d2= \" << d2 << \"\\n\";\n        std::cout << \"  d3= \" << d3 << \"\\n\";\n        std::cout << \" solution edge: \" << g[ g.source(edge) ].index << \"[\" << g[ g.source(edge) ].type<<\"]{\" << g[ g.source(edge) ].status<<\"}\";\n        std::cout << \" -[\" << g[edge].type << \"]- \";\n        std::cout << g[ g.target(edge) ].index << \"[\" << g[ g.target(edge) ].type << \"]{\" << g[ g.target(edge) ].status<<\"}\\n\";\n    \n        return false;\n    }\n    return true;\n}\n\n/// distance-error\n// new vertices should be equidistant to the three adjacent sites that define the vertex\n// we here calculate the distances d1, d2, d3 from the Solution to the three sites s1, s2, s3\n// and return the max deviation from the solution t-value.\n// this works as a sanity check for the solver.\n// a high error value here is also an indication of numerical instability in the solver\ndouble VertexPositioner::dist_error(HEEdge e, const solvers::Solution& sl, Site* s3) {\n    HEFace face = g[e].face;     \n    HEEdge tw_edge = g[e].twin;\n    HEFace twin_face = g[tw_edge].face;      \n    \n    Site* s1 = g[face].site;\n    Site* s2 = g[twin_face].site;\n    \n    double d1 = (sl.p - s1->apex_point(sl.p) ).norm();\n    double d2 = (sl.p - s2->apex_point(sl.p) ).norm();  \n    double d3 = (sl.p - s3->apex_point(sl.p) ).norm(); \n    \n    return std::max( std::max( fabs(sl.t-d1),fabs(sl.t-d2)) , fabs(sl.t-d3));\n\n}\n\n/// are \\a d1 and \\a d2 roughly equal?\nbool VertexPositioner::equal(double d1, double d2) {\n    double tol = 1e-3;\n    if ( fabs(d1-d2) < 1e-15 )\n        return true;\n    if ( fabs(d1-d2) > tol*std::max(d1,d2) )\n        return false;\n    return true;\n}\n    \n    \n} // end namespace\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  Idea and code for point/line/arc voronoi-vertex positioning code by\n *  Andy Payne, andy \"at\" payne \"dot\" org, November, 2010\n *  see: http://www.payne.org/index.php/Calculating_Voronoi_Nodes\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include <vector>\n#include <cassert>\n\n#include \"solver.hpp\"\n#include \"../site.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop()\n\nnamespace ovd {\nnamespace solvers {\n    \n/// \\brief templated point-class, so we can use qd_real as the coordinate type.\ntemplate<class Scalar>\nstruct scalar_pt {\n    scalar_pt<Scalar>() : x(0), y(0) {}\n    /// \\param xi x coordinate\n    /// \\param yi y coordinate\n    scalar_pt<Scalar>(Scalar xi, Scalar yi) : x(xi), y(yi) {}\n    \n    /// x coordinate\n    Scalar x;\n    /// y coordinate\n    Scalar y;\n    /// return x coordinate\n    double getx() { return x; }\n    /// return y coordinate\n    double gety() { return y; }\n    /// assignment operator\n    scalar_pt<Scalar> &operator=(const Point& p) {\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n};\n\n// with the qd_real number-type we need to_double() to get the solution coordinates as double type.\n/// \\brief template-specialization for qd_real\ntemplate<>\nstruct scalar_pt<qd_real> {\n    scalar_pt<qd_real>() : x(qd_real(0)), y(qd_real(0)) {}\n    /// \\param xi x coordinate\n    /// \\param yi y coordinate\n    scalar_pt<qd_real>(qd_real xi, qd_real yi) : x(xi), y(yi) {}\n    \n    /// x coordinate\n    qd_real x;\n    /// y coordinate\n    qd_real y;\n    /// return x coordinate as double\n    double getx() { return to_double(x); }\n    /// return y coordinate as double\n    double gety() { return to_double(y); }\n    /// assignment\n    scalar_pt<qd_real> &operator=(const Point& p) {\n        x = p.x;\n        y = p.y;\n        return *this;\n    }\n};\n\n\n/// point-point-point Solver (based on Sugihara & Iri paper)\ntemplate<class Scalar>\nclass PPPSolver : public solvers::Solver {\npublic:\n\nint solve( Site* s1, double, Site* s2, double, Site* s3, double, std::vector<Solution>& slns ) {\n    assert( s1->isPoint() && s2->isPoint() && s3->isPoint() );\n    Point pi = s1->position();\n    Point pj = s2->position();\n    Point pk = s3->position();\n    \n    if ( pi.is_right(pj,pk) ) \n        std::swap(pi,pj);\n    assert( !pi.is_right(pj,pk) );\n    // 2) point pk should have the largest angle. largest angle is opposite longest side.\n    double longest_side = (pi - pj).norm();\n    while (  ((pj - pk).norm() > longest_side) || (((pi - pk).norm() > longest_side)) ) { \n        std::swap(pi,pj); // cyclic rotation of points until pk is opposite the longest side pi-pj\n        std::swap(pi,pk);  \n        longest_side = (pi - pj).norm();\n    }\n    assert( !pi.is_right(pj,pk) );\n    assert( (pi - pj).norm() >=  (pj - pk).norm() );\n    assert( (pi - pj).norm() >=  (pk - pi).norm() );\n    \n    // we now convert to a higher precision number-type to do the calculations\n    scalar_pt<Scalar> spi,spj,spk;\n    spi = pi;\n    spj = pj;\n    spk = pk;\n    Scalar J2 = (spi.y-spk.y)*( sq(spj.x-spk.x)+sq(spj.y-spk.y) )/2.0 - \n                (spj.y-spk.y)*( sq(spi.x-spk.x)+sq(spi.y-spk.y) )/2.0;\n    Scalar J3 = (spi.x-spk.x)*( sq(spj.x-spk.x)+sq(spj.y-spk.y) )/2.0 - \n                (spj.x-spk.x)*( sq(spi.x-spk.x)+sq(spi.y-spk.y) )/2.0;\n    Scalar J4 = (spi.x-spk.x)*(spj.y-spk.y) - (spj.x-spk.x)*(spi.y-spk.y);\n    assert( J4 != 0.0 );\n    if (J4==0.0) {\n        std::cout << \" PPPSolver: Warning divide-by-zero!!\\n\";\n        std::cout << \" pi = \" << pi << \"\\n\";\n        std::cout << \" pj = \" << pj << \"\\n\";\n        std::cout << \" pk = \" << pk << \"\\n\";\n        exit(-1);\n    }\n    scalar_pt<Scalar> pt( -J2/J4 + spk.x, J3/J4 + spk.y );\n    Point sln_pt = Point( pt.getx(), pt.gety());\n    double dist = (sln_pt-pi).norm();\n    slns.push_back( Solution(  sln_pt , dist , +1) );\n    return 1;\n}\n\n};\n\n} // solvers\n} // ovd\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  Idea and code for point/line/arc voronoi-vertex positioning code by\n *  Andy Payne, andy \"at\" payne \"dot\" org, November, 2010\n *  see: http://www.payne.org/index.php/Calculating_Voronoi_Nodes\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include \"../common/point.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop() determinant()\n\nnamespace ovd {\nnamespace solvers {\n    \n/// \\brief line-line-line Solver\n///\n/// solves 3x3 system.\nclass LLLSolver : public Solver {\npublic:\n\n//  a1 x + b1 y + c1 + k1 t = 0\n//  a2 x + b2 y + c2 + k2 t = 0\n//  a3 x + b3 y + c3 + k3 t = 0\n//\n// or in matrix form\n//\n//  ( a1 b1 k1 ) ( x )    ( c1 )\n//  ( a2 b2 k2 ) ( y ) = -( c2 )          Ax = b\n//  ( a3 b3 k3 ) ( t )    ( c3 )\n//\n//  Cramers rule x_i = det(A_i)/det(A)\n//  where A_i is A with column i replaced by b\n            \nint solve( Site* s1, double k1, \n           Site* s2, double k2, \n           Site* s3, double k3, std::vector<Solution>& slns ) {\n    if (debug && !silent)\n        std::cout << \"LLLSolver.\\n\";\n    \n    assert( s1->isLine() && s2->isLine() && s3->isLine() );\n    \n    std::vector< Eq<qd_real> > eq; // equation-parameters, in quad-precision\n    boost::array<Site*,3> sites = {{s1,s2,s3}};    \n    boost::array<double,3> kvals = {{k1,k2,k3}};\n    for (unsigned int i=0;i<3;i++)\n        eq.push_back( sites[i]->eqp_qd( kvals[i] ) );\n    \n    unsigned int i = 0, j=1, k=2;\n    qd_real d = chop( determinant( eq[i].a, eq[i].b, eq[i].k, \n                                            eq[j].a, eq[j].b, eq[j].k, \n                                            eq[k].a, eq[k].b, eq[k].k ) ); \n    double det_eps = 1e-6;\n    if ( fabs(d) > det_eps ) {\n        qd_real t = determinant(  eq[i].a, eq[i].b, -eq[i].c, \n                                  eq[j].a, eq[j].b, -eq[j].c, \n                                  eq[k].a, eq[k].b, -eq[k].c ) / d ; \n        if (t >= 0) {\n            qd_real sol_x = determinant(  -eq[i].c, eq[i].b, eq[i].k, \n                                          -eq[j].c, eq[j].b, eq[j].k, \n                                          -eq[k].c, eq[k].b, eq[k].k ) / d ; \n            qd_real sol_y = determinant(  eq[i].a, -eq[i].c, eq[i].k, \n                                          eq[j].a, -eq[j].c, eq[j].k, \n                                          eq[k].a, -eq[k].c, eq[k].k ) / d ; \n            if (debug && !silent ) \n                std::cout << \" solution: \" << Point( to_double(sol_x), to_double(sol_y) ) << \" t=\" << to_double(t) << \" k3=\" << k3 << \" det=\" << to_double(d) << \"\\n\";\n            \n            slns.push_back( Solution( Point( to_double(sol_x), to_double(sol_y) ), to_double(t), k3 ) ); // kk3 just passes through without any effect!?\n            return 1;\n        }\n    } else {\n        if (debug && !silent) {\n            std::cout << \"WARNING: LLLSolver small determinant! no solutions. d= \" << d <<\"\\n\";\n            std::cout << \" s1 : \" << eq[0].a << \" \" << eq[0].b << \" \" << eq[0].c << \" \" << eq[0].k << \"\\n\";\n            std::cout << \" s2 : \" << eq[1].a << \" \" << eq[1].b << \" \" << eq[1].c << \" \" << eq[1].k << \"\\n\";\n            std::cout << \" s3 : \" << eq[2].a << \" \" << eq[2].b << \" \" << eq[2].c << \" \" << eq[2].k << \"\\n\";\n            //std::cout << \" 0==1? \" << (eq[0]==eq[1]) << \"\\n\";\n            //std::cout << \"da = \" << (eq[0].a-eq[1].a) << \"\\n\";\n            //std::cout << \"db = \" << (eq[0].b-eq[1].b) << \"\\n\";\n            //std::cout << \"dc = \" << (eq[0].c-eq[1].c) << \"\\n\";\n        }\n        \n    }\n    return 0; // no solution if determinant zero, or t-value negative\n}\n\n};\n\n} // solvers\n} // ovd\n\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *\n *  This file is part of OpenVoronoi.\n * \n *  Idea and C code for point/line/arc voronoi-vertex positioning code by\n *  Andy Payne, andy \"at\" payne \"dot\" org, November, 2010\n *  see: http://www.payne.org/index.php/Calculating_Voronoi_Nodes\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n//#include <qd/qd_real.h> // http://crd.lbl.gov/~dhbailey/mpdist/\n\n#include \"solver.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop() quadratic_roots()\n\nnamespace ovd {\nnamespace solvers {\n\n \n/// \\brief quadratic-linear-linear Solver\nclass QLLSolver : public Solver {\npublic:\n\nint solve( Site* s1, double k1, \n                Site* s2, double k2, \n                Site* s3, double k3, std::vector<Solution>& slns ) {\n    if (debug && !silent) \n        std::cout << \"QLLSolver.\\n\";\n    \n    std::vector< Eq<qd_real> > quads,lins; // equation-parameters, in quad-precision\n    boost::array<Site*,3> sites = {{s1,s2,s3}};\n    boost::array<double,3> kvals = {{k1,k2,k3}};\n    \n    std::cout << \"s:\" << s1->str2() << '|' << s2->str2()<< '|' << s3->str2() <<\" \\n\";\n    std::cout << \"k:\" << k1 << '|' << k2<< '|' << k3 <<\" \\n\";\n    for (unsigned int i=0;i<3;i++) {\n        Eq<qd_real> eqn = sites[i]->eqp_qd( kvals[i] );\n        if (sites[i]->is_linear() ) // store site-equations in lins or quads\n            lins.push_back( eqn ); \n        else\n            quads.push_back( eqn );\n    }\n    std::cout << \"quad num: \" << quads.size() <<\" \\n\";\n    std::cout << \"lin num: \" << lins.size() <<\" \\n\";\n    assert( !quads.empty() );\n    \n    if ( lins.size()==1 || lins.size() == 0 ) {\n        assert( quads.size() == 3 || quads.size() == 2 );\n        for (unsigned int i=1;i<quads.size();i++) {\n            quads[i] = quads[i] - quads[0]; // subtract the first quad from the other one(s), to create new linear eqn(s)\n            lins.push_back(quads[i]);\n        }\n    }\n    \n    std::cout << \"quad: \" << quads[0] <<\" \\n\";\n    std::cout << \"lin1: \" << lins[0] <<\" \\n\";\n    std::cout << \"lin2: \" << lins[1] <<\" \\n\";\n    assert( lins.size() == 2);  // At this point, we should have exactly two linear equations.\n   \n    // TODO:  pick the solution appraoch with the best numerical stability.    \n    // call all three permutations\n    // index shuffling determines if we solve:\n    // x and y in terms of t\n    // y and t in terms of x\n    // t and x in terms of y\n    qll_solver( lins, 0, 1, 2, quads[0], k3, slns);\n    qll_solver( lins, 2, 0, 1, quads[0], k3, slns);\n    qll_solver( lins, 1, 2, 0, quads[0], k3, slns);\n    \n    BOOST_FOREACH(solvers::Solution s, slns) {\n        std::cout << \"sol: \" << s.p <<\" \\n\";\n    }\n    \n    return slns.size();\n}\n\n\nprivate:\n/// \\brief qll solver\n// l0 first linear eqn\n// l1 second linear eqn\n// xi,yi,ti  indexes to shuffle around\n// xk, yk, kk, rk = params of one ('last') quadratic site (point or arc)\n// solns = output solution triplets (x,y,t) or (u,v,t)\n// returns number of solutions found\nint qll_solver( const std::vector< Eq<qd_real> >& lins, int xi, int yi, int ti, \n      const Eq<qd_real>& quad, qd_real k3, std::vector<Solution>& solns) { \n    assert( lins.size() == 2 );\n    qd_real ai = lins[0][xi]; // first linear \n    qd_real bi = lins[0][yi];\n    qd_real ki = lins[0][ti];\n    qd_real ci = lins[0].c;\n    \n    std::cout << \" ai: \" << ai << \" bi: \" << bi << \" ki: \" << ai << \" ci: \" << ci <<\" \\n\";\n    \n    qd_real aj = lins[1][xi]; // second linear\n    qd_real bj = lins[1][yi];\n    qd_real kj = lins[1][ti];\n    qd_real cj = lins[1].c;\n    std::cout << \" aj: \" << aj << \" bj: \" << bj << \" kj: \" << kj << \" cj: \" << cj <<\" \\n\";\n    \n    qd_real d = chop( ai*bj - aj*bi ); // chop! (determinant for 2 linear eqns (?))\n    std::cout << \"qll_solver determinant : \" << d <<\" \\n\";\n    \n    if (d == 0) // no solution can be found!\n        return -1;\n    // these are the w-equations for qll_solve()\n    // (2) u = a1 w + b1\n    // (3) v = a2 w + b2\n    qd_real a0 =  (bi*kj - bj*ki) / d;\n    qd_real a1 = -(ai*kj - aj*ki) / d;\n    qd_real b0 =  (bi*cj - bj*ci) / d;\n    qd_real b1 = -(ai*cj - aj*ci) / d;\n    // based on the 'last' quadratic of (s1,s2,s3)\n    qd_real aargs[3][2];\n    aargs[0][0] = 1.0;\n    aargs[0][1] = quad.a;\n    aargs[1][0] = 1.0;\n    aargs[1][1] = quad.b;\n    aargs[2][0] = -1.0;\n    aargs[2][1] = quad.k;\n    \n    qd_real isolns[2][3];\n    // this solves for w, and returns either 0, 1, or 2 triplets of (u,v,t) in isolns\n    // NOTE: indexes of aargs shuffled depending on (xi,yi,ti) !\n    int scount = qll_solve( aargs[xi][0], aargs[xi][1],\n                            aargs[yi][0], aargs[yi][1],\n                            aargs[ti][0], aargs[ti][1],\n                            quad.c, // xk*xk + yk*yk - rk*rk,\n                            a0, b0, \n                            a1, b1, isolns);\n    double tsolns[2][3];\n    for (int i=0; i<scount; i++) {\n        tsolns[i][xi] = to_double(isolns[i][0]);       // u       x\n        tsolns[i][yi] = to_double(isolns[i][1]);       // v       y\n        tsolns[i][ti] = to_double(isolns[i][2]);       // t       t  chop!\n        solns.push_back( Solution( Point( tsolns[i][0], tsolns[i][1] ), \n                         tsolns[i][2], to_double(k3) ) );\n    }\n    //std::cout << \" k3=\"<<kk3<<\" qqq_solve found \" << scount << \" roots\\n\";\n    return scount;\n}\n\n/// Solve a system of one quadratic equation, and two linear equations.\n/// \n/// (1) a0 u^2 + b0 u + c0 v^2 + d0 v + e0 w^2 + f0 w + g0 = 0\n/// (2) u = a1 w + b1\n/// (3) v = a2 w + b2\n/// solve (1) for w (can have 0, 1, or 2 roots)\n/// then substitute into (2) and (3) to find (u, v, t)\nint qll_solve( qd_real a0, qd_real b0, qd_real c0, qd_real d0, \n                      qd_real e0, qd_real f0, qd_real g0, \n                      qd_real a1, qd_real b1, \n                      qd_real a2, qd_real b2, \n                      qd_real soln[][3])\n{\n    //std::cout << \"qll_solver()\\n\";\n    // TODO:  optimize using abs(a0) == abs(c0) == abs(d0) == 1\n    qd_real a = chop( (a0*(a1*a1) + c0*(a2*a2) + e0) ); \n    qd_real b = chop( (2*a0*a1*b1 + 2*a2*b2*c0 + a1*b0 + a2*d0 + f0) ); \n    qd_real c = a0*(b1*b1) + c0*(b2*b2) + b0*b1 + b2*d0 + g0;\n    std::vector<qd_real> roots = quadratic_roots(a, b, c); // solves a*w^2 + b*w + c = 0\n    if ( roots.empty() ) { // No roots, no solutions\n        return 0;\n    } else {\n        for (unsigned int i=0; i<roots.size(); i++) {\n            qd_real w = roots[i];\n            soln[i][0] = a1*w + b1; // u\n            soln[i][1] = a2*w + b2; // v\n            soln[i][2] = w;         // t\n        }\n        return roots.size();\n    }\n}\n\n};\n\n} // solvers\n} // ovd\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include \"../common/point.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop() determinant()\n\nnamespace ovd {\nnamespace solvers {\n    \n// this solver is called when we want to position a vertex on a SEPARATOR edge\n// a SEPARATOR edge exists between a LineSite and one of its PointSite end-points\n// the input sites are thus s1=LineSite and s2=PointSite  (if arcs are supported in the future then s1=ArcSite is possible)\n// s3 can be either a LineSite or a PointSite (of arcs are supported, s3=ArcSite is possible)\n//\n//  s1 (LineSite) offset eq. is     a1 x + b1 y + c1 + k1 t = 0   (1)\n//  s2 (PointSite) offset eq. is    (x-x2)^2 + (y-y2)^2 = t^2     (2)\n// \n// Two possibilities for s3:\n//   s3 (LineSite)   a3 x + b3 y + c3 + k3 t = 0\n//   s3 (PointSite)  (x-x3)^2 + (y-y3)^2 = t^2 \n// \n// This configuration constrains the solution to lie on the separator edge.\n// The separator is given by\n// SEP = p2 + t* sv\n// where p2 is the location of s2, and the separator direction sv is \n// sv = (-a1,-b1)   if k1=-1\n// sv = (a1,b1)   if k1=-1 \n// thus points on the separator are located at:\n//\n//  x_sep = x2 + t*sv.x\n//  y_sep = y2 + t*sv.y\n//\n//  This can be inserted into (1) or (2) above, which leads to a linear equation in t.\n//\n//  Insert into (1):\n//    a3 (x2 + t*sv.x) + b3 (y2 + t*sv.y) + c3 + k3 t = 0\n//      ==>\n//          t = -( a3*x2 + b3*y2 + c3 ) / (sv.x*a3 + sv.y*b3 + k3)\n//\n//  Insert into (2):\n//    (x2 + t*sv.x-x3)^2 + (y2 + t*sv.y-y3)^2 = t^2\n//    ==> (using dx= x2-x3 and dy = x2-x3)\n//   t^2 (sv.x^2 + sv.y^1 - 1)  + t (2*dx*sv.x + 2*dy*sv.y) + dx^2 + dy^2 = 0\n//    ==>  (since sv is a unit-vector sv.x^2 + sv.y^1 - 1 = 0)\n//         t = - (dx^2+dy^2) / (2*(dx*sv.x + dy*sv.y))\n//\n//  FIXME: what happens if we get a divide by zero situation ??\n//\n\n/// \\brief ::SEPARATOR Solver\nclass SEPSolver : public Solver {\npublic:\n\nint solve( Site* s1, double k1, \n           Site* s2, double k2, \n           Site* s3, double k3, std::vector<Solution>& slns ) {\n    assert( s1->isLine() && s2->isPoint() );\n    assert(s3->isLine());\n    if (debug) \n        std::cout << \"SEPSolver.\\n\";\n    \n    // separator direction\n    Point sv(-s1->a(),-s1->b());\n    if (debug) std::cout << \" SEPSolver sv= \"<< sv << \"\\n\";\n    \n    double tsln = -(s3->a()*s2->x()+s3->b()*s2->y()+s3->c()) / ( sv.x*s3->a() + sv.y*s3->b() + k3  );\n\n    Point psln = Point(s2->x(), s2->y() ) + tsln * sv;\n    slns.push_back( Solution( psln, tsln, k3 ) );\n    return 1;\n}\n\n};\n\n} // solvers\n} // ovd\n","/*  \n *  Copyright 2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include \"../common/point.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop() determinant()\n\nnamespace ovd {\nnamespace solvers {\n    \n// this solver is called when we want to position a vertex on a SEPARATOR edge\n// a SEPARATOR edge exists between a LineSite and one of its PointSite end-points\n// the input sites are thus s1=LineSite and s2=PointSite  (if arcs are supported in the future then s1=ArcSite is possible)\n// s3 can be either a LineSite or a PointSite (of arcs are supported, s3=ArcSite is possible)\n//\n//  s1 (LineSite) offset eq. is     a1 x + b1 y + c1 + k1 t = 0   \n//  s2 (PointSite) offset eq. is    (x-x2)^2 + (y-y2)^2 = t^2     \n// \n// Two possibilities for s3:\n//   s3 (LineSite)   a3 x + b3 y + c3 + k3 t = 0           (1)\n//   s3 (PointSite)  (x-x3)^2 + (y-y3)^2 = t^2             (2)\n// \n// This configuration constrains the solution to lie on the separator edge.\n// The separator is given by\n// SEP = p2 + t* sv\n// where p2 is the location of s2, and the separator direction sv is \n// sv = (-a1,-b1)   if k1=-1\n// sv = (a1,b1)   if k1=+1 \n// thus points on the separator are located at:\n//\n//  x_sep = x2 + t*sv.x\n//  y_sep = y2 + t*sv.y\n//\n//  This can be inserted into (1) or (2) above, which leads to a linear equation in t.\n//\n//  Insert into (1):\n//    a3 (x2 + t*sv.x) + b3 (y2 + t*sv.y) + c3 + k3 t = 0\n//      ==>\n//          t = -( a3*x2 + b3*y2 + c3 ) / (sv.x*a3 + sv.y*b3 + k3)\n//\n//  Insert into (2):\n//    (x2 + t*sv.x-x3)^2 + (y2 + t*sv.y-y3)^2 = t^2\n//    ==> (using dx= x2-x3 and dy = x2-x3)\n//   t^2 (sv.x^2 + sv.y^1 - 1)  + t (2*dx*sv.x + 2*dy*sv.y) + dx^2 + dy^2 = 0\n//    ==>  (since sv is a unit-vector sv.x^2 + sv.y^1 - 1 = 0)\n//         t = - (dx^2+dy^2) / (2*(dx*sv.x + dy*sv.y))\n//\n//  FIXME: what happens if we get a divide by zero situation ??\n//\n/// \\brief alternative ::SEPARATOR Solver\nclass ALTSEPSolver : public Solver {\npublic:\n//virtual void set_type(int t) {type=t;}\nint solve( Site* s1, double k1, \n           Site* s2, double k2, \n           Site* s3, double k3, std::vector<Solution>& slns ) {\n    if (debug && !silent) \n        std::cout << \"ALTSEPSolver.\\n\";\n    Site* lsite;\n    Site* psite;\n    Site* third_site;\n    double lsite_k,  third_site_k;\n    \n    if ( type == 0 ) {\n        lsite = s3; lsite_k = k3;\n        psite = s1; // psite_k = k1;    l3 / p1 form a separator\n        third_site = s2;      third_site_k = 1;\n    } else if ( type == 1 ) {\n        lsite = s3; lsite_k = k3;\n        psite = s2; // psite_k = k2;    l3 / p2 form a separator\n        third_site = s1; third_site_k = 1; \n    } else {\n        std::cout << \"ALTSEPSolver FATAL ERROR! type not known.\\n\";\n        exit(-1);\n        return 0;\n    }\n    // separator direction\n    Point sv = (k3 == - 1) ? Point(lsite->a(),lsite->b()) : Point(-lsite->a(),-lsite->b());\n    \n    if (debug && !silent) {\n        std::cout << \"ALTSEPSolver type=\"<< type <<\"\\n\";\n        std::cout << \" s1= \" << s1->str2() << \"(k=\" << k1<< \")\\n\";\n        std::cout << \" s2= \" << s2->str2() << \"(k=\" << k2<< \")\\n\";\n        std::cout << \" s3= \" << s3->str2() << \"(k=\" << k3<< \")\\n\";\n        std::cout << \" lsite_k=\" << lsite_k << \"\\n\";\n        std::cout << \" sv= \" << sv << \"\\n\";\n    }\n\n    \n    // now we should have this:\n    assert( lsite->isLine() && psite->isPoint() );\n\n    double tsln(0);\n\n    if ( third_site->isPoint() ) {\n        double dx = psite->x() - third_site->x();\n        double dy = psite->y() - third_site->y();\n        if ( fabs(2*( dx*sv.x+dy*sv.y  )) > 0 ) {\n            tsln = -(dx*dx+dy*dy) / (2*( dx*sv.x+dy*sv.y  )); // check for divide-by-zero?\n        } else {\n            //std::cout << \" no solutions. (isPoint)\\n\";\n            return 0;\n        }\n    } else if (third_site->isLine()) {\n        if ( fabs(( sv.x*third_site->a() + sv.y*third_site->b() + third_site_k )) > 0 ) {\n            tsln = -(third_site->a()*psite->x()+third_site->b()*psite->y()+third_site->c()) / \n                ( sv.x*third_site->a() + sv.y*third_site->b() + third_site_k );\n        } else {\n            //std::cout << \" no solutions. (isLine)\\n\";\n            return 0;\n        }\n    } else {\n        assert(0);\n        exit(-1);\n    }\n    Point psln = Point(psite->x(), psite->y() ) + tsln * sv;\n    slns.push_back( Solution( psln, tsln, k3 ) );\n    return 1;\n}\n\n};\n\n} // solvers\n} // ovd\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \n *  Idea and code for point/line/arc voronoi-vertex positioning code by\n *  Andy Payne, andy \"at\" payne \"dot\" org, November, 2010\n *  see: http://www.payne.org/index.php/Calculating_Voronoi_Nodes\n * \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include \"../common/point.hpp\"\n#include \"../common/numeric.hpp\"\n\nusing namespace ovd::numeric; // sq() chop() determinant()\n\nnamespace ovd {\nnamespace solvers {\n    \n/// \\brief line-line-line Solver (parallel line-segment case)\n///\n/// solves 3x3 system.\nclass LLLPARASolver : public Solver {\npublic:\n\n// parallel linesegment edge case.\n//  a1 x + b1 y + c1 + k1 t = 0\n//  a2 x + b2 y + c2 + k2 t = 0\n//  a3 x + b3 y + c3 + k3 t = 0\n//\n// s1 and s2 are parallel, so they have a PARA_LINELINE edge between them\n//\n// this constrains the solution to lie on a line parallel to s1/s2\n// passing through a point equidistant from s1/s2\n// \n// equation of bisector is:\n// ab x + bb y + cb = 0\n// ab = a1\n// bb = b1\n// cb = (c1+c2)2\n// all points on the bisector have a t value\n// tb = fabs(c1-c2)/2\n//\n// find intersection of bisector and offset of third site\n//  ab x + bb y + cb = 0\n//  a3 x + b3 y + c3 + k3 tb = 0\n//  or\n//  ( ab  bb ) ( x ) = ( -cb )\n//  ( a3  b3 ) ( y ) = ( -c3-k3*tb )\n//\n\n\nint solve( Site* s1, double k1, \n           Site* s2, double k2, \n           Site* s3, double k3, std::vector<Solution>& slns ) {\n    if (debug)\n        std::cout << \"LLLPARASolver.\\n\";    \n    assert( s1->isLine() && s2->isLine() && s3->isLine() );\n    \n    Eq<double> bis;\n    bis.a = s1->a();\n    bis.b = s1->b();\n    double s2c = s2->c();\n    // if s1 and s2 have opposite (a,b) normals, flip the sign of s2c\n    if ( Point(s1->a(),s1->b()) == -1*Point(s2->a(),s2->b()) ) {\n        s2c = -s2c;\n    }\n    \n    bis.c = (s1->c() + s2c)/2;\n    double tb = fabs( (s1->c() - s2c )/2 ); // bisector offset distance\n    \n    if (debug) {\n        std::cout << \" s1 : \" << s1->a() << \" \" << s1->b() << \" \" << s1->c() << \" \" << s1->k() << \"\\n\";\n        std::cout << \" s2 : \" << s2->a() << \" \" << s2->b() << \" \" << s2->c() << \" \" << s2->k() << \"\\n\";\n        if ( s3->isLine() )\n            std::cout << \" s3 : \" << s3->a() << \" \" << s3->b() << \" \" << s3->c() << \" \" << s3->k() << \"\\n\";\n        std::cout << \" bis: \" << bis.a << \" \" << bis.b << \" \" << bis.c << \" \\n\";\n    }\n    //if ( s3->isLine() ) {\n        double x,y;\n        if ( two_by_two_solver(bis.a, bis.b, s3->a(), s3->b(), -bis.c, -s3->c()-k3*tb, x,y) ) {\n            if (debug) std::cout << \" Solution: t=\" << tb << \" \" << Point( x, y ) << \" k3=\" << k3 << \" \\n\";\n            slns.push_back( Solution( Point( x, y ) , tb, k3 ) ); \n            return 1;\n        } else {\n            if (debug) std::cout << \"LLLPARASolver. NO Solution!\\n\";    \n            return 0;\n        }\n    //}\n    /*\n    if ( s3->isArc() ) {\n        // bisector ax + by + c = 0\n        // all points are at offset tb from s1 and s2\n        // find a point on the bisector which is also a distance tb from the circle\n        // this point is a distance r+tb from the circle center (?)\n        circle_line_intersection(bis.a, bis.b, bis.c, s3->x(), s3->y(), s3->r(), tb,slns);\n        return 1;\n    }*/\n    return 0;\n}\n\nprivate:\n/*\nvoid circle_line_intersection(double a, double b, double c, \n         double cx, double cy, double r, double tb, std::vector<Solution>& slns) {\n    // line ax+by+c = 0\n    // circle (cx,cy) radius r\n}*/\n    \n/// solve 2z2 system Ax = y by inverting A\n/// x = Ainv * y\n/// returns false if det(A)==0, i.e. no solution found\nbool two_by_two_solver( double a, \n                        double b, \n                        double c,\n                        double d,\n                        double e,\n                        double f,\n                        double& u,\n                        double& v) {\n    //  [ a  b ] [u] = [ e ]\n    //  [ c  d ] [v] = [ f ]\n    // matrix inverse is\n    //          [ d  -b ]\n    //  1/det * [ -c  a ]\n    //  so\n    //  [u]              [ d  -b ] [ e ]\n    //  [v]  =  1/det *  [ -c  a ] [ f ]\n    double det = a*d-c*b;\n    if ( fabs(det) < 1e-15 ) // TOLERANCE!!\n        return false;\n    u = (1.0/det) * (d*e - b*f);\n    v = (1.0/det) * (-c*e + a*f);\n    return true;\n}\n\n};\n\n} // solvers\n} // ovd\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *\n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include \"../common/point.hpp\"\n\nnamespace ovd {\nnamespace solvers {\n    \n/// \\brief a new vertex position solution (position, offset-distance, side)\n///\n/// includes the offset-distamce t, and the offset direction k3\nstruct Solution {\n    /// \\param pt vertex position\n    /// \\param tv clearance-disk radius\n    /// \\param k offset direction\n    Solution(Point pt, double tv, double k) : p(pt), t(tv), k3(k) {}\n    /// position\n    Point p;\n    /// clearance-disk radius\n    double t;\n    /// offfset direction to third adjacent Site\n    double k3;\n};\n\n} // solvers\n} //end ovd namespace\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *\n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n//#include <qd/qd_real.h> // http://crd.lbl.gov/~dhbailey/mpdist/\n\n#include \"graph.hpp\"\n#include \"vertex.hpp\"\n#include \"solvers/solution.hpp\"\n\nnamespace ovd {\n\nnamespace solvers {\nclass Solver; // fwd decl\n}\n\n/// Calculates the (x,y) position of a VoronoiVertex in the VoronoiDiagram\nclass VertexPositioner {\npublic:\n    VertexPositioner(HEGraph& gi);\n    virtual ~VertexPositioner();\n    solvers::Solution position( HEEdge e, Site* s);\n    /// return vector of errors\n    std::vector<double> get_stat() {return errstat;}\n    double dist_error(HEEdge e, const solvers::Solution& sl, Site* s3);\n    void solver_debug(bool b);\n    void set_silent(bool b); ///< no warning messages when silent==true\nprivate:\n\n    /// predicate for rejecting out-of-region solutions\n    struct in_region_filter {\n        /// \\param s Site for in_region check\n        in_region_filter(Site* s): site_(s) {}\n        /// is Solution \\a s in_region of Site \\a site_ ?\n        bool operator()(solvers::Solution s) { \n            return !site_->in_region(s.p); \n        }\n        /// the Site\n        Site* site_;\n    };\n    /// predicate for filtering solutions based on t-value in [tmin,tmax] range\n    struct t_filter {\n        /// create filter for [tmin,tmax]\n        t_filter(double tmin, double tmax): tmin_(tmin),tmax_(tmax) {}\n        /// is the given Solution \\a s in the offset-distance interval [tmin,tmax] ?\n        bool operator()(solvers::Solution s) { \n            double eps=1e-9;\n            double tround=s.t;\n            if ( fabs(s.t-tmin_) < eps )\n                tround=tmin_;\n            else if (fabs(s.t-tmax_)<eps)\n                tround=tmax_;\n            return (tround<tmin_) || (tround>tmax_); // these points rejected!\n        }\n        /// minimum offset-distance value\n        double tmin_;\n        /// maximum offset-distance value\n        double tmax_;\n    };\n\n    solvers::Solution position(Site* s1, double k1, Site* s2, double k2, Site* s3);\n    int solver_dispatch(Site* s1, double k1, \n               Site* s2, double k2, \n               Site* s3, double k3, std::vector<solvers::Solution>& slns ); \n    bool detect_sep_case(Site* lsite, Site* psite);\n\n// solution-filtering\n    double edge_error(solvers::Solution& sl);\n    Point projection_point(solvers::Solution& sl);\n// geometry-checks\n    bool solution_on_edge(solvers::Solution& s);\n    bool check_far_circle(solvers::Solution& s);\n    bool check_dist(HEEdge e, const solvers::Solution& s, Site* s3);\n    bool equal(double d1, double d2);\n    \n    solvers::Solution desperate_solution(Site* s3);\n\n// solvers, to which we dispatch, depending on the input sites\n    \n    solvers::Solver* ppp_solver; ///< point-point-point solver\n    solvers::Solver* lll_solver; ///< line-line-line solver\n    solvers::Solver* lll_para_solver; ///< solver\n    solvers::Solver* qll_solver; ///< solver\n    solvers::Solver* sep_solver; ///< separator solver\n    solvers::Solver* alt_sep_solver; ///< alternative separator solver\n// DATA\n    HEGraph& g;  ///< reference to the VD graph.\n    double t_min; ///< minimum offset-distance\n    double t_max; ///< maximum offset-distance\n    HEEdge edge;  ///< the edge on which we position a new vertex\n    std::vector<double> errstat; ///< error-statistics\n    bool silent; ///< silent mode (outputs no warnings to stdout)\n};\n\n/// \\brief error functor for edge-based desperate solver\n///\n/// minimize error by searching for a point on the solution-edge\nclass VertexError {\npublic:\n    /// \\param gi vd-graph\n    /// \\param sln_edge solution edge\n    /// \\param si3 newly inserted Site\n    VertexError(HEGraph& gi, HEEdge sln_edge, Site* si3) :\n    g(gi),  edge(sln_edge), s3(si3)\n    {}\n    /// return the vertex-error t-d3 where\n    /// t3 is the distance from edge-point(t) to s3, and\n    /// t is the offset-distance of the solution\n    double operator()(const double t) {\n        Point p = edge_point(t);\n        double s3_dist = (p - s3->apex_point(p)).norm();\n        return fabs(t-s3_dist);\n    }\n    /// return a point on the edge at given offset-distance\n    /// \\param t offset-distance ( >= 0 )\n    Point edge_point(const double t) {\n        Point p;\n        if ( g[edge].type == LINELINE ) { // this is a workaround because the LINELINE edge-parameters are wrong? at least in some cases?\n            HEVertex src = g.source(edge);\n            HEVertex trg = g.target(edge);\n            Point src_p = g[src].position;\n            Point trg_p = g[trg].position;\n            double src_t = g[src].dist();\n            double trg_t = g[trg].dist();\n            // edge is src_p -> trg_p\n            if ( trg_t > src_t ) {\n                double frac = (t-src_t) / (trg_t-src_t);\n                p = src_p + frac*(trg_p-src_p);\n            } else {\n                double frac = (t-trg_t) / (src_t-trg_t);\n                p = trg_p + frac*(src_p-trg_p);\n            }\n            \n        } else\n            p = g[edge].point(t);\n        return p;\n    }\nprivate:\n    HEGraph& g; ///< vd-graph\n    HEEdge edge; ///< existing edge on which we have positioned a new vertex\n    Site* s3; ///< newly inserted Site\n};\n\n}\n\n","//  (C) Copyright John Maddock 2006.\n//  Use, modification and distribution are subject to the\n//  Boost Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n\n#ifndef BOOST_MATH_TOOLS_MINIMA_HPP\n#define BOOST_MATH_TOOLS_MINIMA_HPP\n\n#ifdef _MSC_VER\n#pragma once\n#endif\n\n#include <utility>\n#include <boost/config/no_tr1/cmath.hpp>\n#include <boost/math/tools/precision.hpp>\n#include <boost/math/policies/policy.hpp>\n#include <boost/cstdint.hpp>\n\nnamespace boost{ namespace math{ namespace tools{\n\ntemplate <class F, class T>\nstd::pair<T, T> brent_find_minima(F f, T min, T max, int bits, boost::uintmax_t& max_iter)\n{\n   BOOST_MATH_STD_USING\n   bits = (std::min)(policies::digits<T, policies::policy<> >() / 2, bits);\n   T tolerance = static_cast<T>(ldexp(1.0, 1-bits));\n   T x;  // minima so far\n   T w;  // second best point\n   T v;  // previous value of w\n   T u;  // most recent evaluation point\n   T delta;  // The distance moved in the last step\n   T delta2; // The distance moved in the step before last\n   T fu, fv, fw, fx;  // function evaluations at u, v, w, x\n   T mid; // midpoint of min and max\n   T fract1, fract2;  // minimal relative movement in x\n\n   static const T golden = 0.3819660f;  // golden ratio, don't need too much precision here!\n\n   x = w = v = max;\n   fw = fv = fx = f(x);\n   delta2 = delta = 0;\n\n   uintmax_t count = max_iter;\n\n   do{\n      // get midpoint\n      mid = (min + max) / 2;\n      // work out if we're done already:\n      fract1 = tolerance * fabs(x) + tolerance / 4;\n      fract2 = 2 * fract1;\n      if(fabs(x - mid) <= (fract2 - (max - min) / 2))\n         break;\n\n      if(fabs(delta2) > fract1)\n      {\n         // try and construct a parabolic fit:\n         T r = (x - w) * (fx - fv);\n         T q = (x - v) * (fx - fw);\n         T p = (x - v) * q - (x - w) * r;\n         q = 2 * (q - r);\n         if(q > 0)\n            p = -p;\n         q = fabs(q);\n         T td = delta2;\n         delta2 = delta;\n         // determine whether a parabolic step is acceptible or not:\n         if((fabs(p) >= fabs(q * td / 2)) || (p <= q * (min - x)) || (p >= q * (max - x)))\n         {\n            // nope, try golden section instead\n            delta2 = (x >= mid) ? min - x : max - x;\n            delta = golden * delta2;\n         }\n         else\n         {\n            // whew, parabolic fit:\n            delta = p / q;\n            u = x + delta;\n            if(((u - min) < fract2) || ((max- u) < fract2))\n               delta = (mid - x) < 0 ? (T)-fabs(fract1) : (T)fabs(fract1);\n         }\n      }\n      else\n      {\n         // golden section:\n         delta2 = (x >= mid) ? min - x : max - x;\n         delta = golden * delta2;\n      }\n      // update current position:\n      u = (fabs(delta) >= fract1) ? T(x + delta) : (delta > 0 ? T(x + fabs(fract1)) : T(x - fabs(fract1)));\n      fu = f(u);\n      if(fu <= fx)\n      {\n         // good new point is an improvement!\n         // update brackets:\n         if(u >= x)\n            min = x;\n         else\n            max = x;\n         // update control points:\n         v = w;\n         w = x;\n         x = u;\n         fv = fw;\n         fw = fx;\n         fx = fu;\n      }\n      else\n      {\n         // Oh dear, point u is worse than what we have already,\n         // even so it *must* be better than one of our endpoints:\n         if(u < x)\n            min = u;\n         else\n            max = u;\n         if((fu <= fw) || (w == x))\n         {\n            // however it is at least second best:\n            v = w;\n            w = u;\n            fv = fw;\n            fw = fu;\n         }\n         else if((fu <= fv) || (v == x) || (v == w))\n         {\n            // third best:\n            v = u;\n            fv = fu;\n         }\n      }\n\n   }while(--count);\n\n   max_iter -= count;\n\n   return std::make_pair(x, fx);\n}\n\ntemplate <class F, class T>\ninline std::pair<T, T> brent_find_minima(F f, T min, T max, int digits)\n{\n   boost::uintmax_t m = (std::numeric_limits<boost::uintmax_t>::max)();\n   return brent_find_minima(f, min, max, digits, m);\n}\n\n}}} // namespaces\n\n#endif\n\n\n\n\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *\n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\nnamespace ovd {\n\nclass Site;\n    \nnamespace solvers {\n/*! \n * \\namespace ovd::solvers\n * \\brief Voronoi vertex position solvers\n */\n\n/// \\brief abstract base-class for voronoi vertex position solvers\n///\n/// The input to the solver is three Sites (s1,s2,s3) and three offset-directions (k1,k2,k3).\n/// The optput is a vector with one or more Solution.\nclass Solver {\npublic:\n    /// virtual dtor required for correct destruction of derived classes\n    virtual ~Solver() { }\n    \n    /// \\brief solve for position of VoronoiVertex with given adjacent sites and directions\n    ///\n    /// \\param s1 first adjacent Site\n    /// \\param k1 direction from \\a s1 to new VoronoiVertex\n    /// \\param s2 second adjacent Site\n    /// \\param k2 direction from \\a s2 to new VoronoiVertex\n    /// \\param s3 third adjacent Site\n    /// \\param k3 direction from \\a s3 to new VoronoiVertex\n    /// \\param slns Solution vector, will be updated by Solver\n    virtual int solve(Site* s1, double k1, \n                           Site* s2, double k2, \n                           Site* s3, double k3, std::vector<Solution>& slns ) =0;\n\n    /// used by alt_sep_solver\n    virtual void set_type(int t) {type=t;}\n    /// set the debug mode to \\a b\n    void set_debug(bool b) {debug=b;}\n    /// no warnings/messages to stdout will be written, if silent is set true.\n    void set_silent(bool b) {silent=b;}\nprotected:\n    /// flag for debug output\n    bool debug;\n    /// separator case type.\n    /// - type = 0 means l3 / p1 form a separator\n    /// - type = 1 means l3 / p2 form a separator\n    int  type;\n    bool silent; ///< suppress all warnings or other stdout output\n};\n\n} // solvers\n} //end ovd namespace\n","/* \n *  Copyright 2011-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n// notes from the Okabe-Boots-Sugihara book, page 171->:\n/* \n * Distance-function.\n * R1 - region of endpoint pi1\n * R2 - region of endpoint pi2\n * R3 - region of line-segment Li\n *               dist(p,pi1) if  p in R1\n * dist(p,Li) =  dist(p,pi2) if  p in R2\n *               dist(p,Li)  if p in R3\n * \n * dist(p,Li) = distance from p to L, along perpendicular line to L\n * \n * = norm(  (x-xi1)   -  dotprod( (x-xi1), (xi2-xi1) ) / ( norm_sq(xi2-xi1) ) * (xi2,xi1) )\n * \n * \n * \n * Vertex - LineSegment\n * Bisectors:\n *  B1: point-point: line\n *  B2: point-line: parabola\n *  B3: line-line: line\n * \n *  Voronoi Edges:\n *  E1: point pi - point pj. straight line bisecting pi-pj\n *  E2: edge generated by line-segment L's endpoint pi. perpendicular to L, passing through pi\n *  E3: point pi - segment Lj. dist(E3, p) == dist(E3,Lj). Parabolic arc\n *  E4: line Li - Line Lj. straight line bisector\n *  (G): generator segment edge\n * \n *  Voronoi vertices (see p177 of Okabe book):\n *  V1: generators(pi, pj, pk). edges(E1, E1, E1)\n *     - compute using detH. This is also the circumcenter of the pi,pj,pk triangle\n *  V2: generators(pi, Lj, pj1) point, segment, segment's endpoint. edges(E1, E2, E3)   E1 and E3 are tangent at V2\n *     - ? compute by mirroring pi in the separator and use detH\n *  V3: generators(Li, pj, pk) edges(E1, E3, E3)   E3-edges have common directrix(Li)\n *  V4: generators(Li, Lj, pi1)  edges(E2, E3, E4)  E3-E4 tangent at V4\n *  V5: generators(pi, Lj, Lk) edges (E3, E3, E4)\n *  V6: generators(Li, Lj, Lk) edges(E4, E4, E4)\n *    - this is the incenter of a incircle inscribed by triangle Li,Lj,Lk (or sometiems excenter of excircle if V6 outside triangle?)\n *    - The Cartesian coordinates of the incenter are a weighted average of the coordinates of the three vertices using the side \n *       lengths of the triangle as weights. (The weights are positive so the incenter lies inside the triangle as stated above.) \n *      If the three vertices are located at (xa,ya), (xb,yb), and (xc,yc), and the sides opposite these vertices have corresponding \n *      lengths a, b, and c, then the incenter is at   \n *      (a x_a + b x_b + c x_c)/ (a+b+c) \n * \n * bisector formulas\n * x = x1 - x2 - x3*t +/- x4 * sqrt( square(x5+x6*t) - square(x7+x8*t) )\n * (same formula for y-coordinate)\n * line (line/line)\n * parabola (circle/line)\n * hyperbola (circle/circle)\n * ellipse (circle/circle)\n * \n * line: a1*x + b1*y + c + k*t = 0  (t is amount of offset) k=+1 offset left of line, k=-1 right of line\n * with a*a + b*b = 1\n * \n * circle: square(x-xc) + square(y-yc) = square(r+k*t)  k=+1 for enlarging circle, k=-1 shrinking\n */\n \n\n#pragma once\n\n#include <boost/graph/adjacency_list.hpp>\n\n\n//#include <qd/qd_real.h>\n#include <sstream>\n\n#include \"common/point.hpp\"\n#include \"common/numeric.hpp\"\n\nnamespace ovd {\n\n#define OUT_EDGE_CONTAINER boost::listS \n#define VERTEX_CONTAINER boost::listS\n#define EDGE_LIST_CONTAINER boost::listS\n\n// type of edge-descriptors in the graph\n// FIXME, we whould really define these only once, somewhere else..\ntypedef boost::adjacency_list_traits<OUT_EDGE_CONTAINER, \n                                     VERTEX_CONTAINER, \n                                     boost::bidirectionalS, \n                                     EDGE_LIST_CONTAINER >::edge_descriptor HEEdge;\ntypedef boost::adjacency_list_traits<OUT_EDGE_CONTAINER, \n                                     VERTEX_CONTAINER, \n                                     boost::bidirectionalS, \n                                     EDGE_LIST_CONTAINER >::vertex_descriptor HEVertex;                                     \n\n/// \\brief Offset equation parameters of a Site\n///\n/// the offset in direction k by a distance t of a general site (point,line,circle) can be expressed as\n/// q ( x*x + y*y - t*t ) + a x + b y + c + k t = 0\n/// the parameters (q,a,b,k,c) are set as:\n/// line:   (0,   a,   b,    k, c          )    line ax+by+c=0  where a*a+b*b=1\n/// circle: (1, -2x, -2y, -2kr, x*x+y*y-r*r)    circle center at (x,y) and radius r\n/// point:  (1, -2x, -2y,    0, x*x+y*y    )    point at (x,y)\ntemplate<class Scalar>\nstruct Eq {\n    \n    bool q; ///< true for quadratic, false for linear\n    Scalar a; ///< a parameter of line-equation\n    Scalar b; ///< b parameter of line equation\n    Scalar c; ///< c parameter of line equation\n    Scalar k; ///< offset direction parameter\n    \n    /// default ctor\n    Eq<Scalar>() {\n        a = Scalar(0);\n        b = Scalar(0);\n        c = Scalar(0);\n        k = Scalar(0);\n        q = false;\n    }\n    /// assignment\n    template<class Scalar2>\n    Eq<Scalar>& operator=(const Eq<Scalar2>& other) {\n        q = other.q;\n        a = other.a;\n        b = other.b;\n        c = other.c;\n        k = other.k;\n        return *this;\n    }\n    /// subtract two equations from eachother\n    Eq<Scalar>& operator-=(const Eq<Scalar>& other) {\n        a-=other.a;\n        b-=other.b;\n        c-=other.c;\n        k-=other.k;\n        return *this;\n    }\n    /// subtraction\n    const Eq<Scalar> operator-(const Eq<Scalar>& other) const {\n        return Eq<Scalar>(*this) -= other;\n    }\n    \n    /// equality\n    template <class TScalar>\n    bool operator==(const Eq<TScalar>& other) {\n        return ( a==other.a && b==other.b && c==other.c );\n    }\n    /// access parameters through operator[]\n    Scalar operator[](int idx) const {\n        switch (idx) {\n            case 0:\n                return a;\n            case 1:\n                return b;\n            case 2:\n                return k;\n            default:\n                assert(0);\n                return Scalar(0);\n        }\n    }\n    friend std::ostream& operator<<(std::ostream &stream, const Eq &eq) {\n        stream << \"q = \" << eq.q << \" a = \" << eq.a << \" b = \" << eq.b << \" c = \" << eq.c << \" k = \" << eq.k;\n        return stream;\n\n    }\n};\n\n/// \\brief base-class for offset-elements\n///\n/// preliminary offset-prerensentations. experiental...\nclass Ofs {\npublic:\n    /// string\n    virtual std::string str() = 0;\n    /// radius, -1 if line\n    virtual double radius() = 0; // {return -1;}\n    /// center (for arc)\n    virtual Point center() =0; //{return Point(0,0);}\n    /// start point\n    virtual Point start() =0;//{return Point(0,0);}\n    /// end point\n    virtual Point end() =0; //{return Point(0,0);}\n};\n/// \\brief offset-element of LineSite\nclass LineOfs : public Ofs {\npublic:\n    /// \\param p1 start point\n    /// \\param p2 end point\n    LineOfs(Point p1, Point p2) : _start(p1), _end(p2) {}\n    virtual std::string str() {\n        std::ostringstream o;\n        o << \"LineOfs from:\"<<_start<<\" to \" << _end << \"\\n\";\n        return o.str();        \n    }\n    virtual double radius()  {return -1;}\n    virtual Point center() {return Point(0,0);}\n    virtual Point start() {return _start;}\n    virtual Point end() {return _end;}\nprotected:\n    Point _start; ///< start point\n    Point _end;  ///< end point\n};\n/// \\brief offset-element of PointSite or ArcSite\nclass ArcOfs : public Ofs {\npublic:\n    /// \\param p1 start Point\n    /// \\param p2 end Point\n    /// \\param cen center Point\n    /// \\param rad radius\n    ArcOfs(Point p1, Point p2, Point cen, double rad) : _start(p1), _end(p2), c(cen), r(rad) {}\n    virtual std::string str() {\n        std::ostringstream o;\n        o << \"ArcOfs  from:\"<<_start<<\" to \" << _end << \" r=\"<<r<<\"\\n\";\n        return o.str();\n    }\n    virtual double radius() {return r;}\n    virtual Point center() {return c;}\n    virtual Point start() {return _start;}\n    virtual Point end() {return _end;}\nprotected:\n    Point _start; ///< start\n    Point _end;   ///< end\n    Point c;      ///< center\n    double r;     ///< radius\n};\n\n/// Base-class for a voronoi-diagram site, or generator.\nclass Site {\npublic:\n    /// ctor\n    Site() {}\n    /// dtor\n    virtual ~Site() {}\n    /// return closest point on site to given point p\n    virtual Point apex_point(const Point& p) = 0;\n    /// return offset of site\n    virtual Ofs* offset(Point, Point) = 0;\n    /// position of site for PointSite\n    inline virtual const Point position() const {assert(0); return Point(0,0);}\n    /// start point of site (for LineSite and ArcSite)\n    virtual const Point start() const {assert(0); return Point(0,0);}\n    /// end point of site (for LineSite and ArcSite)\n    virtual const Point end() const {assert(0); return Point(0,0);}\n    /// return equation parameters\n    Eq<double> eqp() {return eq;} \n    /// return equation parameters\n    Eq<double> eqp(double kk) {\n        Eq<double> eq2(eq);\n        eq2.k *= kk;\n        return eq2;\n    } \n    /// return equation parameters\n    Eq<qd_real> eqp_qd(double kk) const {\n        Eq<qd_real> eq2;\n        eq2=eq;\n        eq2.k *= kk;\n        return eq2;\n    }\n    /// true for LineSite\n    bool is_linear() {return isLine(); }\n    /// true for PointSite and ArcSite\n    bool is_quadratic() {return isPoint();}\n    /// x position\n    virtual double x() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// y position\n    virtual double y() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// radius (zero for PointSite)\n    virtual double r() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// offset direction\n    virtual double k() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// LineSite a parameter\n    virtual double a() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// LineSite b parameter\n    virtual double b() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n    /// LineSite c parameter\n    virtual double c() const {\n        std::cout << \" WARNING: never call Site !\\n\";\n        assert(0); \n        return 0;\n    }\n\n    /// string output\n    virtual std::string str() const =0; //{assert(0); return \"Site\";}\n    /// alternative string output\n    virtual std::string str2() const =0; //{assert(0); return \"Site\";}\n    /// true for PointSite\n    inline virtual bool isPoint() const { return false;}\n    /// true for LineSite\n    inline virtual bool isLine() const  { return false;}\n    /// true for ArcSite\n    inline virtual bool isArc() const  { return false;}\n    /// true for CW oriented ArcSite\n    virtual bool cw() {return false;}\n    /// is given Point in_region ?\n    virtual bool in_region(const Point& ) const =0; \n    /*{\n        std::cout << \" WARNING: never call Site !\\n\";\n        return false;\n    }*/\n    /// is given Point in region?\n    virtual double in_region_t(const Point& ) const { std::cout << \" WARNING: never call Site !\\n\"; return 0; } \n    /// in-region t-valye\n    virtual double in_region_t_raw(const Point&) const { assert(0); return -99; }\n    /// return edge (if this is a LineSite or ArcSite\n    virtual HEEdge edge() {return HEEdge();}\n    /// return vertex, if this is a PointSite\n    virtual HEVertex vertex() {\n        std::cout << \" DON'T call Site::vertex() !! \\n\";\n        exit(-1); \n        return HEVertex();\n    }\n    /// face descriptor type\n    typedef unsigned int HEFace;\n    /// the HEFace of this Site\n    HEFace face;\nprotected:\n    /// equation parameters\n    Eq<double> eq;\n};\n\n/// vertex Site\nclass PointSite : public Site {\npublic:\n    /// ctor\n    PointSite( const Point& p, HEFace f=0): _p(p)  {\n        face = f;\n        eq.q = true;\n        eq.a = -2*p.x;\n        eq.b = -2*p.y;\n        eq.k = 0;\n        eq.c = p.x*p.x + p.y*p.y;\n    }\n    /// ctor\n    PointSite( const Point& p, HEFace f, HEVertex vert):  v(vert), _p(p) {\n        face = f;\n        eq.q = true;\n        eq.a = -2*p.x;\n        eq.b = -2*p.y;\n        eq.k = 0;\n        eq.c = p.x*p.x + p.y*p.y;\n    }\n    ~PointSite() {}\n    virtual Point apex_point(const Point& ) { return _p; }\n    virtual Ofs* offset(Point p1,Point p2) {\n        double rad = (p1-_p).norm();\n        return new ArcOfs(p1, p2, _p, rad); \n    }\n    inline virtual const Point position() const { return _p; }\n    virtual double x() const {return _p.x;}\n    virtual double y() const {return _p.y;}\n    virtual double r() const {return 0;}\n    virtual double k() const {return 0;}\n    inline virtual bool isPoint() const {return true;}\n    virtual std::string str() const {return \"PointSite\";}\n    virtual std::string str2() const {\n        std::string out = \"PointSite: \";\n        out.append( _p.str() );\n        return out;\n    }\n    virtual bool in_region(const Point& ) const {return true;}\n    virtual double in_region_t(const Point& p) const {return -1;}\n    virtual HEVertex vertex() {return v;}\n    HEVertex v; ///< vertex descriptor of this PointSite\nprivate:\n    PointSite() {} // don't use!\n    Point _p; ///< position\n};\n\n/// line segment Site\nclass LineSite : public Site {\npublic:\n    /// create line-site between start and end Point.\n    LineSite( const Point& st, const Point& en, double koff, HEFace f = 0): _start(st), _end(en) {\n        face = f;\n        eq.q = false;\n        eq.a = _end.y - _start.y;\n        eq.b = _start.x - _end.x;\n        eq.k = koff; // ??\n        eq.c = _end.x*_start.y - _start.x*_end.y;\n        // now normalize\n        double d = sqrt( eq.a*eq.a + eq.b*eq.b );\n        eq.a /= d;\n        eq.b /= d;\n        eq.c /= d;\n        e = HEEdge();\n        assert( fabs( eq.a*eq.a + eq.b*eq.b -1.0 ) < 1e-5);\n    }\n    /// copy ctor\n    LineSite( Site& s ) { // \"downcast\" like constructor? required??\n        eq = s.eqp();\n        face = s.face;\n        _start = s.start();\n        _end = s.end();\n    }\n    ~LineSite() {}\n    virtual Ofs* offset(Point p1,Point p2) {return new LineOfs(p1, p2); }\n    \n    /// closest point on start-end segment to given point.\n    /// project onto line and return either the projected point\n    /// or one endpoint of the linesegment\n    virtual Point apex_point(const Point& p) {\n        Point s_p = p-_start;\n        Point s_e = _end - _start;\n        double t = s_p.dot(s_e) / s_e.dot(s_e);\n        if (t<0)\n            return _start;\n        if (t>1)\n            return _end;\n        else {\n            return _start + t*(_end-_start);\n        }\n    }\n    virtual std::string str() const {return \"LineSite\";}\n    virtual std::string str2() const {\n        std::string out = \"LineSite: \";\n        out.append( _start.str() );\n        out.append( \" - \" );\n        out.append( _end.str() );\n        return out;\n    }\n    virtual bool in_region(const Point& p) const{\n        double t = in_region_t(p);\n        return ( (t>=0) && (t<=1) );\n    }\n    virtual double in_region_t(const Point& p) const {\n        Point s_p = p-_start;\n        Point s_e = _end - _start;\n        double t = s_p.dot(s_e) / s_e.dot(s_e);\n        double eps = 1e-7;\n        if (fabs(t) < eps)  // rounding... UGLY\n            t = 0.0;\n        else if ( fabs(t-1.0) < eps )\n            t = 1.0;\n        return t;\n    }\n    virtual double in_region_t_raw(const Point& p) const {\n        Point s_p = p-_start;\n        Point s_e = _end - _start;\n        double t = s_p.dot(s_e) / s_e.dot(s_e);\n        return t;\n    }\n    inline virtual bool isLine() const {return true;}\n    virtual double a() const { return eq.a; }\n    virtual double b() const { return eq.b; }\n    virtual double c() const { return eq.c; }\n    virtual double k() const {\n        assert( eq.k==1 || eq.k==-1 );\n        return eq.k;\n    }\n    virtual const Point start() const {return _start;}\n    virtual const Point end() const {return _end;}\n    virtual HEEdge edge() {return e;}\n    \n    HEEdge e; ///< edge_descriptor to the ::LINESITE pseudo-edge\nprivate:\n    LineSite() {} // don't use!\n    Point _start; ///< start Point of LineSite\n    Point _end; ///< end Point of LineSite\n};\n\n/// circular arc Site\nclass ArcSite : public Site {\npublic:\n    /// create arc-site\n    ArcSite( const Point& startpt, const Point& endpt, const Point& centr, bool dir) : \n        _start(startpt), _end(endpt), _center(centr), _dir(dir) {\n        _radius = (_center - _start).norm();\n        eq.q = true;\n        eq.a = -2*_center.x;\n        eq.b = -2*_center.y;\n        _k = 1;\n        eq.k = -2*_k*_radius; \n        eq.c = _center.x*_center.x + _center.y*_center.y - _radius*_radius;\n    }\n    ~ArcSite() {}\n    virtual Ofs* offset(Point p1,Point p2) {return new ArcOfs(p1,p2,_center,-1); } //FIXME: radius\n    \n    virtual bool in_region(const Point& p) const {\n        /*\n        if (_dir) {\n            return p.is_right(_center,_start) && !p.is_right(_center,_end);\n        } else {\n            return !p.is_right(_center,_start) && p.is_right(_center,_end);\n        }\n        */\n        if (p==_center)\n            return true;\n            \n        double t = in_region_t(p);\n        return ( (t>=0) && (t<=1) );\n        \n    }\n    \n    /// \\todo fix arc-site in_region_t test!!\n    virtual double in_region_t(const Point& pt) const {\n        // projection onto circle\n        /*\n        Point cen_start = _start - _center;\n        Point cen_end   = _end - _center;\n        Point cen_pt = pt - _center;\n        Point proj = _center + ( _radius/cen_pt.norm())*cen_pt;\n        \n        double diangle_min,diangle_max;\n        if (!_dir) {\n            diangle_min = numeric::diangle( cen_start.x, cen_start.y );\n            diangle_max = numeric::diangle( cen_end.x, cen_end.y );\n        } else {\n            diangle_max = numeric::diangle( cen_start.x, cen_start.y );\n            diangle_min = numeric::diangle( cen_end.x, cen_end.y );\n        }\n        //double fuzz(0.01);\n        double diangle_pt = numeric::diangle(cen_pt.x, cen_pt.y);\n        */\n        double t = in_region_t_raw(pt); //(diangle_pt - diangle_min) / (diangle_max-diangle_min);\n        double eps = 1e-7;\n        if (fabs(t) < eps)  // rounding... UGLY\n            t = 0.0;\n        else if ( fabs(t-1.0) < eps )\n            t = 1.0;\n        return t;\n        \n        /// find t-value along arc\n        //return 0.5; // FIXME\n    }\n    virtual double in_region_t_raw(const Point& pt) const {\n        // projection onto circle\n        Point cen_start = _start - _center;\n        Point cen_end   = _end - _center;\n        Point cen_pt = pt - _center;\n        Point proj = _center + ( _radius/cen_pt.norm())*cen_pt;\n        \n        double diangle_min,diangle_max;\n        if (!_dir) {\n            diangle_min = numeric::diangle( cen_start.x, cen_start.y );\n            diangle_max = numeric::diangle( cen_end.x, cen_end.y );\n        } else {\n            diangle_max = numeric::diangle( cen_start.x, cen_start.y );\n            diangle_min = numeric::diangle( cen_end.x, cen_end.y );\n        }\n        //double fuzz(0.01);\n        double diangle_pt = numeric::diangle(cen_pt.x, cen_pt.y);\n        \n        double t = (diangle_pt - diangle_min) / (diangle_max-diangle_min);\n        return t;\n    }\n    Point apex_point(const Point& p) {\n        if (in_region(p))\n            return projection_point(p);\n        else\n            return closer_endpoint(p);\n    }\n    \n    virtual double x() const {return _center.x;}\n    virtual double y() const {return _center.y;}\n    virtual double r() const {return _radius;}\n    virtual double k() const {return _k;} // ?\n\n    \n    virtual std::string str() const {return \"ArcSite\";}\n    virtual std::string str2() const {\n        std::string out = \"ArcSite: \";\n        out.append( _start.str() );\n        out.append( \" - \" );\n        out.append( _end.str() );\n        out.append( \" c=\" );\n        out.append( _center.str() );\n        out.append( \" cw=\" );\n        out.append( (_dir ? \"1\" : \"0\" ) );\n\n        return out;\n    }\n    HEEdge e; ///< edge_descriptor to ::ARCSITE pseudo-edge\n    /// return start Point of ArcSite\n    const Point start() const {return _start;}\n    /// return end Point of ArcSite\n    const Point end() const {return _end;}\n    /// return center Point of ArcSite\n    Point center() {return _center;}\n    /// return radius of ArcSite\n    double radius() {return _radius;}\n    /// return true for CW ArcSite and false for CCW\n    bool cw() {return _dir;}\n    inline virtual bool isArc() const  { return true;}\n\nprivate:\n    /// projection of given Point onto the ArcSite\n    Point projection_point(const Point& p) const {\n        if ( p == _center ) {\n            return _start;\n        } else {\n            Point dir = (p-_center);\n            dir.normalize();\n            return _center + _radius*dir; // this point should lie on the arc\n        }\n    }\n    /// return the end Point (either _start or _end) that is closest to the given Point \n    Point closer_endpoint(const Point& p) const {\n        double d_start = (_start-p).norm();\n        double d_end = (_end-p).norm();\n        if (d_start < d_end)\n            return _start;\n        else\n            return _end;\n    }\n    ArcSite() {} // don't use!\n    Point _start;  ///< start Point of arc\n    Point _end;    ///< end Point of arc\n    Point _center; ///< center Point of arc\n    bool _dir;     ///< CW or CCW direction flag\n    double _radius;///< radius of arc\n    double _k; ///< offset-direction. +1 for enlarging, -1 for shrinking circle\n};\n\n\n} // end namespace\n","/* The following code declares class array,\n * an STL container (as wrapper) for arrays of constant size.\n *\n * See\n *      http://www.boost.org/libs/array/\n * for documentation.\n *\n * The original author site is at: http://www.josuttis.com/\n *\n * (C) Copyright Nicolai M. Josuttis 2001.\n *\n * Distributed under the Boost Software License, Version 1.0. (See\n * accompanying file LICENSE_1_0.txt or copy at\n * http://www.boost.org/LICENSE_1_0.txt)\n *\n * 14 Apr 2012 - (mtc) Added support for boost::hash\n * 28 Dec 2010 - (mtc) Added cbegin and cend (and crbegin and crend) for C++Ox compatibility.\n * 10 Mar 2010 - (mtc) fill method added, matching resolution of the standard library working group.\n *      See <http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#776> or Trac issue #3168\n *      Eventually, we should remove \"assign\" which is now a synonym for \"fill\" (Marshall Clow)\n * 10 Mar 2010 - added workaround for SUNCC and !STLPort [trac #3893] (Marshall Clow)\n * 29 Jan 2004 - c_array() added, BOOST_NO_PRIVATE_IN_AGGREGATE removed (Nico Josuttis)\n * 23 Aug 2002 - fix for Non-MSVC compilers combined with MSVC libraries.\n * 05 Aug 2001 - minor update (Nico Josuttis)\n * 20 Jan 2001 - STLport fix (Beman Dawes)\n * 29 Sep 2000 - Initial Revision (Nico Josuttis)\n *\n * Jan 29, 2004\n */\n#ifndef BOOST_ARRAY_HPP\n#define BOOST_ARRAY_HPP\n\n#include <boost/detail/workaround.hpp>\n\n#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)  \n# pragma warning(push)  \n# pragma warning(disable:4996) // 'std::equal': Function call with parameters that may be unsafe\n# pragma warning(disable:4510) // boost::array<T,N>' : default constructor could not be generated \n# pragma warning(disable:4610) // warning C4610: class 'boost::array<T,N>' can never be instantiated - user defined constructor required \n#endif\n\n#include <cstddef>\n#include <stdexcept>\n#include <boost/assert.hpp>\n#include <boost/swap.hpp>\n\n// Handles broken standard libraries better than <iterator>\n#include <boost/detail/iterator.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/functional/hash_fwd.hpp>\n#include <algorithm>\n\n// FIXES for broken compilers\n#include <boost/config.hpp>\n\n\nnamespace boost {\n\n    template<class T, std::size_t N>\n    class array {\n      public:\n        T elems[N];    // fixed-size array of elements of type T\n\n      public:\n        // type definitions\n        typedef T              value_type;\n        typedef T*             iterator;\n        typedef const T*       const_iterator;\n        typedef T&             reference;\n        typedef const T&       const_reference;\n        typedef std::size_t    size_type;\n        typedef std::ptrdiff_t difference_type;\n\n        // iterator support\n        iterator        begin()       { return elems; }\n        const_iterator  begin() const { return elems; }\n        const_iterator cbegin() const { return elems; }\n        \n        iterator        end()       { return elems+N; }\n        const_iterator  end() const { return elems+N; }\n        const_iterator cend() const { return elems+N; }\n\n        // reverse iterator support\n#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_MSVC_STD_ITERATOR) && !defined(BOOST_NO_STD_ITERATOR_TRAITS)\n        typedef std::reverse_iterator<iterator> reverse_iterator;\n        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n#elif defined(_MSC_VER) && (_MSC_VER == 1300) && defined(BOOST_DINKUMWARE_STDLIB) && (BOOST_DINKUMWARE_STDLIB == 310)\n        // workaround for broken reverse_iterator in VC7\n        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, iterator,\n                                      reference, iterator, reference> > reverse_iterator;\n        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, const_iterator,\n                                      const_reference, iterator, reference> > const_reverse_iterator;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) \n        typedef std::reverse_iterator<iterator, std::random_access_iterator_tag, \n              value_type, reference, iterator, difference_type> reverse_iterator; \n        typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag,\n              value_type, const_reference, const_iterator, difference_type> const_reverse_iterator;\n#else\n        // workaround for broken reverse_iterator implementations\n        typedef std::reverse_iterator<iterator,T> reverse_iterator;\n        typedef std::reverse_iterator<const_iterator,T> const_reverse_iterator;\n#endif\n\n        reverse_iterator rbegin() { return reverse_iterator(end()); }\n        const_reverse_iterator rbegin() const {\n            return const_reverse_iterator(end());\n        }\n        const_reverse_iterator crbegin() const {\n            return const_reverse_iterator(end());\n        }\n\n        reverse_iterator rend() { return reverse_iterator(begin()); }\n        const_reverse_iterator rend() const {\n            return const_reverse_iterator(begin());\n        }\n        const_reverse_iterator crend() const {\n            return const_reverse_iterator(begin());\n        }\n\n        // operator[]\n        reference operator[](size_type i) \n        { \n            BOOST_ASSERT_MSG( i < N, \"out of range\" );\n            return elems[i];\n        }\n        \n        const_reference operator[](size_type i) const \n        {     \n            BOOST_ASSERT_MSG( i < N, \"out of range\" );\n            return elems[i]; \n        }\n\n        // at() with range check\n        reference at(size_type i) { rangecheck(i); return elems[i]; }\n        const_reference at(size_type i) const { rangecheck(i); return elems[i]; }\n    \n        // front() and back()\n        reference front() \n        { \n            return elems[0]; \n        }\n        \n        const_reference front() const \n        {\n            return elems[0];\n        }\n        \n        reference back() \n        { \n            return elems[N-1]; \n        }\n        \n        const_reference back() const \n        { \n            return elems[N-1]; \n        }\n\n        // size is constant\n        static size_type size() { return N; }\n        static bool empty() { return false; }\n        static size_type max_size() { return N; }\n        enum { static_size = N };\n\n        // swap (note: linear complexity)\n        void swap (array<T,N>& y) {\n            for (size_type i = 0; i < N; ++i)\n                boost::swap(elems[i],y.elems[i]);\n        }\n\n        // direct access to data (read-only)\n        const T* data() const { return elems; }\n        T* data() { return elems; }\n\n        // use array as C array (direct read/write access to data)\n        T* c_array() { return elems; }\n\n        // assignment with type conversion\n        template <typename T2>\n        array<T,N>& operator= (const array<T2,N>& rhs) {\n            std::copy(rhs.begin(),rhs.end(), begin());\n            return *this;\n        }\n\n        // assign one value to all elements\n        void assign (const T& value) { fill ( value ); }    // A synonym for fill\n        void fill   (const T& value)\n        {\n            std::fill_n(begin(),size(),value);\n        }\n\n        // check range (may be private because it is static)\n        static void rangecheck (size_type i) {\n            if (i >= size()) {\n                std::out_of_range e(\"array<>: index out of range\");\n                boost::throw_exception(e);\n            }\n        }\n\n    };\n\n#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION)\n    template< class T >\n    class array< T, 0 > {\n\n      public:\n        // type definitions\n        typedef T              value_type;\n        typedef T*             iterator;\n        typedef const T*       const_iterator;\n        typedef T&             reference;\n        typedef const T&       const_reference;\n        typedef std::size_t    size_type;\n        typedef std::ptrdiff_t difference_type;\n\n        // iterator support\n        iterator        begin()       { return       iterator( reinterpret_cast<       T * >( this ) ); }\n        const_iterator  begin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }\n        const_iterator cbegin() const { return const_iterator( reinterpret_cast< const T * >( this ) ); }\n\n        iterator        end()       { return  begin(); }\n        const_iterator  end() const { return  begin(); }\n        const_iterator cend() const { return cbegin(); }\n\n        // reverse iterator support\n#if !defined(BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION) && !defined(BOOST_MSVC_STD_ITERATOR) && !defined(BOOST_NO_STD_ITERATOR_TRAITS)\n        typedef std::reverse_iterator<iterator> reverse_iterator;\n        typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n#elif defined(_MSC_VER) && (_MSC_VER == 1300) && defined(BOOST_DINKUMWARE_STDLIB) && (BOOST_DINKUMWARE_STDLIB == 310)\n        // workaround for broken reverse_iterator in VC7\n        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, iterator,\n                                      reference, iterator, reference> > reverse_iterator;\n        typedef std::reverse_iterator<std::_Ptrit<value_type, difference_type, const_iterator,\n                                      const_reference, iterator, reference> > const_reverse_iterator;\n#elif defined(_RWSTD_NO_CLASS_PARTIAL_SPEC) \n        typedef std::reverse_iterator<iterator, std::random_access_iterator_tag, \n              value_type, reference, iterator, difference_type> reverse_iterator; \n        typedef std::reverse_iterator<const_iterator, std::random_access_iterator_tag,\n              value_type, const_reference, const_iterator, difference_type> const_reverse_iterator;\n#else\n        // workaround for broken reverse_iterator implementations\n        typedef std::reverse_iterator<iterator,T> reverse_iterator;\n        typedef std::reverse_iterator<const_iterator,T> const_reverse_iterator;\n#endif\n\n        reverse_iterator rbegin() { return reverse_iterator(end()); }\n        const_reverse_iterator rbegin() const {\n            return const_reverse_iterator(end());\n        }\n        const_reverse_iterator crbegin() const {\n            return const_reverse_iterator(end());\n        }\n\n        reverse_iterator rend() { return reverse_iterator(begin()); }\n        const_reverse_iterator rend() const {\n            return const_reverse_iterator(begin());\n        }\n        const_reverse_iterator crend() const {\n            return const_reverse_iterator(begin());\n        }\n\n        // operator[]\n        reference operator[](size_type /*i*/)\n        {\n            return failed_rangecheck();\n        }\n\n        const_reference operator[](size_type /*i*/) const\n        {\n            return failed_rangecheck();\n        }\n\n        // at() with range check\n        reference at(size_type /*i*/)               {   return failed_rangecheck(); }\n        const_reference at(size_type /*i*/) const   {   return failed_rangecheck(); }\n\n        // front() and back()\n        reference front()\n        {\n            return failed_rangecheck();\n        }\n\n        const_reference front() const\n        {\n            return failed_rangecheck();\n        }\n\n        reference back()\n        {\n            return failed_rangecheck();\n        }\n\n        const_reference back() const\n        {\n            return failed_rangecheck();\n        }\n\n        // size is constant\n        static size_type size() { return 0; }\n        static bool empty() { return true; }\n        static size_type max_size() { return 0; }\n        enum { static_size = 0 };\n\n        void swap (array<T,0>& /*y*/) {\n        }\n\n        // direct access to data (read-only)\n        const T* data() const { return 0; }\n        T* data() { return 0; }\n\n        // use array as C array (direct read/write access to data)\n        T* c_array() { return 0; }\n\n        // assignment with type conversion\n        template <typename T2>\n        array<T,0>& operator= (const array<T2,0>& ) {\n            return *this;\n        }\n\n        // assign one value to all elements\n        void assign (const T& value) { fill ( value ); }\n        void fill   (const T& ) {}\n        \n        // check range (may be private because it is static)\n        static reference failed_rangecheck () {\n                std::out_of_range e(\"attempt to access element of an empty array\");\n                boost::throw_exception(e);\n#if defined(BOOST_NO_EXCEPTIONS) || (!defined(BOOST_MSVC) && !defined(__PATHSCALE__))\n                //\n                // We need to return something here to keep\n                // some compilers happy: however we will never\n                // actually get here....\n                //\n                static T placeholder;\n                return placeholder;\n#endif\n            }\n    };\n#endif\n\n    // comparisons\n    template<class T, std::size_t N>\n    bool operator== (const array<T,N>& x, const array<T,N>& y) {\n        return std::equal(x.begin(), x.end(), y.begin());\n    }\n    template<class T, std::size_t N>\n    bool operator< (const array<T,N>& x, const array<T,N>& y) {\n        return std::lexicographical_compare(x.begin(),x.end(),y.begin(),y.end());\n    }\n    template<class T, std::size_t N>\n    bool operator!= (const array<T,N>& x, const array<T,N>& y) {\n        return !(x==y);\n    }\n    template<class T, std::size_t N>\n    bool operator> (const array<T,N>& x, const array<T,N>& y) {\n        return y<x;\n    }\n    template<class T, std::size_t N>\n    bool operator<= (const array<T,N>& x, const array<T,N>& y) {\n        return !(y<x);\n    }\n    template<class T, std::size_t N>\n    bool operator>= (const array<T,N>& x, const array<T,N>& y) {\n        return !(x<y);\n    }\n\n    // global swap()\n    template<class T, std::size_t N>\n    inline void swap (array<T,N>& x, array<T,N>& y) {\n        x.swap(y);\n    }\n\n#if defined(__SUNPRO_CC)\n//  Trac ticket #4757; the Sun Solaris compiler can't handle\n//  syntax like 'T(&get_c_array(boost::array<T,N>& arg))[N]'\n//  \n//  We can't just use this for all compilers, because the \n//      borland compilers can't handle this form. \n    namespace detail {\n       template <typename T, std::size_t N> struct c_array\n       {\n           typedef T type[N];\n       };\n    }\n    \n   // Specific for boost::array: simply returns its elems data member.\n   template <typename T, std::size_t N>\n   typename detail::c_array<T,N>::type& get_c_array(boost::array<T,N>& arg)\n   {\n       return arg.elems;\n   }\n\n   // Specific for boost::array: simply returns its elems data member.\n   template <typename T, std::size_t N>\n   typename const detail::c_array<T,N>::type& get_c_array(const boost::array<T,N>& arg)\n   {\n       return arg.elems;\n   }\n#else\n// Specific for boost::array: simply returns its elems data member.\n    template <typename T, std::size_t N>\n    T(&get_c_array(boost::array<T,N>& arg))[N]\n    {\n        return arg.elems;\n    }\n    \n    // Const version.\n    template <typename T, std::size_t N>\n    const T(&get_c_array(const boost::array<T,N>& arg))[N]\n    {\n        return arg.elems;\n    }\n#endif\n    \n#if 0\n    // Overload for std::array, assuming that std::array will have\n    // explicit conversion functions as discussed at the WG21 meeting\n    // in Summit, March 2009.\n    template <typename T, std::size_t N>\n    T(&get_c_array(std::array<T,N>& arg))[N]\n    {\n        return static_cast<T(&)[N]>(arg);\n    }\n    \n    // Const version.\n    template <typename T, std::size_t N>\n    const T(&get_c_array(const std::array<T,N>& arg))[N]\n    {\n        return static_cast<T(&)[N]>(arg);\n    }\n#endif\n\n\n    template<class T, std::size_t N>\n    std::size_t hash_value(const array<T,N>& arr)\n    {\n        return boost::hash_range(arr.begin(), arr.end());\n    }\n\n} /* namespace boost */\n\n\n#if BOOST_WORKAROUND(BOOST_MSVC, >= 1400)  \n# pragma warning(pop)  \n#endif \n\n#endif /*BOOST_ARRAY_HPP*/\n","/* \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef NUMERIC_HPP\n#define NUMERIC_HPP\n\n#include <vector>\n//#include <qd/qd_real.h>\n\ntypedef long double qd_real;\n\n#define to_double(x) ((double)x)\n\nnamespace ovd {\n\n// this namespace holds general numerical functions that are not specific\n// to voronoi-diagrams and may be useful elsewhere too\nnamespace numeric {\n    //double chop8(double a);\n    double chop(double val);\n    double chop(double val, double tolerance);\n    qd_real chop(qd_real val);\n    \n    template<class Scalar>\n    Scalar sq( Scalar x) {return x*x;}\n    \n    /// solve quadratic eqn: a*x*x + b*x + c = 0\n    /// returns real roots (0, 1, or 2) as vector\n    template<class Scalar>\n    std::vector<Scalar>  quadratic_roots(Scalar a, Scalar b, Scalar c) {\n        std::vector<Scalar> roots;\n        if ((a == 0) and (b == 0)) {\n            //std::cout << \" quadratic_roots() a == b == 0. no roots.\\n\";\n            return roots;\n        }\n        if (a == 0) {\n            roots.push_back( -c / b );\n            return roots;\n        }\n        if (b == 0) {\n            Scalar sqr = -c / a;\n            if (sqr > 0) {\n                roots.push_back( sqrt(sqr) );\n                roots.push_back( -roots[0] );\n                return roots;\n            } else if (sqr == 0) {\n                roots.push_back( Scalar(0) );\n                return roots;\n            } else {\n                //std::cout << \" quadratic_roots() b == 0. no roots.\\n\";\n                return roots;\n            }\n        }\n        Scalar disc = chop(b*b - 4*a*c); // discriminant, chop!\n        if (disc > 0) {\n            Scalar q;\n            if (b > 0)\n                q = (b + sqrt(disc)) / -2;\n            else\n                q = (b - sqrt(disc)) / -2;\n            roots.push_back( q / a );\n            roots.push_back( c / q ); \n            return roots;\n        } else if (disc == 0) {\n            roots.push_back( -b / (2*a) );\n            return roots;\n        }\n        //std::cout << \" quadratic_roots() disc < 0. no roots. disc= \" << disc << \"\\n\";\n        return roots;\n    }\n    \n    template <class Scalar>\n    inline Scalar determinant( Scalar a, Scalar b, Scalar c,\n                        Scalar d, Scalar e, Scalar f,\n                        Scalar g, Scalar h, Scalar i ) {\n        return a*(e*i-h*f)-b*(d*i-g*f)+c*(d*h-g*e);\n    }\n    \n    double diangle(double x, double y);\n    double diangle_x(double a);\n    double diangle_y(double a);\n    std::pair<double,double> diangle_xy(double a);\n    bool diangle_bracket(double less, double a, double more);\n    double diangle_mid(double alfa1, double alfa2);\n    \n} // numeric\n} // ovd\n\n#endif\n","//\n//  boost/assert.hpp - BOOST_ASSERT(expr)\n//                     BOOST_ASSERT_MSG(expr, msg)\n//                     BOOST_VERIFY(expr)\n//\n//  Copyright (c) 2001, 2002 Peter Dimov and Multi Media Ltd.\n//  Copyright (c) 2007 Peter Dimov\n//  Copyright (c) Beman Dawes 2011\n//\n// Distributed under the Boost Software License, Version 1.0. (See\n// accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n//\n//  Note: There are no include guards. This is intentional.\n//\n//  See http://www.boost.org/libs/utility/assert.html for documentation.\n//\n\n//\n// Stop inspect complaining about use of 'assert':\n//\n// boostinspect:naassert_macro\n//\n\n//--------------------------------------------------------------------------------------//\n//                                     BOOST_ASSERT                                     //\n//--------------------------------------------------------------------------------------//\n\n#undef BOOST_ASSERT\n\n#if defined(BOOST_DISABLE_ASSERTS)\n\n# define BOOST_ASSERT(expr) ((void)0)\n\n#elif defined(BOOST_ENABLE_ASSERT_HANDLER)\n\n#include <boost/config.hpp>\n#include <boost/current_function.hpp>\n\nnamespace boost\n{\n  void assertion_failed(char const * expr,\n                        char const * function, char const * file, long line); // user defined\n} // namespace boost\n\n#define BOOST_ASSERT(expr) (BOOST_LIKELY(!!(expr)) \\\n  ? ((void)0) \\\n  : ::boost::assertion_failed(#expr, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))\n\n#else\n# include <assert.h> // .h to support old libraries w/o <cassert> - effect is the same\n# define BOOST_ASSERT(expr) assert(expr)\n#endif\n\n//--------------------------------------------------------------------------------------//\n//                                   BOOST_ASSERT_MSG                                   //\n//--------------------------------------------------------------------------------------//\n\n# undef BOOST_ASSERT_MSG\n\n#if defined(BOOST_DISABLE_ASSERTS) || defined(NDEBUG)\n\n  #define BOOST_ASSERT_MSG(expr, msg) ((void)0)\n\n#elif defined(BOOST_ENABLE_ASSERT_HANDLER)\n\n  #include <boost/config.hpp>\n  #include <boost/current_function.hpp>\n\n  namespace boost\n  {\n    void assertion_failed_msg(char const * expr, char const * msg,\n                              char const * function, char const * file, long line); // user defined\n  } // namespace boost\n\n  #define BOOST_ASSERT_MSG(expr, msg) (BOOST_LIKELY(!!(expr)) \\\n    ? ((void)0) \\\n    : ::boost::assertion_failed_msg(#expr, msg, BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))\n\n#else\n  #ifndef BOOST_ASSERT_HPP\n    #define BOOST_ASSERT_HPP\n    #include <cstdlib>\n    #include <iostream>\n    #include <boost/config.hpp>\n    #include <boost/current_function.hpp>\n\n    //  IDE's like Visual Studio perform better if output goes to std::cout or\n    //  some other stream, so allow user to configure output stream:\n    #ifndef BOOST_ASSERT_MSG_OSTREAM\n    # define BOOST_ASSERT_MSG_OSTREAM std::cerr\n    #endif\n\n    namespace boost\n    {\n      namespace assertion\n      {\n        namespace detail\n        {\n          // Note: The template is needed to make the function non-inline and avoid linking errors\n          template< typename CharT >\n          BOOST_NOINLINE void assertion_failed_msg(CharT const * expr, char const * msg, char const * function,\n            char const * file, long line)\n          {\n            BOOST_ASSERT_MSG_OSTREAM\n              << \"***** Internal Program Error - assertion (\" << expr << \") failed in \"\n              << function << \":\\n\"\n              << file << '(' << line << \"): \" << msg << std::endl;\n#ifdef UNDER_CE\n            // The Windows CE CRT library does not have abort() so use exit(-1) instead.\n            std::exit(-1);\n#else\n            std::abort();\n#endif\n          }\n        } // detail\n      } // assertion\n    } // detail\n  #endif\n\n  #define BOOST_ASSERT_MSG(expr, msg) (BOOST_LIKELY(!!(expr)) \\\n    ? ((void)0) \\\n    : ::boost::assertion::detail::assertion_failed_msg(#expr, msg, \\\n          BOOST_CURRENT_FUNCTION, __FILE__, __LINE__))\n#endif\n\n//--------------------------------------------------------------------------------------//\n//                                     BOOST_VERIFY                                     //\n//--------------------------------------------------------------------------------------//\n\n#undef BOOST_VERIFY\n\n#if defined(BOOST_DISABLE_ASSERTS) || ( !defined(BOOST_ENABLE_ASSERT_HANDLER) && defined(NDEBUG) )\n\n# define BOOST_VERIFY(expr) ((void)(expr))\n\n#else\n\n# define BOOST_VERIFY(expr) BOOST_ASSERT(expr)\n\n#endif\n","/* \n *  Copyright 2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"edge.hpp\"\n#include \"common/numeric.hpp\"\n\nusing namespace ovd::numeric;\n\nnamespace ovd {\n\n/// create edge with zero edge-parameters\nEdgeProps::EdgeProps() {\n    x[0]=0;x[1]=0;x[2]=0;x[3]=0;x[4]=0;x[5]=0;x[6]=0;x[7]=0;\n    y[0]=0;y[1]=0;y[2]=0;y[3]=0;y[4]=0;y[5]=0;y[6]=0;y[7]=0;\n    has_null_face = false;\n    valid=true;\n}\n\n#define stringify( name ) # name\n/// table for type_str()\nconst char* edgeTypeNames[] = {\n  stringify( LINE ),\n  stringify( LINELINE ),\n  stringify( PARA_LINELINE ),\n  stringify( OUTEDGE ),\n  stringify( PARABOLA ),\n  stringify( ELLIPSE ),\n  stringify( HYPERBOLA ),\n  stringify( SEPARATOR ),\n  stringify( NULLEDGE ),\n  stringify( LINESITE )\n};\n\n/// return type of edge as string\nstd::string EdgeProps::type_str() const {\n    std::ostringstream o;\n    o << edgeTypeNames[type];\n    return o.str();\n}\n\n// the edge is not parametrized by t-value as normal edges\n// so we need a projection of sl onto the edge instead\n/*\nPoint EdgeProps::projection_point(Solution& sl) const {\n    assert( type == PARA_LINELINE );\n    // edge given by\n    // x = x[0] + x[1]*t\n    // y = y[0] + y[1]*t\n    //\n    // p = p0 + v*t\n    // (p-p0) = v*t\n    // t = (p-p0).dot(v) / v.dot(v)\n    Point p0(x[0],y[0]);\n    Point v(x[1],y[1]);\n    std::cout << \" edge is from \" << p0 << \"\\n\";\n    std::cout << \" edge direction: \" << v << \"\\n\";\n    \n    double t = (sl.p - p0).dot(v) / v.dot(v);\n    // clamp to [0,1]\n    if ( t>1)\n        t=1;\n    else if (t<0)\n        t=0;\n    std::cout << \" projection of solution \" << sl.p << \" is \" << (p0+v*t) << \"\\n\";\n    return (p0+v*t);\n}*/\n\n/// \\brief return point on edge at given offset-distance t\n///\n/// the eight-parameter formula for a point on the edge is:\n/// x = x1 - x2 - x3*t +/- x4 * sqrt( square(x5+x6*t) - square(x7+x8*t) )\nPoint EdgeProps::point(double t) const {\n    double discr1 =  chop( sq(x[4]+x[5]*t) - sq(x[6]+x[7]*t), 1e-14 );\n    double discr2 =  chop( sq(y[4]+y[5]*t) - sq(y[6]+y[7]*t), 1e-14 );\n    if ( (discr1 >= 0) && (discr2 >= 0) ) {\n        double psig = sign ? +1 : -1;\n        double nsig = sign ? -1 : +1;\n        double xc = x[0] - x[1] - x[2]*t + psig * x[3] * sqrt( discr1 );\n        double yc = y[0] - y[1] - y[2]*t + nsig * y[3] * sqrt( discr2 );\n        if (xc!=xc) { // test for NaN!\n            std::cout << \"Edge::point() ERROR: \" << xc << \" , \" << yc << \" t=\" << t << \"\\n\";\n            print_params();\n            assert(0);\n            return Point(0,0);\n        }\n        return Point(xc,yc);\n    } else {\n        std::cout << \" warning bisector sqrt(-1) discr1=\" << discr1 << \" discr2=\" << discr2 << \"!\\n\";\n        std::cout << \" t= \" << t << \"\\n\";\n        // assert(0);\n        return Point(x[0] - x[1] - x[2]*t ,y[0] - y[1] - y[2]*t); // coordinates without sqrt()\n    }\n}\n\n/// dispatch to setter functions based on type of \\a s1 and \\a s2\nvoid EdgeProps::set_parameters(Site* s1, Site* s2, bool sig) {\n    sign = sig; // sqrt() sign for edge-parametrization\n    if (s1->isPoint() && s2->isPoint())        // PP\n        set_pp_parameters(s1,s2);\n    else if (s1->isPoint() && s2->isLine())    // PL\n        set_pl_parameters(s1,s2);\n    else if (s2->isPoint() && s1->isLine())  {  // LP\n        set_pl_parameters(s2,s1);\n        sign = !sign;\n    } else if (s1->isLine() && s2->isLine())     // LL\n        set_ll_parameters(s2,s1);\n    else if (s1->isPoint() && s2->isArc() ) // PA\n        set_pa_parameters(s1,s2);\n    else if (s2->isPoint() && s1->isArc() ) { // AP\n        sign = !sign;\n        set_pa_parameters(s2,s1);\n        \n    } else if (s1->isLine() && s2->isArc() ) // LA\n        set_la_parameters(s1,s2);\n    else if (s2->isLine() && s1->isArc() ) // AL\n        set_la_parameters(s2,s1);\n    else\n        assert(0);\n        // AA\n}\n\n/// assignment of edge-parameters\nEdgeProps& EdgeProps::operator=(const EdgeProps &other) {\n    if (this == &other)\n        return *this;\n    sign = other.sign;\n    x[0] = other.x[0];\n    x[1] = other.x[1];\n    x[2] = other.x[2];\n    x[3] = other.x[3];\n    x[4] = other.x[4];\n    x[5] = other.x[5];\n    x[6] = other.x[6];        \n    x[7] = other.x[7];\n    y[0] = other.y[0];\n    y[1] = other.y[1];\n    y[2] = other.y[2];\n    y[3] = other.y[3];\n    y[4] = other.y[4];\n    y[5] = other.y[5];\n    y[6] = other.y[6];        \n    y[7] = other.y[7];\n    face = other.face; \n    null_face = other.null_face;\n    has_null_face = other.has_null_face;\n    k=other.k; \n    type = other.type;\n    valid = other.valid;\n    // NOTE we do *not* set: twin, next    \n    return *this;\n}\n\n/// set edge parameters for PointSite-PointSite edge\nvoid EdgeProps::set_pp_parameters(Site* s1, Site* s2) {\n    assert( s1->isPoint() && s2->isPoint() );\n    double d = (s1->position() - s2->position()).norm();\n    double alfa1 = (s2->x() - s1->x()) / d;\n    double alfa2 = (s2->y() - s1->y()) / d;\n    double alfa3 = -d/2;\n    \n    type = LINE;\n    x[0]=s1->x();       \n    x[1]=alfa1*alfa3; // \n    x[2]=0;  \n    x[3]=-alfa2;       \n    x[4]=0;             \n    x[5]=+1;          \n    x[6]=alfa3;       \n    x[7]=0;\n    y[0]=s1->y();     \n    y[1]=alfa2*alfa3; \n    y[2]=0; \n    y[3]=-alfa1;       \n    y[4]=0;           \n    y[5]=+1;          \n    y[6]=alfa3;       \n    y[7]=0;\n}\n\n/// set ::PARABOLA edge parameters (between PointSite and LineSite).\nvoid EdgeProps::set_pl_parameters(Site* s1, Site* s2) {\n    assert( s1->isPoint() && s2->isLine() );\n    \n    type = PARABOLA;\n    double alfa3 = s2->a()*s1->x() + s2->b()*s1->y() + s2->c(); // signed distance to line\n    \n    // figure out kk, i.e. offset-direction for LineSite\n    //double kk = 1.0;\n    /*\n    if (alfa3>0.0) {\n        std::cout << \" alfa3>0 ! \\n\";\n        kk = -1.0;\n        assert(0); // this branch never taken?\n    } else {\n    */    \n        //std::cout << \" alfa3<0 ! \\n\";\n    //    sign = !sign;\n    //}\n    \n    x[0]=s1->x();       // xc1\n    x[1]=s2->a()*alfa3; // alfa1*alfa3\n    x[2]=s2->a(); //*kk;    // -alfa1 = - a2 * k2?\n    x[3]=s2->b();       // alfa2 = b2\n    x[4]=0;             // alfa4 = r1 (PointSite has zero radius)\n    x[5]=+1;            // lambda1 (allways positive offset from PointSite)\n    x[6]=alfa3;         // alfa3= a2*xc1+b2*yc1+d2?\n    x[7]=+1; //kk;            // -1 = k2 side of line??\n\n    y[0]=s1->y();       // yc1\n    y[1]=s2->b()*alfa3; // alfa2*alfa3\n    y[2]=s2->b(); //*kk;    // -alfa2 = -b2\n    y[3]=s2->a();       // alfa1 = a2\n    y[4]=0;             // alfa4 = r1 (PointSite has zero radius)\n    y[5]=+1;            // lambda1 (allways positive offset from PointSite)\n    y[6]=alfa3;         // alfa3\n    y[7]=+1; //kk;            // -1 = k2 side of line??\n}\n\n/// set ::SEPARATOR edge parameters\nvoid EdgeProps::set_sep_parameters(Point& endp, Point& p) {\n    type = SEPARATOR;\n    double dx = p.x - endp.x;\n    double dy = p.y - endp.y;\n    double d = (p-endp).norm();\n    assert( d > 0 );\n    x[0]=endp.x;\n    x[2]=-dx/d; // negative of normalized direction from endp to p\n    y[0]=endp.y;\n    y[2]=-dy/d;\n    \n    x[1]=0;x[3]=0;x[4]=0;x[5]=0;x[6]=0;x[7]=0;\n    y[1]=0;y[3]=0;y[4]=0;y[5]=0;y[6]=0;y[7]=0;\n}\n\n/// set edge parametrization for LineSite-LineSite edge (parallel case)\nvoid EdgeProps::set_ll_para_parameters(Site* s1, Site* s2) {\n    assert( s1->isLine() && s2->isLine() );\n    type = PARA_LINELINE;\n    \n    // find a point (x1,y1) on the line s1\n    // ax+by+c=0\n    double x1(0),y1(0);\n    if ( fabs( s1->a() ) >  fabs( s1->b() ) ) {\n        y1=0;\n        x1=-s1->c()/s1->a();\n    } else {\n        x1=0;\n        y1=-s1->c()/s1->b();\n    }\n    \n    // find a point (x2,y2) on the line s2\n    // ax+by+c=0\n    double x2(0),y2(0);\n    if ( fabs( s2->a() ) >  fabs( s2->b() ) ) {\n        y2=0;\n        x2=-s2->c()/s2->a();\n    } else {\n        x2=0;\n        y2=-s2->c()/s2->b();\n    }\n    \n    // now e.g. the s2 line is given by\n    // p = (x2,y2) + t*(-b2, a)\n    // and we can find the projection of (x1,y1) onto s2 as\n    // p1 = p2 = p0 + t*v\n    Point p1(x1,y1);\n    Point p2(x2,y2);\n    Point v(-s2->b(),s2->a() );\n    double t = (p1-p2).dot(v) / v.dot(v);\n    Point p1_proj = p2+t*v;\n\n    assert( (p1-p1_proj).norm() > 0 );\n    \n    // from this point, go a distance d/2 in the direction of the normal\n    // to find a point through which the bisector passes\n    x1 = x1 + (p1_proj-p1).x / 2;\n    y1 = y1 + (p1_proj-p1).y / 2;\n    // the tangent of the bisector (as well as the two line-sites) is a vector\n    // (-b , a)\n\n    x[0]=  x1;\n    x[1]= -s1->b();\n    y[0]= y1;\n    y[1]= s1->a();\n    \n    x[2]=0;x[3]=0;x[4]=0;x[5]=0;x[6]=0;x[7]=0;\n    y[2]=0;y[3]=0;y[4]=0;y[5]=0;y[6]=0;y[7]=0;\n}\n\n/// set edge parametrization for LineSite-LineSite edge\nvoid EdgeProps::set_ll_parameters(Site* s1, Site* s2) {  // Held thesis p96\n    assert( s1->isLine() && s2->isLine() );\n    type = LINELINE;\n    double delta =  s1->a()*s2->b() - s1->b()*s2->a() ;\n    if ( delta==0 ) { // parallel line segments\n        set_ll_para_parameters(s1,s2);\n        return;\n    }\n    assert( delta != 0 );       \n    double alfa1 = ( s1->b()*s2->c()-s2->b()*s1->c() ) / delta;\n    double alfa2 = ( s2->a()*s1->c()-s1->a()*s2->c() ) / delta;\n    double alfa3 = -( s2->b()-s1->b() ) / delta;\n    double alfa4 = -( s1->a()-s2->a() ) / delta;\n    \n    // point (alfa1,alfa2) is the intersection point between the line-segments\n    // vector (-alfa3,-alfa4) is the direction/tangent of the bisector\n    x[0]=  alfa1;  \n    x[2]= -alfa3; \n    y[0]=  alfa2;         \n    y[2]= -alfa4;  \n\n    x[1]=0;x[3]=0;x[4]=0;x[5]=0;x[6]=0;x[7]=0;\n    y[1]=0;y[3]=0;y[4]=0;y[5]=0;y[6]=0;y[7]=0;\n}\n\n/// set edge parameters when s1 is PointSite and s2 is ArcSite\nvoid EdgeProps::set_pa_parameters(Site* s1, Site* s2) {\n    assert( s1->isPoint() && s2->isArc() );\n    //std::cout << \"set_pa_parameters()\\n\";\n    \n    type = HYPERBOLA; // hyperbola or ellipse?\n    double lamb2(1.0);\n    //if (s2->cw())\n    //    lamb2 = +1.0;\n    //else\n    \n    //sign=!sign;\n    // distance between centers\n    double d = sqrt( (s1->x() - s2->x())*(s1->x() - s2->x()) + (s1->y()-s2->y())*(s1->y()-s2->y()) );\n    assert( d > 0 );\n    if (d<=s2->r()) {\n        lamb2=-1.0;\n        sign=!sign;\n    }\n        \n    //if (s2->cw()) {\n    //    lamb2 = +1.0;\n    //} else {\n    //    lamb2 = -1.0;\n    //}\n    \n    double alfa1 = ( s2->x() - s1->x() ) / d;\n    double alfa2 = ( s2->y() - s1->y() ) / d;\n    double alfa3 = ( s2->r()*s2->r() -  d*d) / (2*d);\n    double alfa4 = ( lamb2 * s2->r()  ) / d;\n    x[0] = s1->x();\n    x[1] = alfa1*alfa3;\n    x[2] = alfa1*alfa4;\n    x[3] = alfa2;\n    x[4] = 0; //r1;  PointSite has zero radius\n    x[5] = +1; //lamb1; allways outward offset from PointSite\n    x[6] = alfa3;\n    x[7] = alfa4;\n    \n    y[0] = s1->y();\n    y[1] = alfa2*alfa3;\n    y[2] = alfa2*alfa4;\n    y[3] = alfa1;\n    y[4] = 0; //r1;     PointSite has zero radius\n    y[5] = +1; //lamb1; allways outward offset from PointSite\n    y[6] = alfa3;\n    y[7] = alfa4;\n    //print_params();\n}\n\n\n/// set edge parameters when s1 is ArcSite and s2 is LineSite\nvoid EdgeProps::set_la_parameters(Site* s1, Site* s2) { \n    assert( s1->isLine() && s2->isArc() );\n    std::cout << \"set_la_parameters() sign= \" << sign << \" cw= \" << s2->cw() << \"\\n\";\n    type = PARABOLA;\n    double lamb2;\n    if (s2->cw())\n        lamb2 = +1.0;\n    else\n        lamb2 = -1.0;\n    double alfa1 = s1->a(); //a2\n    double alfa2 = s1->b(); //b2\n    double alfa3 = ( s1->a()*s2->x() + s1->b()*s2->y() + s1->c() );\n    double alfa4 = s2->r();\n    double kk = +1; // # positive line-offset\n    //if (alfa3 > 0) {\n    //    kk = -1;\n    //    assert(0);\n    //}\n    //sign = false;\n    // figure out sign?\n    \n    x[0] = s2->x();\n    x[1] = alfa1*alfa3;\n    x[2] = alfa1*kk;\n    x[3] = alfa2;\n    x[4] = alfa4;\n    x[5] = lamb2;\n    x[6] = alfa3;\n    x[7] = kk;\n    \n    y[0] = s2->y();\n    y[1] = alfa2*alfa3;\n    y[2] = alfa2*kk;\n    y[3] = alfa1;\n    y[4] = alfa4;\n    y[5] = lamb2;\n    y[6] = alfa3;\n    y[7] = kk;\n    print_params();\n}\n\n\n/// \\return minumum t-value for this edge\n/// this function dispatches to a helper-function based on the Site:s \\a s1 and \\a s2\n// used only for positioning APEX vertices?\ndouble EdgeProps::minimum_t( Site* s1, Site* s2) {\n    if (s1->isPoint() && s2->isPoint())        // PP\n        return minimum_pp_t(s1,s2);\n    else if (s1->isPoint() && s2->isLine())    // PL\n        return minimum_pl_t(s1,s2);\n    else if (s2->isPoint() && s1->isLine())    // LP\n        return minimum_pl_t(s2,s1);\n    else if (s1->isLine() && s2->isLine())     // LL, non-parallel lines allways cross somewhere..\n        return 0;\n    else if (s1->isPoint() && s2->isArc() ) // PA\n        return minimum_pa_t(s1,s2);\n    else if (s2->isPoint() && s1->isArc() ) // AP\n        return minimum_pa_t(s2,s1);\n    else\n        assert(0);\n    // todo:  AP, AL, AA\n    return -1;\n}\n/// minimum t-value for LINE edge between PointSite and PointSite\ndouble EdgeProps::minimum_pp_t(Site* s1, Site* s2) {\n    assert( s1->isPoint() && s2->isPoint() );\n    double p1p2 = (s1->position() - s2->position()).norm() ;\n    assert( p1p2 >=0 );\n    return p1p2/2; // this splits point-point edges at APEX\n}\n/// minimum t-value for ::PARABOLA edge \ndouble EdgeProps::minimum_pl_t(Site* , Site* ) {\n    double mint = - x[6]/(2.0*x[7]);\n    assert( mint >=0 );\n    return mint;\n}\n/// minimum t-value for edge between PointSite and ArcSite\ndouble EdgeProps::minimum_pa_t(Site* s1, Site* s2) {\n    assert( s1->isPoint() && s2->isArc() );\n    double p1p2 = (s1->position() - s2->apex_point(s1->position()) ).norm(); // - s2->r() ;\n    assert( p1p2 >=0 );\n    return p1p2/2; // this splits point-point edges at APEX\n}\n/// print out edge parametrization\nvoid EdgeProps::print_params() const {\n    std::cout << \"x-params: \";\n    for (int m=0;m<8;m++)\n        std::cout << x[m] << \" \";\n    std::cout << \"sign= \" << sign;\n    std::cout << \"\\n\";\n    \n    std::cout << \"y-params: \";\n    for (int m=0;m<8;m++)\n        std::cout << y[m] << \" \";\n    std::cout << \"\\n\";\n}\n\n} // end namespace\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenCAMlib is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenCAMlib is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenCAMlib.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <cassert>\n#include <limits>\n\n#include <boost/assign.hpp>\n\n#include \"vertex.hpp\"\n#include \"common/numeric.hpp\"\n\nnamespace ovd {\n\nint VoronoiVertex::count = 0;\n\n// the expected degree of a vertex. checked by topology-checker\nVoronoiVertex::VertexDegreeMap VoronoiVertex::expected_degree = boost::assign::map_list_of \n    (OUTER,4)     // special outer vertices\n    (NORMAL,6)    // normal vertex in the graph\n    (POINTSITE,0) // point site\n    (ENDPOINT,6)  // end-point of line or arc\n    (SEPPOINT,6)  // end-point of separator\n    (SPLIT,4)     // split point, to avoid loops in delete-tree\n    (APEX,4) ;    // apex point on quadratic bisector\n    \n/// ctor with given status and type\nVoronoiVertex::VoronoiVertex( Point p, VertexStatus st, VertexType t) {\n    init(p,st,t);\n}\n/// ctor with initial apex Point\nVoronoiVertex::VoronoiVertex( Point p, VertexStatus st, VertexType t, Point initDist) {\n    init(p,st,t,initDist);\n}\n/// ctor with initial k3-value\nVoronoiVertex::VoronoiVertex( Point p, VertexStatus st, VertexType t, Point initDist, double lk3) {   \n    init(p,st,t,initDist,lk3);\n}\n/// ctor with initial clearance-disk radius\nVoronoiVertex::VoronoiVertex( Point p, VertexStatus st, VertexType t, double init_radius) {\n    init(p,st,t);\n    r = init_radius;\n}\nVoronoiVertex::~VoronoiVertex() {}\n\n/// set index, increase count, initialize in_queue to false.\nvoid VoronoiVertex::init() {\n    index = count;\n    count++;\n    in_queue = false;\n    alfa=-1; // invalid/non-initialized alfa value\n    null_face = std::numeric_limits<HEFace>::quiet_NaN();    \n    type = NORMAL;\n    face = std::numeric_limits<HEFace>::quiet_NaN();  \n    max_error = 0;\n}\n\n/// set position and status\nvoid VoronoiVertex::init(Point p, VertexStatus st) {\n    init();\n    position=p;\n    status=st;\n}\n/// set position, status and type\nvoid VoronoiVertex::init(Point p, VertexStatus st, VertexType t) {\n    init(p,st);\n    type = t;\n}\n/// set position, status, type, and clearance-disk through givem apex-point\nvoid VoronoiVertex::init(Point p, VertexStatus st, VertexType t, Point initDist) {\n    init(p,st,t);\n    init_dist(initDist);\n}\n/// set position, status, type, clerance-disk radius, and k3-side\nvoid VoronoiVertex::init(Point p, VertexStatus st, VertexType t, Point initDist, double lk3) {\n    init(p,st,t,initDist);\n    k3 = lk3;\n}\n\n/// set in_queue false, and status to ::UNDECIDED\nvoid VoronoiVertex::reset_status() {\n    in_queue = false;\n    status = UNDECIDED;\n}\nvoid VoronoiVertex::set_alfa(const Point& dir) {\n    alfa = numeric::diangle(dir.x,dir.y);\n}\n/// initialize clerance-disk\nvoid VoronoiVertex::init_dist(const Point& p) { r = dist(p); }\n/// return distance to a point from this vertex\ndouble VoronoiVertex::dist(const Point& p) const { return (position-p).norm(); }\n/// set clearance-disk to zero\nvoid VoronoiVertex::zero_dist() {r=0;}\n/// return clearance disk-radius\ndouble VoronoiVertex::dist() const { return r; }\n/// in-circle predicate \ndouble VoronoiVertex::in_circle(const Point& p) const {\n    //if ( r==0 && dist(p) == 0 ) \n    //    return -1;\n    //else\n        return dist(p) - r; \n}\n/// reset the index count\nvoid VoronoiVertex::reset_count() { count = 0; }\n\n\n} // end ovd namespace\n","// Boost.Assign library\n//\n//  Copyright Thorsten Ottosen 2003-2004. Use, modification and\n//  distribution is subject to the Boost Software License, Version\n//  1.0. (See accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n// For more information, see http://www.boost.org/libs/assign/\n//\n\n\n#ifndef BOOST_ASSIGN_LIST_OF_HPP\n#define BOOST_ASSIGN_LIST_OF_HPP\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n#include <boost/assign/assignment_exception.hpp>\n#include <boost/range/iterator_range.hpp>\n#include <boost/config.hpp>\n#include <boost/tuple/tuple.hpp>\n#include <boost/type_traits/remove_const.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/type_traits/is_reference.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/type_traits/detail/yes_no_type.hpp>\n#include <boost/type_traits/decay.hpp>\n#include <boost/type_traits/is_array.hpp>\n#include <boost/mpl/if.hpp>\n#include <deque>\n#include <cstddef>\n#include <utility>\n\n#include <boost/preprocessor/repetition/enum_binary_params.hpp>\n#include <boost/preprocessor/repetition/enum_params.hpp>\n#include <boost/preprocessor/iteration/local.hpp>\n\n#if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n// BCB requires full type definition for is_array<> to work correctly.\n#include <boost/array.hpp>\n#endif\n\nnamespace boost\n{\n\n// this here is necessary to avoid compiler error in <boost/array.hpp>\n#if !BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    template< class T, std::size_t sz >\n    class array;\n#endif    \n    \nnamespace assign_detail\n{\n    /////////////////////////////////////////////////////////////////////////\n    // Part 0: common conversion code\n    /////////////////////////////////////////////////////////////////////////\n\n    template< class T >\n    struct assign_decay\n    {\n        //\n        // Add constness to array parameters\n        // to support string literals properly\n        //\n        typedef BOOST_DEDUCED_TYPENAME mpl::eval_if<\n            ::boost::is_array<T>,\n            ::boost::decay<const T>,\n            ::boost::decay<T> >::type type;\n    };\n    \n    template< class T, std::size_t sz >\n    type_traits::yes_type assign_is_array( const array<T,sz>* );\n    type_traits::no_type assign_is_array( ... );\n    template< class T, class U >\n    type_traits::yes_type assign_is_pair( const std::pair<T,U>* );\n    type_traits::no_type assign_is_pair( ... ); \n\n\n    \n    struct array_type_tag\n    {\n    #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    private:\n      char dummy_;  // BCB would by default use 8 bytes\n    #endif\n    };\n    struct adapter_type_tag\n    {\n    #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    private:\n      char dummy_;  // BCB would by default use 8 bytes\n    #endif\n    };\n    struct pair_type_tag\n    {\n    #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    private:\n      char dummy_;  // BCB would by default use 8 bytes\n    #endif\n    };\n    struct default_type_tag\n    {\n    #if BOOST_WORKAROUND(__BORLANDC__, BOOST_TESTED_AT(0x564))\n    private:\n      char dummy_;  // BCB would by default use 8 bytes\n    #endif\n    };\n\n\n    \n    template< class DerivedTAssign, class Iterator >\n    class converter\n    {\n    public: // Range operations\n        typedef Iterator iterator;\n        typedef Iterator const_iterator;\n        \n        iterator begin() const \n        {\n            return static_cast<const DerivedTAssign*>(this)->begin();\n        }\n\n        iterator end() const\n        {\n            return static_cast<const DerivedTAssign*>(this)->end();\n        }\n        \n    public:\n\n        template< class Container >\n        Container convert_to_container() const\n        {\n            static Container* c = 0;\n            BOOST_STATIC_CONSTANT( bool, is_array_flag = sizeof( assign_detail::assign_is_array( c ) ) \n                                   == sizeof( type_traits::yes_type ) );\n\n            typedef BOOST_DEDUCED_TYPENAME mpl::if_c< is_array_flag,\n                                                      array_type_tag,\n                                             default_type_tag >::type tag_type;\n\n            return convert<Container>( c, tag_type() );\n        }\n        \n    private:\n        \n        template< class Container >\n        Container convert( const Container*, default_type_tag ) const\n        {\n\n#if BOOST_WORKAROUND(BOOST_DINKUMWARE_STDLIB, == 1)\n// old Dinkumware doesn't support iterator type as template\n            Container result;\n            iterator it  = begin(), \n                     e   = end();\n            while( it != e )\n            {\n                result.insert( result.end(), *it );\n                ++it;\n            }\n            return result;\n#else\n            return Container( begin(), end() );\n#endif\n        }\n\n        template< class Array >\n        Array convert( const Array*, array_type_tag ) const\n        {\n            typedef BOOST_DEDUCED_TYPENAME Array::value_type value_type;\n\n#if BOOST_WORKAROUND(BOOST_INTEL, <= 910 ) || BOOST_WORKAROUND(__SUNPRO_CC, <= 0x580 )\n            BOOST_DEDUCED_TYPENAME remove_const<Array>::type ar;\n#else\n            Array ar;\n#endif            \n            const std::size_t sz = ar.size();\n            if( sz < static_cast<const DerivedTAssign*>(this)->size() )\n                throw assign::assignment_exception( \"array initialized with too many elements\" );\n            std::size_t n = 0; \n            iterator i   = begin(), \n                     e   = end();\n            for( ; i != e; ++i, ++n )\n                ar[n] = *i;\n            for( ; n < sz; ++n )\n                ar[n] = value_type();\n            return ar; \n        }\n\n        template< class Adapter >\n        Adapter convert_to_adapter( const Adapter* = 0 ) const\n        {\n            Adapter a;\n            iterator i   = begin(), \n                     e   = end();\n            for( ; i != e; ++i )\n                a.push( *i );\n            return a;\n        }\n\n    private:\n        struct adapter_converter;\n        friend struct adapter_converter;\n\n        struct adapter_converter\n        {\n            const converter& gl;\n            adapter_converter( const converter& this_ ) : gl( this_ )\n            {}\n\n            adapter_converter( const adapter_converter& r ) \n            : gl( r.gl )\n            { }\n\n            template< class Adapter >\n            operator Adapter() const\n            {\n                return gl.convert_to_adapter<Adapter>();\n            }\n        };\n\n    public: \n        template< class Container >\n        Container to_container( Container& c ) const\n        {\n            return convert( &c, default_type_tag() ); \n        }\n\n        adapter_converter to_adapter() const\n        {\n            return adapter_converter( *this );\n        }\n\n        template< class Adapter >\n        Adapter to_adapter( Adapter& a ) const\n        {\n            return this->convert_to_adapter( &a ); \n        }\n\n        template< class Array >\n        Array to_array( Array& a ) const\n        {\n            return convert( &a, array_type_tag() );\n        }\n    };\n\n    template< class T, class I, class Range >\n    inline bool operator==( const converter<T,I>& l, const Range& r )\n    {\n        return ::boost::iterator_range_detail::equal( l, r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator==( const Range& l, const converter<T,I>& r )\n    {\n        return r == l;\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator!=( const converter<T,I>& l, const Range& r )\n    {\n        return !( l == r );\n    }\n    \n    template< class T, class I, class Range >\n    inline bool operator!=( const Range& l, const converter<T,I>& r )\n    {\n        return !( l == r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator<( const converter<T,I>& l, const Range& r )\n    {\n        return ::boost::iterator_range_detail::less_than( l, r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator<( const Range& l, const converter<T,I>& r )\n    {\n        return ::boost::iterator_range_detail::less_than( l, r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator>( const converter<T,I>& l, const Range& r )\n    {\n        return r < l;\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator>( const Range& l, const converter<T,I>& r )\n    {\n        return r < l;\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator<=( const converter<T,I>& l, const Range& r )\n    {\n        return !( l > r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator<=( const Range& l, const converter<T,I>& r )\n    {\n        return !( l > r );\n    }\n    \n    template< class T, class I, class Range >\n    inline bool operator>=( const converter<T,I>& l, const Range& r )\n    {\n        return !( l < r );\n    }\n\n    template< class T, class I, class Range >\n    inline bool operator>=( const Range& l, const converter<T,I>& r )\n    {\n        return !( l < r );\n    }\n\n    template< class T, class I, class Elem, class Traits >\n    inline std::basic_ostream<Elem,Traits>& \n    operator<<( std::basic_ostream<Elem, Traits>& Os,\n                const converter<T,I>& r )\n    {\n        return Os << ::boost::make_iterator_range( r.begin(), r.end() );\n    }\n    \n    /////////////////////////////////////////////////////////////////////////\n    // Part 1: flexible, but inefficient interface\n    /////////////////////////////////////////////////////////////////////////    \n\n    template< class T > \n    class generic_list : \n        public converter< generic_list< BOOST_DEDUCED_TYPENAME assign_decay<T>::type >,\n                          BOOST_DEDUCED_TYPENAME std::deque<BOOST_DEDUCED_TYPENAME \n                                                            assign_decay<T>::type>::iterator >\n    {\n        typedef BOOST_DEDUCED_TYPENAME assign_decay<T>::type Ty;\n        typedef std::deque<Ty>  impl_type;\n        mutable impl_type       values_;\n        \n    public:\n        typedef BOOST_DEDUCED_TYPENAME impl_type::iterator         iterator;\n        typedef iterator                                           const_iterator;\n        typedef BOOST_DEDUCED_TYPENAME impl_type::value_type       value_type;\n        typedef BOOST_DEDUCED_TYPENAME impl_type::size_type        size_type;\n        typedef BOOST_DEDUCED_TYPENAME impl_type::difference_type  difference_type;\n        \n    public:\n        iterator begin() const       { return values_.begin(); }\n        iterator end() const         { return values_.end(); }\n        bool empty() const           { return values_.empty(); }\n        size_type size() const       { return values_.size(); }\n        \n    private:\n        void push_back( value_type r ) { values_.push_back( r ); }\n        \n    public:\n        generic_list& operator,( const Ty& u )\n        {\n            this->push_back( u ); \n            return *this;\n        }\n\n        generic_list& operator()()\n        {\n            this->push_back( Ty() );\n            return *this;\n        }\n\n        generic_list& operator()( const Ty& u )\n        {\n            this->push_back( u );\n            return *this;\n        }\n        \n       \n#ifndef BOOST_ASSIGN_MAX_PARAMS // use user's value\n#define BOOST_ASSIGN_MAX_PARAMS 5\n#endif        \n#define BOOST_ASSIGN_MAX_PARAMETERS (BOOST_ASSIGN_MAX_PARAMS - 1) \n#define BOOST_ASSIGN_PARAMS1(n) BOOST_PP_ENUM_PARAMS(n, class U)\n#define BOOST_ASSIGN_PARAMS2(n) BOOST_PP_ENUM_BINARY_PARAMS(n, U, const& u)\n#define BOOST_ASSIGN_PARAMS3(n) BOOST_PP_ENUM_PARAMS(n, u)\n#define BOOST_ASSIGN_PARAMS4(n) BOOST_PP_ENUM_PARAMS(n, U)\n#define BOOST_ASSIGN_PARAMS2_NO_REF(n) BOOST_PP_ENUM_BINARY_PARAMS(n, U, u)\n\n#define BOOST_PP_LOCAL_LIMITS (1, BOOST_ASSIGN_MAX_PARAMETERS)\n#define BOOST_PP_LOCAL_MACRO(n) \\\n    template< class U, BOOST_ASSIGN_PARAMS1(n) > \\\n    generic_list& operator()(U const& u, BOOST_ASSIGN_PARAMS2(n) ) \\\n    { \\\n        this->push_back( Ty(u, BOOST_ASSIGN_PARAMS3(n))); \\\n        return *this; \\\n    } \\\n    /**/\n        \n#include BOOST_PP_LOCAL_ITERATE()\n\n        \n        template< class U >\n        generic_list& repeat( std::size_t sz, U u )\n        {\n            std::size_t i = 0;\n            while( i++ != sz )\n                this->push_back( u );\n            return *this;\n        }\n        \n        template< class Nullary_function >\n        generic_list& repeat_fun( std::size_t sz, Nullary_function fun )\n        {\n            std::size_t i = 0;\n            while( i++ != sz )\n                this->push_back( fun() );\n            return *this;\n        }\n\n        template< class SinglePassIterator >\n        generic_list& range( SinglePassIterator first, \n                             SinglePassIterator last )\n        {\n            for( ; first != last; ++first )\n                this->push_back( *first );\n            return *this;\n        }\n        \n        template< class SinglePassRange >\n        generic_list& range( const SinglePassRange& r )\n        {\n            return range( boost::begin(r), boost::end(r) );\n        }\n\n        template< class Container >\n        operator Container() const\n        {\n            return this-> BOOST_NESTED_TEMPLATE convert_to_container<Container>();\n        }\n    };\n    \n    /////////////////////////////////////////////////////////////////////////\n    // Part 2: efficient, but inconvenient interface\n    /////////////////////////////////////////////////////////////////////////\n\n    template< class T >\n    struct assign_reference\n    {\n        assign_reference()\n        { /* intentionally empty */ }\n\n        assign_reference( T& r ) : ref_(&r)\n        { }\n\n        void operator=( T& r )\n        {\n            ref_ = &r;\n        }\n\n        operator T&() const\n        {\n            return *ref_;\n        }\n\n        void swap( assign_reference& r )\n        {\n            std::swap( *ref_, *r.ref_ );\n        }\n\n        T& get_ref() const\n        {\n            return *ref_;\n        }\n        \n    private:\n        T* ref_;\n\n    };\n\n    template< class T >\n    inline bool operator<( const assign_reference<T>& l, \n                           const assign_reference<T>& r )\n    {\n        return l.get_ref() < r.get_ref();\n    }\n\n    template< class T >\n    inline bool operator>( const assign_reference<T>& l,\n                           const assign_reference<T>& r )\n    {\n        return l.get_ref() > r.get_ref();\n    }\n\n    template< class T >\n    inline void swap( assign_reference<T>& l, \n                      assign_reference<T>& r )\n    {\n        l.swap( r );\n    }\n\n\n    \n    template< class T, int N >\n    struct static_generic_list : \n        public converter< static_generic_list<T,N>, assign_reference<T>* >\n    {\n    private:\n        typedef T                                     internal_value_type;\n\n    public:\n        typedef assign_reference<internal_value_type> value_type;\n        typedef value_type*                           iterator;\n        typedef value_type*                           const_iterator;\n        typedef std::size_t                           size_type;\n        typedef std::ptrdiff_t                        difference_type;\n\n    \n        static_generic_list( T& r ) :\n            current_(1)\n        {\n            refs_[0] = r;\n        }\n\n        static_generic_list& operator()( T& r )\n        {\n            insert( r );\n            return *this;\n        }\n\n        iterator begin() const \n        {\n            return &refs_[0];\n        }\n\n        iterator end() const\n        {\n            return &refs_[current_];\n        }\n\n        size_type size() const\n        {\n            return static_cast<size_type>( current_ ); \n        }\n\n        bool empty() const\n        {\n            return false;\n        }\n\n        template< class ForwardIterator >\n        static_generic_list& range( ForwardIterator first, \n                                    ForwardIterator last )\n        {\n            for( ; first != last; ++first )\n                this->insert( *first );\n            return *this;\n        }\n\n        template< class ForwardRange >\n        static_generic_list& range( ForwardRange& r )\n        {\n            return range( boost::begin(r), boost::end(r) );\n        }\n\n        template< class ForwardRange >\n        static_generic_list& range( const ForwardRange& r )\n        {\n            return range( boost::begin(r), boost::end(r) );\n        }\n\n        template< class Container >\n        operator Container() const\n        {\n            return this-> BOOST_NESTED_TEMPLATE convert_to_container<Container>();\n        }\n\n    private:\n        void insert( T& r )\n        {\n            refs_[current_] = r;\n            ++current_;\n        }\n        \n        static_generic_list();\n        \n        mutable assign_reference<internal_value_type> refs_[N];\n        int current_;\n    };\n\n} // namespace 'assign_detail'\n\nnamespace assign\n{\n    template< class T >\n    inline assign_detail::generic_list<T>\n    list_of()\n    {\n        return assign_detail::generic_list<T>()( T() );\n    }\n    \n    template< class T >\n    inline assign_detail::generic_list<T> \n    list_of( const T& t )\n    {\n        return assign_detail::generic_list<T>()( t );\n    }\n\n    template< int N, class T >\n    inline assign_detail::static_generic_list< BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type,N>\n    ref_list_of( T& t )\n    {\n        return assign_detail::static_generic_list<BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type,N>( t );\n    }\n    \n    template< int N, class T >\n    inline assign_detail::static_generic_list<const BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type,N>\n    cref_list_of( const T& t )\n    {\n        return assign_detail::static_generic_list<const BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type,N>( t );\n    }\n\n#define BOOST_PP_LOCAL_LIMITS (1, BOOST_ASSIGN_MAX_PARAMETERS)\n#define BOOST_PP_LOCAL_MACRO(n) \\\n    template< class T, class U, BOOST_ASSIGN_PARAMS1(n) > \\\n    inline assign_detail::generic_list<T> \\\n    list_of(U const& u, BOOST_ASSIGN_PARAMS2(n) ) \\\n    { \\\n        return assign_detail::generic_list<T>()(u, BOOST_ASSIGN_PARAMS3(n)); \\\n    } \\\n    /**/\n    \n#include BOOST_PP_LOCAL_ITERATE()\n\n#define BOOST_PP_LOCAL_LIMITS (1, BOOST_ASSIGN_MAX_PARAMETERS)\n#define BOOST_PP_LOCAL_MACRO(n) \\\n    template< class U, BOOST_ASSIGN_PARAMS1(n) > \\\n    inline assign_detail::generic_list< tuple<U, BOOST_ASSIGN_PARAMS4(n)> > \\\n    tuple_list_of(U u, BOOST_ASSIGN_PARAMS2_NO_REF(n) ) \\\n    { \\\n        return assign_detail::generic_list< tuple<U, BOOST_ASSIGN_PARAMS4(n)> >()( tuple<U,BOOST_ASSIGN_PARAMS4(n)>( u, BOOST_ASSIGN_PARAMS3(n) )); \\\n    } \\\n    /**/\n    \n#include BOOST_PP_LOCAL_ITERATE()\n\n\n    template< class Key, class T >\n    inline assign_detail::generic_list< std::pair\n        < \n            BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<Key>::type, \n            BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type\n        > >\n    map_list_of( const Key& k, const T& t )\n    {\n        typedef BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<Key>::type k_type;\n        typedef BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<T>::type   t_type;\n        return assign_detail::generic_list< std::pair<k_type,t_type> >()( k, t );\n    }\n\n    template< class F, class S >\n    inline assign_detail::generic_list< std::pair\n        < \n            BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<F>::type, \n            BOOST_DEDUCED_TYPENAME assign_detail::assign_decay<S>::type\n        > >\n    pair_list_of( const F& f, const S& s )\n    {\n        return map_list_of( f, s );\n    }\n\n\n} // namespace 'assign'\n} // namespace 'boost'\n\n\n#undef BOOST_ASSIGN_PARAMS1\n#undef BOOST_ASSIGN_PARAMS2\n#undef BOOST_ASSIGN_PARAMS3\n#undef BOOST_ASSIGN_PARAMS4\n#undef BOOST_ASSIGN_PARAMS2_NO_REF\n#undef BOOST_ASSIGN_MAX_PARAMETERS\n\n#endif\n","# /* **************************************************************************\n#  *                                                                          *\n#  *     (C) Copyright Paul Mensonides 2002.\n#  *     Distributed under the Boost Software License, Version 1.0. (See\n#  *     accompanying file LICENSE_1_0.txt or copy at\n#  *     http://www.boost.org/LICENSE_1_0.txt)\n#  *                                                                          *\n#  ************************************************************************** */\n#\n# /* See http://www.boost.org for most recent version. */\n#\n# if !defined(BOOST_PP_LOCAL_LIMITS)\n#    error BOOST_PP_ERROR:  local iteration boundaries are not defined\n# elif !defined(BOOST_PP_LOCAL_MACRO)\n#    error BOOST_PP_ERROR:  local iteration target macro is not defined\n# else\n#    if ~BOOST_PP_CONFIG_FLAGS() & BOOST_PP_CONFIG_EDG()\n#        define BOOST_PP_LOCAL_S BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_LOCAL_LIMITS)\n#        define BOOST_PP_LOCAL_F BOOST_PP_TUPLE_ELEM(2, 1, BOOST_PP_LOCAL_LIMITS)\n#    else\n#        define BOOST_PP_VALUE BOOST_PP_TUPLE_ELEM(2, 0, BOOST_PP_LOCAL_LIMITS)\n#        include <boost/preprocessor/iteration/detail/start.hpp>\n#        define BOOST_PP_VALUE BOOST_PP_TUPLE_ELEM(2, 1, BOOST_PP_LOCAL_LIMITS)\n#        include <boost/preprocessor/iteration/detail/finish.hpp>\n#        define BOOST_PP_LOCAL_S BOOST_PP_LOCAL_SE()\n#        define BOOST_PP_LOCAL_F BOOST_PP_LOCAL_FE()\n#    endif\n# endif\n#\n# if (BOOST_PP_LOCAL_S) > (BOOST_PP_LOCAL_F)\n#    include <boost/preprocessor/iteration/detail/rlocal.hpp>\n# else\n#    if BOOST_PP_LOCAL_C(0)\n        BOOST_PP_LOCAL_MACRO(0)\n#    endif\n#    if BOOST_PP_LOCAL_C(1)\n        BOOST_PP_LOCAL_MACRO(1)\n#    endif\n#    if BOOST_PP_LOCAL_C(2)\n        BOOST_PP_LOCAL_MACRO(2)\n#    endif\n#    if BOOST_PP_LOCAL_C(3)\n        BOOST_PP_LOCAL_MACRO(3)\n#    endif\n#    if BOOST_PP_LOCAL_C(4)\n        BOOST_PP_LOCAL_MACRO(4)\n#    endif\n#    if BOOST_PP_LOCAL_C(5)\n        BOOST_PP_LOCAL_MACRO(5)\n#    endif\n#    if BOOST_PP_LOCAL_C(6)\n        BOOST_PP_LOCAL_MACRO(6)\n#    endif\n#    if BOOST_PP_LOCAL_C(7)\n        BOOST_PP_LOCAL_MACRO(7)\n#    endif\n#    if BOOST_PP_LOCAL_C(8)\n        BOOST_PP_LOCAL_MACRO(8)\n#    endif\n#    if BOOST_PP_LOCAL_C(9)\n        BOOST_PP_LOCAL_MACRO(9)\n#    endif\n#    if BOOST_PP_LOCAL_C(10)\n        BOOST_PP_LOCAL_MACRO(10)\n#    endif\n#    if BOOST_PP_LOCAL_C(11)\n        BOOST_PP_LOCAL_MACRO(11)\n#    endif\n#    if BOOST_PP_LOCAL_C(12)\n        BOOST_PP_LOCAL_MACRO(12)\n#    endif\n#    if BOOST_PP_LOCAL_C(13)\n        BOOST_PP_LOCAL_MACRO(13)\n#    endif\n#    if BOOST_PP_LOCAL_C(14)\n        BOOST_PP_LOCAL_MACRO(14)\n#    endif\n#    if BOOST_PP_LOCAL_C(15)\n        BOOST_PP_LOCAL_MACRO(15)\n#    endif\n#    if BOOST_PP_LOCAL_C(16)\n        BOOST_PP_LOCAL_MACRO(16)\n#    endif\n#    if BOOST_PP_LOCAL_C(17)\n        BOOST_PP_LOCAL_MACRO(17)\n#    endif\n#    if BOOST_PP_LOCAL_C(18)\n        BOOST_PP_LOCAL_MACRO(18)\n#    endif\n#    if BOOST_PP_LOCAL_C(19)\n        BOOST_PP_LOCAL_MACRO(19)\n#    endif\n#    if BOOST_PP_LOCAL_C(20)\n        BOOST_PP_LOCAL_MACRO(20)\n#    endif\n#    if BOOST_PP_LOCAL_C(21)\n        BOOST_PP_LOCAL_MACRO(21)\n#    endif\n#    if BOOST_PP_LOCAL_C(22)\n        BOOST_PP_LOCAL_MACRO(22)\n#    endif\n#    if BOOST_PP_LOCAL_C(23)\n        BOOST_PP_LOCAL_MACRO(23)\n#    endif\n#    if BOOST_PP_LOCAL_C(24)\n        BOOST_PP_LOCAL_MACRO(24)\n#    endif\n#    if BOOST_PP_LOCAL_C(25)\n        BOOST_PP_LOCAL_MACRO(25)\n#    endif\n#    if BOOST_PP_LOCAL_C(26)\n        BOOST_PP_LOCAL_MACRO(26)\n#    endif\n#    if BOOST_PP_LOCAL_C(27)\n        BOOST_PP_LOCAL_MACRO(27)\n#    endif\n#    if BOOST_PP_LOCAL_C(28)\n        BOOST_PP_LOCAL_MACRO(28)\n#    endif\n#    if BOOST_PP_LOCAL_C(29)\n        BOOST_PP_LOCAL_MACRO(29)\n#    endif\n#    if BOOST_PP_LOCAL_C(30)\n        BOOST_PP_LOCAL_MACRO(30)\n#    endif\n#    if BOOST_PP_LOCAL_C(31)\n        BOOST_PP_LOCAL_MACRO(31)\n#    endif\n#    if BOOST_PP_LOCAL_C(32)\n        BOOST_PP_LOCAL_MACRO(32)\n#    endif\n#    if BOOST_PP_LOCAL_C(33)\n        BOOST_PP_LOCAL_MACRO(33)\n#    endif\n#    if BOOST_PP_LOCAL_C(34)\n        BOOST_PP_LOCAL_MACRO(34)\n#    endif\n#    if BOOST_PP_LOCAL_C(35)\n        BOOST_PP_LOCAL_MACRO(35)\n#    endif\n#    if BOOST_PP_LOCAL_C(36)\n        BOOST_PP_LOCAL_MACRO(36)\n#    endif\n#    if BOOST_PP_LOCAL_C(37)\n        BOOST_PP_LOCAL_MACRO(37)\n#    endif\n#    if BOOST_PP_LOCAL_C(38)\n        BOOST_PP_LOCAL_MACRO(38)\n#    endif\n#    if BOOST_PP_LOCAL_C(39)\n        BOOST_PP_LOCAL_MACRO(39)\n#    endif\n#    if BOOST_PP_LOCAL_C(40)\n        BOOST_PP_LOCAL_MACRO(40)\n#    endif\n#    if BOOST_PP_LOCAL_C(41)\n        BOOST_PP_LOCAL_MACRO(41)\n#    endif\n#    if BOOST_PP_LOCAL_C(42)\n        BOOST_PP_LOCAL_MACRO(42)\n#    endif\n#    if BOOST_PP_LOCAL_C(43)\n        BOOST_PP_LOCAL_MACRO(43)\n#    endif\n#    if BOOST_PP_LOCAL_C(44)\n        BOOST_PP_LOCAL_MACRO(44)\n#    endif\n#    if BOOST_PP_LOCAL_C(45)\n        BOOST_PP_LOCAL_MACRO(45)\n#    endif\n#    if BOOST_PP_LOCAL_C(46)\n        BOOST_PP_LOCAL_MACRO(46)\n#    endif\n#    if BOOST_PP_LOCAL_C(47)\n        BOOST_PP_LOCAL_MACRO(47)\n#    endif\n#    if BOOST_PP_LOCAL_C(48)\n        BOOST_PP_LOCAL_MACRO(48)\n#    endif\n#    if BOOST_PP_LOCAL_C(49)\n        BOOST_PP_LOCAL_MACRO(49)\n#    endif\n#    if BOOST_PP_LOCAL_C(50)\n        BOOST_PP_LOCAL_MACRO(50)\n#    endif\n#    if BOOST_PP_LOCAL_C(51)\n        BOOST_PP_LOCAL_MACRO(51)\n#    endif\n#    if BOOST_PP_LOCAL_C(52)\n        BOOST_PP_LOCAL_MACRO(52)\n#    endif\n#    if BOOST_PP_LOCAL_C(53)\n        BOOST_PP_LOCAL_MACRO(53)\n#    endif\n#    if BOOST_PP_LOCAL_C(54)\n        BOOST_PP_LOCAL_MACRO(54)\n#    endif\n#    if BOOST_PP_LOCAL_C(55)\n        BOOST_PP_LOCAL_MACRO(55)\n#    endif\n#    if BOOST_PP_LOCAL_C(56)\n        BOOST_PP_LOCAL_MACRO(56)\n#    endif\n#    if BOOST_PP_LOCAL_C(57)\n        BOOST_PP_LOCAL_MACRO(57)\n#    endif\n#    if BOOST_PP_LOCAL_C(58)\n        BOOST_PP_LOCAL_MACRO(58)\n#    endif\n#    if BOOST_PP_LOCAL_C(59)\n        BOOST_PP_LOCAL_MACRO(59)\n#    endif\n#    if BOOST_PP_LOCAL_C(60)\n        BOOST_PP_LOCAL_MACRO(60)\n#    endif\n#    if BOOST_PP_LOCAL_C(61)\n        BOOST_PP_LOCAL_MACRO(61)\n#    endif\n#    if BOOST_PP_LOCAL_C(62)\n        BOOST_PP_LOCAL_MACRO(62)\n#    endif\n#    if BOOST_PP_LOCAL_C(63)\n        BOOST_PP_LOCAL_MACRO(63)\n#    endif\n#    if BOOST_PP_LOCAL_C(64)\n        BOOST_PP_LOCAL_MACRO(64)\n#    endif\n#    if BOOST_PP_LOCAL_C(65)\n        BOOST_PP_LOCAL_MACRO(65)\n#    endif\n#    if BOOST_PP_LOCAL_C(66)\n        BOOST_PP_LOCAL_MACRO(66)\n#    endif\n#    if BOOST_PP_LOCAL_C(67)\n        BOOST_PP_LOCAL_MACRO(67)\n#    endif\n#    if BOOST_PP_LOCAL_C(68)\n        BOOST_PP_LOCAL_MACRO(68)\n#    endif\n#    if BOOST_PP_LOCAL_C(69)\n        BOOST_PP_LOCAL_MACRO(69)\n#    endif\n#    if BOOST_PP_LOCAL_C(70)\n        BOOST_PP_LOCAL_MACRO(70)\n#    endif\n#    if BOOST_PP_LOCAL_C(71)\n        BOOST_PP_LOCAL_MACRO(71)\n#    endif\n#    if BOOST_PP_LOCAL_C(72)\n        BOOST_PP_LOCAL_MACRO(72)\n#    endif\n#    if BOOST_PP_LOCAL_C(73)\n        BOOST_PP_LOCAL_MACRO(73)\n#    endif\n#    if BOOST_PP_LOCAL_C(74)\n        BOOST_PP_LOCAL_MACRO(74)\n#    endif\n#    if BOOST_PP_LOCAL_C(75)\n        BOOST_PP_LOCAL_MACRO(75)\n#    endif\n#    if BOOST_PP_LOCAL_C(76)\n        BOOST_PP_LOCAL_MACRO(76)\n#    endif\n#    if BOOST_PP_LOCAL_C(77)\n        BOOST_PP_LOCAL_MACRO(77)\n#    endif\n#    if BOOST_PP_LOCAL_C(78)\n        BOOST_PP_LOCAL_MACRO(78)\n#    endif\n#    if BOOST_PP_LOCAL_C(79)\n        BOOST_PP_LOCAL_MACRO(79)\n#    endif\n#    if BOOST_PP_LOCAL_C(80)\n        BOOST_PP_LOCAL_MACRO(80)\n#    endif\n#    if BOOST_PP_LOCAL_C(81)\n        BOOST_PP_LOCAL_MACRO(81)\n#    endif\n#    if BOOST_PP_LOCAL_C(82)\n        BOOST_PP_LOCAL_MACRO(82)\n#    endif\n#    if BOOST_PP_LOCAL_C(83)\n        BOOST_PP_LOCAL_MACRO(83)\n#    endif\n#    if BOOST_PP_LOCAL_C(84)\n        BOOST_PP_LOCAL_MACRO(84)\n#    endif\n#    if BOOST_PP_LOCAL_C(85)\n        BOOST_PP_LOCAL_MACRO(85)\n#    endif\n#    if BOOST_PP_LOCAL_C(86)\n        BOOST_PP_LOCAL_MACRO(86)\n#    endif\n#    if BOOST_PP_LOCAL_C(87)\n        BOOST_PP_LOCAL_MACRO(87)\n#    endif\n#    if BOOST_PP_LOCAL_C(88)\n        BOOST_PP_LOCAL_MACRO(88)\n#    endif\n#    if BOOST_PP_LOCAL_C(89)\n        BOOST_PP_LOCAL_MACRO(89)\n#    endif\n#    if BOOST_PP_LOCAL_C(90)\n        BOOST_PP_LOCAL_MACRO(90)\n#    endif\n#    if BOOST_PP_LOCAL_C(91)\n        BOOST_PP_LOCAL_MACRO(91)\n#    endif\n#    if BOOST_PP_LOCAL_C(92)\n        BOOST_PP_LOCAL_MACRO(92)\n#    endif\n#    if BOOST_PP_LOCAL_C(93)\n        BOOST_PP_LOCAL_MACRO(93)\n#    endif\n#    if BOOST_PP_LOCAL_C(94)\n        BOOST_PP_LOCAL_MACRO(94)\n#    endif\n#    if BOOST_PP_LOCAL_C(95)\n        BOOST_PP_LOCAL_MACRO(95)\n#    endif\n#    if BOOST_PP_LOCAL_C(96)\n        BOOST_PP_LOCAL_MACRO(96)\n#    endif\n#    if BOOST_PP_LOCAL_C(97)\n        BOOST_PP_LOCAL_MACRO(97)\n#    endif\n#    if BOOST_PP_LOCAL_C(98)\n        BOOST_PP_LOCAL_MACRO(98)\n#    endif\n#    if BOOST_PP_LOCAL_C(99)\n        BOOST_PP_LOCAL_MACRO(99)\n#    endif\n#    if BOOST_PP_LOCAL_C(100)\n        BOOST_PP_LOCAL_MACRO(100)\n#    endif\n#    if BOOST_PP_LOCAL_C(101)\n        BOOST_PP_LOCAL_MACRO(101)\n#    endif\n#    if BOOST_PP_LOCAL_C(102)\n        BOOST_PP_LOCAL_MACRO(102)\n#    endif\n#    if BOOST_PP_LOCAL_C(103)\n        BOOST_PP_LOCAL_MACRO(103)\n#    endif\n#    if BOOST_PP_LOCAL_C(104)\n        BOOST_PP_LOCAL_MACRO(104)\n#    endif\n#    if BOOST_PP_LOCAL_C(105)\n        BOOST_PP_LOCAL_MACRO(105)\n#    endif\n#    if BOOST_PP_LOCAL_C(106)\n        BOOST_PP_LOCAL_MACRO(106)\n#    endif\n#    if BOOST_PP_LOCAL_C(107)\n        BOOST_PP_LOCAL_MACRO(107)\n#    endif\n#    if BOOST_PP_LOCAL_C(108)\n        BOOST_PP_LOCAL_MACRO(108)\n#    endif\n#    if BOOST_PP_LOCAL_C(109)\n        BOOST_PP_LOCAL_MACRO(109)\n#    endif\n#    if BOOST_PP_LOCAL_C(110)\n        BOOST_PP_LOCAL_MACRO(110)\n#    endif\n#    if BOOST_PP_LOCAL_C(111)\n        BOOST_PP_LOCAL_MACRO(111)\n#    endif\n#    if BOOST_PP_LOCAL_C(112)\n        BOOST_PP_LOCAL_MACRO(112)\n#    endif\n#    if BOOST_PP_LOCAL_C(113)\n        BOOST_PP_LOCAL_MACRO(113)\n#    endif\n#    if BOOST_PP_LOCAL_C(114)\n        BOOST_PP_LOCAL_MACRO(114)\n#    endif\n#    if BOOST_PP_LOCAL_C(115)\n        BOOST_PP_LOCAL_MACRO(115)\n#    endif\n#    if BOOST_PP_LOCAL_C(116)\n        BOOST_PP_LOCAL_MACRO(116)\n#    endif\n#    if BOOST_PP_LOCAL_C(117)\n        BOOST_PP_LOCAL_MACRO(117)\n#    endif\n#    if BOOST_PP_LOCAL_C(118)\n        BOOST_PP_LOCAL_MACRO(118)\n#    endif\n#    if BOOST_PP_LOCAL_C(119)\n        BOOST_PP_LOCAL_MACRO(119)\n#    endif\n#    if BOOST_PP_LOCAL_C(120)\n        BOOST_PP_LOCAL_MACRO(120)\n#    endif\n#    if BOOST_PP_LOCAL_C(121)\n        BOOST_PP_LOCAL_MACRO(121)\n#    endif\n#    if BOOST_PP_LOCAL_C(122)\n        BOOST_PP_LOCAL_MACRO(122)\n#    endif\n#    if BOOST_PP_LOCAL_C(123)\n        BOOST_PP_LOCAL_MACRO(123)\n#    endif\n#    if BOOST_PP_LOCAL_C(124)\n        BOOST_PP_LOCAL_MACRO(124)\n#    endif\n#    if BOOST_PP_LOCAL_C(125)\n        BOOST_PP_LOCAL_MACRO(125)\n#    endif\n#    if BOOST_PP_LOCAL_C(126)\n        BOOST_PP_LOCAL_MACRO(126)\n#    endif\n#    if BOOST_PP_LOCAL_C(127)\n        BOOST_PP_LOCAL_MACRO(127)\n#    endif\n#    if BOOST_PP_LOCAL_C(128)\n        BOOST_PP_LOCAL_MACRO(128)\n#    endif\n#    if BOOST_PP_LOCAL_C(129)\n        BOOST_PP_LOCAL_MACRO(129)\n#    endif\n#    if BOOST_PP_LOCAL_C(130)\n        BOOST_PP_LOCAL_MACRO(130)\n#    endif\n#    if BOOST_PP_LOCAL_C(131)\n        BOOST_PP_LOCAL_MACRO(131)\n#    endif\n#    if BOOST_PP_LOCAL_C(132)\n        BOOST_PP_LOCAL_MACRO(132)\n#    endif\n#    if BOOST_PP_LOCAL_C(133)\n        BOOST_PP_LOCAL_MACRO(133)\n#    endif\n#    if BOOST_PP_LOCAL_C(134)\n        BOOST_PP_LOCAL_MACRO(134)\n#    endif\n#    if BOOST_PP_LOCAL_C(135)\n        BOOST_PP_LOCAL_MACRO(135)\n#    endif\n#    if BOOST_PP_LOCAL_C(136)\n        BOOST_PP_LOCAL_MACRO(136)\n#    endif\n#    if BOOST_PP_LOCAL_C(137)\n        BOOST_PP_LOCAL_MACRO(137)\n#    endif\n#    if BOOST_PP_LOCAL_C(138)\n        BOOST_PP_LOCAL_MACRO(138)\n#    endif\n#    if BOOST_PP_LOCAL_C(139)\n        BOOST_PP_LOCAL_MACRO(139)\n#    endif\n#    if BOOST_PP_LOCAL_C(140)\n        BOOST_PP_LOCAL_MACRO(140)\n#    endif\n#    if BOOST_PP_LOCAL_C(141)\n        BOOST_PP_LOCAL_MACRO(141)\n#    endif\n#    if BOOST_PP_LOCAL_C(142)\n        BOOST_PP_LOCAL_MACRO(142)\n#    endif\n#    if BOOST_PP_LOCAL_C(143)\n        BOOST_PP_LOCAL_MACRO(143)\n#    endif\n#    if BOOST_PP_LOCAL_C(144)\n        BOOST_PP_LOCAL_MACRO(144)\n#    endif\n#    if BOOST_PP_LOCAL_C(145)\n        BOOST_PP_LOCAL_MACRO(145)\n#    endif\n#    if BOOST_PP_LOCAL_C(146)\n        BOOST_PP_LOCAL_MACRO(146)\n#    endif\n#    if BOOST_PP_LOCAL_C(147)\n        BOOST_PP_LOCAL_MACRO(147)\n#    endif\n#    if BOOST_PP_LOCAL_C(148)\n        BOOST_PP_LOCAL_MACRO(148)\n#    endif\n#    if BOOST_PP_LOCAL_C(149)\n        BOOST_PP_LOCAL_MACRO(149)\n#    endif\n#    if BOOST_PP_LOCAL_C(150)\n        BOOST_PP_LOCAL_MACRO(150)\n#    endif\n#    if BOOST_PP_LOCAL_C(151)\n        BOOST_PP_LOCAL_MACRO(151)\n#    endif\n#    if BOOST_PP_LOCAL_C(152)\n        BOOST_PP_LOCAL_MACRO(152)\n#    endif\n#    if BOOST_PP_LOCAL_C(153)\n        BOOST_PP_LOCAL_MACRO(153)\n#    endif\n#    if BOOST_PP_LOCAL_C(154)\n        BOOST_PP_LOCAL_MACRO(154)\n#    endif\n#    if BOOST_PP_LOCAL_C(155)\n        BOOST_PP_LOCAL_MACRO(155)\n#    endif\n#    if BOOST_PP_LOCAL_C(156)\n        BOOST_PP_LOCAL_MACRO(156)\n#    endif\n#    if BOOST_PP_LOCAL_C(157)\n        BOOST_PP_LOCAL_MACRO(157)\n#    endif\n#    if BOOST_PP_LOCAL_C(158)\n        BOOST_PP_LOCAL_MACRO(158)\n#    endif\n#    if BOOST_PP_LOCAL_C(159)\n        BOOST_PP_LOCAL_MACRO(159)\n#    endif\n#    if BOOST_PP_LOCAL_C(160)\n        BOOST_PP_LOCAL_MACRO(160)\n#    endif\n#    if BOOST_PP_LOCAL_C(161)\n        BOOST_PP_LOCAL_MACRO(161)\n#    endif\n#    if BOOST_PP_LOCAL_C(162)\n        BOOST_PP_LOCAL_MACRO(162)\n#    endif\n#    if BOOST_PP_LOCAL_C(163)\n        BOOST_PP_LOCAL_MACRO(163)\n#    endif\n#    if BOOST_PP_LOCAL_C(164)\n        BOOST_PP_LOCAL_MACRO(164)\n#    endif\n#    if BOOST_PP_LOCAL_C(165)\n        BOOST_PP_LOCAL_MACRO(165)\n#    endif\n#    if BOOST_PP_LOCAL_C(166)\n        BOOST_PP_LOCAL_MACRO(166)\n#    endif\n#    if BOOST_PP_LOCAL_C(167)\n        BOOST_PP_LOCAL_MACRO(167)\n#    endif\n#    if BOOST_PP_LOCAL_C(168)\n        BOOST_PP_LOCAL_MACRO(168)\n#    endif\n#    if BOOST_PP_LOCAL_C(169)\n        BOOST_PP_LOCAL_MACRO(169)\n#    endif\n#    if BOOST_PP_LOCAL_C(170)\n        BOOST_PP_LOCAL_MACRO(170)\n#    endif\n#    if BOOST_PP_LOCAL_C(171)\n        BOOST_PP_LOCAL_MACRO(171)\n#    endif\n#    if BOOST_PP_LOCAL_C(172)\n        BOOST_PP_LOCAL_MACRO(172)\n#    endif\n#    if BOOST_PP_LOCAL_C(173)\n        BOOST_PP_LOCAL_MACRO(173)\n#    endif\n#    if BOOST_PP_LOCAL_C(174)\n        BOOST_PP_LOCAL_MACRO(174)\n#    endif\n#    if BOOST_PP_LOCAL_C(175)\n        BOOST_PP_LOCAL_MACRO(175)\n#    endif\n#    if BOOST_PP_LOCAL_C(176)\n        BOOST_PP_LOCAL_MACRO(176)\n#    endif\n#    if BOOST_PP_LOCAL_C(177)\n        BOOST_PP_LOCAL_MACRO(177)\n#    endif\n#    if BOOST_PP_LOCAL_C(178)\n        BOOST_PP_LOCAL_MACRO(178)\n#    endif\n#    if BOOST_PP_LOCAL_C(179)\n        BOOST_PP_LOCAL_MACRO(179)\n#    endif\n#    if BOOST_PP_LOCAL_C(180)\n        BOOST_PP_LOCAL_MACRO(180)\n#    endif\n#    if BOOST_PP_LOCAL_C(181)\n        BOOST_PP_LOCAL_MACRO(181)\n#    endif\n#    if BOOST_PP_LOCAL_C(182)\n        BOOST_PP_LOCAL_MACRO(182)\n#    endif\n#    if BOOST_PP_LOCAL_C(183)\n        BOOST_PP_LOCAL_MACRO(183)\n#    endif\n#    if BOOST_PP_LOCAL_C(184)\n        BOOST_PP_LOCAL_MACRO(184)\n#    endif\n#    if BOOST_PP_LOCAL_C(185)\n        BOOST_PP_LOCAL_MACRO(185)\n#    endif\n#    if BOOST_PP_LOCAL_C(186)\n        BOOST_PP_LOCAL_MACRO(186)\n#    endif\n#    if BOOST_PP_LOCAL_C(187)\n        BOOST_PP_LOCAL_MACRO(187)\n#    endif\n#    if BOOST_PP_LOCAL_C(188)\n        BOOST_PP_LOCAL_MACRO(188)\n#    endif\n#    if BOOST_PP_LOCAL_C(189)\n        BOOST_PP_LOCAL_MACRO(189)\n#    endif\n#    if BOOST_PP_LOCAL_C(190)\n        BOOST_PP_LOCAL_MACRO(190)\n#    endif\n#    if BOOST_PP_LOCAL_C(191)\n        BOOST_PP_LOCAL_MACRO(191)\n#    endif\n#    if BOOST_PP_LOCAL_C(192)\n        BOOST_PP_LOCAL_MACRO(192)\n#    endif\n#    if BOOST_PP_LOCAL_C(193)\n        BOOST_PP_LOCAL_MACRO(193)\n#    endif\n#    if BOOST_PP_LOCAL_C(194)\n        BOOST_PP_LOCAL_MACRO(194)\n#    endif\n#    if BOOST_PP_LOCAL_C(195)\n        BOOST_PP_LOCAL_MACRO(195)\n#    endif\n#    if BOOST_PP_LOCAL_C(196)\n        BOOST_PP_LOCAL_MACRO(196)\n#    endif\n#    if BOOST_PP_LOCAL_C(197)\n        BOOST_PP_LOCAL_MACRO(197)\n#    endif\n#    if BOOST_PP_LOCAL_C(198)\n        BOOST_PP_LOCAL_MACRO(198)\n#    endif\n#    if BOOST_PP_LOCAL_C(199)\n        BOOST_PP_LOCAL_MACRO(199)\n#    endif\n#    if BOOST_PP_LOCAL_C(200)\n        BOOST_PP_LOCAL_MACRO(200)\n#    endif\n#    if BOOST_PP_LOCAL_C(201)\n        BOOST_PP_LOCAL_MACRO(201)\n#    endif\n#    if BOOST_PP_LOCAL_C(202)\n        BOOST_PP_LOCAL_MACRO(202)\n#    endif\n#    if BOOST_PP_LOCAL_C(203)\n        BOOST_PP_LOCAL_MACRO(203)\n#    endif\n#    if BOOST_PP_LOCAL_C(204)\n        BOOST_PP_LOCAL_MACRO(204)\n#    endif\n#    if BOOST_PP_LOCAL_C(205)\n        BOOST_PP_LOCAL_MACRO(205)\n#    endif\n#    if BOOST_PP_LOCAL_C(206)\n        BOOST_PP_LOCAL_MACRO(206)\n#    endif\n#    if BOOST_PP_LOCAL_C(207)\n        BOOST_PP_LOCAL_MACRO(207)\n#    endif\n#    if BOOST_PP_LOCAL_C(208)\n        BOOST_PP_LOCAL_MACRO(208)\n#    endif\n#    if BOOST_PP_LOCAL_C(209)\n        BOOST_PP_LOCAL_MACRO(209)\n#    endif\n#    if BOOST_PP_LOCAL_C(210)\n        BOOST_PP_LOCAL_MACRO(210)\n#    endif\n#    if BOOST_PP_LOCAL_C(211)\n        BOOST_PP_LOCAL_MACRO(211)\n#    endif\n#    if BOOST_PP_LOCAL_C(212)\n        BOOST_PP_LOCAL_MACRO(212)\n#    endif\n#    if BOOST_PP_LOCAL_C(213)\n        BOOST_PP_LOCAL_MACRO(213)\n#    endif\n#    if BOOST_PP_LOCAL_C(214)\n        BOOST_PP_LOCAL_MACRO(214)\n#    endif\n#    if BOOST_PP_LOCAL_C(215)\n        BOOST_PP_LOCAL_MACRO(215)\n#    endif\n#    if BOOST_PP_LOCAL_C(216)\n        BOOST_PP_LOCAL_MACRO(216)\n#    endif\n#    if BOOST_PP_LOCAL_C(217)\n        BOOST_PP_LOCAL_MACRO(217)\n#    endif\n#    if BOOST_PP_LOCAL_C(218)\n        BOOST_PP_LOCAL_MACRO(218)\n#    endif\n#    if BOOST_PP_LOCAL_C(219)\n        BOOST_PP_LOCAL_MACRO(219)\n#    endif\n#    if BOOST_PP_LOCAL_C(220)\n        BOOST_PP_LOCAL_MACRO(220)\n#    endif\n#    if BOOST_PP_LOCAL_C(221)\n        BOOST_PP_LOCAL_MACRO(221)\n#    endif\n#    if BOOST_PP_LOCAL_C(222)\n        BOOST_PP_LOCAL_MACRO(222)\n#    endif\n#    if BOOST_PP_LOCAL_C(223)\n        BOOST_PP_LOCAL_MACRO(223)\n#    endif\n#    if BOOST_PP_LOCAL_C(224)\n        BOOST_PP_LOCAL_MACRO(224)\n#    endif\n#    if BOOST_PP_LOCAL_C(225)\n        BOOST_PP_LOCAL_MACRO(225)\n#    endif\n#    if BOOST_PP_LOCAL_C(226)\n        BOOST_PP_LOCAL_MACRO(226)\n#    endif\n#    if BOOST_PP_LOCAL_C(227)\n        BOOST_PP_LOCAL_MACRO(227)\n#    endif\n#    if BOOST_PP_LOCAL_C(228)\n        BOOST_PP_LOCAL_MACRO(228)\n#    endif\n#    if BOOST_PP_LOCAL_C(229)\n        BOOST_PP_LOCAL_MACRO(229)\n#    endif\n#    if BOOST_PP_LOCAL_C(230)\n        BOOST_PP_LOCAL_MACRO(230)\n#    endif\n#    if BOOST_PP_LOCAL_C(231)\n        BOOST_PP_LOCAL_MACRO(231)\n#    endif\n#    if BOOST_PP_LOCAL_C(232)\n        BOOST_PP_LOCAL_MACRO(232)\n#    endif\n#    if BOOST_PP_LOCAL_C(233)\n        BOOST_PP_LOCAL_MACRO(233)\n#    endif\n#    if BOOST_PP_LOCAL_C(234)\n        BOOST_PP_LOCAL_MACRO(234)\n#    endif\n#    if BOOST_PP_LOCAL_C(235)\n        BOOST_PP_LOCAL_MACRO(235)\n#    endif\n#    if BOOST_PP_LOCAL_C(236)\n        BOOST_PP_LOCAL_MACRO(236)\n#    endif\n\n#    if BOOST_PP_LOCAL_C(237)\n        BOOST_PP_LOCAL_MACRO(237)\n#    endif\n#    if BOOST_PP_LOCAL_C(238)\n        BOOST_PP_LOCAL_MACRO(238)\n#    endif\n#    if BOOST_PP_LOCAL_C(239)\n        BOOST_PP_LOCAL_MACRO(239)\n#    endif\n#    if BOOST_PP_LOCAL_C(240)\n        BOOST_PP_LOCAL_MACRO(240)\n#    endif\n#    if BOOST_PP_LOCAL_C(241)\n        BOOST_PP_LOCAL_MACRO(241)\n#    endif\n#    if BOOST_PP_LOCAL_C(242)\n        BOOST_PP_LOCAL_MACRO(242)\n#    endif\n#    if BOOST_PP_LOCAL_C(243)\n        BOOST_PP_LOCAL_MACRO(243)\n#    endif\n#    if BOOST_PP_LOCAL_C(244)\n        BOOST_PP_LOCAL_MACRO(244)\n#    endif\n#    if BOOST_PP_LOCAL_C(245)\n        BOOST_PP_LOCAL_MACRO(245)\n#    endif\n#    if BOOST_PP_LOCAL_C(246)\n        BOOST_PP_LOCAL_MACRO(246)\n#    endif\n#    if BOOST_PP_LOCAL_C(247)\n        BOOST_PP_LOCAL_MACRO(247)\n#    endif\n#    if BOOST_PP_LOCAL_C(248)\n        BOOST_PP_LOCAL_MACRO(248)\n#    endif\n#    if BOOST_PP_LOCAL_C(249)\n        BOOST_PP_LOCAL_MACRO(249)\n#    endif\n#    if BOOST_PP_LOCAL_C(250)\n        BOOST_PP_LOCAL_MACRO(250)\n#    endif\n#    if BOOST_PP_LOCAL_C(251)\n        BOOST_PP_LOCAL_MACRO(251)\n#    endif\n#    if BOOST_PP_LOCAL_C(252)\n        BOOST_PP_LOCAL_MACRO(252)\n#    endif\n#    if BOOST_PP_LOCAL_C(253)\n        BOOST_PP_LOCAL_MACRO(253)\n#    endif\n#    if BOOST_PP_LOCAL_C(254)\n        BOOST_PP_LOCAL_MACRO(254)\n#    endif\n#    if BOOST_PP_LOCAL_C(255)\n        BOOST_PP_LOCAL_MACRO(255)\n#    endif\n#    if BOOST_PP_LOCAL_C(256)\n        BOOST_PP_LOCAL_MACRO(256)\n#    endif\n# endif\n#\n# undef BOOST_PP_LOCAL_LIMITS\n#\n# undef BOOST_PP_LOCAL_S\n# undef BOOST_PP_LOCAL_F\n#\n# undef BOOST_PP_LOCAL_MACRO\n","// -*- C++ -*-\n//===---------------------------- deque -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_DEQUE\n#define _LIBCPP_DEQUE\n\n/*\n    deque synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass deque\n{\npublic:\n    // types:\n    typedef T value_type;\n    typedef Allocator allocator_type;\n\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    // construct/copy/destroy:\n    deque() noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit deque(const allocator_type& a);\n    explicit deque(size_type n);\n    explicit deque(size_type n, const allocator_type& a); // C++14\n    deque(size_type n, const value_type& v);\n    deque(size_type n, const value_type& v, const allocator_type& a);\n    template <class InputIterator>\n        deque(InputIterator f, InputIterator l);\n    template <class InputIterator>\n        deque(InputIterator f, InputIterator l, const allocator_type& a);\n    deque(const deque& c);\n    deque(deque&& c)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    deque(initializer_list<value_type> il, const Allocator& a = allocator_type());\n    deque(const deque& c, const allocator_type& a);\n    deque(deque&& c, const allocator_type& a);\n    ~deque();\n\n    deque& operator=(const deque& c);\n    deque& operator=(deque&& c)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    deque& operator=(initializer_list<value_type> il);\n\n    template <class InputIterator>\n        void assign(InputIterator f, InputIterator l);\n    void assign(size_type n, const value_type& v);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    // iterators:\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    // capacity:\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    void resize(size_type n);\n    void resize(size_type n, const value_type& v);\n    void shrink_to_fit();\n    bool empty() const noexcept;\n\n    // element access:\n    reference operator[](size_type i);\n    const_reference operator[](size_type i) const;\n    reference at(size_type i);\n    const_reference at(size_type i) const;\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    // modifiers:\n    void push_front(const value_type& v);\n    void push_front(value_type&& v);\n    void push_back(const value_type& v);\n    void push_back(value_type&& v);\n    template <class... Args> void emplace_front(Args&&... args);\n    template <class... Args> void emplace_back(Args&&... args);\n    template <class... Args> iterator emplace(const_iterator p, Args&&... args);\n    iterator insert(const_iterator p, const value_type& v);\n    iterator insert(const_iterator p, value_type&& v);\n    iterator insert(const_iterator p, size_type n, const value_type& v);\n    template <class InputIterator>\n        iterator insert (const_iterator p, InputIterator f, InputIterator l);\n    iterator insert(const_iterator p, initializer_list<value_type> il);\n    void pop_front();\n    void pop_back();\n    iterator erase(const_iterator p);\n    iterator erase(const_iterator f, const_iterator l);\n    void swap(deque& c)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void clear() noexcept;\n};\n\ntemplate <class T, class Allocator>\n    bool operator==(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator< (const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator!=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator> (const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator>=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\ntemplate <class T, class Allocator>\n    bool operator<=(const deque<T,Allocator>& x, const deque<T,Allocator>& y);\n\n// specialized algorithms:\ntemplate <class T, class Allocator>\n    void swap(deque<T,Allocator>& x, deque<T,Allocator>& y)\n         noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n#include <__config>\n#include <__split_buffer>\n#include <type_traits>\n#include <initializer_list>\n#include <iterator>\n#include <algorithm>\n#include <stdexcept>\n\n#include <__undef_min_max>\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Allocator> class __deque_base;\n\ntemplate <class _ValueType, class _Pointer, class _Reference, class _MapPointer,\n          class _DiffType, _DiffType _BlockSize>\nclass _LIBCPP_TYPE_VIS_ONLY __deque_iterator;\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r);\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\ntemplate <class _ValueType, class _Pointer, class _Reference, class _MapPointer,\n          class _DiffType, _DiffType _BlockSize>\nclass _LIBCPP_TYPE_VIS_ONLY __deque_iterator\n{\n    typedef _MapPointer __map_iterator;\npublic:\n    typedef _Pointer  pointer;\n    typedef _DiffType difference_type;\nprivate:\n    __map_iterator __m_iter_;\n    pointer        __ptr_;\n\n    static const difference_type __block_size = _BlockSize;\npublic:\n    typedef _ValueType                  value_type;\n    typedef random_access_iterator_tag  iterator_category;\n    typedef _Reference                  reference;\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n     : __m_iter_(nullptr), __ptr_(nullptr)\n#endif\n     {}\n\n    template <class _Pp, class _Rp, class _MP>\n    _LIBCPP_INLINE_VISIBILITY\n    __deque_iterator(const __deque_iterator<value_type, _Pp, _Rp, _MP, difference_type, __block_size>& __it,\n                typename enable_if<is_convertible<_Pp, pointer>::value>::type* = 0) _NOEXCEPT\n        : __m_iter_(__it.__m_iter_), __ptr_(__it.__ptr_) {}\n\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const {return __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator++()\n    {\n        if (++__ptr_ - *__m_iter_ == __block_size)\n        {\n            ++__m_iter_;\n            __ptr_ = *__m_iter_;\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator++(int)\n    {\n        __deque_iterator __tmp = *this;\n        ++(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator--()\n    {\n        if (__ptr_ == *__m_iter_)\n        {\n            --__m_iter_;\n            __ptr_ = *__m_iter_ + __block_size;\n        }\n        --__ptr_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator--(int)\n    {\n        __deque_iterator __tmp = *this;\n        --(*this);\n        return __tmp;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator+=(difference_type __n)\n    {\n        if (__n != 0)\n        {\n            __n += __ptr_ - *__m_iter_;\n            if (__n > 0)\n            {\n                __m_iter_ += __n / __block_size;\n                __ptr_ = *__m_iter_ + __n % __block_size;\n            }\n            else // (__n < 0)\n            {\n                difference_type __z = __block_size - 1 - __n;\n                __m_iter_ -= __z / __block_size;\n                __ptr_ = *__m_iter_ + (__block_size - 1 - __z % __block_size);\n            }\n        }\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator& operator-=(difference_type __n)\n    {\n        return *this += -__n;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator+(difference_type __n) const\n    {\n        __deque_iterator __t(*this);\n        __t += __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator operator-(difference_type __n) const\n    {\n        __deque_iterator __t(*this);\n        __t -= __n;\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend __deque_iterator operator+(difference_type __n, const __deque_iterator& __it)\n        {return __it + __n;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    friend difference_type operator-(const __deque_iterator& __x, const __deque_iterator& __y)\n    {\n        if (__x != __y)\n            return (__x.__m_iter_ - __y.__m_iter_) * __block_size\n                 + (__x.__ptr_ - *__x.__m_iter_)\n                 - (__y.__ptr_ - *__y.__m_iter_);\n        return 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY reference operator[](difference_type __n) const\n        {return *(*this + __n);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator==(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __x.__ptr_ == __y.__ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator!=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__x == __y);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator<(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __x.__m_iter_ < __y.__m_iter_ ||\n               (__x.__m_iter_ == __y.__m_iter_ && __x.__ptr_ < __y.__ptr_);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator>(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return __y < __x;}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator<=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__y < __x);}\n\n    _LIBCPP_INLINE_VISIBILITY friend\n        bool operator>=(const __deque_iterator& __x, const __deque_iterator& __y)\n        {return !(__x < __y);}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY __deque_iterator(__map_iterator __m, pointer __p) _NOEXCEPT\n        : __m_iter_(__m), __ptr_(__p) {}\n\n    template <class _Tp, class _Ap> friend class __deque_base;\n    template <class _Tp, class _Ap> friend class _LIBCPP_TYPE_VIS_ONLY deque;\n    template <class _Vp, class _Pp, class _Rp, class _MP, class _Dp, _Dp>\n        friend class _LIBCPP_TYPE_VIS_ONLY __deque_iterator;\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy(_RAIter __f,\n         _RAIter __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy_backward(_RAIter __f,\n                  _RAIter __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    copy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move(_RAIter __f,\n         _RAIter __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n         typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n         __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n         __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n\n    template <class _RAIter,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move_backward(_RAIter __f,\n                  _RAIter __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n                  typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _OutputIterator>\n    friend\n    _OutputIterator\n    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  _OutputIterator __r);\n\n    template <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n              class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n    friend\n    __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\n    move_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n                  __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n                  __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r);\n};\n\n// copy\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        pointer __rb = __r.__ptr_;\n        pointer __re = *__r.__m_iter_ + _B2;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __l;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __f + __n;\n        }\n        _VSTD::copy(__f, __m, __rb);\n        __f = __m;\n        __r += __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + _B1;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::copy(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + _B1;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::copy(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// copy_backward\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = _VSTD::prev(__r);\n        pointer __rb = *__rp.__m_iter_;\n        pointer __re = __rp.__ptr_ + 1;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __f;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __l - __n;\n        }\n        _VSTD::copy_backward(__m, __l, __re);\n        __l = __m;\n        __r -= __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::copy_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\ncopy_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::copy_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\n// move\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(_RAIter __f,\n     _RAIter __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n     typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        pointer __rb = __r.__ptr_;\n        pointer __re = *__r.__m_iter_ + _B2;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __l;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __f + __n;\n        }\n        _VSTD::move(__f, __m, __rb);\n        __f = __m;\n        __r += __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + _B1;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n     __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n     __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + _B1;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// move_backward\n\ntemplate <class _RAIter,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(_RAIter __f,\n              _RAIter __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r,\n              typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::difference_type difference_type;\n    typedef typename __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>::pointer pointer;\n    while (__f != __l)\n    {\n        __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __rp = _VSTD::prev(__r);\n        pointer __rb = *__rp.__m_iter_;\n        pointer __re = __rp.__ptr_ + 1;\n        difference_type __bs = __re - __rb;\n        difference_type __n = __l - __f;\n        _RAIter __m = __f;\n        if (__n > __bs)\n        {\n            __n = __bs;\n            __m = __l - __n;\n        }\n        _VSTD::move_backward(__m, __l, __re);\n        __l = __m;\n        __r -= __n;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _OutputIterator>\n_OutputIterator\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              _OutputIterator __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <class _V1, class _P1, class _R1, class _M1, class _D1, _D1 _B1,\n          class _V2, class _P2, class _R2, class _M2, class _D2, _D2 _B2>\n__deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2>\nmove_backward(__deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __f,\n              __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1> __l,\n              __deque_iterator<_V2, _P2, _R2, _M2, _D2, _B2> __r)\n{\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::difference_type difference_type;\n    typedef typename __deque_iterator<_V1, _P1, _R1, _M1, _D1, _B1>::pointer pointer;\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\ntemplate <bool>\nclass __deque_base_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__deque_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"deque\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__deque_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"deque\");\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\nclass __deque_base\n    : protected __deque_base_common<true>\n{\n    __deque_base(const __deque_base& __c);\n    __deque_base& operator=(const __deque_base& __c);\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n\n    static const difference_type __block_size = sizeof(value_type) < 256 ? 4096 / sizeof(value_type) : 16;\n\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<pointer>\n#else\n                rebind_alloc<pointer>::other\n#endif\n                                                         __pointer_allocator;\n    typedef allocator_traits<__pointer_allocator>        __map_traits;\n    typedef typename __map_traits::pointer               __map_pointer;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<const_pointer>\n#else\n                rebind_alloc<const_pointer>::other\n#endif\n                                                         __const_pointer_allocator;\n    typedef typename allocator_traits<__const_pointer_allocator>::const_pointer __map_const_pointer;\n    typedef __split_buffer<pointer, __pointer_allocator> __map;\n\n    typedef __deque_iterator<value_type, pointer, reference, __map_pointer,\n                             difference_type, __block_size>    iterator;\n    typedef __deque_iterator<value_type, const_pointer, const_reference, __map_const_pointer,\n                             difference_type, __block_size>    const_iterator;\n\n    __map __map_;\n    size_type __start_;\n    __compressed_pair<size_type, allocator_type> __size_;\n\n    iterator       begin() _NOEXCEPT;\n    const_iterator begin() const _NOEXCEPT;\n    iterator       end() _NOEXCEPT;\n    const_iterator end() const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY size_type&            size()          {return __size_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& size() const _NOEXCEPT {return __size_.first();}\n    _LIBCPP_INLINE_VISIBILITY allocator_type&       __alloc()       {return __size_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __size_.second();}\n\n    __deque_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __deque_base(const allocator_type& __a);\npublic:\n    ~__deque_base();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    __deque_base(__deque_base&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __deque_base(__deque_base&& __c, const allocator_type& __a);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void swap(__deque_base& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\nprotected:\n    void clear() _NOEXCEPT;\n\n    bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(__deque_base& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value)\n    {\n        __map_ = _VSTD::move(__c.__map_);\n        __start_ = __c.__start_;\n        size() = __c.size();\n        __move_assign_alloc(__c);\n        __c.__start_ = __c.size() = 0;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_move_assignment::value ||\n                   is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__deque_base&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__deque_base<_Tp, _Allocator>::__invariants() const\n{\n    if (!__map_.__invariants())\n        return false;\n    if (__map_.size() >= size_type(-1) / __block_size)\n        return false;\n    for (typename __map::const_iterator __i = __map_.begin(), __e = __map_.end();\n         __i != __e; ++__i)\n        if (*__i == nullptr)\n            return false;\n    if (__map_.size() != 0)\n    {\n        if (size() >= __map_.size() * __block_size)\n            return false;\n        if (__start_ >= __map_.size() * __block_size - size())\n            return false;\n    }\n    else\n    {\n        if (size() != 0)\n            return false;\n        if (__start_ != 0)\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::iterator\n__deque_base<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    __map_pointer __mp = __map_.begin() + __start_ / __block_size;\n    return iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::const_iterator\n__deque_base<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __start_ / __block_size);\n    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __start_ % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::iterator\n__deque_base<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    size_type __p = size() + __start_;\n    __map_pointer __mp = __map_.begin() + __p / __block_size;\n    return iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename __deque_base<_Tp, _Allocator>::const_iterator\n__deque_base<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    size_type __p = size() + __start_;\n    __map_const_pointer __mp = static_cast<__map_const_pointer>(__map_.begin() + __p / __block_size);\n    return const_iterator(__mp, __map_.empty() ? 0 : *__mp + __p % __block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__deque_base<_Tp, _Allocator>::__deque_base()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __start_(0), __size_(0) {}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__deque_base<_Tp, _Allocator>::__deque_base(const allocator_type& __a)\n    : __map_(__pointer_allocator(__a)), __start_(0), __size_(0, __a) {}\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::~__deque_base()\n{\n    clear();\n    typename __map::iterator __i = __map_.begin();\n    typename __map::iterator __e = __map_.end();\n    for (; __i != __e; ++__i)\n        __alloc_traits::deallocate(__alloc(), *__i, __block_size);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __map_(_VSTD::move(__c.__map_)),\n      __start_(_VSTD::move(__c.__start_)),\n      __size_(_VSTD::move(__c.__size_))\n{\n    __c.__start_ = 0;\n    __c.size() = 0;\n}\n\ntemplate <class _Tp, class _Allocator>\n__deque_base<_Tp, _Allocator>::__deque_base(__deque_base&& __c, const allocator_type& __a)\n    : __map_(_VSTD::move(__c.__map_), __pointer_allocator(__a)),\n      __start_(_VSTD::move(__c.__start_)),\n      __size_(_VSTD::move(__c.size()), __a)\n{\n    if (__a == __c.__alloc())\n    {\n        __c.__start_ = 0;\n        __c.size() = 0;\n    }\n    else\n    {\n        __map_.clear();\n        __start_ = 0;\n        size() = 0;\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__deque_base<_Tp, _Allocator>::swap(__deque_base& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    __map_.swap(__c.__map_);\n    _VSTD::swap(__start_, __c.__start_);\n    _VSTD::swap(size(), __c.size());\n    __swap_alloc(__alloc(), __c.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__deque_base<_Tp, _Allocator>::clear() _NOEXCEPT\n{\n    allocator_type& __a = __alloc();\n    for (iterator __i = begin(), __e = end(); __i != __e; ++__i)\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n    size() = 0;\n    while (__map_.size() > 2)\n    {\n        __alloc_traits::deallocate(__a, __map_.front(), __block_size);\n        __map_.pop_front();\n    }\n    switch (__map_.size())\n    {\n    case 1:\n        __start_ = __block_size / 2;\n        break;\n    case 2:\n        __start_ = __block_size;\n        break;\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY deque\n    : private __deque_base<_Tp, _Allocator>\n{\npublic:\n    // types:\n\n    typedef _Tp value_type;\n    typedef _Allocator allocator_type;\n\n    typedef __deque_base<value_type, allocator_type> __base;\n\n    typedef typename __base::__alloc_traits        __alloc_traits;\n    typedef typename __base::reference             reference;\n    typedef typename __base::const_reference       const_reference;\n    typedef typename __base::iterator              iterator;\n    typedef typename __base::const_iterator        const_iterator;\n    typedef typename __base::size_type             size_type;\n    typedef typename __base::difference_type       difference_type;\n\n    typedef typename __base::pointer               pointer;\n    typedef typename __base::const_pointer         const_pointer;\n    typedef _VSTD::reverse_iterator<iterator>       reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    deque()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {}\n    _LIBCPP_INLINE_VISIBILITY deque(const allocator_type& __a) : __base(__a) {}\n    explicit deque(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit deque(size_type __n, const _Allocator& __a);\n#endif\n    deque(size_type __n, const value_type& __v);\n    deque(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIter>\n        deque(_InputIter __f, _InputIter __l,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);\n    template <class _InputIter>\n        deque(_InputIter __f, _InputIter __l, const allocator_type& __a,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type* = 0);\n    deque(const deque& __c);\n    deque(const deque& __c, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    deque(initializer_list<value_type> __il);\n    deque(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    deque& operator=(const deque& __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    deque& operator=(initializer_list<value_type> __il) {assign(__il); return *this;}\n#endif   // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    deque(deque&& __c) _NOEXCEPT_(is_nothrow_move_constructible<__base>::value);\n    deque(deque&& __c, const allocator_type& __a);\n    deque& operator=(deque&& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _InputIter>\n        void assign(_InputIter __f, _InputIter __l,\n                    typename enable_if<__is_input_iterator<_InputIter>::value &&\n                                      !__is_random_access_iterator<_InputIter>::value>::type* = 0);\n    template <class _RAIter>\n        void assign(_RAIter __f, _RAIter __l,\n                    typename enable_if<__is_random_access_iterator<_RAIter>::value>::type* = 0);\n    void assign(size_type __n, const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il) {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    allocator_type get_allocator() const _NOEXCEPT;\n\n    // iterators:\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT       {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT         {return __base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT {return __base::end();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(__base::begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(__base::begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __base::begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __base::end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return const_reverse_iterator(__base::end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return const_reverse_iterator(__base::begin());}\n\n    // capacity:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT {return __base::size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n        {return __alloc_traits::max_size(__base::__alloc());}\n    void resize(size_type __n);\n    void resize(size_type __n, const value_type& __v);\n    void shrink_to_fit() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT {return __base::size() == 0;}\n\n    // element access:\n    reference operator[](size_type __i);\n    const_reference operator[](size_type __i) const;\n    reference at(size_type __i);\n    const_reference at(size_type __i) const;\n    reference front();\n    const_reference front() const;\n    reference back();\n    const_reference back() const;\n\n    // 23.2.2.3 modifiers:\n    void push_front(const value_type& __v);\n    void push_back(const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args> void emplace_front(_Args&&... __args);\n    template <class... _Args> void emplace_back(_Args&&... __args);\n    template <class... _Args> iterator emplace(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    void push_front(value_type&& __v);\n    void push_back(value_type&& __v);\n    iterator insert(const_iterator __p, value_type&& __v);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __p, const value_type& __v);\n    iterator insert(const_iterator __p, size_type __n, const value_type& __v);\n    template <class _InputIter>\n        iterator insert (const_iterator __p, _InputIter __f, _InputIter __l,\n                         typename enable_if<__is_input_iterator<_InputIter>::value\n                                         &&!__is_bidirectional_iterator<_InputIter>::value>::type* = 0);\n    template <class _BiIter>\n        iterator insert (const_iterator __p, _BiIter __f, _BiIter __l,\n                         typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, initializer_list<value_type> __il)\n        {return insert(__p, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    void pop_front();\n    void pop_back();\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __f, const_iterator __l);\n\n    void swap(deque& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n    void clear() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __invariants() const {return __base::__invariants();}\nprivate:\n    typedef typename __base::__map_const_pointer __map_const_pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __recommend_blocks(size_type __n)\n    {\n        return __n / __base::__block_size + (__n % __base::__block_size != 0);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __capacity() const\n    {\n        return __base::__map_.size() == 0 ? 0 : __base::__map_.size() * __base::__block_size - 1;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __front_spare() const\n    {\n        return __base::__start_;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __back_spare() const\n    {\n        return __capacity() - (__base::__start_ + __base::size());\n    }\n\n    template <class _InpIter>\n        void __append(_InpIter __f, _InpIter __l,\n                 typename enable_if<__is_input_iterator<_InpIter>::value &&\n                                   !__is_forward_iterator<_InpIter>::value>::type* = 0);\n    template <class _ForIter>\n        void __append(_ForIter __f, _ForIter __l,\n                      typename enable_if<__is_forward_iterator<_ForIter>::value>::type* = 0);\n    void __append(size_type __n);\n    void __append(size_type __n, const value_type& __v);\n    void __erase_to_end(const_iterator __f);\n    void __add_front_capacity();\n    void __add_front_capacity(size_type __n);\n    void __add_back_capacity();\n    void __add_back_capacity(size_type __n);\n    iterator __move_and_check(iterator __f, iterator __l, iterator __r,\n                              const_pointer& __vt);\n    iterator __move_backward_and_check(iterator __f, iterator __l, iterator __r,\n                                       const_pointer& __vt);\n    void __move_construct_and_check(iterator __f, iterator __l,\n                                    iterator __r, const_pointer& __vt);\n    void __move_construct_backward_and_check(iterator __f, iterator __l,\n                                             iterator __r, const_pointer& __vt);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque& __c, true_type)\n        {\n            if (__base::__alloc() != __c.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __base::__alloc() = __c.__alloc();\n            __base::__map_.__alloc() = __c.__map_.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const deque&, false_type)\n        {}\n\n    void __move_assign(deque& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(deque& __c, false_type);\n};\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n)\n{\n    if (__n > 0)\n        __append(__n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const _Allocator& __a)\n    : __base(__a)\n{\n    if (__n > 0)\n        __append(__n);\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v)\n{\n    if (__n > 0)\n        __append(__n, __v);\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(size_type __n, const value_type& __v, const allocator_type& __a)\n    : __base(__a)\n{\n    if (__n > 0)\n        __append(__n, __v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ndeque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)\n{\n    __append(__f, __l);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ndeque<_Tp, _Allocator>::deque(_InputIter __f, _InputIter __l, const allocator_type& __a,\n              typename enable_if<__is_input_iterator<_InputIter>::value>::type*)\n    : __base(__a)\n{\n    __append(__f, __l);\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(const deque& __c)\n    : __base(__alloc_traits::select_on_container_copy_construction(__c.__alloc()))\n{\n    __append(__c.begin(), __c.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(const deque& __c, const allocator_type& __a)\n    : __base(__a)\n{\n    __append(__c.begin(), __c.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(initializer_list<value_type> __il)\n{\n    __append(__il.begin(), __il.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>::deque(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n    __append(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ndeque<_Tp, _Allocator>&\ndeque<_Tp, _Allocator>::operator=(const deque& __c)\n{\n    if (this != &__c)\n    {\n        __copy_assign_alloc(__c);\n        assign(__c.begin(), __c.end());\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ndeque<_Tp, _Allocator>::deque(deque&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<__base>::value)\n    : __base(_VSTD::move(__c))\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ndeque<_Tp, _Allocator>::deque(deque&& __c, const allocator_type& __a)\n    : __base(_VSTD::move(__c), __a)\n{\n    if (__a != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ndeque<_Tp, _Allocator>&\ndeque<_Tp, _Allocator>::operator=(deque&& __c)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__c, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_assign(deque& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_assign(deque& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __base::__move_assign(__c);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\nvoid\ndeque<_Tp, _Allocator>::assign(_InputIter __f, _InputIter __l,\n                               typename enable_if<__is_input_iterator<_InputIter>::value &&\n                                                 !__is_random_access_iterator<_InputIter>::value>::type*)\n{\n    iterator __i = __base::begin();\n    iterator __e = __base::end();\n    for (; __f != __l && __i != __e; ++__f, ++__i)\n        *__i = *__f;\n    if (__f != __l)\n        __append(__f, __l);\n    else\n        __erase_to_end(__i);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _RAIter>\nvoid\ndeque<_Tp, _Allocator>::assign(_RAIter __f, _RAIter __l,\n                               typename enable_if<__is_random_access_iterator<_RAIter>::value>::type*)\n{\n    if (static_cast<size_type>(__l - __f) > __base::size())\n    {\n        _RAIter __m = __f + __base::size();\n        _VSTD::copy(__f, __m, __base::begin());\n        __append(__m, __l);\n    }\n    else\n        __erase_to_end(_VSTD::copy(__f, __l, __base::begin()));\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::assign(size_type __n, const value_type& __v)\n{\n    if (__n > __base::size())\n    {\n        _VSTD::fill_n(__base::begin(), __base::size(), __v);\n        __n -= __base::size();\n        __append(__n, __v);\n    }\n    else\n        __erase_to_end(_VSTD::fill_n(__base::begin(), __n, __v));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n_Allocator\ndeque<_Tp, _Allocator>::get_allocator() const _NOEXCEPT\n{\n    return __base::__alloc();\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::resize(size_type __n)\n{\n    if (__n > __base::size())\n        __append(__n - __base::size());\n    else if (__n < __base::size())\n        __erase_to_end(__base::begin() + __n);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::resize(size_type __n, const value_type& __v)\n{\n    if (__n > __base::size())\n        __append(__n - __base::size(), __v);\n    else if (__n < __base::size())\n        __erase_to_end(__base::begin() + __n);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    allocator_type& __a = __base::__alloc();\n    if (empty())\n    {\n        while (__base::__map_.size() > 0)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n        __base::__start_ = 0;\n    }\n    else\n    {\n        if (__front_spare() >= __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n            __base::__map_.pop_front();\n            __base::__start_ -= __base::__block_size;\n        }\n        if (__back_spare() >= __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n    __base::__map_.shrink_to_fit();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::operator[](size_type __i)\n{\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::operator[](size_type __i) const\n{\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::at(size_type __i)\n{\n    if (__i >= __base::size())\n        __base::__throw_out_of_range();\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::at(size_type __i) const\n{\n    if (__i >= __base::size())\n        __base::__throw_out_of_range();\n    size_type __p = __base::__start_ + __i;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::front()\n{\n    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)\n                                      + __base::__start_ % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::front() const\n{\n    return *(*(__base::__map_.begin() + __base::__start_ / __base::__block_size)\n                                      + __base::__start_ % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::reference\ndeque<_Tp, _Allocator>::back()\n{\n    size_type __p = __base::size() + __base::__start_ - 1;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename deque<_Tp, _Allocator>::const_reference\ndeque<_Tp, _Allocator>::back() const\n{\n    size_type __p = __base::size() + __base::__start_ - 1;\n    return *(*(__base::__map_.begin() + __p / __base::__block_size) + __p % __base::__block_size);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_back(const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), __v);\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_back(value_type&& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::move(__v));\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\ndeque<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() == 0)\n        __add_back_capacity();\n    // __back_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);\n    ++__base::size();\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_front(const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);\n    --__base::__start_;\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::push_front(value_type&& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::move(__v));\n    --__base::__start_;\n    ++__base::size();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\ndeque<_Tp, _Allocator>::emplace_front(_Args&&... __args)\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() == 0)\n        __add_front_capacity();\n    // __front_spare() >= 1\n    __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::forward<_Args>(__args)...);\n    --__base::__start_;\n    ++__base::size();\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, const value_type& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), __v);\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            if (__vt == pointer_traits<const_pointer>::pointer_to(*__b))\n                __vt = pointer_traits<const_pointer>::pointer_to(*__bm1);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = __move_and_check(_VSTD::next(__b), __b + __pos, __b, __vt);\n            *__b = *__vt;\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), __v);\n            ++__base::size();\n        }\n        else\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            if (__vt == pointer_traits<const_pointer>::pointer_to(*__em1))\n                __vt = pointer_traits<const_pointer>::pointer_to(*__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = __move_backward_and_check(__e - __de, __em1, __e, __vt);\n            *--__e = *__vt;\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, value_type&& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::move(__v));\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = _VSTD::move(_VSTD::next(__b), __b + __pos, __b);\n            *__b = _VSTD::move(__v);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::move(__v));\n            ++__base::size();\n        }\n        else\n        {\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = _VSTD::move_backward(__e - __de, __em1, __e);\n            *--__e = _VSTD::move(__v);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::emplace(const_iterator __p, _Args&&... __args)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__front_spare() == 0)\n            __add_front_capacity();\n        // __front_spare() >= 1\n        if (__pos == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__base::begin()), _VSTD::forward<_Args>(__args)...);\n            --__base::__start_;\n            ++__base::size();\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            iterator __b = __base::begin();\n            iterator __bm1 = _VSTD::prev(__b);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__bm1), _VSTD::move(*__b));\n            --__base::__start_;\n            ++__base::size();\n            if (__pos > 1)\n                __b = _VSTD::move(_VSTD::next(__b), __b + __pos, __b);\n            *__b = _VSTD::move(__tmp);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        if (__back_spare() == 0)\n            __add_back_capacity();\n        // __back_capacity >= 1\n        size_type __de = __base::size() - __pos;\n        if (__de == 0)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);\n            ++__base::size();\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            iterator __e = __base::end();\n            iterator __em1 = _VSTD::prev(__e);\n            __alloc_traits::construct(__a, _VSTD::addressof(*__e), _VSTD::move(*__em1));\n            ++__base::size();\n            if (__de > 1)\n                __e = _VSTD::move_backward(__e - __de, __em1, __e);\n            *--__e = _VSTD::move(__tmp);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, size_type __n, const value_type& __v)\n{\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__n > __front_spare())\n            __add_front_capacity(__n - __front_spare());\n        // __n <= __front_spare()\n        size_type __old_n = __n;\n        iterator __old_begin = __base::begin();\n        iterator __i = __old_begin;\n        if (__n > __pos)\n        {\n            for (size_type __m = __n - __pos; __m; --__m, --__base::__start_, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), __v);\n            __n = __pos;\n        }\n        if (__n > 0)\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __obn = __old_begin + __n;\n            __move_construct_backward_and_check(__old_begin, __obn, __i, __vt);\n            if (__n < __pos)\n                __old_begin = __move_and_check(__obn, __old_begin + __pos, __old_begin, __vt);\n            _VSTD::fill_n(__old_begin, __n, *__vt);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        size_type __back_capacity = __back_spare();\n        if (__n > __back_capacity)\n            __add_back_capacity(__n - __back_capacity);\n        // __n <= __back_capacity\n        size_type __old_n = __n;\n        iterator __old_end = __base::end();\n        iterator __i = __old_end;\n        size_type __de = __base::size() - __pos;\n        if (__n > __de)\n        {\n            for (size_type __m = __n - __de; __m; --__m, ++__i, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);\n            __n = __de;\n        }\n        if (__n > 0)\n        {\n            const_pointer __vt = pointer_traits<const_pointer>::pointer_to(__v);\n            iterator __oen = __old_end - __n;\n            __move_construct_and_check(__oen, __old_end, __i, __vt);\n            if (__n < __de)\n                __old_end = __move_backward_and_check(__old_end - __de, __oen, __old_end, __vt);\n            _VSTD::fill_n(__old_end - __n, __n, *__vt);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, _InputIter __f, _InputIter __l,\n                               typename enable_if<__is_input_iterator<_InputIter>::value\n                                               &&!__is_bidirectional_iterator<_InputIter>::value>::type*)\n{\n    __split_buffer<value_type, allocator_type&> __buf(__base::__alloc());\n    __buf.__construct_at_end(__f, __l);\n    typedef typename __split_buffer<value_type, allocator_type&>::iterator __bi;\n    return insert(__p, move_iterator<__bi>(__buf.begin()), move_iterator<__bi>(__buf.end()));\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _BiIter>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::insert(const_iterator __p, _BiIter __f, _BiIter __l,\n                               typename enable_if<__is_bidirectional_iterator<_BiIter>::value>::type*)\n{\n    size_type __n = _VSTD::distance(__f, __l);\n    size_type __pos = __p - __base::begin();\n    size_type __to_end = __base::size() - __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < __to_end)\n    {   // insert by shifting things backward\n        if (__n > __front_spare())\n            __add_front_capacity(__n - __front_spare());\n        // __n <= __front_spare()\n        size_type __old_n = __n;\n        iterator __old_begin = __base::begin();\n        iterator __i = __old_begin;\n        _BiIter __m = __f;\n        if (__n > __pos)\n        {\n            __m = __pos < __n / 2 ? _VSTD::prev(__l, __pos) : _VSTD::next(__f, __n - __pos);\n            for (_BiIter __j = __m; __j != __f; --__base::__start_, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), *--__j);\n            __n = __pos;\n        }\n        if (__n > 0)\n        {\n            iterator __obn = __old_begin + __n;\n            for (iterator __j = __obn; __j != __old_begin;)\n            {\n                __alloc_traits::construct(__a, _VSTD::addressof(*--__i), _VSTD::move(*--__j));\n                --__base::__start_;\n                ++__base::size();\n            }\n            if (__n < __pos)\n                __old_begin = _VSTD::move(__obn, __old_begin + __pos, __old_begin);\n            _VSTD::copy(__m, __l, __old_begin);\n        }\n    }\n    else\n    {   // insert by shifting things forward\n        size_type __back_capacity = __back_spare();\n        if (__n > __back_capacity)\n            __add_back_capacity(__n - __back_capacity);\n        // __n <= __back_capacity\n        size_type __old_n = __n;\n        iterator __old_end = __base::end();\n        iterator __i = __old_end;\n        _BiIter __m = __l;\n        size_type __de = __base::size() - __pos;\n        if (__n > __de)\n        {\n            __m = __de < __n / 2 ? _VSTD::next(__f, __de) : _VSTD::prev(__l, __n - __de);\n            for (_BiIter __j = __m; __j != __l; ++__i, ++__j, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), *__j);\n            __n = __de;\n        }\n        if (__n > 0)\n        {\n            iterator __oen = __old_end - __n;\n            for (iterator __j = __oen; __j != __old_end; ++__i, ++__j, ++__base::size())\n                __alloc_traits::construct(__a, _VSTD::addressof(*__i), _VSTD::move(*__j));\n            if (__n < __de)\n                __old_end = _VSTD::move_backward(__old_end - __de, __oen, __old_end);\n            _VSTD::copy_backward(__f, __m, __old_end);\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InpIter>\nvoid\ndeque<_Tp, _Allocator>::__append(_InpIter __f, _InpIter __l,\n                                 typename enable_if<__is_input_iterator<_InpIter>::value &&\n                                                   !__is_forward_iterator<_InpIter>::value>::type*)\n{\n    for (; __f != __l; ++__f)\n        push_back(*__f);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForIter>\nvoid\ndeque<_Tp, _Allocator>::__append(_ForIter __f, _ForIter __l,\n                                 typename enable_if<__is_forward_iterator<_ForIter>::value>::type*)\n{\n    size_type __n = _VSTD::distance(__f, __l);\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __f != __l; ++__i, ++__f, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i), *__f);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__append(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i));\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__append(size_type __n, const value_type& __v)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __back_capacity = __back_spare();\n    if (__n > __back_capacity)\n        __add_back_capacity(__n - __back_capacity);\n    // __n <= __back_capacity\n    for (iterator __i = __base::end(); __n; --__n, ++__i, ++__base::size())\n        __alloc_traits::construct(__a, _VSTD::addressof(*__i), __v);\n}\n\n// Create front capacity for one block of elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_front_capacity()\n{\n    allocator_type& __a = __base::__alloc();\n    if (__back_spare() >= __base::__block_size)\n    {\n        __base::__start_ += __base::__block_size;\n        pointer __pt = __base::__map_.back();\n        __base::__map_.pop_back();\n        __base::__map_.push_front(__pt);\n    }\n    // Else if __base::__map_.size() < __base::__map_.capacity() then we need to allocate 1 buffer\n    else if (__base::__map_.size() < __base::__map_.capacity())\n    {   // we can put the new buffer into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        if (__base::__map_.__front_spare() > 0)\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        else\n        {\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n            // Done allocating, reorder capacity\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n        __base::__start_ = __base::__map_.size() == 1 ?\n                               __base::__block_size / 2 :\n                               __base::__start_ + __base::__block_size;\n    }\n    // Else need to allocate 1 buffer, *and* we need to reallocate __map_.\n    else\n    {\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2 * __base::__map_.capacity(), 1),\n                  0, __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __alloc_traits::deallocate(__a, __buf.front(), __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (typename __base::__map_pointer __i = __base::__map_.begin();\n                __i != __base::__map_.end(); ++__i)\n            __buf.push_back(*__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ = __base::__map_.size() == 1 ?\n                               __base::__block_size / 2 :\n                               __base::__start_ + __base::__block_size;\n    }\n}\n\n// Create front capacity for __n elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_front_capacity(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());\n    // Number of unused blocks at back:\n    size_type __back_capacity = __back_spare() / __base::__block_size;\n    __back_capacity = _VSTD::min(__back_capacity, __nb);  // don't take more than you need\n    __nb -= __back_capacity;  // number of blocks need to allocate\n    // If __nb == 0, then we have sufficient capacity.\n    if (__nb == 0)\n    {\n        __base::__start_ += __base::__block_size * __back_capacity;\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())\n    {   // we can put the new buffers into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        for (; __nb > 0; --__nb, __base::__start_ += __base::__block_size - (__base::__map_.size() == 1))\n        {\n            if (__base::__map_.__front_spare() == 0)\n                break;\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        }\n        for (; __nb > 0; --__nb, ++__back_capacity)\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        // Done allocating, reorder capacity\n        __base::__start_ += __back_capacity * __base::__block_size;\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            pointer __pt = __base::__map_.back();\n            __base::__map_.pop_back();\n            __base::__map_.push_front(__pt);\n        }\n    }\n    // Else need to allocate __nb buffers, *and* we need to reallocate __map_.\n    else\n    {\n        size_type __ds = (__nb + __back_capacity) * __base::__block_size - __base::__map_.empty();\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(),\n                                 __nb + __base::__map_.size()),\n                  0, __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __nb > 0; --__nb)\n                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            for (typename __base::__map_pointer __i = __buf.begin();\n                    __i != __buf.end(); ++__i)\n                __alloc_traits::deallocate(__a, *__i, __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __back_capacity > 0; --__back_capacity)\n        {\n            __buf.push_back(__base::__map_.back());\n            __base::__map_.pop_back();\n        }\n        for (typename __base::__map_pointer __i = __base::__map_.begin();\n                __i != __base::__map_.end(); ++__i)\n            __buf.push_back(*__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ += __ds;\n    }\n}\n\n// Create back capacity for one block of elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_back_capacity()\n{\n    allocator_type& __a = __base::__alloc();\n    if (__front_spare() >= __base::__block_size)\n    {\n        __base::__start_ -= __base::__block_size;\n        pointer __pt = __base::__map_.front();\n        __base::__map_.pop_front();\n        __base::__map_.push_back(__pt);\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__base::__map_.size() < __base::__map_.capacity())\n    {   // we can put the new buffer into the map, but don't shift things around\n        // until it is allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        if (__base::__map_.__back_spare() != 0)\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        else\n        {\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n            // Done allocating, reorder capacity\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else need to allocate 1 buffer, *and* we need to reallocate __map_.\n    else\n    {\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(), 1),\n                  __base::__map_.size(),\n                  __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __alloc_traits::deallocate(__a, __buf.back(), __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (typename __base::__map_pointer __i = __base::__map_.end();\n                __i != __base::__map_.begin();)\n            __buf.push_front(*--__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n    }\n}\n\n// Create back capacity for __n elements.\n// Strong guarantee.  Either do it or don't touch anything.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__add_back_capacity(size_type __n)\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __nb = __recommend_blocks(__n + __base::__map_.empty());\n    // Number of unused blocks at front:\n    size_type __front_capacity = __front_spare() / __base::__block_size;\n    __front_capacity = _VSTD::min(__front_capacity, __nb);  // don't take more than you need\n    __nb -= __front_capacity;  // number of blocks need to allocate\n    // If __nb == 0, then we have sufficient capacity.\n    if (__nb == 0)\n    {\n        __base::__start_ -= __base::__block_size * __front_capacity;\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else if __nb <= __map_.capacity() - __map_.size() then we need to allocate __nb buffers\n    else if (__nb <= __base::__map_.capacity() - __base::__map_.size())\n    {   // we can put the new buffers into the map, but don't shift things around\n        // until all buffers are allocated.  If we throw, we don't need to fix\n        // anything up (any added buffers are undetectible)\n        for (; __nb > 0; --__nb)\n        {\n            if (__base::__map_.__back_spare() == 0)\n                break;\n            __base::__map_.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n        }\n        for (; __nb > 0; --__nb, ++__front_capacity, __base::__start_ +=\n                                 __base::__block_size - (__base::__map_.size() == 1))\n            __base::__map_.push_front(__alloc_traits::allocate(__a, __base::__block_size));\n        // Done allocating, reorder capacity\n        __base::__start_ -= __base::__block_size * __front_capacity;\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            pointer __pt = __base::__map_.front();\n            __base::__map_.pop_front();\n            __base::__map_.push_back(__pt);\n        }\n    }\n    // Else need to allocate __nb buffers, *and* we need to reallocate __map_.\n    else\n    {\n        size_type __ds = __front_capacity * __base::__block_size;\n        __split_buffer<pointer, typename __base::__pointer_allocator&>\n            __buf(max<size_type>(2* __base::__map_.capacity(),\n                                 __nb + __base::__map_.size()),\n                  __base::__map_.size() - __front_capacity,\n                  __base::__map_.__alloc());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __nb > 0; --__nb)\n                __buf.push_back(__alloc_traits::allocate(__a, __base::__block_size));\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            for (typename __base::__map_pointer __i = __buf.begin();\n                    __i != __buf.end(); ++__i)\n                __alloc_traits::deallocate(__a, *__i, __base::__block_size);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __front_capacity > 0; --__front_capacity)\n        {\n            __buf.push_back(__base::__map_.front());\n            __base::__map_.pop_front();\n        }\n        for (typename __base::__map_pointer __i = __base::__map_.end();\n                __i != __base::__map_.begin();)\n            __buf.push_front(*--__i);\n        _VSTD::swap(__base::__map_.__first_, __buf.__first_);\n        _VSTD::swap(__base::__map_.__begin_, __buf.__begin_);\n        _VSTD::swap(__base::__map_.__end_, __buf.__end_);\n        _VSTD::swap(__base::__map_.__end_cap(), __buf.__end_cap());\n        __base::__start_ -= __ds;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::pop_front()\n{\n    allocator_type& __a = __base::__alloc();\n    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +\n                                                    __base::__start_ / __base::__block_size) +\n                                                    __base::__start_ % __base::__block_size));\n    --__base::size();\n    if (++__base::__start_ >= 2 * __base::__block_size)\n    {\n        __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n        __base::__map_.pop_front();\n        __base::__start_ -= __base::__block_size;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::pop_back()\n{\n    allocator_type& __a = __base::__alloc();\n    size_type __p = __base::size() + __base::__start_ - 1;\n    __alloc_traits::destroy(__a, __to_raw_pointer(*(__base::__map_.begin() +\n                                                    __p / __base::__block_size) +\n                                                    __p % __base::__block_size));\n    --__base::size();\n    if (__back_spare() >= 2 * __base::__block_size)\n    {\n        __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n        __base::__map_.pop_back();\n    }\n}\n\n// move assign [__f, __l) to [__r, __r + (__l-__f)).\n// If __vt points into [__f, __l), then subtract (__f - __r) from __vt.\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::__move_and_check(iterator __f, iterator __l, iterator __r,\n                                         const_pointer& __vt)\n{\n    // as if\n    //   for (; __f != __l; ++__f, ++__r)\n    //       *__r = _VSTD::move(*__f);\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __base::__block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        if (__fb <= __vt && __vt < __fe)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) -= __f - __r).__ptr_;\n        __r = _VSTD::move(__fb, __fe, __r);\n        __n -= __bs;\n        __f += __bs;\n    }\n    return __r;\n}\n\n// move assign [__f, __l) to [__r - (__l-__f), __r) backwards.\n// If __vt points into [__f, __l), then add (__r - __l) to __vt.\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::__move_backward_and_check(iterator __f, iterator __l, iterator __r,\n                                                  const_pointer& __vt)\n{\n    // as if\n    //   while (__f != __l)\n    //       *--__r = _VSTD::move(*--__l);\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        if (__lb <= __vt && __vt < __le)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) += __r - __l - 1).__ptr_;\n        __r = _VSTD::move_backward(__lb, __le, __r);\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n    return __r;\n}\n\n// move construct [__f, __l) to [__r, __r + (__l-__f)).\n// If __vt points into [__f, __l), then add (__r - __f) to __vt.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_construct_and_check(iterator __f, iterator __l,\n                                                   iterator __r, const_pointer& __vt)\n{\n    allocator_type& __a = __base::__alloc();\n    // as if\n    //   for (; __f != __l; ++__r, ++__f, ++__base::size())\n    //       __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__f));\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        pointer __fb = __f.__ptr_;\n        pointer __fe = *__f.__m_iter_ + __base::__block_size;\n        difference_type __bs = __fe - __fb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __fe = __fb + __bs;\n        }\n        if (__fb <= __vt && __vt < __fe)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__f.__m_iter_), __vt) += __r - __f).__ptr_;\n        for (; __fb != __fe; ++__fb, ++__r, ++__base::size())\n            __alloc_traits::construct(__a, _VSTD::addressof(*__r), _VSTD::move(*__fb));\n        __n -= __bs;\n        __f += __bs;\n    }\n}\n\n// move construct [__f, __l) to [__r - (__l-__f), __r) backwards.\n// If __vt points into [__f, __l), then subtract (__l - __r) from __vt.\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__move_construct_backward_and_check(iterator __f, iterator __l,\n                                                            iterator __r, const_pointer& __vt)\n{\n    allocator_type& __a = __base::__alloc();\n    // as if\n    //   for (iterator __j = __l; __j != __f;)\n    //   {\n    //       __alloc_traitsconstruct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__j));\n    //       --__base::__start_;\n    //       ++__base::size();\n    //   }\n    difference_type __n = __l - __f;\n    while (__n > 0)\n    {\n        --__l;\n        pointer __lb = *__l.__m_iter_;\n        pointer __le = __l.__ptr_ + 1;\n        difference_type __bs = __le - __lb;\n        if (__bs > __n)\n        {\n            __bs = __n;\n            __lb = __le - __bs;\n        }\n        if (__lb <= __vt && __vt < __le)\n            __vt = (const_iterator(static_cast<__map_const_pointer>(__l.__m_iter_), __vt) -= __l - __r + 1).__ptr_;\n        while (__le != __lb)\n        {\n            __alloc_traits::construct(__a, _VSTD::addressof(*--__r), _VSTD::move(*--__le));\n            --__base::__start_;\n            ++__base::size();\n        }\n        __n -= __bs;\n        __l -= __bs - 1;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::erase(const_iterator __f)\n{\n    difference_type __n = 1;\n    iterator __b = __base::begin();\n    difference_type __pos = __f - __b;\n    iterator __p = __b + __pos;\n    allocator_type& __a = __base::__alloc();\n    if (__pos < (__base::size() - 1) / 2)\n    {   // erase from front\n        _VSTD::move_backward(__b, __p, _VSTD::next(__p));\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__b));\n        --__base::size();\n        ++__base::__start_;\n        if (__front_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n            __base::__map_.pop_front();\n            __base::__start_ -= __base::__block_size;\n        }\n    }\n    else\n    {   // erase from back\n        iterator __i = _VSTD::move(_VSTD::next(__p), __base::end(), __p);\n        __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n        --__base::size();\n        if (__back_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename deque<_Tp, _Allocator>::iterator\ndeque<_Tp, _Allocator>::erase(const_iterator __f, const_iterator __l)\n{\n    difference_type __n = __l - __f;\n    iterator __b = __base::begin();\n    difference_type __pos = __f - __b;\n    iterator __p = __b + __pos;\n    if (__n > 0)\n    {\n        allocator_type& __a = __base::__alloc();\n        if (__pos < (__base::size() - __n) / 2)\n        {   // erase from front\n            iterator __i = _VSTD::move_backward(__b, __p, __p + __n);\n            for (; __b != __i; ++__b)\n                __alloc_traits::destroy(__a, _VSTD::addressof(*__b));\n            __base::size() -= __n;\n            __base::__start_ += __n;\n            while (__front_spare() >= 2 * __base::__block_size)\n            {\n                __alloc_traits::deallocate(__a, __base::__map_.front(), __base::__block_size);\n                __base::__map_.pop_front();\n                __base::__start_ -= __base::__block_size;\n            }\n        }\n        else\n        {   // erase from back\n            iterator __i = _VSTD::move(__p + __n, __base::end(), __p);\n            for (iterator __e = __base::end(); __i != __e; ++__i)\n                __alloc_traits::destroy(__a, _VSTD::addressof(*__i));\n            __base::size() -= __n;\n            while (__back_spare() >= 2 * __base::__block_size)\n            {\n                __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n                __base::__map_.pop_back();\n            }\n        }\n    }\n    return __base::begin() + __pos;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\ndeque<_Tp, _Allocator>::__erase_to_end(const_iterator __f)\n{\n    iterator __e = __base::end();\n    difference_type __n = __e - __f;\n    if (__n > 0)\n    {\n        allocator_type& __a = __base::__alloc();\n        iterator __b = __base::begin();\n        difference_type __pos = __f - __b;\n        for (iterator __p = __b + __pos; __p != __e; ++__p)\n            __alloc_traits::destroy(__a, _VSTD::addressof(*__p));\n        __base::size() -= __n;\n        while (__back_spare() >= 2 * __base::__block_size)\n        {\n            __alloc_traits::deallocate(__a, __base::__map_.back(), __base::__block_size);\n            __base::__map_.pop_back();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ndeque<_Tp, _Allocator>::swap(deque& __c)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    __base::swap(__c);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ndeque<_Tp, _Allocator>::clear() _NOEXCEPT\n{\n    __base::clear();\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    const typename deque<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const deque<_Tp, _Allocator>& __x, const deque<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(deque<_Tp, _Allocator>& __x, deque<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_DEQUE\n","/* \n *  Copyright 2010-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <cassert>\n\n#include <boost/foreach.hpp>\n#include <boost/math/tools/roots.hpp> // for toms748\n#include <boost/tuple/tuple.hpp>\n#include <boost/assign/list_of.hpp>\n\n#include \"voronoidiagram.hpp\"\n\n#include \"checker.hpp\"\n#include \"common/numeric.hpp\" // for diangle\n\nnamespace ovd {\n\n/// \\brief create a VoronoiDiagram\n/// \\param far is the radius of a circle within which all sites must be located. use far==1.0\n/// \\param n_bins is the number of bins for FaceGrid, the bucket-search for nearest-neighbors \n///        used in insert_point_site(). Use roughly sqrt(N) for a voronoi-diagram with N sites.\nVoronoiDiagram::VoronoiDiagram(double far, unsigned int n_bins) {\n    //fgrid = new FaceGrid(far, n_bins); // helper-class for nearest-neighbor search \n    kd_tree = new kdtree::KDTree<kd_point>(2);\n    \n    vd_checker = new VoronoiDiagramChecker( g ); // helper-class that checks topology/geometry\n     \n    vpos = new VertexPositioner( g ); // helper-class that positions vertices\n    far_radius=far;\n    initialize();\n    num_psites=3;\n    num_lsites=0;\n    num_asites=0;\n    reset_vertex_count();\n    debug = false;\n}\n\n/// \\brief delete allocated resources: FaceGrid, checker, positioner\nVoronoiDiagram::~VoronoiDiagram() { \n    //std::cout << \"~VoronoiDiagram()\\n\";\n    //delete fgrid; \n    delete kd_tree;\n    delete vpos;\n    delete vd_checker;\n    \n    //std::cout << \"~VoronoiDiagram() DONE.\\n\";\n}\n\n/// \\brief initialize the diagram with three generators\n///\n/// add one vertex at origo and three vertices at 'infinity' and their associated edges\nvoid VoronoiDiagram::initialize() {\n    using namespace boost::assign;\n    double far_multiplier = 6;\n    // initial generators/sites:\n    Point gen1 = Point( 0, 3.0*far_radius );\n    Point gen2 = Point( -3.0*sqrt(3.0)*far_radius/2.0, -3.0*far_radius/2.0 );\n    Point gen3 = Point( +3.0*sqrt(3.0)*far_radius/2.0, -3.0*far_radius/2.0 );\n    // initial vd-vertices\n    Point vd1 = Point(            0                 , -3.0*far_radius*far_multiplier    );\n    Point vd2 = Point( +3.0*sqrt(3.0)*far_radius*far_multiplier/2.0, +3.0*far_radius*far_multiplier/2.0);\n    Point vd3 = Point( -3.0*sqrt(3.0)*far_radius*far_multiplier/2.0, +3.0*far_radius*far_multiplier/2.0);\n    // add init vertices\n    HEVertex v00 = g.add_vertex( VoronoiVertex( Point(0,0), UNDECIDED, NORMAL, gen1 ) );\n    HEVertex v01 = g.add_vertex( VoronoiVertex( vd1, OUT, OUTER, gen3) );\n    HEVertex v02 = g.add_vertex( VoronoiVertex( vd2, OUT, OUTER, gen1) );\n    HEVertex v03 = g.add_vertex( VoronoiVertex( vd3, OUT, OUTER, gen2) );\n    // add initial sites to graph \n    HEVertex vert1 = g.add_vertex( VoronoiVertex( gen1 , OUT, POINTSITE) );\n    HEVertex vert2 = g.add_vertex( VoronoiVertex( gen2 , OUT, POINTSITE) );\n    HEVertex vert3 = g.add_vertex( VoronoiVertex( gen3 , OUT, POINTSITE) );\n\n    // apex-points on the three edges: \n    HEVertex a1 = g.add_vertex( VoronoiVertex( 0.5*(gen2+gen3), UNDECIDED, APEX, gen2 ) );\n    HEVertex a2 = g.add_vertex( VoronoiVertex( 0.5*(gen1+gen3), UNDECIDED, APEX, gen3 ) );\n    HEVertex a3 = g.add_vertex( VoronoiVertex( 0.5*(gen1+gen2), UNDECIDED, APEX, gen1 ) );\n\n    // add face 1: v0-v1-v2 which encloses gen3\n    HEEdge e1_1 =  g.add_edge( v00 , a1 );    \n    HEEdge e1_2 =  g.add_edge( a1 , v01 );   \n    HEEdge e2   =  g.add_edge( v01, v02 );\n    HEEdge e3_1 =  g.add_edge( v02, a2  ); \n    HEEdge e3_2 =  g.add_edge( a2 , v00 ); \n    HEFace f1   =  g.add_face(); \n    g[f1].site  = new PointSite(gen3,f1, vert3);\n    g[f1].status = NONINCIDENT;\n    //fgrid->add_face( f1, gen3 ); // for grid search\n    kd_tree->insert( kd_point(gen3,f1) );\n    g.set_next_cycle( list_of(e1_1)(e1_2)(e2)(e3_1)(e3_2) , f1 ,1);\n\n    // add face 2: v0-v02-v03 which encloses gen1\n    HEEdge e4_1 = g.add_edge( v00, a2  );\n    HEEdge e4_2 = g.add_edge( a2, v02 );\n    HEEdge e5   = g.add_edge( v02, v03  );\n    HEEdge e6_1 = g.add_edge( v03, a3 );\n    HEEdge e6_2 = g.add_edge( a3, v00 ); \n    HEFace f2   =  g.add_face();\n    g[f2].site  = new PointSite(gen1,f2, vert1);\n    g[f2].status = NONINCIDENT;    \n    //fgrid->add_face( f2, gen1 );\n    kd_tree->insert( kd_point(gen1,f2) );\n    g.set_next_cycle( list_of(e4_1)(e4_2)(e5)(e6_1)(e6_2) , f2 ,1);\n\n    // add face 3: v0-v3-v1 which encloses gen2\n    HEEdge e7_1 = g.add_edge( v00, a3 );  \n    HEEdge e7_2 = g.add_edge( a3 , v03 );   \n    HEEdge e8   = g.add_edge( v03, v01 );\n    HEEdge e9_1 = g.add_edge( v01, a1  ); \n    HEEdge e9_2 = g.add_edge( a1 , v00 ); \n    HEFace f3   =  g.add_face();\n    g[f3].site  = new PointSite(gen2,f3, vert2); // this constructor needs f3...\n    g[f3].status = NONINCIDENT;    \n    //fgrid->add_face( f3, gen2 );\n    kd_tree->insert( kd_point(gen2,f3) );\n    g.set_next_cycle( list_of(e7_1)(e7_2)(e8)(e9_1)(e9_2) , f3 , 1);    \n\n    // set type. \n    g[e1_1].type = LINE;  g[e1_1].set_parameters(g[f1].site, g[f3].site, false);\n    g[e1_2].type = LINE;  g[e1_2].set_parameters(g[f1].site, g[f3].site, true);\n    g[e2].type = OUTEDGE; \n    g[e3_1].type = LINE; g[e3_1].set_parameters(g[f2].site, g[f1].site, true);\n    g[e3_2].type = LINE; g[e3_2].set_parameters(g[f2].site, g[f1].site, false);\n    g[e4_1].type = LINE; g[e4_1].set_parameters(g[f2].site, g[f1].site, false);\n    g[e4_2].type = LINE; g[e4_2].set_parameters(g[f2].site, g[f1].site, true);\n    g[e5].type = OUTEDGE;\n    g[e6_1].type = LINE; g[e6_1].set_parameters(g[f2].site, g[f3].site, false);\n    g[e6_2].type = LINE; g[e6_2].set_parameters(g[f2].site, g[f3].site, true);\n    g[e7_1].type = LINE; g[e7_1].set_parameters(g[f2].site, g[f3].site, true);\n    g[e7_2].type = LINE; g[e7_2].set_parameters(g[f2].site, g[f3].site, false);\n    g[e8].type = OUTEDGE;\n    g[e9_1].type = LINE; g[e9_1].set_parameters(g[f1].site, g[f3].site, true);\n    g[e9_2].type = LINE; g[e9_2].set_parameters(g[f1].site, g[f3].site, false);\n    \n    // twin edges\n    g.twin_edges(e1_1,e9_2);\n    g.twin_edges(e1_2,e9_1);\n    g[e2].twin = HEEdge(); // the outermost edges have invalid twins\n    g[e5].twin = HEEdge();\n    g[e8].twin = HEEdge();\n    g.twin_edges(e3_1, e4_2);\n    g.twin_edges(e3_2, e4_1);\n    g.twin_edges(e6_1, e7_2);\n    g.twin_edges(e6_2, e7_1);\n    \n    assert( vd_checker->is_valid() );\n}\n\n\n/// \\brief insert a PointSite into the diagram \n///\n/// \\param p position of site\n/// \\param step (optional, for debugging) stop at this step\n/// \\return integer handle to the inserted point. use this integer when inserting lines/arcs with insert_line_site\n///\n/// \\details\n/// \\attention All PointSite:s must be inserted before any LineSite:s or ArcSite:s are inserted. \n/// \\attention It is an error to insert duplicate PointSite:s (i.e. points with the same x,y coordinates)\n///\n/// All PointSite:s must be inserted before any LineSite:s or ArcSite:s are inserted.\n/// This is roughly \"algorithm A\" from the Sugihara-Iri 1994 paper, page 15/50\n///\n/// -# find the face that is closest to the new site, see FaceGrid\n/// -# among the vertices on the closest face, find the seed vertex, see find_seed_vertex()\n/// -# grow the tree of IN-vertices, see augment_vertex_set()\n/// -# add new voronoi-vertices on all IN-OUT edges so they becone IN-NEW-OUT, see add_vertices()\n/// -# add new face by splitting each INCIDENT face into two parts by inserting a NEW-NEW edge. see add_edges()\n/// -# repair the next-pointers of faces that have been modified. see repair_face()\n/// -# remove IN-IN edges and IN-NEW edges, see remove_vertex_set()\n/// -# reset vertex/face status to be ready for next incremental operation, see reset_status()\nint VoronoiDiagram::insert_point_site(const Point& p, int step) {\n    num_psites++;\n    //int current_step=1;\n    if (p.norm() >= far_radius ) {\n        std::cout << \"openvoronoi error. All points must lie within unit-circle. You are trying to add p= \" << p \n        << \" with p.norm()= \" << p.norm() << \"\\n\";\n    } \n    assert( p.norm() < far_radius );     // only add vertices within the far_radius circle\n    \n    HEVertex new_vert = g.add_vertex( VoronoiVertex(p,OUT,POINTSITE) );\n    PointSite* new_site =  new PointSite(p);\n    new_site->v = new_vert;\n    vertex_map.insert( VertexMapPair(g[new_vert].index,new_vert) ); // so that we can find the descriptor later based on its index\n    std::pair<kd_point,bool> nearest = kd_tree->nearest( kd_point(p) );\n    assert( nearest.second );\n    HEVertex v_seed = find_seed_vertex( nearest.first.face , new_site);\n    mark_vertex( v_seed, new_site );\n//if (step==current_step) return -1; current_step++;\n    augment_vertex_set( new_site ); // grow the tree to maximum size\n//if (step==current_step) return -1; current_step++;\n    add_vertices( new_site );  // insert new vertices on IN-OUT edges\n//if (step==current_step) return -1; current_step++;\n    HEFace newface = add_face( new_site );\n    g[new_vert].face = newface; // Vertices that correspond to point-sites have their .face property set!\n    BOOST_FOREACH( HEFace f, incident_faces ) { // add NEW-NEW edges on all INCIDENT faces\n        add_edges(newface, f);\n    }\n//if (step==current_step) return -1; current_step++;\n    repair_face( newface  );\n    if (debug) { std::cout << \" new face: \"; g.print_face( newface ); }\n    remove_vertex_set(); // remove all IN vertices and adjacent edges\n//if (step==current_step) return -1; current_step++;\n    reset_status(); // reset all vertices to UNDECIDED\n \n    assert( vd_checker->face_ok( newface ) );\n    assert( vd_checker->is_valid() );\n \n    return g[new_vert].index;\n}\n\n/// \\brief insert a LineSite into the diagram\n///\n/// \\param idx1 int handle to startpoint of line-segment\n/// \\param idx2 int handle to endpoint of line-segment\n/// \\param step (optional, for debug) stop at step\n///\n/// \\details\n/// \\attention All PointSite:s must be inserted before any LineSite:s are inserted. \n///   All LineSite:s should be inserted before any ArcSite:s are inserted.\n/// \\attention It is an error to insert a LineSite that intersects an existing LineSite in the diagram!\n///\n/// The basic idea of the incremental diagram update is similar to that in insert_point_site().\n/// The major differences are:\n/// - the handling of null-faces at the endpoints of the LineSite.\n/// - addition of ::SEPARATOR edges\n/// - addition of ::SPLIT vertices during augment_vertex_set()\n/// - removal of ::SPLIT vertices at the end\n///\n/// The steps of the algorithm are:\n/// -# based on \\a idx1 and \\a idx2, look up the corresponding vertex descriptors. It is an error if these are not found.\n/// -# find a seed-vertex\n/// -# grow the delete-tree of ::IN vertices.\n/// -# create or modify the null-faces at the startpoint and endpoint of the LineSite\n/// -# create and add ::LINESITE pseudo-edges\n/// -# add ::NEW vertices on all ::IN-::OUT edges.\n/// -# add up to four ::SEPARATOR edges, where applicable\n/// -# add non-separator edges by calling add_edges() on all ::INCIDENT faces\n/// -# repair the next-pointers of faces that have been modified. see repair_face()\n/// -# remove IN-IN edges and IN-NEW edges, see remove_vertex_set()\n/// -# remove ::SPLIT vertices\n/// -# reset vertex/face status to be ready for next incremental operation, see reset_status()\nbool VoronoiDiagram::insert_line_site(int idx1, int idx2, int step) {\n    num_lsites++;\n    int current_step=1;\n    // find the vertices corresponding to idx1 and idx2\n    HEVertex start=HEVertex(), end=HEVertex();\n    boost::tie(start,end) = find_endpoints(idx1,idx2);\n    g[start].status=OUT;\n    g[end].status=OUT;   \n    g[start].zero_dist();\n    g[end].zero_dist();\n    \n    if (debug) std::cout << \"insert_line_site( \" << g[start].index << \" - \" << g[end].index << \" )\\n\";\n    \n    // create a point which is left of src->trg\n    // determine k (offset-dir) for this point\n    // then we know which site/face is the k==+1 and which is k==-1\n    Point src_se = g[start].position;\n    Point trg_se = g[end  ].position;\n    Point left = 0.5*(src_se+trg_se) + (trg_se-src_se).xy_perp(); // this is used below and in find_null_face()\n    #ifndef NDEBUG\n    bool linesite_k_sign = left.is_right(src_se,trg_se); \n    #endif\n    \nif (step==current_step) return false; current_step++;\n\n    LineSite* pos_site;\n    LineSite* neg_site;\n    assert(!linesite_k_sign);\n    // 2012-03-20: coverage testing shows this never happens:\n    //if ( linesite_k_sign ) {\n    //    pos_site = new LineSite( g[start].position, g[end  ].position , +1);\n    //    neg_site = new LineSite( g[end  ].position, g[start].position , -1);\n    //} else {\n    pos_site = new LineSite( g[end  ].position, g[start].position , +1);\n    neg_site = new LineSite( g[start].position, g[end  ].position , -1);\n    //}\n\nif (step==current_step) return false; current_step++;\n\n    HEFace seed_face = g[start].face; // assumes this point-site has a face!\n    \n    // on the face of start-point, find the seed vertex\n    HEVertex v_seed = find_seed_vertex(seed_face, pos_site ) ;\n    if (debug) std::cout << \" start face seed  = \" << g[v_seed].index << \"\\n\";\n    mark_vertex( v_seed, pos_site  );\n\nif (step==current_step) return false; current_step++;\n\n    augment_vertex_set( pos_site  ); // it should not matter if we use pos_site or neg_site here\n    // todo(?) sanity checks:\n    // check that end_face is INCIDENT? \n    // check that tree (i.e. v0) includes end_face_seed ?\n    if (debug) { std::cout << \" delete-set |v0|=\"<< v0.size() <<\" : \";  g.print_vertices(v0); }\n\nif (step==current_step) return false; current_step++;\n\n    // process the null-faces here\n    HEVertex seg_start, seg_end; // new segment end-point vertices. these are created here.\n    HEFace start_null_face, end_null_face; // either existing or new null-faces at endpoints\n    HEVertex pos_sep_start = HEVertex(); // optional positive separator vertex at start\n    HEVertex neg_sep_start = HEVertex(); // optional negative separator vertex at start \n    HEVertex pos_sep_end = HEVertex();   // optional positive separator vertex at end\n    HEVertex neg_sep_end = HEVertex();   // optional negative separator vertex at end\n    HEFace start_to_null = g.HFace(); // when a point-site completely disappears, we \"null\" the face belonging to this pointsite\n    HEFace   end_to_null = g.HFace();\n    // returns new seg_start/end vertices, new or existing null-faces, and separator endpoints (if separators should be added)\n    Point dir2 = g[start].position - g[end].position;\n    Point dir1 = g[end].position - g[start].position;\n    boost::tie(seg_start, start_null_face, pos_sep_start, neg_sep_start, start_to_null) = find_null_face(start, end  , left, dir1, pos_site);\n    boost::tie(seg_end  , end_null_face  , pos_sep_end  , neg_sep_end  , end_to_null  ) = find_null_face(end  , start, left, dir2, pos_site);\n\n    // now safe to set the zero-face edge\n    // in the collinear case, set the edge for the face that \"disappears\" to a null edge\n    if (start_to_null!=g.HFace())\n        g[start_to_null].edge = g[start_null_face].edge; \n    if (end_to_null!=g.HFace())\n        g[end_to_null].edge = g[end_null_face].edge; \n\nif (step==current_step) return false; current_step++;\n    // create LINESITE pseudo edges and faces\n    HEFace pos_face, neg_face; \n    HEEdge pos_edge, neg_edge;\n    {\n        // 2012-03-20: coverage-testing shows this never happens!\n        //if ( linesite_k_sign ) {\n        //    boost::tie(pos_edge, neg_edge) = g.add_twin_edges( seg_start,   seg_end );\n        //    g[pos_edge].inserted_direction = true;\n        //    g[neg_edge].inserted_direction = false;\n        //} else {\n        assert(!linesite_k_sign);\n            boost::tie( pos_edge, neg_edge) = g.add_twin_edges( seg_end  ,seg_start );\n            g[pos_edge].inserted_direction = false;\n            g[neg_edge].inserted_direction = true;\n        //}\n        g[pos_edge].type = LINESITE;\n        g[neg_edge].type = LINESITE;\n        g[pos_edge].k = +1;\n        g[neg_edge].k = -1;\n        pos_face = add_face( pos_site ); //  this face to the left of start->end edge    \n        neg_face = add_face( neg_site ); //  this face is to the left of end->start edge\n        g[pos_face].edge = pos_edge;\n        g[neg_face].edge = neg_edge;\n        g[pos_edge].face = pos_face;\n        g[neg_edge].face = neg_face;\n        \n        // associate sites with LINESITE edges\n        pos_site->e = pos_edge;\n        neg_site->e = neg_edge;\n        \n        if (debug) std::cout << \"created faces: pos_face=\" << pos_face << \" neg_face=\" << neg_face << \"\\n\";   \n    }\n\nif (step==current_step) return false; current_step++;\n\n    add_vertices( pos_site );  // add NEW vertices on all IN-OUT edges.\n\nif (step==current_step) return false; current_step++;\n\n    { // add SEPARATORS\n        // find SEPARATOR targets first\n        typedef boost::tuple<HEEdge, HEVertex, HEEdge,bool> SepTarget;\n        SepTarget pos_start_target, neg_start_target;\n        pos_start_target = find_separator_target( g[start].face , pos_sep_start);\n        neg_start_target = find_separator_target( g[start].face , neg_sep_start);\n        \n        // add positive separator edge at start\n        add_separator( g[start].face , start_null_face, pos_start_target, pos_sep_start, g[pos_face].site , g[neg_face].site );\n        \nif (step==current_step) return false; current_step++;\n        \n        // add negative separator edge at start\n        add_separator( g[start].face , start_null_face, neg_start_target, neg_sep_start, g[pos_face].site , g[neg_face].site );\n        g[ g[start].face ].status = NONINCIDENT; // face is now done.\n        assert( vd_checker->face_ok( g[start].face ) );\n        \nif (step==current_step) return false; current_step++;\n\n        SepTarget pos_end_target, neg_end_target;\n        pos_end_target = find_separator_target( g[end].face ,  pos_sep_end);\n        neg_end_target = find_separator_target( g[end].face , neg_sep_end);\n        // add positive separator edge at end\n        add_separator( g[end].face , end_null_face, pos_end_target, pos_sep_end, g[pos_face].site , g[neg_face].site );\n        \nif (step==current_step) return false; current_step++;\n        \n        // add negative separator edge at end\n        add_separator( g[end].face , end_null_face, neg_end_target, neg_sep_end, g[pos_face].site , g[neg_face].site );\n        g[ g[end].face ].status = NONINCIDENT;\n        assert( vd_checker->face_ok( g[end].face ) );\n\n        if(debug) std::cout << \"all separators  done.\\n\";\n    } // end SEPARATORS\n\nif (step==current_step) return false; current_step++;\n\n// add non-separator edges by calling add_edges on all INCIDENT faces\n    {\n        if(debug) std::cout << \"adding edges.\\n\";\n        BOOST_FOREACH( HEFace f, incident_faces ) {\n            if ( g[f].status == INCIDENT )  {// end-point faces already dealt with in add_separator()\n                if(debug) { \n                    std::cout << \" add_edges f= \" << f << \"\\n\";\n                    g.print_face(f);\n                }\n                add_edges( pos_face, f, neg_face, std::make_pair(seg_start,seg_end)); // each INCIDENT face is split into two parts: newface and f\n            }\n        }\n        if(debug) std::cout << \"adding edges. DONE.\\n\";\n    }\n\nif (step==current_step) return false; current_step++;\n\n// new vertices and edges inserted. remove the delete-set, repair faces.\n\n    remove_vertex_set();\n\n    if (debug) { std::cout << \"will now repair pos/neg faces: \" << pos_face << \" \" << neg_face << \"\\n\"; }\n\n    repair_face( pos_face, std::make_pair(seg_start,seg_end), \n                           std::make_pair(start_to_null,end_to_null),\n                           std::make_pair(start_null_face,end_null_face) );\n    assert( vd_checker->face_ok( pos_face ) );\n\n    repair_face( neg_face, std::make_pair(seg_start,seg_end), \n                           std::make_pair(start_to_null,end_to_null),\n                           std::make_pair(start_null_face,end_null_face) );\n    assert( vd_checker->face_ok( neg_face ) );\n    if (debug) { std::cout << \"faces repaired.\\n\"; }\n\nif (step==current_step) return false; current_step++;\n\n    // we are done and can remove split-vertices\n    BOOST_FOREACH(HEFace f, incident_faces) {\n        remove_split_vertex(f);\n    }\n    reset_status();\n\n\n    assert( vd_checker->face_ok( start_null_face ) );\n    assert( vd_checker->face_ok( end_null_face ) );\n    assert( vd_checker->face_ok( pos_face ) );\n    assert( vd_checker->face_ok( neg_face ) );    \n    assert( vd_checker->is_valid() );\n\n    return true; \n}\n\n/// \\brief insert a circular arc Site into the diagram\n/// \\param idx1 index of start vertex\n/// \\param idx2 index of end vertex\n/// \\param center center Point of arc\n/// \\param cw bool flag true=CW arc, false=CCW arc\n/// \\param step for debug, stop algorithm at this sub-step\nvoid VoronoiDiagram::insert_arc_site(int idx1, int idx2, const Point& center, bool cw, int step) {\n    num_asites++;\n    int current_step=1;\n    // find the vertices corresponding to idx1 and idx2\n    HEVertex start=HEVertex(), end=HEVertex();\n    boost::tie(start,end) = find_endpoints(idx1,idx2);\n    g[start].status=OUT;\n    g[end].status=OUT;   \n    g[start].zero_dist();\n    g[end].zero_dist();\n    double radius = (g[start].position - center).norm();\n    if (debug) {\n        std::cout << \"insert_arc_site( \" << g[start].index << \" - \" << g[end].index << \",\" ;\n        std::cout << \" c= \" << center << \", cw= \" << cw;\n        std::cout << \" )\\n\";\n        std::cout << \" radius= \" << radius << \"\\n\";\n    }\nif (step==current_step) return; current_step++;\n    \n    ArcSite* pos_site;\n    ArcSite* neg_site;\n    if (cw) {\n        pos_site = new ArcSite( g[end  ].position, g[start].position , center, cw);\n        neg_site = new ArcSite( g[start].position, g[end  ].position , center, !cw);\n    } else {\n        pos_site = new ArcSite( g[start].position, g[end].position , center, !cw);\n        neg_site = new ArcSite( g[end].position, g[start].position , center, cw);\n    }\n    \n    if (debug) {\n        std::cout << \" pos site =  \" << pos_site->str2() << \"\\n\";\n        std::cout << \" neg site =  \" << neg_site->str2() << \"\\n\";\n    }\nif (step==current_step) return; current_step++;\n\n    HEFace seed_face = g[start].face; // assumes this point-site has a face!\n    // on the face of start-point, find the seed vertex\n    HEVertex v_seed = find_seed_vertex(seed_face, pos_site ) ;\n    if (debug) std::cout << \" start face seed  = \" << g[v_seed].index << \"\\n\";\n    mark_vertex( v_seed, pos_site  );\n\nif (step==current_step) return; current_step++;\n    \n    augment_vertex_set( pos_site  ); // it should not matter if we use pos_site or neg_site here\n    // todo(?) sanity checks:\n    // check that end_face is INCIDENT? \n    // check that tree (i.e. v0) includes end_face_seed ?\n    if (debug) { std::cout << \" delete-set |v0|=\"<< v0.size() <<\" : \";  g.print_vertices(v0); }\n\nif (step==current_step) return; current_step++;\n    // process the null-faces here\n    HEVertex seg_start, seg_end; // new segment end-point vertices. these are created here.\n    HEFace start_null_face, end_null_face; // either existing or new null-faces at endpoints\n    HEVertex pos_sep_start = HEVertex(); // optional positive separator vertex at start\n    HEVertex neg_sep_start = HEVertex(); // optional negative separator vertex at start \n    HEVertex pos_sep_end = HEVertex();   // optional positive separator vertex at end\n    HEVertex neg_sep_end = HEVertex();   // optional negative separator vertex at end\n    HEFace start_to_null = g.HFace(); // when a point-site completely disappears, we \"null\" the face belonging to this pointsite\n    HEFace   end_to_null = g.HFace();\n    Point src_se = g[start].position;\n    Point trg_se = g[end  ].position;\n\n    Point left = 0.5*(src_se+trg_se) + (trg_se-src_se).xy_perp(); // this is used below and in find_null_face()\n    // returns new seg_start/end vertices, new or existing null-faces, and separator endpoints (if separators should be added)\n    Point dir1,dir2;\n    if (cw) {\n        dir1 = (g[start].position - center).xy_perp();\n        dir2 = -1*(g[end].position - center).xy_perp();\n    } else {\n        dir1 = -1*(g[start].position - center).xy_perp();\n        dir2 = (g[end].position - center).xy_perp();\n    }\n    if (debug) std::cout << \"find_null_face( \" << g[start].index << \" )\\n\";\n    \n    boost::tie(seg_start, start_null_face, pos_sep_start, neg_sep_start, start_to_null) = find_null_face(start, end  , left, dir1, pos_site);\n    if (debug) std::cout << \"find_null_face( \" << g[end].index << \" )\\n\";\n    boost::tie(seg_end  , end_null_face  , pos_sep_end  , neg_sep_end  , end_to_null  ) = find_null_face(end  , start, left, dir2, pos_site);\n\n    // now safe to set the zero-face edge\n    // in the collinear case, set the edge for the face that \"disappears\" to a null edge\n    if (start_to_null!=g.HFace())\n        g[start_to_null].edge = g[start_null_face].edge; \n    if (end_to_null!=g.HFace())\n        g[end_to_null].edge = g[end_null_face].edge; \n\nif (step==current_step) return; current_step++;\n    // create pseudo edges (sites) and faces\n    HEFace pos_face, neg_face; \n    HEEdge pos_edge, neg_edge;\n    {\n        if (cw)\n            boost::tie( pos_edge, neg_edge) = g.add_twin_edges( seg_end  ,seg_start );\n        else\n            boost::tie( neg_edge, pos_edge) = g.add_twin_edges( seg_end  ,seg_start );\n\n        g[pos_edge].inserted_direction = false;\n        g[neg_edge].inserted_direction = true;\n        g[pos_edge].type = ARCSITE;\n        g[neg_edge].type = ARCSITE;\n        g[pos_edge].k = +1;\n        g[neg_edge].k = -1;\n        pos_face = add_face( pos_site ); //  this face to the left of start->end edge    \n        neg_face = add_face( neg_site ); //  this face is to the left of end->start edge\n        g[pos_face].edge = pos_edge;\n        g[neg_face].edge = neg_edge;\n        g[pos_edge].face = pos_face;\n        g[neg_edge].face = neg_face;\n        \n        //if (debug) std::cout << \"created ARCSITE edge \" << g[seg_end].index << \" -[f\" <<  << \"]- << g[seg_start].index << \"\\n\";  \n        \n        // associate sites with ARCSITE edges\n        pos_site->e = pos_edge;\n        neg_site->e = neg_edge;\n        \n        if (debug) std::cout << \"created faces: pos_face=\" << pos_face << \" neg_face=\" << neg_face << \"\\n\";   \n    }\n\nif (step==current_step) return; current_step++;\n\n    add_vertices( pos_site );  // add NEW vertices on all IN-OUT edges.\n    \nif (step==current_step) return; current_step++;\n\n    { // add SEPARATORS\n    \n        // find SEPARATOR targets first\n        typedef boost::tuple<HEEdge, HEVertex, HEEdge,bool> SepTarget;\n        SepTarget pos_start_target, neg_start_target;\n        pos_start_target = find_separator_target( g[start].face , pos_sep_start);\n        neg_start_target = find_separator_target( g[start].face , neg_sep_start);\n        \n        // add positive separator edge at start\n        add_separator( g[start].face , start_null_face, pos_start_target, pos_sep_start, g[pos_face].site , g[neg_face].site );\n        \nif (step==current_step) return; current_step++;\n        \n        // add negative separator edge at start\n        add_separator( g[start].face , start_null_face, neg_start_target, neg_sep_start, g[pos_face].site , g[neg_face].site );\n        g[ g[start].face ].status = NONINCIDENT; // face is now done.\n        assert( vd_checker->face_ok( g[start].face ) );\n        \nif (step==current_step) return; current_step++;\n\n        SepTarget pos_end_target, neg_end_target;\n        pos_end_target = find_separator_target( g[end].face ,  pos_sep_end);\n        neg_end_target = find_separator_target( g[end].face , neg_sep_end);\n        // add positive separator edge at end\n        add_separator( g[end].face , end_null_face, pos_end_target, pos_sep_end, g[pos_face].site , g[neg_face].site );\n        \nif (step==current_step) return; current_step++;\n        \n        // add negative separator edge at end\n        add_separator( g[end].face , end_null_face, neg_end_target, neg_sep_end, g[pos_face].site , g[neg_face].site );\n        g[ g[end].face ].status = NONINCIDENT;\n        assert( vd_checker->face_ok( g[end].face ) );\n\n        if(debug) std::cout << \"all separators  done.\\n\";\n    } // end SEPARATORS\n\nif (step==current_step) return; current_step++;\n// add non-separator edges by calling add_edges on all INCIDENT faces\n    {\n        if(debug) std::cout << \"adding edges.\\n\";\n        BOOST_FOREACH( HEFace f, incident_faces ) {\n            if ( g[f].status == INCIDENT )  {// end-point faces already dealt with in add_separator()\n                if(debug) { \n                    std::cout << \" add_edges f= \" << f << \"\\n\";\n                    g.print_face(f);\n                }\n                add_edges( pos_face, f, neg_face, std::make_pair(seg_start,seg_end)); // each INCIDENT face is split into two parts: newface and f\n            }\n        }\n        if(debug) std::cout << \"adding edges. DONE.\\n\";\n    }\n\nif (step==current_step) return; current_step++;\n\n// new vertices and edges inserted. remove the delete-set, repair faces.\n\n    remove_vertex_set();\n\n    if (debug) { std::cout << \"will now repair pos/neg faces: \" << pos_face << \" \" << neg_face << \"\\n\"; }\n\n    repair_face( pos_face, std::make_pair(seg_start,seg_end), \n                           std::make_pair(start_to_null,end_to_null),\n                           std::make_pair(start_null_face,end_null_face) );\n    assert( vd_checker->face_ok( pos_face ) );\n\n    repair_face( neg_face, std::make_pair(seg_start,seg_end), \n                           std::make_pair(start_to_null,end_to_null),\n                           std::make_pair(start_null_face,end_null_face) );\n    assert( vd_checker->face_ok( neg_face ) );\n    if (debug) { std::cout << \"faces repaired.\\n\"; }\n\nif (step==current_step) return; current_step++;\n\n    // we are done and can remove split-vertices\n    BOOST_FOREACH(HEFace f, incident_faces) {\n        remove_split_vertex(f);\n    }\n    reset_status();\n\n\n    assert( vd_checker->face_ok( start_null_face ) );\n    assert( vd_checker->face_ok( end_null_face ) );\n    assert( vd_checker->face_ok( pos_face ) );\n    assert( vd_checker->face_ok( neg_face ) );    \n    assert( vd_checker->is_valid() );\n\n    //return true; \n\n}\n\n/// \\brief find vertex descriptors corresponding to \\a idx1 and \\a idx2\n// given indices idx1 and idx2, return the corresponding vertex descriptors\n// the vertex_map is populated in insert_point_site()\nstd::pair<HEVertex,HEVertex> VoronoiDiagram::find_endpoints(int idx1, int idx2) {\n    std::map<int,HEVertex>::iterator it_start, it_end;\n    it_start = vertex_map.find(idx1);\n    it_end = vertex_map.find(idx2);\n    assert( it_start != vertex_map.end() && it_end != vertex_map.end() ); // we must find idx1 and idx2 in the map\n    return std::make_pair( it_start->second, it_end->second);\n}\n\n\n/// \\brief prepare null-face \n// next_edge lies on an existing null face\n// - Here we either insert a NEW NORMAL or SEPPOINT in the edge\n// - OR we push and convert an existing vertex.\n// the next_prev flag indicates if we are dealing with the next edge from the new segment-endpoint next_prev=true\n// or if we are dealing with the previous edge (next_prev=false)\nstd::pair<HEVertex,HEFace> VoronoiDiagram::process_null_edge(Point dir, HEEdge next_edge , bool k3, bool next_prev) {\n    assert( g[next_edge].type == NULLEDGE );\n    HEVertex trg = g.target(next_edge);\n    HEVertex src = g.source(next_edge);\n    \n    HEVertex adj = next_prev ? trg : src; // this is the vertex adjacent to the end-point, on the null face\n    assert( g[ next_prev ? src : trg ].type == ENDPOINT );  // this is the end-point of the segment we are inserting\n    \n    HEVertex sep_point = HEVertex();\n    double dir_mult = next_prev ? +1 : -1;\n    Point   sep_dir = dir.xy_perp()*dir_mult;\n    double sep_alfa = numeric::diangle(sep_dir.x,sep_dir.y); // alfa of potential SEPPOINT\n\n    double new_k3; // k3-value of a new or pushed vertex\n    if (next_prev) {\n        new_k3 = k3 ? +1 : -1; \n    } else {\n        new_k3 = k3 ? -1 : +1;\n    }\n    \n    if (debug) { std::cout << \"process_null_edge: \";\n        g.print_edge(next_edge);\n        std::cout << \" next_prev=\" << next_prev << \"\\n\";  \n    }\n    \n    if ( g[adj].type == ENDPOINT ) { // target is endpoint\n        // insert a normal vertex, positioned at mid-alfa between src/trg.\n        HEVertex new_v = g.add_vertex( VoronoiVertex(g[src].position,NEW,NORMAL,g[src].position) );\n        double mid = numeric::diangle_mid( g[src].alfa, g[trg].alfa  );\n        g[new_v].alfa = mid;\n        modified_vertices.insert(new_v);\n        g.add_vertex_in_edge( new_v, next_edge);\n        g[new_v].k3=new_k3;\n\n        if (debug) {\n            std::cout << \" e.trg=(ENDPOINT) \\n\";\n            std::cout << \" added NEW NORMAL vertex \" << g[new_v].index << \" in edge \"; g.print_edge(next_edge);\n        }\n        return std::make_pair(HEVertex(), g.HFace() );\n        \n    } else {\n        // Not an ENDPOINT vertex.\n        assert( g[adj].type != ENDPOINT );\n        double mid(0);\n        bool seppoint_pred(false);\n        bool parallel_pred(false);\n        \n        // set the two predicates \n        if (next_prev) {\n            HEEdge next_next = g[next_edge].next; \n            HEEdge next_previous = g.previous_edge(next_edge);\n            HEVertex next_trg = g.target(next_next); // source\n            mid = numeric::diangle_mid( g[src].alfa, g[next_trg].alfa  ); // prev_src, trg\n            seppoint_pred = ( g[next_trg].type != ENDPOINT );\n            if (debug) {\n                std::cout << \"          next edge : \"; g.print_edge(next_edge);\n                std::cout << \" next_previous edge : \"; g.print_edge(next_previous);\n            }\n            HEVertex next_out_trg;\n            bool next_out_found = null_vertex_target( g.target(next_edge) , next_out_trg ); \n            HEVertex prev_out_trg;\n            bool prev_out_found = null_vertex_target( g.source(next_previous), prev_out_trg ); \n            if (next_out_found && prev_out_found) {\n                \n                if (debug) std::cout << \" \" << g[g.target(next_edge)].index << \" has out-vertex \" << g[next_out_trg].index << \" status=\" << g[next_out_trg].status << \"\\n\";\n                if (debug) std::cout << \" \" << g[g.source(next_previous)].index << \" has out-vertex \" << g[prev_out_trg].index << \" status=\" << g[prev_out_trg].status << \"\\n\";\n                \n                parallel_pred = ( ( ( g[ next_out_trg ].status == OUT ) || ( g[ next_out_trg ].status == NEW ) || ( g[ next_out_trg ].status == UNDECIDED ) ) &&\n                                  ( ( g[ prev_out_trg ].status == OUT ) || ( g[ prev_out_trg ].status == NEW ) || ( g[ prev_out_trg ].status == UNDECIDED ))\n                                );\n            }\n        } else { // !next_prev\n            HEEdge prev_prev = g.previous_edge(next_edge);\n            HEEdge next_next2 = g[next_edge].next;\n            HEVertex prev_src = g.source(prev_prev);\n            mid = numeric::diangle_mid( g[prev_src].alfa, g[trg].alfa  );\n            seppoint_pred = ( g[prev_src].type != ENDPOINT );\n\n            HEVertex next_out_trg2;\n            bool next_out_found2 = null_vertex_target( g.source(next_edge), next_out_trg2 ); \n            HEVertex prev_out_trg2;\n            bool prev_out_found2 = null_vertex_target( g.target(next_next2), prev_out_trg2 );\n            if (next_out_found2 && prev_out_found2) { \n                if (debug) std::cout << \" \" << g[g.source(next_edge)].index << \" has out-vertex \" << g[next_out_trg2].index << \" status=\" << g[next_out_trg2].status << \"\\n\";\n                if (debug) std::cout << \" \" << g[g.target(next_next2)].index << \" has out-vertex \" << g[prev_out_trg2].index << \" status=\" << g[prev_out_trg2].status << \"\\n\";\n      \n                parallel_pred = ( ( ( g[ next_out_trg2 ].status == OUT ) || ( g[ next_out_trg2 ].status == NEW ) || ( g[ next_out_trg2 ].status == UNDECIDED ) ) &&\n                                  ( ( g[ prev_out_trg2 ].status == OUT ) || ( g[ prev_out_trg2 ].status == NEW ) || ( g[ prev_out_trg2 ].status == UNDECIDED ) )\n                                );\n            }\n\n        } // predicates now set.\n\n        // parallel line-segments case\n        if ( parallel_pred && g[adj].type == SEPPOINT ) {\n            if (debug)  { std::cout << \" identical SEPPOINT case!\\n\";\n                //std::cout << \" old alfa pred \" << (sep_alfa == g[adj].alfa) << \"\\n\";\n            }\n            // assign face of separator-edge\n            // mark separator target NEW\n            HEEdge sep_edge=HEEdge();\n            BOOST_FOREACH(HEEdge e, g.out_edge_itr(adj) ) {\n                assert( g.source(e) == adj );\n                if ( g[e].type == SEPARATOR )\n                    sep_edge = e;\n            }\n            assert(sep_edge!=HEEdge()); \n            if (debug) { std::cout << \" existing SEPARATOR is \"; g.print_edge(sep_edge); }\n            HEEdge sep_twin = g[sep_edge].twin;\n            HEFace sep_face =  g[sep_edge].face;\n            Site* sep_site = g[sep_face].site;\n            HEFace sep_twin_face = g[sep_twin].face;\n            Site* sep_twin_site = g[sep_twin_face].site;\n            HEEdge pointsite_edge;\n            if (sep_site->isPoint() ) {\n                if (debug) { std::cout << \" PointSite SEPARATOR is \"; g.print_edge(sep_edge); }\n                pointsite_edge = sep_edge;\n            }  else if (sep_twin_site->isPoint() ) {\n                if (debug) { std::cout << \" PointSite SEPARATOR is \"; g.print_edge(sep_twin); }\n                pointsite_edge = sep_twin;\n            }\n            \n            // set the separator target to NEW\n            if (debug) { std::cout << \" setting SEPARATOR target \"<< g[g.target(sep_edge)].index << \" to NEW\\n\"; }\n            HEVertex sep_target = g.target(sep_edge);\n            g[sep_target].status = NEW;\n            g[sep_target].k3 = new_k3;\n            modified_vertices.insert(sep_target);\n            \n            return std::make_pair( HEVertex(), g[pointsite_edge].face ); // no new separator-point returned\n        }\n\n        HEVertex adj_out;\n        bool adj_out_found = null_vertex_target(adj, adj_out);\n        if (!adj_out_found) { exit(-1); }\n        if (debug) std::cout << \" not identical SEPPOINT case. either inserting new SEPPOINT, or pushing existing vertex which becomes SEPPOINT/NORMAL\\n\";\n        if (debug) std::cout << \" \" << g[adj].index << \" has out-vertex \" << g[adj_out].index << \" status=\" << g[adj_out].status << \"\\n\";\n        \n        if ( g[adj_out].status == OUT || g[adj_out].status == UNDECIDED) {\n            if (debug) {\n                std::cout << \" inserting SEPPOINT in edge: \"; g.print_edge(next_edge);\n                std::cout << \"   src alfa = \" << g[src].alfa << \"\\n\";\n                std::cout << \"   SEP==src alfa? = \" << (g[src].alfa == sep_alfa) << \"\\n\";\n                std::cout << \"   SEP alfa = \" << sep_alfa << \"\\n\";\n                std::cout << \"   trg alfa = \" << g[trg].alfa << \"\\n\"; \n            }\n            sep_point = add_separator_vertex(src, next_edge, sep_dir);\n            g[sep_point].k3 = new_k3;\n            return std::make_pair( sep_point, g.HFace() );\n        } else {\n            // target is not endpoint so we push and convert the vertex\n\n            if ( seppoint_pred  ) { \n                // the pushed vertex becomes a SEPPOINT\n                if (debug) {\n                    std::cout << \" pushed vertex \" << g[adj].index << \" becomes SEPPOINT, \";\n                    std::cout << \"   sep_alfa = \" << sep_alfa << \"\\n\";\n                }\n                g[adj].alfa = sep_alfa;\n                g[adj].type = SEPPOINT;\n                g[adj].status = NEW;\n                sep_point = adj;\n            } else {\n                // otherwise it becomes a normal NEW vertex\n                if (debug) std::cout << \" pushed vertex \" << g[adj].index << \" becomes NORMAL\\n\";\n                g[adj].alfa = mid;\n                g[adj].type = NORMAL;\n                g[adj].status = NEW;\n            }\n            g[adj].k3 = new_k3;\n            modified_vertices.insert(adj);\n            return std::make_pair( sep_point, g.HFace() );\n        }\n    }\n}\n\n/// \\brief add a ::SEPPOINT vertex into the given null-edge\n///\n/// \\param endp the endpoint corresponding to the null-edge/null-face\n/// \\param edge the null-edge into which we insert the new vertex\n/// \\param sep_dir direction for setting alfa of the new vertex\nHEVertex VoronoiDiagram::add_separator_vertex(HEVertex endp, HEEdge edge, Point sep_dir) {\n    HEVertex sep = g.add_vertex( VoronoiVertex(g[endp].position,OUT,SEPPOINT) );\n    g[sep].set_alfa(sep_dir);\n    if (debug) {\n        std::cout << \" adding separator \" << g[sep].index << \" in null edge \"; \n        g.print_edge(edge);\n    }\n    g.add_vertex_in_edge(sep,edge);\n    modified_vertices.insert(sep);\n    return sep;\n}\n\n/// \\brief find an adjacent vertex to v, along an edge that is not a ::NULLEDGE\n// return true if found, otherwise false.\nbool VoronoiDiagram::null_vertex_target( HEVertex v , HEVertex& trg) {\n    BOOST_FOREACH( HEEdge e, g.out_edge_itr( v ) ) { \n        if ( g[e].type != NULLEDGE ) {\n            trg = g.target(e);\n            return true;\n        }\n    }\n    return false;\n}\n\n\n/// \\brief either find an existing null-face, or create a new one.\n/// \\param start  the end of the segment for which we will find/create a null-face\n/// \\param other  the other end of the new segment\n/// \\param left   a point left of the new segment\n/// \\param dir    alfa-direction for positioning endpoint vertex on null-face\n/// \\param new_site    the new Site we are inserting \n///\n/// \\return HEVertex ::ENDPOINT-vertex for the new vertex\n/// \\return HEFace  null-face at endpoint (new or existing)\n/// \\return HEVertex positive ::SEPARATOR edge endpoint vertex (if a positive separator should be added)\n/// \\return HEVertex negative ::SEPARATOR edge endpoint vertex (if a negative separator should be added)\n/// \\return HEFace face-to-null. if a PointSite face should disappear, we return it here.\nboost::tuple<HEVertex,HEFace,HEVertex,HEVertex,HEFace>\nVoronoiDiagram::find_null_face(HEVertex start, HEVertex other, Point left, Point dir, Site* new_site) {\n    HEVertex seg_start = HEVertex(); // new end-point vertices\n    HEFace start_null_face; // either existing or new null-face at start-vertex\n    \n    HEVertex pos_sep_start = HEVertex(); // optional separator endpoints at start\n    HEVertex neg_sep_start = HEVertex(); // invalid vertices are default\n    \n    HEFace face_to_null = g.HFace(); // invalid face is default\n    \n    // this works for LineSite\n    bool k3_sign(true);\n    if (new_site->isLine() ) {\n        k3_sign = left.is_right( g[start].position , g[other].position); \n    } else if (new_site->isArc()) {\n        k3_sign = Point(new_site->x(),new_site->y()).is_right( g[start].position , g[other].position );\n    } else {\n        assert(0);\n    }\n    // this is used below and in find_null_face()\n    // k3_sign is already calculated in insert_line_segment() ??\n    \n    if (g[start].null_face != g.HFace() ) { // there is an existing null face\n        if (debug) {\n            std::cout << \" endp= \" << g[start].index << \" has existing null_face :\\n\";\n            g.print_face( g[start].null_face  );\n        }\n        start_null_face = g[start].null_face;\n\n        // create a new segment ENDPOINT vertex with zero clearance-disk\n        seg_start = g.add_vertex( VoronoiVertex(g[start].position,OUT,ENDPOINT,0) );\n        // find the edge on the null-face where we insert seg_start\n        HEEdge insert_edge = HEEdge();\n        {\n            HEEdge current2 = g[start_null_face].edge;\n            HEEdge start_edge2 = current2;\n            g[seg_start].set_alfa(dir);\n            bool found = false;\n            if (debug) std::cout << \" Looking for endpoint edge:\\n\";\n            do {\n                bool face_incident = ( g[ g[ g[current2].twin ].face ].status == INCIDENT);\n                if (debug) {\n                    std::cout << \"  incident= \" << face_incident << \"  \"; g.print_edge(current2);\n                }\n                if ( face_incident ) { // pick any incident face!\n                        insert_edge = current2;\n                        found = true;\n                }\n                current2 = g[current2].next;\n            } while (current2!=start_edge2 && !found ); // FIXME end early with !found \n            assert( insert_edge != HEEdge() );\n            assert( found );\n            /*\n            if (!found) {\n                std::cout << \"find_null_face() FATAL ERROR. can't find edge to insert segment endpoint.\\n\";\n                std::cout << \" null face for endpoint \" << g[start].index <<\" is \"; g.print_face(start_null_face);\n                \n                exit(-1);\n            }*/\n            if (debug) { std::cout << \"  endpoint edge is \"; g.print_edge(insert_edge); }\n        }\n        g.add_vertex_in_edge(seg_start,insert_edge); // insert endpoint in null-edge\n\n        if (debug) { std::cout << \"  new endpoint vertex \" << g[seg_start].index << \" inserted in edge \"; g.print_edge(insert_edge); }\n\n        // \"process\" the adjacent null-edges \n        HEEdge next_edge, prev_edge;\n        boost::tie(next_edge,prev_edge) = g.find_next_prev(start_null_face, seg_start);\n        //assert( g[prev_edge].next == next_edge );\n        boost::tie( neg_sep_start, face_to_null ) = process_null_edge(dir, next_edge, k3_sign, true);\n        boost::tie( pos_sep_start, face_to_null ) = process_null_edge(dir, prev_edge, k3_sign, false);\n        if (debug) {\n            //std::cout << \"find_null_face() endp= \" << g[start].index << \" has existing null_face : \" << g[start].null_face << \"\\n\";\n            g.print_face( g[start].null_face  );\n        }\n        return boost::make_tuple( seg_start, start_null_face, pos_sep_start, neg_sep_start, face_to_null);\n    } else { // no existing null-face\n        // create a new null face at start. the face has three vertices/edges:\n        //\n        //  neg_sep -> seg_endp -> pos_sep\n        //\n        start_null_face = g.add_face(); //  this face to the left of start->end edge  \n        g[start_null_face].null = true;\n          \n        if (debug) std::cout << \" find_null_face() endp= \" << g[start].index <<  \" creating new null_face \" << start_null_face << \"\\n\";\n        seg_start = g.add_vertex( VoronoiVertex(g[start].position,OUT,ENDPOINT) );\n        g[seg_start].zero_dist();\n        g[seg_start].set_alfa(dir);\n        g[seg_start].k3=0;\n        pos_sep_start = g.add_vertex( VoronoiVertex(g[start].position,UNDECIDED,SEPPOINT) );\n        neg_sep_start = g.add_vertex( VoronoiVertex(g[start].position,UNDECIDED,SEPPOINT) );\n        \n        g[pos_sep_start].zero_dist();\n        g[neg_sep_start].zero_dist();\n    \n        if (k3_sign) {\n            g[pos_sep_start].k3 = +1; \n            g[neg_sep_start].k3 = -1;\n        } else {\n            g[pos_sep_start].k3 = -1; \n            g[neg_sep_start].k3 = +1;\n        }\n        g[pos_sep_start].set_alfa( dir.xy_perp()*(+1) );        \n        g[neg_sep_start].set_alfa( dir.xy_perp()*(-1) );\n        if (debug) {\n            std::cout << \" k3_sign = \" << k3_sign <<\"\\n\"; \n            std::cout << \" sep1 = \" << g[pos_sep_start].index << \" k3=\" << g[pos_sep_start].k3 << \"\\n\";\n            std::cout << \" sep2 = \" << g[neg_sep_start].index << \" k3=\" << g[neg_sep_start].k3 << \"\\n\";\n        }\n        // null-edges around the face\n        HEEdge e1,e1_tw;\n        boost::tie(e1,e1_tw) = g.add_twin_edges(seg_start,pos_sep_start);\n        HEEdge e2,e2_tw;\n        boost::tie(e2,e2_tw) = g.add_twin_edges(pos_sep_start,neg_sep_start);\n        HEEdge e3,e3_tw;\n        boost::tie(e3,e3_tw) = g.add_twin_edges(neg_sep_start,seg_start);\n        \n        // e1  ->  e2  ->  e3     on start_null_face, k=1\n        // e1t <-  e2t <-  e3t   on g[start].face, k=1\n        g.set_next_cycle( boost::assign::list_of(e1)(e2)(e3) , start_null_face, 1);\n        HEFace start_face = g[start].face;\n        HEEdge start_face_edge=g[start_face].edge; // crazy workaround, because set_next_cycles sets g[face].edge wrong here!\n        g.set_next_cycle( boost::assign::list_of(e3_tw)(e2_tw)(e1_tw), g[start].face, 1);\n        g[start_null_face].edge = e1;\n        g[start_face].edge = start_face_edge;\n        \n        g[e1].type = NULLEDGE; g[e2].type = NULLEDGE; g[e3].type = NULLEDGE;\n        g[e1_tw].type = NULLEDGE; g[e3_tw].type = NULLEDGE; g[e2_tw].type = NULLEDGE;\n\n        g[start].null_face = start_null_face;\n        g[start_null_face].site = g[start_face].site;\n        \n        return boost::make_tuple( seg_start, start_null_face, pos_sep_start, neg_sep_start, face_to_null);\n    }\n}\n\n/// \\brief add ::SEPARATOR edge on the face f, which contains the endpoint\n/// \\param f is the face of endp \n/// \\param null_face null face of the endpoint\n/// \\param target target-data found by ??\n/// \\param sep_endp ??\n/// \\param s1 positive LineSite\n/// \\param s2 negative LineSite\nvoid VoronoiDiagram::add_separator(HEFace f, HEFace null_face, \n                                   boost::tuple<HEEdge, HEVertex, HEEdge, bool> target,\n                                   HEVertex sep_endp, Site* s1, Site* s2) {\n    if ( sep_endp == HEVertex() ) // no separator\n        return; // do nothing!\n    \n    if (debug) std::cout << \"add_separator() f=\"<<f<<\" endp=\" << g[sep_endp].index << \"\\n\";\n    \n    assert( (g[sep_endp].k3==1) || (g[sep_endp].k3==-1) );    \n    g[sep_endp].zero_dist();\n    \n    HEEdge endp_next = HEEdge();\n    HEEdge endp_prev = HEEdge();\n    HEEdge endp_next_tw = HEEdge();\n    HEEdge endp_prev_tw = HEEdge();\n\n    boost::tie( endp_next_tw, endp_prev_tw ) = g.find_next_prev(null_face, sep_endp);\n    if (debug) {\n        std::cout << \"  add_separator() endp_next_tw=\"; g.print_edge(endp_next_tw); \n        std::cout << \"  add_separator() endp_prev_tw=\"; g.print_edge(endp_prev_tw); \n        std::cout << \"  add_separator() g[endp_next_tw].twin=\"; g.print_edge(g[endp_next_tw].twin); \n        std::cout << \"  add_separator() g[endp_prev_tw].twin=\"; g.print_edge(g[endp_prev_tw].twin); \n    }\n    endp_prev = g[endp_next_tw].twin; // NOTE twin!\n    endp_next = g[endp_prev_tw].twin; // NOTE twin!\n    assert( endp_next != HEEdge() );\n    assert( endp_prev != HEEdge() );\n\n    // find NEW vertex on the old face f\n    // this vertex has the correct alfa angle for this endp/separator\n    HEEdge v_previous = boost::get<0>(target);\n    HEVertex v_target = boost::get<1>(target);\n    HEEdge    v_next  = boost::get<2>(target);\n    bool    out_new_in = boost::get<3>(target);\n    if (debug) {\n        std::cout << \"  add_separator() v_previous=\"; g.print_edge(v_previous) ;\n        std::cout << \"  add_separator() v_target=\"<< g[v_target].index <<\"\\n\";\n    }\n    assert( (g[v_target].k3==1) || (g[v_target].k3==-1) );    \n    assert( g[sep_endp].k3 == g[v_target].k3 );\n    if (!s1->in_region( g[v_target].position ) ) {\n        std::cout << \" Error separator endpoint not in region of site \" << s1->str() << \"\\n\";\n        std::cout << \" site in_region_t = \" << s1->in_region_t(  g[v_target].position ) << \"\\n\";\n        std::cout << \" site in_region_raw = \" << s1->in_region_t_raw(  g[v_target].position ) << \"\\n\";\n        \n    }\n    assert( s1->in_region( g[v_target].position ) ); // v1 and v2 should be in the region of the line-site\n    assert( s2->in_region( g[v_target].position ) );\n    \n    // add new separator edge, and its twin\n    HEEdge e2, e2_tw;\n    boost::tie(e2,e2_tw) = g.add_twin_edges( sep_endp, v_target );\n    g[e2].type    = SEPARATOR;\n    g[e2_tw].type = SEPARATOR;\n    \n    // there are two cases. depending on how v_target (NEW) is found:\n    // OUT-NEW-IN, when out_new_in = true\n    // IN-NEW-OUT, when out_new_in = false\n    // here we set the faces, sites, and next-pointers depending on the case\n    if ( out_new_in ) {\n        g[e2].k    = g[v_target].k3; // e2 is on the segment side\n        g[e2_tw].k = +1;             // e2_tw is on the point-site side\n        \n        g[e2_tw].face = f; // point-site face\n        g[e2_tw].null_face = f;\n        g[e2_tw].has_null_face = true;\n        \n        g[f].edge = e2_tw;\n        g[endp_prev].k = g[e2].k; // endp_prev is on the line-site side\n\n        if (g[e2].k == -1) { // choose either s1 or s2 as the site\n            g[e2].face = s2->face;\n            g[s2->face].edge=e2;\n            g[endp_prev].face = s2->face;\n        } else {\n            g[e2].face = s1->face;\n            g[s1->face].edge=e2;\n            g[endp_prev].face = s1->face;\n        }\n\n        g.set_next(v_previous,e2_tw);\n        g.set_next(e2_tw, endp_next);\n\n        g[endp_next].face = f;      // the null-edge\n        g[endp_next].k = 1;\n\n        //g.set_next(endp_prev,e2); // don't set!\n\n        g.set_next(e2,v_next);\n    } else {\n        g[e2].k    = +1;             // e2 is on the point-site side\n        g[e2_tw].k = g[v_target].k3; // e2_tw is on the segment side\n        \n        g[e2].face    = f; // point-site face\n        g[e2].null_face    = f;\n        g[e2].has_null_face = true;\n        \n        g[f].edge     = e2;\n        g[endp_next].k = g[e2_tw].k; // endp_next is on the linesite-side\n        if (g[e2_tw].k == -1) {\n            g[e2_tw].face = s2->face;\n            g[s2->face].edge=e2_tw;\n            g[endp_next].face = s2->face;\n        } else {\n            g[e2_tw].face = s1->face;\n            g[s1->face].edge=e2_tw;\n            g[endp_next].face = s1->face;\n        }\n        g.set_next(v_previous,e2_tw);\n        //g.set_next(e2_tw,endp_next);\n        g[endp_prev].face = f;\n        g[endp_prev].k = 1;\n\n        g.set_next(endp_prev, e2);\n        g.set_next(e2,v_next);\n    }\n    g[e2   ].set_sep_parameters( g[sep_endp].position, g[v_target].position );\n    g[e2_tw].set_sep_parameters( g[sep_endp].position, g[v_target].position );\n        \n    if (debug) {\n        std::cout << \"add_separator(): \";\n        std::cout << g[sep_endp].index << \" - \" << g[v_target].index << \". Done.\\n\";\n    }\n    assert( vd_checker->check_edge(e2) );\n    assert( vd_checker->check_edge(e2_tw) );\n}\n\n/// find amount of clearance-disk violation on all vertices of face f \n/// \\return vertex with the largest clearance-disk violation\nHEVertex VoronoiDiagram::find_seed_vertex(HEFace f, Site* site)  {\n    if (debug) { std::cout << \"find_seed_vertex on f=\" << f << \"\\n\"; g.print_face(f); }\n    double minPred( 0.0 ); \n    HEVertex minimalVertex = HEVertex();\n    bool first( true );\n    HEEdge current = g[f].edge;\n    HEEdge start = current;\n    do {        \n        HEVertex q = g.target(current);\n        if ( (g[q].status != OUT) && (g[q].type == NORMAL) ) {\n            double h = g[q].in_circle( site->apex_point( g[q].position ) ); \n            if (debug) { \n                std::cout << g[q].index << \" h= \" << h << \" dist=\" << g[q].dist();\n                std::cout << \"apex=\"<< site->apex_point( g[q].position ) << \"  \";\n                std::cout << \"\\n\";  \n            }\n            if ( first || ( (h<minPred) && (site->in_region(g[q].position) ) ) ) {\n                minPred = h;\n                minimalVertex = q;\n                first = false;\n            }\n        }\n        current = g[current].next;\n    } while(current!=start);  \n    assert( minPred < 0 );\n    return minimalVertex;\n}\n\n\n/// \\brief grow the delete-tree of ::IN vertices by \"weighted breadth-first search\"\n///\n/// we start at the seed and add vertices with detH<0 provided that:\n/// - (C4) v should not be adjacent to two or more IN vertices (this would result in a loop/cycle!)\n/// - (C5) for an incident face containing v: v is adjacent to an IN vertex on this face\n///\n/// C4 and C5 refer to the Sugihara&Iri 1992 \"one million\" paper.\n///  We process ::UNDECIDED vertices adjacent to known ::IN-vertices in a \"weighted breadth-first-search\" manner\n///  where vertices with a large fabs(detH) are processed first, since we assume the in-circle predicate\n///  to be more reliable the larger fabs(in_circle()) is.\nvoid VoronoiDiagram::augment_vertex_set(  Site* site ) {\n    while( !vertexQueue.empty() ) {\n        HEVertex v = HEVertex();\n        double h(0);\n        boost::tie( v, h ) = vertexQueue.top();\n        assert( g.g[v].status == UNDECIDED );\n        vertexQueue.pop(); \n        if ( h < 0.0 ) { // try to mark IN if h<0 and passes (C4) and (C5) tests and in_region(). otherwise mark OUT\n            if ( predicate_c4(v) || !predicate_c5(v) || !site->in_region(g[v].position) ) {\n                g[v].status = OUT; // C4 or C5 violated, so mark OUT\n                if (debug) std::cout << g[v].index << \" marked OUT (topo): c4=\"<< predicate_c4(v) << \" c5=\" << !predicate_c5(v) << \" r=\" << !site->in_region(g[v].position) << \" h=\" << h << \"\\n\";\n            } else {\n                mark_vertex( v,  site); // h<0 and no violations, so mark IN. push adjacent UNDECIDED vertices onto Q.\n                if (debug) { \n                    std::cout << g[v].index << \" marked IN (in_circle) ( \" << h << \" )\\n\";\n                    //std::cout << \"  in_region?= \" << site->in_region(g[v].position);\n                    //std::cout << \"  in_region_t= \"<< site->in_region_t(g[v].position) << \"\\n\";\n                    //std::cout << \"  in_region_t_raw= \"<< (site->in_region_t_raw(g[v].position)-1.0) << \"\\n\";\n                }\n            }\n        } else {\n            g[v].status = OUT; // detH was positive (or zero), so mark OUT\n            if (debug) std::cout << g[v].index << \" marked OUT (in_circle) ( \" << h << \" )\\n\";\n        }\n        modified_vertices.insert( v );\n    }\n    \n    assert( vertexQueue.empty() );\n    assert( vd_checker->all_in(v0) );\n    if (debug) std::cout << \"augment_vertex_set() DONE\\n\";\n\n    // sanity-check?: for all incident faces the IN/OUT-vertices should be connected\n}\n\n/// mark vertex ::IN and mark adjacent faces ::INCIDENT\n// push adjacent UNDECIDED vertices onto queue \nvoid VoronoiDiagram::mark_vertex(HEVertex& v,  Site* site) {\n    g[v].status = IN;\n    v0.push_back( v );\n    modified_vertices.insert(v);\n    \n    if (site->isPoint())\n        mark_adjacent_faces_p(v);\n    else\n        mark_adjacent_faces( v, site );\n\n    // push the v-adjacent vertices onto the queue\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr( v )) {\n        HEVertex w = g.target( e );\n        if ( (g[w].status == UNDECIDED) && (!g[w].in_queue) ) {\n                // when pushing onto queue we also evaluate in_circle predicate so that we process vertices in the correct order\n                vertexQueue.push( VertexDetPair(w , g[w].in_circle(site->apex_point(g[w].position)) ) ); \n                g[w].in_queue=true;\n                if (debug) std::cout << \"  \" << g[w].index << \" queued (h=\" << g[w].in_circle(site->apex_point(g[w].position)) << \" )\\n\";\n        }\n    }\n}\n\n/// mark adjacent faces ::INCIDENT\n// IN-Vertex v has three adjacent faces, mark nonincident faces incident\n// and push them to the incident_faces queue\n// NOTE: call this only when inserting point-sites\nvoid VoronoiDiagram::mark_adjacent_faces_p( HEVertex v ) {\n    assert( g[v].status == IN );\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr( v )) {\n        HEFace adj_face = g[e].face;\n        if ( g[adj_face].status  != INCIDENT ) {\n            g[adj_face].status = INCIDENT; \n            incident_faces.push_back(adj_face);\n        }\n    }\n\n}\n\n/// mark adjacent faces ::INCIDENT\n// call this when inserting line-sites\n// since we call add_split_vertex we can't use iterators, because they get invalidated\n// so use the slower adjacent_faces() instead.\nvoid VoronoiDiagram::mark_adjacent_faces( HEVertex v, Site* site) {\n    assert( g[v].status == IN );\n    FaceVector new_adjacent_faces = g.adjacent_faces( v );\n    \n    assert(\n        (g[v].type == APEX && new_adjacent_faces.size()==2 ) ||\n        (g[v].type == SPLIT && new_adjacent_faces.size()==2 ) ||\n        new_adjacent_faces.size()==3\n    );\n\n    BOOST_FOREACH( HEFace adj_face, new_adjacent_faces ) {\n        if ( g[adj_face].status != INCIDENT ) {\n            if ( site->isLine() )\n                add_split_vertex(adj_face, site);\n\n            g[adj_face].status = INCIDENT;\n            incident_faces.push_back(adj_face);\n        }\n    }\n}\n\n/// \\brief find and return edges on which we potentially need ::SPLIT vertices\n///\n/// walk around the face f\n/// return edges whose endpoints are on separate sides of pt1-pt2 line\n/// \\todo ?not all edges found like this *need* SPLIT vertices? (but it does not hurt to insert SPLIT-vertices in this case)\nEdgeVector VoronoiDiagram::find_split_edges(HEFace f, Point pt1, Point pt2) {\n    assert( vd_checker->face_ok(f) );\n    EdgeVector out;\n    HEEdge current_edge = g[f].edge;\n    HEEdge start_edge = current_edge;\n    //int count=0;                             \n    do { // FIND ALL! not just one.\n        HEVertex trg = g.target( current_edge );\n        HEVertex src = g.source( current_edge );\n        bool src_is_right = g[src].position.is_right(pt1,pt2);\n        bool trg_is_right = g[trg].position.is_right(pt1,pt2);\n        if ( g[src].type == NORMAL || g[src].type == APEX || g[src].type == SPLIT) { //? check edge-type instead?\n            if ( src_is_right != trg_is_right  ) { \n                out.push_back(current_edge);\n                assert(vd_checker->check_edge(current_edge));\n            }\n        }\n        current_edge = g[current_edge].next;   \n        //count++;\n        //assert(count<100000); // some reasonable max number of edges in face, to avoid infinite loop\n    } while (current_edge!=start_edge);\n    \n    if (debug) {\n        std::cout << \" face \" << f << \" requires SPLIT vertices on edges: \\n\";\n        BOOST_FOREACH( HEEdge e, out ) {\n            std::cout << \"  \"; g.print_edge(e);\n        }\n    }\n    return out;\n}\n\n/// \\brief add one or many ::SPLIT vertices to the edges of the give face\n///\n/// these are projections/mirrors of the site of f with the new Site s acting as the mirror\n///\n/// ::SPLIT vertices are inserted to avoid deleting loops during augment_vertex_set()\nvoid VoronoiDiagram::add_split_vertex(HEFace f, Site* s) {\n    assert(!s->isPoint()); // no split-vertices when inserting point-sites\n        \n    Site* fs = g[f].site;\n    \n    // don't search for split-vertex on the start or end face\n    if (fs->isPoint() && s->isLine()) {\n        if ( fs->position() == s->start() || fs->position() == s->end() ) // FIXME: don't compare Points, instead compare vertex-index!\n            return;\n    }\n        \n    if ( fs->isPoint() && s->isLine() && s->in_region( fs->position() ) ) {\n        // 1) find the correct edge\n        Point pt1 = fs->position();\n        Point pt2 = pt1-Point( s->a(), s->b() ); \n        \n        assert( (pt1-pt2).norm() > 0 ); \n        \n        EdgeVector split_edges = find_split_edges(f, pt1, pt2);\n        // the sought edge should have src on one side of pt1-pt2\n        // and trg on the other side of pt1-pt2\n        \n        BOOST_FOREACH(HEEdge split_edge, split_edges) {\n            if ( (g[split_edge].type == SEPARATOR) || (g[split_edge].type == LINESITE) )\n                return; // don't place split points on linesites or separators(?)\n\n            // find a point = src + u*(trg-src)\n            // with min_t < u < max_t\n            // and minimum distance to the pt1-pt2 line\n        #define TOMS748\n        \n        Point split_pt_pos;\n        \n        #ifdef TOMS748\n            HEVertex split_src = g.source(split_edge);\n            HEVertex split_trg = g.target(split_edge);\n            if (debug) {\n                std::cout << \" split src=\" << g[split_src].index << \"(\"<< g[split_src].dist() << \")\";\n                std::cout << \" trg=\" << g[split_trg].index << \"(\"<< g[split_trg].dist() << \") \\n\";\n                std::cout << \"is_right src=\" << g[split_src].position.is_right(pt1,pt2) << \"  trg=\"<< g[split_trg].position.is_right(pt1,pt2) << \"\\n\";\n            }\n            SplitPointError errFunctr( g, split_edge, pt1, pt2); // error functor\n            typedef std::pair<double, double> Result;\n            boost::uintmax_t max_iter=500;\n            boost::math::tools::eps_tolerance<double> tol(64); // bits of tolerance?\n            double min_t = std::min( g[split_src].dist() , g[split_trg].dist() );\n            double max_t = std::max( g[split_src].dist() , g[split_trg].dist() );\n            // require that min_t and max_t bracket the root\n            if ( errFunctr(min_t)*errFunctr(max_t) >= 0 )\n                return;\n                \n            Result r1 = boost::math::tools::toms748_solve(errFunctr, min_t, max_t, tol, max_iter);\n            split_pt_pos = g[split_edge].point( r1.first ); \n        #endif\n        \n            // alternative SPLIT-vertex positioning:\n            // - create virtual line-site vs: same direction as s(lineSite), but goes through fs(pointSite)\n            // - use solver to position SPLIT vertex. The sites are: (vs,fs, fs-adjacent)\n        #ifndef TOMS748\n            Site* vs = new LineSite(*s);\n            vs->set_c( fs->position() ); // modify the line-equation so that the line goes trough fs->position()\n            Solution sl = vpos->position( split_edge, vs );\n            split_pt_pos = sl.p;\n        #endif\n        \n            HEVertex v = g.add_vertex( VoronoiVertex(split_pt_pos, UNDECIDED, SPLIT, fs->position() ) );\n            \n        #ifndef TOMS748\n            delete vs;\n        #endif\n        \n            //std::cout << \"toms748: \" << split_pt << \"\\n\";\n            //std::cout << \"solver:  \" << sl.p << \"\\n\";\n            if (debug) {\n                std::cout << \" new split-vertex \" << g[v].index << \" t=\" << r1.first;\n                std::cout << \" inserted into edge \" << g[split_src].index << \"-\" << g[split_trg].index  << \"\\n\";\n            }\n            \n            assert( vd_checker->check_edge(split_edge) );\n            // 3) insert new SPLIT vertex into the edge\n            g.add_vertex_in_edge(v, split_edge);\n        }\n    }\n}\n\n/// find a ::SPLIT vertex on the Face f\n// return true, and set v, if found.\nbool VoronoiDiagram::find_split_vertex(HEFace f, HEVertex& v)  {\n    VertexVector verts = g.face_vertices(f);\n    BOOST_FOREACH(HEVertex q, verts) {\n        if (g[q].type == SPLIT) {\n            v = q;\n            return true;\n        }\n    }\n    return false;\n}\n\n/// \\brief remove all ::SPLIT type vertices on the HEFace \\a f\nvoid VoronoiDiagram::remove_split_vertex(HEFace f) {\n\n    if (debug) {\n        std::cout << \"remove_split_vertex( \" << f << \" )\\n\";\n        g.print_face(f);\n    }\n    assert( vd_checker->face_ok( f ) );\n    \n    HEVertex v;\n    while ( find_split_vertex(f,v) ) {\n        assert(g[v].type == SPLIT); \n        if (debug) std::cout << \" removing split-vertex \" << g[v].index << \"\\n\";\n        \n        g.remove_deg2_vertex( v );\n        modified_vertices.erase(v);\n        \n        assert( vd_checker->face_ok( f ) );\n    }\n    \n    assert( vd_checker->face_ok( f ) );\n}\n\n/// \\brief add ::NEW vertices on ::IN-::OUT edges\n/// \n/// generate new voronoi-vertices on all IN-OUT edges \n/// Note: used only by insert_point_site() !!\nvoid VoronoiDiagram::add_vertices( Site* new_site ) {\n    if (debug) std::cout << \"add_vertices(): \\n\";\n    assert( !v0.empty() );\n    EdgeVector q_edges = find_in_out_edges();       // new vertices generated on these IN-OUT edges\n    for( unsigned int m=0; m<q_edges.size(); ++m )  {   \n        if (debug) {\n            HEVertex src = g.source(q_edges[m]);\n            HEVertex trg = g.target(q_edges[m]);\n            std::cout << \" Position NEW vertex on \" << g[src].index << \" - \" << g[trg].index << \"\\n\";\n            vpos->solver_debug(true);\n        }\n        solvers::Solution sl = vpos->position( q_edges[m], new_site ); // vertex_positioner.cpp\n\n        if ( vpos->dist_error( q_edges[m], sl, new_site) > 1e-3 ) {\n            HEVertex src = g.source(q_edges[m]);\n            HEVertex trg = g.target(q_edges[m]);\n            std::cout << \"ERROR while positioning new vertex  on edge\\n\";\n            std::cout << g[ src ].index << \"[\" << g[ src ].type << \"]\" << \"{\" << g[ src ].status << \"}\" << \"(t=\" << g[ src ].dist() << \")\";\n            std::cout <<  \" -[\" << g[q_edges[m]].type << \"]- \"; \n            std::cout << g[ trg ].index << \"[\" << g[ trg ].type << \"]\" << \"{\" << g[ trg ].status << \"}\" << \"(t=\" << g[ trg ].dist() << \")\";\n            \n            std::cout <<  \"     derr =\" << vpos->dist_error( q_edges[m], sl, new_site) << \"\\n\";\n            //exit(-1);\n        }\n        HEVertex q = g.add_vertex( VoronoiVertex( sl.p, NEW, NORMAL, new_site->apex_point( sl.p ), sl.k3 ) );\n        modified_vertices.insert(q);\n        g.add_vertex_in_edge( q, q_edges[m] );\n        g[q].max_error = vpos->dist_error( q_edges[m], sl, new_site);\n        if (debug) {\n            HEVertex src = g.source(q_edges[m]);\n            HEVertex trg = g.target(q_edges[m]);\n            std::cout << \" NEW vertex \" << g[q].index << \" k3= \"<< g[q].k3 << \" on edge \" << g[src].index << \" - \" << g[trg].index << \"\\n\";\n            assert( (g[q].k3==1) || (g[q].k3==-1) );\n        }\n    }\n    if (debug) std::cout << \"add_vertices() done.\\n\";\n}\n\n/// \\brief add a new face corresponding to the new Site\n///\n/// call add_new_edge() on all the incident_faces that should be split\nHEFace VoronoiDiagram::add_face(Site* s) { \n    HEFace newface =  g.add_face(); \n    g[newface].site = s;\n    s->face = newface;\n    g[newface].status = NONINCIDENT;\n    if (s->isPoint() )\n        kd_tree->insert( kd_point( s->position(), newface ) );\n        //fgrid->add_face( newface, s->position() ); \n    \n    return newface;\n}\n\n/// two-argument version used by insert_point_site()\nvoid VoronoiDiagram::add_edges(HEFace newface, HEFace f) {\n    add_edges( newface, f, g.HFace(), std::make_pair(HEVertex(),HEVertex()) );\n}\n\n/// \\brief add all ::NEW-::NEW edges\n///\n/// by adding a NEW-NEW edge, split the face f into one part which is newface, and the other part is the old f\n/// for linesegment or arc sites we pass in both the k=+1 face newface and the k=-1 face newface2\n/// the segment endpoints are passed to find_edge_data()\nvoid VoronoiDiagram::add_edges(HEFace newface, HEFace f, HEFace newface2, std::pair<HEVertex, HEVertex> segment) {\n    int new_count = num_new_vertices(f);\n    if (debug) std::cout << \" add_edges() on f=\" << f << \" with \" << new_count << \" NEW verts.\\n\";\n    assert( new_count > 0 );\n    assert( (new_count % 2) == 0 );\n    //if ((new_count % 2) != 0) {\n    //    std::cout << \" add_edges() FATAL ERROR on f=\" << f << \" with \" << new_count << \" NEW verts.\\n\";\n    //    exit(-1);\n    //}\n    int new_pairs = new_count / 2; // we add one NEW-NEW edge for each pair found\n    VertexVector startverts; // this holds ed.v1 vertices for edges already added\n    for (int m=0;m<new_pairs;m++) {\n        EdgeData ed = find_edge_data(f, startverts, segment);\n        add_edge( ed, newface, newface2);\n        startverts.push_back( ed.v1 );\n    }\n    if (debug) std::cout << \" add_edges() all edges on f=\" << f << \" added.\\n\";\n}\n\n/// \\brief add a new edge to the diagram\n// newface = the k=+1 positive offset face\n// newface2 = the k=-1 negative offset face\nvoid VoronoiDiagram::add_edge(EdgeData ed, HEFace newface, HEFace newface2) {\n    HEEdge new_previous = ed.v1_prv;\n    HEVertex new_source = ed.v1;         //-OUT-NEW(v1)-IN-...\n    HEEdge twin_next = ed.v1_nxt;\n    \n    HEEdge twin_previous = ed.v2_prv;\n    HEVertex new_target = ed.v2;         // -IN-NEW(v2)-OUT-\n    HEEdge new_next = ed.v2_nxt;\n        \n    HEFace f = ed.f;\n    Site* f_site = g[f].site;\n    Site* new_site;\n    HEFace new_face;\n    if ( g[new_source].k3 == 1 ) { // find out if newface or newface2 should be used\n        new_site = g[newface].site;\n        new_face = newface; \n    } else {\n        new_site = g[newface2].site; \n        new_face = newface2;\n    }\n        \n    // both trg and src should be on same side of new site \n    assert( g[new_target].k3 == g[new_source].k3 );\n\n    //                                           f\n    // now connect:   new_previous -> new_source -> new_target -> new_next\n    // and:              twin_next <- new_source <- new_target <- twin_previous \n    //                                           new_face   \n\n    // check for potential apex-split\n    // we need an apex-vertex if the source and target are on different branches of the new quadratic edge\n    // we can set the src_sign and trg_sign with is_right where we compare to a line through the apex \n    bool src_sign=true, trg_sign=true;\n    if (f_site->isPoint()  &&  new_site->isLine()  ) { // PL or PA\n        Point pt2 = f_site->position();\n        Point pt1 = new_site->apex_point(pt2); // projection of pt2 onto LineSite or ArcSite\n        src_sign = g[new_source].position.is_right( pt1, pt2 );\n        trg_sign = g[new_target].position.is_right( pt1, pt2 );\n    } else if (f_site->isPoint()  &&   new_site->isArc()  ) {\n        Point pt2 = f_site->position();\n        // project p2 onto circle\n        Point cen = Point( new_site->x(), new_site->y() );\n        Point cen_pt2 = pt2 - cen;\n        Point pt1 = cen + (new_site->r()/cen_pt2.norm())*cen_pt2;\n        src_sign = g[new_source].position.is_right( pt1, pt2 );\n        trg_sign = g[new_target].position.is_right( pt1, pt2 );        \n    } else if (f_site->isPoint() && new_site->isPoint() ) { // PP\n        src_sign = g[new_source].position.is_right( f_site->position(), new_site->position() );\n        trg_sign = g[new_target].position.is_right( f_site->position(), new_site->position() );\n    } else if (f_site->isLine() && new_site->isLine() )  { // LL\n        //  a line-line bisector, sign should not matter because there is no sqrt()\n        /*\n        std::cout << \"add_edge() LL-edge \" << g[new_source].index << \" - \" << g[new_target].index ;\n        std::cout << \" f_site->k()= \" << f_site->k() << \" new_site->k()= \"<< new_site->k() << \"\\n\";\n        std::cout << \" f_site <-> src(\"<< g[new_source].index << \") = \" << g[new_source].position.is_right( f_site->start(), f_site->end() ) << \" \" << g[new_source].position << \"\\n\";\n        std::cout << \" f_site <-> trg(\"<< g[new_target].index << \") = \" << g[new_target].position.is_right( f_site->start(), f_site->end() ) << \" \" << g[new_target].position <<  \"\\n\";\n        std::cout << \" n_site <-> src(\"<< g[new_source].index << \") = \" << g[new_source].position.is_right( new_site->start(), new_site->end() ) << \"\\n\";\n        std::cout << \" n_site <-> trg(\"<< g[new_target].index << \") = \" << g[new_target].position.is_right( new_site->start(), new_site->end() ) << \"\\n\";\n        */\n        // this is essentially an in-region test \n        if ( (g[new_source].position != g[new_target].position) && // src and trg are different\n              ( g[new_source].position != f_site->start() ) &&  // src/trg is not start or end\n              ( g[new_source].position != f_site->end() ) &&\n              ( g[new_target].position != f_site->start() ) &&\n              ( g[new_target].position != f_site->end() ) &&\n              ( (g[new_source].position -f_site->apex_point( g[new_source].position ) ).norm() > 1e-3 ) && // require some distance, \n              ( (g[new_target].position -f_site->apex_point( g[new_target].position ) ).norm() > 1e-3 )  // so that the is_right predicate is accurate\n            ) {\n                assert( !g[new_source].position.is_right( f_site->start(), f_site->end() ) );\n                assert( !g[new_target].position.is_right( f_site->start(), f_site->end() ) );\n                assert( !g[new_source].position.is_right( new_site->start(), new_site->end() ) );\n                assert( !g[new_target].position.is_right( new_site->start(), new_site->end() ) );\n        }\n    } else if (f_site->isLine() && new_site->isArc() )  { // LA\n        Point pt2 = Point( new_site->x(), new_site->y() );\n        Point pt1 = f_site->apex_point(pt2);\n        src_sign = g[new_source].position.is_right( pt1, pt2 );\n        trg_sign = g[new_target].position.is_right( pt1, pt2 );\n        // if one vertex is on a null-face, we cannot trust the sign\n        if ( g[new_source].dist() == 0 || g[new_target].dist() == 0 ) {\n            if ( g[new_source].dist() > g[new_target].dist() ) {\n                src_sign = trg_sign;\n            } else {\n                trg_sign = src_sign;\n            }\n        }\n    } else { // unhandled case!\n        std::cout << \" add_edge() WARNING: no code to deremine src_sign and trg_sign!\\n\";\n        std::cout << \" add_edge() f_site \" << f_site->str() << \"\\n\";\n        std::cout << \" add_edge() new_site \" << new_site->str() << \"\\n\"; // WARNING: no code to deremine src_sign and trg_sign!\\n\";\n        assert(0);\n    }\n    \n    // both src and trg are on the same side of the new site.\n    // so no apex-split is required, just add a single edge.\n    if ( src_sign == trg_sign ) {  // add a single src-trg edge\n        if (debug) {\n            std::cout << \" add_edge \" << g[new_source].index << \" - \" << g[new_target].index << \"\\n\";\n            std::cout << \" f= \" << f << \" new_face= \" << new_face << \"\\n\";\n            std::cout << \" site= \" << f_site->str() << \" new_site=\" << new_site->str() << \"\\n\";\n        }\n        HEEdge e_new, e_twin;\n        boost::tie(e_new,e_twin) = g.add_twin_edges( new_source, new_target );\n        g[e_new].next = new_next;\n        assert( g[new_next].k == g[new_previous].k );\n        g[e_new].k = g[new_next].k; // the next edge is on the same face, so has the correct k-value\n        g[e_new].face = f; // src-trg edge has f on its left\n        g[new_previous].next = e_new;\n        g[f].edge = e_new; \n        g[e_new].set_parameters( f_site, new_site, !src_sign ); \n\n        g[twin_previous].next = e_twin;\n        g[e_twin].next = twin_next;\n        g[e_twin].k = g[new_source].k3; \n        g[e_twin].set_parameters( f_site, new_site,  !src_sign ); // new_site, f_site, src_sign \n        g[e_twin].face = new_face; \n        g[new_face].edge = e_twin;\n\n        assert( vd_checker->check_edge(e_new) && vd_checker->check_edge(e_twin) );\n        /*\n        std::cout << \" added edge \" << g[new_target].index << \"(\" << g[new_target].dist() <<\")\";\n        std::cout << \" - \" << g[new_source].index << \"(\" << g[new_source].dist() << \")\";\n        std::cout << \" f=\" << g[e_new].face << \" k=\" << g[e_twin].k;\n        std::cout << \" twf=\" << g[e_twin].face << \" twk=\" << g[e_new].k;\n        std::cout << \" type=\" << g[e_twin].type <<   \" \\n\";\n        */\n        //std::cout << \" k3 target-source: \"<<  g[new_target].k3 << \" - \" << g[new_source].k3 << \"\\n\";\n    } else {\n        // need to do apex-split, and add two new edges\n        //                         f               f  \n        //   new_prv -> NEW -- e1 ----> APEX --e2 ---> NEW -> new_nxt\n        //   twn_nxt <- NEW <- e1_tw -- APEX <-e2_tw-- NEW <- twn_prv    \n        //                       new1/new2         new1/new2\n        //   \n        HEVertex apex = g.add_vertex( VoronoiVertex(Point(0,0), NEW,APEX) );\n        if (debug) std::cout << \" add_edge with APEX \" << g[new_source].index << \" - [\" << g[apex].index << \"] - \" << g[new_target].index << \"\\n\";\n        \n        HEEdge e1, e1_tw;\n        HEEdge e2, e2_tw;\n        boost::tie(e1, e1_tw) = g.add_twin_edges( new_source, apex );\n        boost::tie(e2, e2_tw) = g.add_twin_edges( apex, new_target );\n        g[e1].set_parameters( f_site, new_site, !src_sign);\n        g[e2].set_parameters( f_site, new_site, !trg_sign);\n        \n        assert( g[new_previous].face == f );\n        assert( g[new_next].face == g[new_previous].face );\n        assert( g[new_next].k == g[new_previous].k );\n\n        // new_previous -> e1 -> e2 -> new_next\n        //g.set_next_chain( boost::assign::list_of(new_previous)(e1)(e2)(new_next), f, g[new_next].k );\n        g[new_previous].next=e1; g[e1].next=e2; g[e2].next=new_next;\n        g[e1].face=f; g[e2].face=f;\n        g[e1].k=g[new_next].k; g[e2].k=g[new_next].k;\n        g[f].edge=e1;\n    // twin edges\n        g[e1_tw].set_parameters(new_site, f_site, src_sign);\n        g[e2_tw].set_parameters(new_site, f_site, trg_sign);\n\n        assert( g[twin_previous].k == g[twin_next].k );  \n        assert( g[twin_previous].face == g[twin_next].face );        \n        // twin_prev -> e2_tw -> e1_tw -> twin_next   on new_face \n\n        //g.set_next_chain( boost::assign::list_of(twin_previous)(e2_tw)(e1_tw)(twin_next) );\n        g[twin_previous].next=e2_tw; g[e2_tw].next=e1_tw; g[e1_tw].next=twin_next;\n        //g[e1].face=f; g[e2].face=f;\n        //g[e1].k=g[new_next].k; g[e2].k=g[new_next].k;\n\n        //, new_face,  g[new_source].k3  );\n\n                \n        g[e1_tw].k = g[new_source].k3;\n        g[e2_tw].k = g[new_source].k3;\n        g[new_face].edge = e1_tw;\n        g[e1_tw].face = new_face;\n        g[e2_tw].face = new_face;\n        \n        assert( vd_checker->check_edge(e1) && vd_checker->check_edge(e1_tw) );\n        assert( vd_checker->check_edge(e2) && vd_checker->check_edge(e2_tw) );\n        \n    // position the apex\n        double min_t = g[e1].minimum_t(f_site,new_site);\n        g[apex].position = g[e1].point(min_t);\n        g[apex].init_dist(f_site->apex_point(g[apex].position));\n        modified_vertices.insert( apex );\n    }\n}\n\n\n/// \\brief find the target of a new ::SEPARATOR edge\n/// \\param f the HEFace on which we search for the target vertex\n/// \\param endp the end-point of the null-face with the ::SEPARATOR source\n///\n/// we want to insert a ::SEPARATOR edge (endp, target) , on the give face f.\n/// find and return the target vertex to which the new ::SEPARATOR edge should connect\n/// also return the adjacent next/prev edges\n///\n/// flag==true when an ::OUT-::NEW-::IN vertex was found\n///\n/// flag==false when an ::IN-::NEW-::OUT vertex was found\n///\nboost::tuple<HEEdge,HEVertex,HEEdge,bool> VoronoiDiagram::find_separator_target(HEFace f, HEVertex endp) {\n    if (endp==HEVertex()) // no separator\n        return boost::make_tuple( HEEdge(), HEVertex(), HEEdge(), false) ;\n    \n    HEEdge current_edge = g[f].edge; // start on some edge of the face\n    HEEdge start_edge = current_edge;\n    bool found = false;\n    HEVertex v_target = HEVertex();\n    HEEdge v_previous, v_next;\n    bool flag(true);\n    if (debug) { \n        std::cout << \" find_separator_target f=\" << f << \" endp= \" << g[endp].index << \"\\n\";\n        g.print_face(f);\n    }\n    do {\n        HEEdge next_edge = g[current_edge].next;\n        HEVertex previous_vertex = g.source( current_edge );\n        HEVertex current_vertex  = g.target( current_edge );\n        HEVertex next_vertex     = g.target( next_edge );\n        bool out_new_in = ( ((g[previous_vertex].status == OUT) || (g[previous_vertex].status == UNDECIDED)) && \n                             g[current_vertex].status == NEW && \n                             g[next_vertex].status == IN );\n        bool in_new_out = ( g[previous_vertex].status == IN && \n                            g[current_vertex].status == NEW && \n                            (g[next_vertex].status == OUT || (g[next_vertex].status == UNDECIDED)) ); \n        if ( out_new_in || in_new_out ) {\n            if (debug) {\n                std::cout << \"potential OUT/IN-NEW-IN/OUT: \" << g[previous_vertex].index << \"-\" << g[current_vertex].index;\n                std::cout << \"-\" << g[next_vertex].index << \"\\n\";\n            }\n            if ( (g[endp].k3 == g[current_vertex].k3)  && endp!=current_vertex ) {\n                    v_target = current_vertex;\n                    v_previous = current_edge;\n                    v_next = next_edge;\n                    flag = out_new_in ? true : false;\n                    found = true;                 \n                    if (debug) std::cout << \"FOUND!\\n\";\n            }  else {\n                if (debug) {\n                    std::cout << \" g[endp].k3  = \" <<  g[endp].k3  <<\"\\n\";\n                    std::cout << \" g[current_vertex].k3  = \" << g[current_vertex].k3  <<\"\\n\";\n                    std::cout << \" k3 match? = \" <<  (g[endp].k3 == g[current_vertex].k3) <<\"\\n\";\n                    std::cout << \" endp!=current_vertex ? = \" <<  (endp!=current_vertex) <<\"\\n\";\n                }\n            }\n        }\n        current_edge = g[current_edge].next;   \n        //count++;\n        //assert(count<10000); // some reasonable max number of edges in face, to avoid infinite loop\n    } while (current_edge!=start_edge && !found);\n    if (!found) {\n        std::cout << \"find_separator_target() FATAL ERROR\\n\";\n        std::cout << \" find_separator_target Unable to find target vertex on face f=\" << f << \" endp= \" << g[endp].index << \"\\n\";\n        std::cout << \" looking for OUT-NEW-IN: \" << OUT << \" - \" << NEW << \" - \" << IN << \"\\n\";\n        std::cout << \" looking for IN-NEW-OUT: \" << IN << \" - \" << NEW << \" - \" << OUT << \"\\n\";\n        g.print_face(f);\n        exit(-1);\n    }\n    assert(found);\n\n    return boost::make_tuple(v_previous, v_target, v_next, flag);\n}\n\n/// \\brief find EdgeData for a new edge\n///\n/// on a face which has ::IN and ::OUT-vertices, find the sequence\n/// OUT-OUT-OUT-..-OUT-NEW(v1)-IN-...-IN-NEW(v2)-OUT-OUT\n/// and return v1/v2 together with their previous and next edges\n/// \\param f face on which we search for vertices\n/// \\param startverts contains NEW-vertices already found, which are not valid for this call to find_edge_data\n/// \\param segment contains ENDPOINT vertices, when we are inserting a line-segment\n/// (these vertices are needed to ensure finding correct points around sites/null-edges)\n\nVoronoiDiagram::EdgeData VoronoiDiagram::find_edge_data(HEFace f, VertexVector startverts, std::pair<HEVertex,HEVertex> segment)  {\n    EdgeData ed;\n    ed.f = f;\n    if (debug) {\n        std::cout << \"find_edge_data():\\n\";\n        std::cout << \" \"; g.print_face(f);\n    }\n    HEEdge current_edge = g[f].edge; // start on some edge of the face\n    HEEdge start_edge = current_edge;\n    bool found = false;\n    //int count=0;    \n    if (debug) std::cout << \"    finding OUT-NEW-IN vertex: \\n\";                         \n    do { // find OUT-NEW-IN vertices in this loop\n        HEEdge next_edge = g[current_edge].next;\n        \n        HEVertex previous_vertex = g.source( current_edge);\n        HEVertex  current_vertex = g.target( current_edge );\n        HEVertex     next_vertex = g.target( next_edge );\n        bool previous_not_endpoint = (previous_vertex!=segment.first && previous_vertex!=segment.second);\n        bool next_is_endpoint = (next_vertex==segment.first || next_vertex==segment.second);\n        \n        if ( (g[current_vertex].status==NEW) && (g[current_vertex].type != SEPPOINT) &&\n             (  ( (g[previous_vertex].status==OUT || g[previous_vertex].status==UNDECIDED)  &&  \n                     previous_not_endpoint ) \n                   ||\n                ( next_is_endpoint )\n             )\n           ) {\n            // slow? linear search through vector. but startverts.size() should not be too large..\n            bool v_in_startverts =\n                ( std::find(startverts.begin(), startverts.end(),  current_vertex) != startverts.end() );\n            if (debug) {\n                std::cout << \"     \" << g[current_vertex].index << \"N=\" << (g[current_vertex].status == NEW) ;\n                std::cout << \" !SEPP=\" << (g[current_vertex].type != SEPPOINT) << \"\\n\";\n            }\n            if ( !v_in_startverts ) {\n                ed.v1 = current_vertex;\n                ed.v1_prv = current_edge;\n                ed.v1_nxt = g[current_edge].next;\n                found = true;\n            }\n        }\n        current_edge = g[current_edge].next;   \n        //count++;\n        //assert(count<10000); // some reasonable max number of edges in face, to avoid infinite loop\n    } while (current_edge!=start_edge && !found);\n    //if (!found) {\n    //    std::cout << \"ERROR: unable to find OUT-NEW-IN vertex on face:\\n\";\n    //    g.print_face(f);\n    //    std::cout << \" The excluded vertices are: (size=\" << startverts.size()<<\")\"; g.print_vertices(startverts);\n    //}\n    assert(found);\n    if (debug) std::cout << \" OUT-NEW-IN vertex is  \" << g[ed.v1].index << \"\\n\";\n\n    // now search for v2\n    //count=0; \n    start_edge = current_edge; // note that this search starts where we ended in the loop above!\n    found=false;\n    if (debug) std::cout << \"    finding IN-NEW-OUT vertex: \\n\";   \n    do { // find IN-NEW-OUT vertices in this loop\n        HEVertex  current_vertex = g.target( current_edge );\n        if ( g[current_vertex].status == NEW && g[current_vertex].type != SEPPOINT ) {\n            if (debug) {\n                std::cout << \"     \" << g[current_vertex].index << \"N=\" << (g[current_vertex].status == NEW) ;\n                std::cout << \" !SEPP=\" << (g[current_vertex].type != SEPPOINT);\n                std::cout << \" !ed.v1=\" << (current_vertex != ed.v1) <<\"\\n\";\n            }\n            if (  current_vertex != ed.v1) { // -IN-NEW(v2)\n                    ed.v2     = current_vertex;\n                    ed.v2_prv = current_edge;\n                    ed.v2_nxt = g[current_edge].next;\n                    found = true;                 \n            }\n        }\n        current_edge = g[current_edge].next;   \n        //count++;\n        //assert(count<10000); // some reasonable max number of edges in face, to avoid infinite loop\n    } while (current_edge!=start_edge && !found);\n    assert(found);\n    if (debug) std::cout << \" IN-NEW-OUT vertex is \" << g[ed.v2].index << \"\\n\";\n\n    if (debug) std::cout << \"find_edge_data() NEW-NEW vertex pair: \" << g[ed.v1].index << \" - \" << g[ed.v2].index << \"\\n\";\n    return ed;\n}\n\n/// one-argument version of repair_face() used by insert_point_site()\nvoid VoronoiDiagram::repair_face( HEFace f ) {\n    repair_face(f,  std::make_pair(HEVertex(),HEVertex()), \n                    std::make_pair(g.HFace(), g.HFace() ),\n                    std::make_pair(g.HFace(), g.HFace() ) );\n}\n\n/// \\brief repair next-pointers of HEFace \\a f\n///\n/// start on g[newface].edge, walk around the face and repair the next-pointers\n/// this is called on the newly created face after all NEW-NEW edges have been added\nvoid VoronoiDiagram::repair_face( HEFace f, std::pair<HEVertex,HEVertex> segment, \n                                            std::pair<HEFace,HEFace> nulled_faces,\n                                            std::pair<HEFace,HEFace> null_face ) {\n    if (debug) {\n        std::cout << \"repair_face ( \" << f << \" ) null1=\" << null_face.first << \" null2=\" << null_face.second << \"\\n\";\n        if ( (segment.first!=HEVertex()) && (segment.second!=HEVertex()) )\n            std::cout << \" seg_start=\" << g[segment.first].index << \" seg_end=\" << g[segment.second].index << \"\\n\";\n        std::cout << \" nulled.first=\" << nulled_faces.first << \" nulled.second=\" << nulled_faces.second << \"\\n\";\n    }\n    HEEdge current_edge = g[f].edge;\n    HEEdge start_edge = current_edge;\n    //int count=0;\n    do {\n        assert( vd_checker->check_edge(current_edge) );\n        HEVertex current_target = g.target( current_edge ); // an edge on the new face\n        HEVertex current_source = g.source( current_edge );\n        #ifndef NDEBUG\n        bool found_next_edge= false;\n        #endif\n        if (debug) { \n            std::cout << \" edge \" << g[ g.source(current_edge) ].index << \" - \";\n            std::cout <<  g[ g.target(current_edge) ].index << \"\\n\";\n        }\n        BOOST_FOREACH(HEEdge e, g.out_edge_itr(current_target)){\n            HEVertex out_target = g.target( e );\n            if(debug) {\n                std::cout << \"     candidate: \" << g[ g.source(e) ].index << \" - \";\n                std::cout << g[ g.target(e) ].index << \" f= \"<< g[e].face << \" \\n\";\n            }\n            if ( (out_target != current_source) && \n                 ( (g[out_target].status == NEW)    || \n                   (g[out_target].type == ENDPOINT) || \n                   (g[out_target].type == SEPPOINT) ) ) { // these are the possible vertices we want to go to\n                \n                \n                // special cases where we do a brute-force face-assignment for a null-edge, or a separator\n                if ( ((g[e].type == NULLEDGE) &&\n                      (g[current_edge].type != NULLEDGE) && // only one null-edge in succession!\n                         (\n                           // from sep to end\n                           ( (g[current_target].type==SEPPOINT) && (g[out_target].type == ENDPOINT) ) ||\n                           // or from end -> end \n                           ( (g[current_source].type == ENDPOINT) && (g[current_target].type==ENDPOINT)  )\n                           ||\n                           (out_target == segment.first)\n                           ||\n                           (out_target == segment.second) \n                         ) &&\n                        (g[e].face!=null_face.first) && // not along a null-face edge!\n                        (g[e].face!=null_face.second)\n                     ) \n                     ||\n                     (g[e].face == nulled_faces.first) // edge previously belonged to point-site that has disappeared\n                     ||\n                     (g[e].face == nulled_faces.second)\n                     )\n                      {\n                         \n                    g[e].face = f; // override face-assignment!\n                    g[e].k=g[current_edge].k; // override k-assignment!\n                    if (debug) std::cout << \" face and k-val override! f=\"<< f << \" k=\" << g[current_edge].k << \"\\n\";\n                }\n                    \n                // the next vertex should not where we came from\n                // and it should be on the same face.\n                if ( g[e].face == f ) {  \n                    g[current_edge].next = e; // this is the edge we want to take\n                    #ifndef NDEBUG\n                    found_next_edge = true;\n                    #endif\n                    if(debug) {\n                        std::cout << \"         next: \" << g[ g.source(e) ].index << \" - \";\n                        std::cout << g[ g.target(e) ].index << \"\\n\";\n                    }\n                    assert( g[current_edge].k == g[e].k );\n                    assert( vd_checker->current_face_equals_next_face( current_edge ) );\n                }\n            } \n        }\n        //if (!found_next_edge) {\n        //    std::cout << \" repair_face( \" << f << \" ) error. could not find next-edge!\\n\";\n        //    exit(-1);\n        //}\n        assert(found_next_edge); // must find a next-edge!\n        //count++;\n        //if (count>30)\n        //    exit(-1);\n        current_edge = g[current_edge].next; // jump to the next edge\n    } while (current_edge != start_edge);\n    \n}\n\n/// \\brief remove the ::IN vertices of the delete-tree\n///\n/// removes the IN vertices stored in v0 (and associated IN-NEW edges)\nvoid VoronoiDiagram::remove_vertex_set() {\n    BOOST_FOREACH( HEVertex& v, v0 ) {      // it should now be safe to delete all IN vertices\n        assert( g[v].status == IN );\n        g.delete_vertex(v); // this also removes edges connecting to v\n        modified_vertices.erase(v);\n    }\n}\n\n/// \\brief reset status of modified_vertices and incident_faces\n///    \n/// at the end after an incremental insertion of a new site,\n/// reset status of modified_vertices to UNDECIDED and incident_faces to NONINCIDENT,\n/// so that we are ready for the next insertion.\nvoid VoronoiDiagram::reset_status() {\n    BOOST_FOREACH( HEVertex v, modified_vertices ) {\n        g[v].reset_status();\n    }\n    modified_vertices.clear();\n    BOOST_FOREACH(HEFace& f, incident_faces ) { \n        g[f].status = NONINCIDENT; \n    }\n    incident_faces.clear();\n    v0.clear();\n}\n\n/// \\brief find and return ::IN - ::OUT edges\n/// \n/// given the set v0 of ::IN vertices, find and return the adjacent ::IN - ::OUT edges.\n/// Later ::NEW vertices are inserted into each of the found ::IN - ::OUT edges\nEdgeVector VoronoiDiagram::find_in_out_edges() { \n    assert( !v0.empty() );\n    EdgeVector output; // new vertices generated on these edges\n    BOOST_FOREACH( HEVertex& v, v0 ) {                                   \n        assert( g[v].status == IN ); // all verts in v0 are IN\n        BOOST_FOREACH(HEEdge e, g.out_edge_itr(v)){\n            if ( g[ g.target( e ) ].status == OUT ) \n                output.push_back(e); // this is an IN-OUT edge\n        }\n    }\n    if (debug) std::cout << \"find_in_out_edges() \" << output.size() << \" IN-OUT edges \\n\";\n    assert( !output.empty() );\n    return output;\n}\n\n/// \\brief adjacent in-count predicate for buildingdelete-tree\n///\n/// number of IN vertices adjacent to given vertex v\n/// predicate C4 i.e. \"adjacent in-count\" from Sugihara&Iri 1992 \"one million\" paper\nbool VoronoiDiagram::predicate_c4(HEVertex v) {\n    int in_count=0;\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr(v)){\n        HEVertex w = g.target( e );\n        if ( g[w].status == IN ) {\n            in_count++;\n            if (in_count >= 2)\n                return true;\n        }\n    }\n    return false;\n}\n\n/// \\brief connectedness-predicate for delete-tree building\n///\n/// do any of the three faces that are adjacent to the given IN-vertex v have an IN-vertex ?\n/// predicate C5 i.e. \"connectedness\"  from Sugihara&Iri 1992 \"one million\" paper\nbool VoronoiDiagram::predicate_c5(HEVertex v) {\n    if (g[v].type == APEX || g[v].type == SPLIT ) { return true; } // ?\n    FaceVector adjacent_incident_faces;\n\n    BOOST_FOREACH(HEEdge e, g.out_edge_itr(v)){\n        //HEFace f = ;\n        if ( g[ g[e].face ].status == INCIDENT )\n            adjacent_incident_faces.push_back( g[e].face );\n    }\n\n    assert( !adjacent_incident_faces.empty() );\n    \n    //bool all_found = true;\n    BOOST_FOREACH( HEFace f, adjacent_incident_faces ) { // check each adjacent face f for an IN-vertex\n        bool face_ok=false;\n        HEEdge current = g[f].edge;\n        HEEdge start = current;\n        do {\n            HEVertex w = g.target(current);\n            if ( w != v && g[w].status == IN && g.has_edge(w,v) )  // v should be adjacent to an IN vertex on the face\n                face_ok = true;\n            else if ( w!=v && ( g[w].type == ENDPOINT || g[w].type == APEX  || g[w].type == SPLIT) ) // if we are next to an ENDPOINT, then ok(?)\n                face_ok=true;\n            current = g[current].next;\n        } while(current!=start);  \n\n        if (!face_ok)\n            return false;\n            //all_found=false;\n    }\n    return true; // if we get here we found all ok\n    //return all_found; // if this returns false, we mark a vertex OUT, on topology grounds.\n}\n\n/// return number of ::SPLIT vertices\nint VoronoiDiagram::num_split_vertices() const { \n    int count = 0;\n    BOOST_FOREACH( const HEVertex v, g.vertices() ) {\n        if (g[v].type == SPLIT)\n            count++;\n    }\n    return count; \n}\n\n/// count number of ::NEW vertices on the given face \\a f\nint VoronoiDiagram::num_new_vertices(HEFace f) {\n    HEEdge current = g[f].edge;\n    HEEdge start = current;\n    int count=0;\n    //int num_e=0;\n    do {\n        HEVertex v = g.target(current);\n        if ( (g[v].status == NEW) && (g[v].type != SEPPOINT) )\n            count++;\n        //num_e++;\n        //assert( num_e <3000);\n        current = g[current].next;\n    } while(current!=start);  \n    return count;\n}\n\n/// filter the graph using given Filter \\a flt\nvoid VoronoiDiagram::filter( Filter* flt) {\n    flt->set_graph(&g);\n    BOOST_FOREACH(HEEdge e, g.edges() ) {\n        if ( ! (*flt)(e) )\n            g[e].valid = false;\n    }\n}\n\n/// \\brief reset filtering by setting all edges valid\nvoid VoronoiDiagram::filter_reset() { // this sets valid=true for all edges \n    BOOST_FOREACH(HEEdge e, g.edges() ) {\n        g[e].valid = true;\n    }\n}\n    \n/// run topology/geometry check on diagram\nbool VoronoiDiagram::check() {\n    if( vd_checker->is_valid() ) {\n        if (debug) std::cout << \"diagram check OK.\\n\";\n        return true;\n    } else {\n        if (debug) std::cout << \"diagram check ERROR.\\n\";\n        return false;\n    }\n}\n\n/// string repr\nstd::string VoronoiDiagram::print() const {\n    std::ostringstream o;\n    o << \"VoronoiDiagram \\n\";\n    o << \" num_vertices    = \"<< g.num_vertices() << \"\\n\";\n    o << \" num_edges       = \"<< g.num_edges() <<\"\\n\";\n    o << \" num_point_sites = \"<< num_point_sites() <<\"\\n\";\n    o << \" num_line_sites  = \"<< num_line_sites() <<\"\\n\";\n    o << \" num_split_vertices  = \"<< num_split_vertices() <<\"\\n\";\n    return o.str();\n}\n\n} // end namespace\n// end file voronoidiagram.cpp\n","// -*- C++ -*-\n//===--------------------------- queue ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_QUEUE\n#define _LIBCPP_QUEUE\n\n/*\n    queue synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Container = deque<T>>\nclass queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n\npublic:\n    queue() = default;\n    ~queue() = default;\n\n    queue(const queue& q) = default;\n    queue(queue&& q) = default;\n\n    queue& operator=(const queue& q) = default;\n    queue& operator=(queue&& q) = default;\n\n    explicit queue(const container_type& c);\n    explicit queue(container_type&& c)\n    template <class Alloc>\n        explicit queue(const Alloc& a);\n    template <class Alloc>\n        queue(const container_type& c, const Alloc& a);\n    template <class Alloc>\n        queue(container_type&& c, const Alloc& a);\n    template <class Alloc>\n        queue(const queue& q, const Alloc& a);\n    template <class Alloc>\n        queue(queue&& q, const Alloc& a);\n\n    bool      empty() const;\n    size_type size() const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> void emplace(Args&&... args);\n    void pop();\n\n    void swap(queue& q) noexcept(noexcept(swap(c, q.c)));\n};\n\ntemplate <class T, class Container>\n  bool operator==(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator< (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator!=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator> (const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator>=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  bool operator<=(const queue<T, Container>& x,const queue<T, Container>& y);\n\ntemplate <class T, class Container>\n  void swap(queue<T, Container>& x, queue<T, Container>& y)\n  noexcept(noexcept(x.swap(y)));\n\ntemplate <class T, class Container = vector<T>,\n          class Compare = less<typename Container::value_type>>\nclass priority_queue\n{\npublic:\n    typedef Container                                container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n    Compare comp;\n\npublic:\n    priority_queue() = default;\n    ~priority_queue() = default;\n\n    priority_queue(const priority_queue& q) = default;\n    priority_queue(priority_queue&& q) = default;\n\n    priority_queue& operator=(const priority_queue& q) = default;\n    priority_queue& operator=(priority_queue&& q) = default;\n\n    explicit priority_queue(const Compare& comp);\n    priority_queue(const Compare& comp, const container_type& c);\n    explicit priority_queue(const Compare& comp, container_type&& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp = Compare());\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, const container_type& c);\n    template <class InputIterator>\n        priority_queue(InputIterator first, InputIterator last,\n                       const Compare& comp, container_type&& c);\n    template <class Alloc>\n        explicit priority_queue(const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, const container_type& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const Compare& comp, container_type&& c,\n                       const Alloc& a);\n    template <class Alloc>\n        priority_queue(const priority_queue& q, const Alloc& a);\n    template <class Alloc>\n        priority_queue(priority_queue&& q, const Alloc& a);\n\n    bool            empty() const;\n    size_type       size() const;\n    const_reference top() const;\n\n    void push(const value_type& v);\n    void push(value_type&& v);\n    template <class... Args> void emplace(Args&&... args);\n    void pop();\n\n    void swap(priority_queue& q)\n        noexcept(noexcept(swap(c, q.c)) && noexcept(swap(comp.q.comp)));\n};\n\ntemplate <class T, class Container, class Compare>\n  void swap(priority_queue<T, Container, Compare>& x,\n            priority_queue<T, Container, Compare>& y)\n            noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <deque>\n#include <vector>\n#include <functional>\n#include <algorithm>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Tp, class _Container> class _LIBCPP_TYPE_VIS_ONLY queue;\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y);\n\ntemplate <class _Tp, class _Container = deque<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value)\n        : c() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue(const queue& __q) : c(__q.c) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value)\n        : c(_VSTD::move(__q.c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(const queue& __q) {c = __q.c; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    queue& operator=(queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value)\n        {c = _VSTD::move(__q.c); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(const container_type& __c)  : c(__c) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    explicit queue(container_type&& __c) : c(_VSTD::move(__c)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        explicit queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__q.c, __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(const container_type& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(__c, __a) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(container_type&& __c, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__c), __a) {}\n    template <class _Alloc>\n        _LIBCPP_INLINE_VISIBILITY\n        queue(queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0)\n            : c(_VSTD::move(__q.c), __a) {}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const  {return c.size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference       front()       {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference front() const {return c.front();}\n    _LIBCPP_INLINE_VISIBILITY\n    reference       back()        {return c.back();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference back() const  {return c.back();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void push(const value_type& __v) {c.push_back(__v);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void push(value_type&& __v)      {c.push_back(_VSTD::move(__v));}\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void emplace(_Args&&... __args)\n            {c.emplace_back(_VSTD::forward<_Args>(__args)...);}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void pop() {c.pop_front();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value)\n    {\n        using _VSTD::swap;\n        swap(c, __q.c);\n    }\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator==(const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n\n    template <class _T1, class _C1>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    operator< (const queue<_T1, _C1>& __x,const queue<_T1, _C1>& __y);\n};\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c == __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __x.c < __y.c;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const queue<_Tp, _Container>& __x,const queue<_Tp, _Container>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(queue<_Tp, _Container>& __x, queue<_Tp, _Container>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<queue<_Tp, _Container>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\ntemplate <class _Tp, class _Container = vector<_Tp>,\n          class _Compare = less<typename _Container::value_type> >\nclass _LIBCPP_TYPE_VIS_ONLY priority_queue\n{\npublic:\n    typedef _Container                               container_type;\n    typedef _Compare                                 value_compare;\n    typedef typename container_type::value_type      value_type;\n    typedef typename container_type::reference       reference;\n    typedef typename container_type::const_reference const_reference;\n    typedef typename container_type::size_type       size_type;\n\nprotected:\n    container_type c;\n    value_compare comp;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue()\n        _NOEXCEPT_(is_nothrow_default_constructible<container_type>::value &&\n                   is_nothrow_default_constructible<value_compare>::value)\n        : c(), comp() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(const priority_queue& __q) : c(__q.c), comp(__q.comp) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_constructible<container_type>::value &&\n                   is_nothrow_move_constructible<value_compare>::value)\n        : c(_VSTD::move(__q.c)), comp(_VSTD::move(__q.comp)) {}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(const priority_queue& __q)\n        {c = __q.c; comp = __q.comp; return *this;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    priority_queue& operator=(priority_queue&& __q)\n        _NOEXCEPT_(is_nothrow_move_assignable<container_type>::value &&\n                   is_nothrow_move_assignable<value_compare>::value)\n        {c = _VSTD::move(__q.c); comp = _VSTD::move(__q.comp); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit priority_queue(const value_compare& __comp)\n        : c(), comp(__comp) {}\n    priority_queue(const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    explicit priority_queue(const value_compare& __comp, container_type&& __c);\n#endif\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp = value_compare());\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, const container_type& __c);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIter>\n        priority_queue(_InputIter __f, _InputIter __l,\n                       const value_compare& __comp, container_type&& __c);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        explicit priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, const container_type& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(const priority_queue& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Alloc>\n        priority_queue(const value_compare& __comp, container_type&& __c,\n                       const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n    template <class _Alloc>\n        priority_queue(priority_queue&& __q, const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type* = 0);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool            empty() const {return c.empty();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type       size() const  {return c.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference top() const   {return c.front();}\n\n    void push(const value_type& __v);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void push(value_type&& __v);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args> void emplace(_Args&&... __args);\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop();\n\n    void swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value);\n};\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp)\n    : c(__f, __l),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          const container_type& __c)\n    : c(__c),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(_InputIter __f, _InputIter __l,\n                                                          const value_compare& __comp,\n                                                          container_type&& __c)\n    : c(_VSTD::move(__c)),\n      comp(__comp)\n{\n    c.insert(c.end(), __f, __l);\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__a),\n      comp(__comp)\n{\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          const container_type& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__c, __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const priority_queue& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(__q.c, __a),\n      comp(__q.comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(const value_compare& __comp,\n                                                          container_type&& __c,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__c), __a),\n      comp(__comp)\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\npriority_queue<_Tp, _Container, _Compare>::priority_queue(priority_queue&& __q,\n                                                          const _Alloc& __a,\n                       typename enable_if<uses_allocator<container_type,\n                                                         _Alloc>::value>::type*)\n    : c(_VSTD::move(__q.c), __a),\n      comp(_VSTD::move(__q.comp))\n{\n    _VSTD::make_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(const value_type& __v)\n{\n    c.push_back(__v);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::push(value_type&& __v)\n{\n    c.push_back(_VSTD::move(__v));\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Container, class _Compare>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::emplace(_Args&&... __args)\n{\n    c.emplace_back(_VSTD::forward<_Args>(__args)...);\n    _VSTD::push_heap(c.begin(), c.end(), comp);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::pop()\n{\n    _VSTD::pop_heap(c.begin(), c.end(), comp);\n    c.pop_back();\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npriority_queue<_Tp, _Container, _Compare>::swap(priority_queue& __q)\n        _NOEXCEPT_(__is_nothrow_swappable<container_type>::value &&\n                   __is_nothrow_swappable<value_compare>::value)\n{\n    using _VSTD::swap;\n    swap(c, __q.c);\n    swap(comp, __q.comp);\n}\n\ntemplate <class _Tp, class _Container, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(priority_queue<_Tp, _Container, _Compare>& __x,\n     priority_queue<_Tp, _Container, _Compare>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Tp, class _Container, class _Compare, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator<priority_queue<_Tp, _Container, _Compare>, _Alloc>\n    : public uses_allocator<_Container, _Alloc>\n{\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_QUEUE\n","/*  \n *  Copyright 2012 Anders E. Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include <vector>\n\nnamespace kdtree {\n\n/// a node in the KD-tree\ntemplate<class point_type>\nstruct kd_node {\n    /// create node\n    /// \\param p position of node\n    /// \\param d direction of cut/split at this node\n    /// \\param l left child kd_node\n    /// \\param r right child kd_node\n    kd_node( point_type p, int d, kd_node* l, kd_node* r) :\n        pos(p), dir(d), left(l), right(r) {}\n    virtual ~kd_node() {\n        if (left)\n            delete left;\n        if (right)\n            delete right;\n    }\n    point_type pos; ///< position of the node\n    int dir; ///< direction of cut at this node\n    kd_node *left;     ///< pointer to left child node \n    kd_node *right;    ///< pointer to right child node \n};\n\n/// hyper rectangle\ntemplate<class point_type>\nstruct  kd_hyperrect {\n    /// ctor\n    kd_hyperrect(int dimi, const point_type mini, const point_type maxi) : \n        dim(dimi) {\n        min = mini;\n        max = maxi;\n    }\n    /// extend hyperrectangle to include the given point\n    void extend(const point_type& pos ) {\n        for (int i=0; i < dim; i++) {\n            if (pos[i] < min[i]) {\n                min[i] = pos[i];\n            }\n            if (pos[i] > max[i]) {\n                max[i] = pos[i];\n            }\n        }\n    }\n    \n    int dim; ///< number of dimensions\n    point_type min; ///< minimum point (e.g. lower left corner)\n    point_type max; ///< maximum point (e.g. upper right corner)\n};\n\n/// \\brief KD-tree for nearest neigbor search\ntemplate<class point_type>\nclass KDTree {\npublic:\n    /// ctor\n    KDTree(int dim = 3) : dim_(dim), root_(0), rect_(0) {\n    }\n    virtual ~KDTree() {\n        if (rect_)\n            delete rect_;\n        if (root_)\n            delete root_;\n    }\n    /// insert given point into tree\n    int insert( const point_type pos) {\n        return insert(root_, pos);\n    }\n    /// return a point in the tree that is nearest to the given point\n    /// false is returned if the tree is empty. \n    std::pair<point_type,bool> nearest( const point_type& pos) {\n        num_nearest_i_calls=0;\n        kd_hyperrect<point_type> rect = *rect_;\n        kd_node<point_type>* result;\n        if (!root_) return std::make_pair(pos,false);\n        /* Our first guesstimate is the root node */\n        result = root_;\n        /* Search for the nearest neighbour recursively */\n        double result_dist = root_->pos.dist(pos);\n        kd_nearest_i( root_, pos, result, result_dist , rect);\n        return std::make_pair( result->pos, true);\n    }\n    /// for debug, return the number of function calls made during a search\n    int get_num_calls() {return num_nearest_i_calls;}\n    /// print output of tree\n    void print_tree() {\n        if (root_)\n            print_node(root_,0);\n    }\nprivate:\n    /// insert given point into tree\n    int insert(kd_node<point_type>* node, const point_type pos ) {\n        if ( insert_rec( node, pos,  0) ) {\n            return -1; // error (?)\n        }\n\n        if ( rect_ == 0 ) \n            rect_ = new kd_hyperrect<point_type>(dim_,pos,pos); \n        else\n            rect_->extend( pos );\n\n        return 0;\n    }\n    \n    /// recursive point-insertion function\n    int insert_rec( kd_node<point_type>*& node, const point_type pos, int dir) {\n        if (node == 0) {\n            node = new kd_node<point_type>(pos,dir,0,0);\n            if (root_==0) {\n                root_=node;\n            }\n            return 0;\n        } else {\n        \n            // else an existing node\n            //node = *nptr;\n            int new_dir = (node->dir + 1) % dim_;\n            if( pos[node->dir] < node->pos[ node->dir] )  {\n                //std::cout << \" left \"; print_node(node,0);\n                return insert_rec( node->left, pos,  new_dir  );\n            } else {\n                //std::cout << \" right \"; print_node(node,0);\n                return insert_rec( node->right, pos, new_dir );\n            }\n        }\n    }\n    /// square\n    double sq(double x) {return x*x;}\n    \n\n    /// find nearest point\n    void kd_nearest_i(kd_node<point_type> *node, const point_type pos, \n                       kd_node<point_type>*& result, double& result_dist_sq , kd_hyperrect<point_type>& rect) {\n        int dir = node->dir;\n        num_nearest_i_calls++;\n        //int i;\n        //double dummy;\n        kd_node<point_type> *nearer_subtree, *farther_subtree;\n        double nearer_hyperrect_coord, farther_hyperrect_coord;\n\n        /* Decide whether to go left or right in the tree */\n        //dummy = pos[dir] - node->pos[dir];\n        //if (dummy <= 0) {\n            bool b;\n        if (pos[dir] <= node->pos[dir]) {\n            nearer_subtree = node->left;\n            farther_subtree = node->right;\n            nearer_hyperrect_coord  = rect.max[dir];\n            farther_hyperrect_coord = rect.min[dir];\n            b= true;\n        } else {\n            nearer_subtree = node->right;\n            farther_subtree = node->left;\n            nearer_hyperrect_coord  = rect.min[dir];\n            farther_hyperrect_coord = rect.max[dir];\n            b=false;\n        }\n\n        if (nearer_subtree) {\n            //std::cout << \" recurse into nearer subtree \\n\";\n            /* Slice the hyperrect to get the hyperrect of the nearer subtree */\n            double dummy = nearer_hyperrect_coord;\n            //nearer_hyperrect_coord = node->pos[dir];\n            if (b)\n                rect.max[dir] = node->pos[dir];\n            else\n                rect.min[dir] = node->pos[dir];\n            /* Recurse down into nearer subtree */\n            kd_nearest_i(nearer_subtree, pos, result, result_dist_sq, rect);\n            /* Undo the slice */\n            if (b)\n                rect.max[dir] = dummy; //node->pos[dir];\n            else\n                rect.min[dir] = dummy; //node->pos[dir];\n            //rect->min[dir] = //nearer_hyperrect_coord = dummy;\n        }\n\n        /* Check the distance of the point at the current node, compare it\n         * with our best so far */\n        double dist_sq = node->pos.dist( pos );\n        //for(int i=0; i < dim_; i++) {\n        //    dist_sq += sq(node->pos[i] - pos[i]);\n        //}\n        if (dist_sq < result_dist_sq) {\n            result = node;\n            result_dist_sq = dist_sq;\n        }\n\n        if (farther_subtree) {\n            //std::cout << \" recurse into farther subtree \\n\";\n            /* Get the hyperrect of the farther subtree */\n            double dummy = farther_hyperrect_coord;\n            if (b)\n                rect.min[dir] = node->pos[dir];\n            else\n                rect.max[dir] = node->pos[dir];\n            //farther_hyperrect_coord = node->pos[dir]; // this changes rect_ !!\n            /* Check if we have to recurse down by calculating the closest\n             * point of the hyperrect and see if it's closer than our\n             * minimum distance in result_dist_sq. */\n            if (hyperrect_dist_sq(rect, pos) < result_dist_sq) \n            {\n                /* Recurse down into farther subtree */\n                kd_nearest_i(farther_subtree, pos, result, result_dist_sq, rect);\n                      //double dist_sq = node->pos.dist( pos );\n            //for(int i=0; i < dim_; i++) {\n            //    dist_sq += sq(node->pos[i] - pos[i]);\n            //}\n            /*\n            if (dist_sq < result_dist_sq) {\n                result = node;\n                result_dist_sq = dist_sq;\n            }*/\n            }\n            /* Undo the slice on the hyperrect */\n            if (b)\n                rect.min[dir] = dummy;\n            else\n                rect.max[dir] = dummy;\n                \n            //*farther_hyperrect_coord = dummy;\n        }\n    }\n    /// return distance squared from hyperrect to given point\n    double hyperrect_dist_sq(kd_hyperrect<point_type>& rect, const point_type& pos){\n        double result = 0;\n        for (int i=0; i < dim_; i++) {\n            if (pos[i] < rect.min[i]) {\n                result += sq(rect.min[i] - pos[i]);\n            } else if (pos[i] > rect.max[i]) {\n                result += sq(rect.max[i] - pos[i]);\n            }\n        }\n        return result;\n    }\n\n    /// text output\n    void print_node(kd_node<point_type>* n, int d) {\n        for(int i=0;i<d;++i)\n            std::cout << \" \";\n        std::cout << \"d=\" << n->dir << \" node at \";\n        for (int i=0;i<dim_;++i)\n            std::cout << n->pos[i] << \" \"; // << n->pos[1] << \"  \" << \" \" << n->pos[2] << \"\\n\";\n        std::cout << \"\\n\";\n        if (n->left)\n            print_node(n->left,d+1);\n        if (n->right)\n            print_node(n->right,d+1);\n    }\n\n    int num_nearest_i_calls; ///< for debug, keep track of function calls\n    int dim_; ///< number of dimensions \n    kd_node<point_type>* root_; ///< root of the tree\n    kd_hyperrect<point_type>* rect_; ///< hyperrectangle\n};\n\n} // kdtree namespace\n","/*  \n *  Copyright 2010-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n#pragma once\n\n#include <queue>\n#include <set>\n#include <boost/tuple/tuple.hpp>\n\n#include \"common/point.hpp\"\n#include \"graph.hpp\"\n#include \"vertex_positioner.hpp\"\n#include \"filter.hpp\"\n#include \"kdtree.hpp\"\n\n/*! \\mainpage OpenVoronoi\n *\n * \\author Anders E. Wallin (anders.e.e.wallin \"at\" gmail.com)\n * \\section intro_sec Introduction\n *\n * OpenVoronoi is a c++ library with python bindings (using boost::python) for calculating 2D voronoi-diagrams of point, \n * line-segment, and circular-arc(not implement yet!) sites.\n * An incremental topology-oriented algorithm is used.\n * \n * See github for build/install instructions https://github.com/aewallin/openvoronoi\n * \n * DEB packages for Ubuntu are available at https://launchpad.net/~anders-e-e-wallin/+archive/cam\n * \n * Output gallery: https://picasaweb.google.com/106188605401091280402/OpenVoronoiExamples\n * \n * \\section Utilities\n * - Offset\n * - Medial-Axis\n * - SVG output\n * \n * \\section Tests\n * Tests are written for CTest.\n * - \"ctest -R cpp\" runs only the c++ tests (these are fast)\n * - \"ctest\" runs all tests (some may be slow)\n * Some tests use truetype-tracer (font geometry source), and some use CGAL_RPG (random polygon generator). \n * \n * \\section coverage Code Coverage Testing\n * - compile using CMAKE_BUILD_TYPE=Coverage  (uses \"-fprofile-arcs -ftest-coverage\" )\n * - install the library \"sudo make install\"\n * - Run the custom target coverage-report with \"make coverage-report\". It will do the following:\n *  - reset lcov counters \"lcov --directory ./ --zerocounters\"\n *  - run CTest c++ tests with \"ctest -R cpptest\"\n *  - generate an info-file with \"lcov --directory ./ --capture --output-file app.info\"\n *  - generate html output with \"genhtml --output-directory coverage --title OpenVoronoi Test Coverage app.info\"\n * - point your browser to build/doc/index.html to see the output\n * \n * \\section debian Debian source package\n * - See the files in src/deb for more information. \n * - A debian source package in build/Debian is built with the spackage target, run with \"make spackage\"\n *  - remember to set the \"Release\" build-type in CMakeLists.txt\n *  - disable building of tests (these require truetypetracer(ttt) and randompolygon(rpg) which pbuilder/PPA does not find\n * - The source-package can be tested with pbuilder\n *  - To test-build the package (assuming you are on a precise distribution). This will take a long time.\n *   - \"sudo pbuilder build openvoronoi_12.02.257-ubuntu1~precise1.dsc\" \n *  - To test-build for other distributions:\n *   - \"sudo pbuilder build --distribution lucid openvoronoi_12.02.257-ubuntu1~lucid1.dsc\"\n * - The source-package(s) can be uploaded to the Launchpad PPA with dput (this requires that you have write-access to the PPA)\n *  - \"dput ppa:anders-e-e-wallin/cam *.changes\"\n */\n \n\nnamespace ovd\n{\n/*! \n * \\namespace ovd \n * \\brief OpenVoronoi classes and functions\n */\n \n \nclass VoronoiDiagramChecker;\n\n/// \\brief KD-tree for 2D point location\n///\n/// a kd-tree is used for nearest-neighbor search when inserting point sites\nstruct kd_point {\n    /// default ctor\n    kd_point() : p(0,0), face(0) { }\n    /// kd-point with given position and HEFace\n    kd_point(Point pt, HEFace f) : p(pt), face(f) { }\n    /// kd-point at given position\n    kd_point(Point pt) : p(pt), face(0) { }\n    /// distance (suared) to given point\n    double dist(const kd_point& pt) const {\n        return (p.x-pt.p.x)*(p.x-pt.p.x) + (p.y-pt.p.y)*(p.y-pt.p.y); \n    }\n    /// return x or y coordinate of Point\n    double operator[](unsigned int i) const {\n        return i == 0 ? p.x : p.y; \n    }\n    /// return x or y coordinate of Point\n    double& operator[](unsigned int i) { \n        return i == 0 ? p.x : p.y; \n    }\n    Point p; ///< position of 2D PointSite\n    HEFace face; ///< the HEFace correspoinding to the PointSite\n};\n\n/// type of the KD-tree used for nearest-neighbor search\ntypedef kdtree::KDTree<kd_point> kd_type; \n\n/// \\brief Voronoi diagram.\n///\n/// see http://en.wikipedia.org/wiki/Voronoi_diagram\n/// \n/// the dual of a voronoi diagram is the delaunay diagram(triangulation).\n///  voronoi-faces are dual to delaunay-vertices.\n///  vornoi-vertices are dual to delaunay-faces \n///  voronoi-edges are dual to delaunay-edges\nclass VoronoiDiagram {\npublic:\n    VoronoiDiagram(double far, unsigned int n_bins);\n    virtual ~VoronoiDiagram();\n    int insert_point_site(const Point& p, int step=0);\n    bool insert_line_site(int idx1, int idx2, int step=99); // default step should make algorithm run until the end!\n    void insert_arc_site(int idx1, int idx2, const Point& c, bool cw, int step=99);\n    \n    /// return the far radius\n    double get_far_radius() const {return far_radius;}\n    /// return number of point sites in diagram\n    int num_point_sites() const {return num_psites-3;} // the three initial vertices don't count\n    /// return number of line-segments sites in diagram\n    int num_line_sites() const {return num_lsites;}\n    /// return number of arc-sites in diagram\n    int num_arc_sites() const {return num_asites;}\n    /// return number of voronoi-vertices\n    int num_vertices() const { return g.num_vertices()-num_point_sites(); }\n    /// return number of faces in graph\n    int num_faces() const { return g.num_faces(); }\n    int num_split_vertices() const;\n    /// return reference to graph \\todo not elegant. only used by vd2svg ?\n    HEGraph& get_graph_reference() {return g;}\n    \n    std::string print() const;\n    /// reset vertex index count \\todo not very elegant...\n    static void reset_vertex_count() { VoronoiVertex::reset_count(); }\n    /// turn on debug output\n    void debug_on() {debug=true;} \n    /// set silent mode on/off\n    void set_silent(bool b) {\n        silent=b;\n        vpos->set_silent(silent);\n    } \n    bool check(); \n    void filter( Filter* flt);\n    void filter_reset();\nprotected:\n    /// type for item in VertexQueue. pair of vertex-desxriptor and in_circle predicate\n    typedef std::pair<HEVertex, double> VertexDetPair;\n    /// \\brief comparison-predicate for VertexQueue\n    ///\n    /// in augment_vertex_set() we grow the delete-tree by processing vertices\n    /// one-by-one from a priority_queue. This is the priority_queue sort predicate.\n    /// We handle vertices with a large fabs( in_circle() ) first, since we \n    /// believe their predicate to be more reliable.\n    class abs_comparison {\n    public:\n      /// return true if absolute-value of lhs.second is smaller than rhs.second\n      bool operator() (const VertexDetPair& lhs, const VertexDetPair&rhs) const {\n        return ( fabs(lhs.second) < fabs(rhs.second) );\n      }\n    };\n\n    /// priority_queue for vertex for processing \n    // sorted by decreasing fabs() of in_circle-predicate, so that the vertices whose IN/OUT status we are 'most certain' about are processed first\n    typedef std::priority_queue< VertexDetPair , std::vector<VertexDetPair>, abs_comparison > VertexQueue;\n    \n    /// \\brief data required for adding a new edge\n    ///\n    /// used in add_edge() for storing information related to\n    /// the new edge.\n    struct EdgeData {\n        HEEdge v1_prv; ///< edge prior to v1\n        HEVertex v1;   ///< NEW edge source \n        HEEdge v1_nxt; ///< edge following v1 \n        HEEdge v2_prv; ///< edge prior to v2 \n        HEVertex v2;   ///< NEW edge target \n        HEEdge v2_nxt; ///< edge following v2 \n        HEFace f;      ///< face of v1 and v2 \n    };\n\n    void initialize();\n    HEVertex   find_seed_vertex(HEFace f, Site* site);\n    EdgeVector find_in_out_edges(); \n    EdgeData   find_edge_data(HEFace f, VertexVector startverts, std::pair<HEVertex,HEVertex> segment);\n    EdgeVector find_split_edges(HEFace f, Point pt1, Point pt2);\n    bool       find_split_vertex(HEFace f, HEVertex& v);\n    std::pair<HEVertex,HEVertex> find_endpoints(int idx1, int idx2);\n    bool null_vertex_target( HEVertex v , HEVertex& trg);\n    void augment_vertex_set( Site* site);        \n    bool predicate_c4(HEVertex v);\n    bool predicate_c5(HEVertex v);\n    void mark_adjacent_faces(HEVertex v, Site* site);\n    void mark_adjacent_faces_p( HEVertex v );\n    void mark_vertex(HEVertex& v,  Site* site); \n    void   add_vertices( Site* site );\n    HEFace add_face(Site* site);\n    void   add_edges(HEFace new_f1, HEFace f);        \n    void   add_edges(HEFace new_f1, HEFace f, HEFace new_f2, std::pair<HEVertex,HEVertex> seg);\n    void   add_edge(EdgeData ed, HEFace new1, HEFace new2=0);\n    void   add_separator(HEFace f, HEFace nf, boost::tuple<HEEdge, HEVertex, HEEdge,bool> target, HEVertex endp, Site* s1, Site* s2);\n    void   add_split_vertex(HEFace f, Site* s);\n    boost::tuple<HEVertex,HEFace,HEVertex,HEVertex,HEFace> find_null_face(HEVertex start, HEVertex other, Point l, Point dir, Site* new_site);\n    boost::tuple<HEEdge,HEVertex,HEEdge,bool> find_separator_target(HEFace f, HEVertex endp);\n    std::pair<HEVertex,HEFace> process_null_edge(Point dir, HEEdge next_edge , bool k3, bool next_prev);\n    HEVertex add_separator_vertex(HEVertex endp, HEEdge edge, Point sep_dir);\n    void repair_face( HEFace f );\n    void repair_face( HEFace f , std::pair<HEVertex,HEVertex> segs,\n                                 std::pair<HEFace,HEFace> nulled_faces,\n                                 std::pair<HEFace,HEFace> null_faces );\n    void remove_vertex_set();\n    void remove_split_vertex(HEFace f);\n    void reset_status();\n    int num_new_vertices(HEFace f);\n// HELPER-CLASSES\n    VoronoiDiagramChecker* vd_checker; ///< sanity-checks on the diagram are done by this helper class\n    kd_type* kd_tree; ///< kd-tree for nearest neighbor search during point Site insertion\n    VertexPositioner* vpos; ///< an algorithm for positioning vertices\n// DATA\n    typedef std::map<int,HEVertex> VertexMap; ///< type for vertex-index to vertex-descriptor map\n    typedef std::pair<int,HEVertex> VertexMapPair; ///< associate vertex index with vertex descriptor\n    \n    VertexMap vertex_map; ///< map from int handles to vertex-descriptors, used in insert_line_site()\n    VertexQueue vertexQueue; ///< queue of vertices to be processed\n    HEGraph g; ///< the half-edge diagram of the vd\n    double far_radius; ///< sites must fall within a circle with radius far_radius\n    int num_psites; ///< the number of point sites\n    int num_lsites; ///< the number of line-segment sites\n    int num_asites; ///< the number of arc-sites\n    FaceVector incident_faces; ///< temporary variable for ::INCIDENT faces, will be reset to ::NONINCIDENT after a site has been inserted\n    std::set<HEVertex> modified_vertices; ///< temporary variable for in-vertices, out-vertices that need to be reset after a site has been inserted\n    VertexVector v0; ///< IN-vertices, i.e. to-be-deleted\n    bool debug; ///< turn debug output on/off\n    bool silent; ///< no warnings emitted when silent==true\nprivate:\n    VoronoiDiagram(); // don't use.\n};\n\n/// \\brief error-functor to locate ::SPLIT vertices\n///\n/// for passing to numerical boost::toms748 root-finding algorithm\nclass SplitPointError {\npublic:\n    /// \\param gi graph\n    /// \\param split_edge the edge on which we want to position a SPLIT vertex\n    /// \\param pt1 first point of split-line\n    /// \\param pt2 second point of split-line\n    SplitPointError(HEGraph& gi, HEEdge split_edge, Point pt1, Point pt2) :\n    g(gi),  edge(split_edge), p1(pt1), p2(pt2)\n    {}\n    \n    /// \\return signed distance to the pt1-pt2 line from edge-point at given offset \\a t\n    double operator()(const double t) {\n        Point p = g[edge].point(t);\n        // line: pt1 + u*(pt2-pt1) = p\n        //   (p-pt1) dot (pt2-pt1) = u* (pt2-pt1) dot (pt2-pt1)\n        \n        double u = (p-p1).dot(p2-p1) / ( (p2-p1).dot(p2-p1) );\n        Point proj = p1 + u*(p2-p1);\n        double dist = (proj-p).norm();\n        double sign;\n        if ( p.is_right(p1,p2) )\n            sign = +1;\n        else\n            sign = -1;\n            \n        return sign*dist;\n    }\nprivate:\n    HEGraph& g;      ///< reference to vd-graph\n    HEEdge edge;     ///< the HEEdge on which we position the new SPLIT vertex\n    Point p1;     ///< first point of the split-line\n    Point p2;    ///< second point of the split-line\n};\n\n} // end ovd namespace\n\n// end voronoidiagram.hpp\n","//  (C) Copyright Jeremy Siek 2004 \n//  (C) Copyright Thomas Claveirole 2010\n//  (C) Copyright Ignacy Gawedzki 2010\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n\n#ifndef BOOST_GRAPH_DETAIL_CONTAINER_TRAITS_H\n#define BOOST_GRAPH_DETAIL_CONTAINER_TRAITS_H\n\n// Sure would be nice to be able to forward declare these\n// instead of pulling in all the headers. Too bad that\n// is not legal. There ought to be a standard <stlfwd> header. -JGS \n\n#include <boost/next_prior.hpp>\n\n#include <algorithm>   // for std::remove\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <boost/unordered_set.hpp>\n#include <boost/unordered_map.hpp>\n\n#if !defined BOOST_NO_SLIST\n#  ifdef BOOST_SLIST_HEADER\n#    include BOOST_SLIST_HEADER\n#  else\n#    include <slist>\n#  endif\n#endif\n\n#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n// Stay out of the way of concept checking class templates\n# define Container Container_\n# define AssociativeContainer AssociativeContainer_\n#endif\n\n// The content of this file is in 'graph_detail' because otherwise\n// there will be name clashes with \n// sandbox/boost/sequence_algo/container_traits.hpp\n// The 'detail' subnamespace will still cause problems.\nnamespace boost { namespace graph_detail {\n\n  //======================================================================\n  // Container Category Tags\n  //\n  //   They use virtual inheritance because there are lots of\n  //   inheritance diamonds.\n\n  struct container_tag { };\n  struct forward_container_tag : virtual public container_tag { };\n  struct reversible_container_tag : virtual public forward_container_tag { };\n  struct random_access_container_tag\n    : virtual public reversible_container_tag { };\n  \n  struct sequence_tag : virtual public forward_container_tag { };\n\n  struct associative_container_tag : virtual public forward_container_tag { };\n\n  struct sorted_associative_container_tag \n    : virtual public associative_container_tag,\n      virtual public reversible_container_tag { };\n\n  struct front_insertion_sequence_tag : virtual public sequence_tag { };\n  struct back_insertion_sequence_tag : virtual public sequence_tag { };\n\n  struct unique_associative_container_tag \n    : virtual public associative_container_tag { };\n  struct multiple_associative_container_tag \n    : virtual public associative_container_tag { };\n  struct simple_associative_container_tag \n    : virtual public associative_container_tag { };\n  struct pair_associative_container_tag \n    : virtual public associative_container_tag { };\n\n\n  //======================================================================\n  // Iterator Stability Tags\n  //\n  // Do mutating operations such as insert/erase/resize invalidate all\n  // outstanding iterators?\n\n  struct stable_tag { };\n  struct unstable_tag { };\n\n  //======================================================================\n  // Container Traits Class and container_category() function\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  // don't use this unless there is partial specialization \n  template <class Container>\n  struct container_traits {\n    typedef typename Container::category category;\n    typedef typename Container::iterator_stability iterator_stability;\n  };\n#endif\n\n  // Use this as a compile-time assertion that X is stable\n  inline void require_stable(stable_tag) { }\n\n  // std::vector\n  struct vector_tag :\n    virtual public random_access_container_tag,\n    virtual public back_insertion_sequence_tag { };\n\n  template <class T, class Alloc>\n  vector_tag container_category(const std::vector<T,Alloc>&)\n    { return vector_tag(); }\n\n  template <class T, class Alloc>\n  unstable_tag iterator_stability(const std::vector<T,Alloc>&)\n    { return unstable_tag(); }\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class T, class Alloc>\n  struct container_traits< std::vector<T,Alloc> > {\n    typedef vector_tag category;\n    typedef unstable_tag iterator_stability;\n  };\n#endif\n\n  // std::list\n  struct list_tag :\n    virtual public reversible_container_tag,\n    virtual public back_insertion_sequence_tag\n    // this causes problems for push_dispatch...\n    //    virtual public front_insertion_sequence_tag\n    { };\n\n  template <class T, class Alloc>\n  list_tag container_category(const std::list<T,Alloc>&)\n    { return list_tag(); }\n\n  template <class T, class Alloc>\n  stable_tag iterator_stability(const std::list<T,Alloc>&)\n    { return stable_tag(); }\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class T, class Alloc>\n  struct container_traits< std::list<T,Alloc> > {\n    typedef list_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n\n\n  // std::slist\n#ifndef BOOST_NO_SLIST\n# ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class T, class Alloc>\n  struct container_traits<BOOST_STD_EXTENSION_NAMESPACE::slist<T,Alloc> > {\n    typedef front_insertion_sequence_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n  template <class T, class Alloc>\n  front_insertion_sequence_tag container_category(\n  const BOOST_STD_EXTENSION_NAMESPACE::slist<T,Alloc>&\n  )\n    { return front_insertion_sequence_tag(); }\n\n  template <class T, class Alloc>\n  stable_tag iterator_stability(\n  const BOOST_STD_EXTENSION_NAMESPACE::slist<T,Alloc>&)\n    { return stable_tag(); }\n#endif\n\n\n  // std::set\n  struct set_tag :\n    virtual public sorted_associative_container_tag,\n    virtual public simple_associative_container_tag,\n    virtual public unique_associative_container_tag \n    { };\n\n  template <class Key, class Cmp, class Alloc> \n  set_tag container_category(const std::set<Key,Cmp,Alloc>&)\n  { return set_tag(); }\n\n  template <class Key, class Cmp, class Alloc> \n  stable_tag iterator_stability(const std::set<Key,Cmp,Alloc>&)\n  { return stable_tag(); }\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class Key, class Cmp, class Alloc> \n  struct container_traits< std::set<Key,Cmp,Alloc> > {\n    typedef set_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n\n  // std::multiset\n  struct multiset_tag :\n    virtual public sorted_associative_container_tag,\n    virtual public simple_associative_container_tag,\n    virtual public multiple_associative_container_tag \n    { };\n\n  template <class Key, class Cmp, class Alloc> \n  multiset_tag container_category(const std::multiset<Key,Cmp,Alloc>&)\n  { return multiset_tag(); }\n\n  template <class Key, class Cmp, class Alloc> \n  stable_tag iterator_stability(const std::multiset<Key,Cmp,Alloc>&)\n  { return stable_tag(); }\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class Key, class Cmp, class Alloc> \n  struct container_traits< std::multiset<Key,Cmp,Alloc> > {\n    typedef multiset_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n\n  // deque\n\n  // std::map\n  struct map_tag :\n    virtual public sorted_associative_container_tag,\n    virtual public pair_associative_container_tag,\n    virtual public unique_associative_container_tag \n    { };\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class Key, class T, class Cmp, class Alloc> \n  struct container_traits< std::map<Key,T,Cmp,Alloc> > {\n    typedef map_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n\n  template <class Key, class T, class Cmp, class Alloc> \n  map_tag container_category(const std::map<Key,T,Cmp,Alloc>&)\n  { return map_tag(); }\n\n  template <class Key, class T, class Cmp, class Alloc> \n  stable_tag iterator_stability(const std::map<Key,T,Cmp,Alloc>&)\n  { return stable_tag(); }\n\n  // std::multimap\n  struct multimap_tag :\n    virtual public sorted_associative_container_tag,\n    virtual public pair_associative_container_tag,\n    virtual public multiple_associative_container_tag \n    { };\n\n#if !defined BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class Key, class T, class Cmp, class Alloc> \n  struct container_traits< std::multimap<Key,T,Cmp,Alloc> > {\n    typedef multimap_tag category;\n    typedef stable_tag iterator_stability;\n  };\n#endif\n\n  template <class Key, class T, class Cmp, class Alloc> \n  multimap_tag container_category(const std::multimap<Key,T,Cmp,Alloc>&)\n  { return multimap_tag(); }\n\n  template <class Key, class T, class Cmp, class Alloc> \n  stable_tag iterator_stability(const std::multimap<Key,T,Cmp,Alloc>&)\n  { return stable_tag(); }\n\n\n // hash_set, hash_map\n\n  struct unordered_set_tag :\n    virtual public simple_associative_container_tag,\n    virtual public unique_associative_container_tag\n    { };\n\n  struct unordered_multiset_tag :\n    virtual public simple_associative_container_tag,\n    virtual public multiple_associative_container_tag\n    { };\n\n\n  struct unordered_map_tag :\n    virtual public pair_associative_container_tag,\n    virtual public unique_associative_container_tag\n    { };\n\n  struct unordered_multimap_tag :\n    virtual public pair_associative_container_tag,\n    virtual public multiple_associative_container_tag\n    { };\n\n\n#ifndef BOOST_NO_HASH\n#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n  template <class Key, class Eq, class Hash, class Alloc> \n  struct container_traits< boost::unordered_set<Key,Eq,Hash,Alloc> > {\n    typedef unordered_set_tag category;\n    typedef unstable_tag iterator_stability;\n  };\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  struct container_traits< boost::unordered_map<Key,T,Eq,Hash,Alloc> > {\n    typedef unordered_map_tag category;\n    typedef unstable_tag iterator_stability;\n  };\n  template <class Key, class Eq, class Hash, class Alloc>\n  struct container_traits< boost::unordered_multiset<Key,Eq,Hash,Alloc> > {\n    typedef unordered_multiset_tag category;\n    typedef unstable_tag iterator_stability;\n  };\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  struct container_traits< boost::unordered_multimap<Key,T,Eq,Hash,Alloc> > {\n    typedef unordered_multimap_tag category;\n    typedef unstable_tag iterator_stability;\n  };\n#endif\n  template <class Key, class Eq, class Hash, class Alloc>\n  unordered_set_tag\n  container_category(const boost::unordered_set<Key,Eq,Hash,Alloc>&)\n  { return unordered_set_tag(); }\n\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  unordered_map_tag\n  container_category(const boost::unordered_map<Key,T,Eq,Hash,Alloc>&)\n  { return unordered_map_tag(); }\n\n  template <class Key, class Eq, class Hash, class Alloc>\n  unstable_tag iterator_stability(const boost::unordered_set<Key,Eq,Hash,Alloc>&)\n  { return unstable_tag(); }\n\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  unstable_tag iterator_stability(const boost::unordered_map<Key,T,Eq,Hash,Alloc>&)\n  { return unstable_tag(); }\n  template <class Key, class Eq, class Hash, class Alloc>\n  unordered_multiset_tag\n  container_category(const boost::unordered_multiset<Key,Eq,Hash,Alloc>&)\n  { return unordered_multiset_tag(); }\n\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  unordered_multimap_tag\n  container_category(const boost::unordered_multimap<Key,T,Eq,Hash,Alloc>&)\n  { return unordered_multimap_tag(); }\n\n  template <class Key, class Eq, class Hash, class Alloc>\n  unstable_tag\n  iterator_stability(const boost::unordered_multiset<Key,Eq,Hash,Alloc>&)\n  { return unstable_tag(); }\n\n  template <class Key, class T, class Eq, class Hash, class Alloc>\n  unstable_tag\n  iterator_stability(const boost::unordered_multimap<Key,T,Eq,Hash,Alloc>&)\n  { return unstable_tag(); }\n#endif\n\n\n\n  //===========================================================================\n  // Generalized Container Functions\n\n\n  // Erase\n  template <class Sequence, class T>\n  void erase_dispatch(Sequence& c, const T& x, \n                      sequence_tag)\n  {\n    c.erase(std::remove(c.begin(), c.end(), x), c.end());\n  }\n\n  template <class AssociativeContainer, class T>\n  void erase_dispatch(AssociativeContainer& c, const T& x, \n                      associative_container_tag)\n  {\n    c.erase(x);\n  }\n  template <class Container, class T>\n  void erase(Container& c, const T& x)\n  {\n    erase_dispatch(c, x, container_category(c));\n  }\n\n  // Erase If\n  template <class Sequence, class Predicate, class IteratorStability>\n  void erase_if_dispatch(Sequence& c, Predicate p,\n                         sequence_tag, IteratorStability)\n  {\n#if 0\n    c.erase(std::remove_if(c.begin(), c.end(), p), c.end());\n#else\n    if (! c.empty())\n      c.erase(std::remove_if(c.begin(), c.end(), p), c.end());\n#endif\n  }\n  template <class AssociativeContainer, class Predicate>\n  void erase_if_dispatch(AssociativeContainer& c, Predicate p,\n                         associative_container_tag, stable_tag)\n  {\n    typename AssociativeContainer::iterator i, next;\n    for (i = next = c.begin(); next != c.end(); i = next) {\n      ++next;\n      if (p(*i))\n        c.erase(i);\n    }\n  }\n  template <class AssociativeContainer, class Predicate>\n  void erase_if_dispatch(AssociativeContainer& c, Predicate p,\n                         associative_container_tag, unstable_tag)\n  {\n    // This method is really slow, so hopefully we won't have any\n    // associative containers with unstable iterators!\n    // Is there a better way to do this?\n    typename AssociativeContainer::iterator i;\n    typename AssociativeContainer::size_type n = c.size();\n    while (n--)\n      for (i = c.begin(); i != c.end(); ++i)\n        if (p(*i)) {\n          c.erase(i);\n          break;\n        }\n  }\n  template <class Container, class Predicate>\n  void erase_if(Container& c, Predicate p)\n  {\n    erase_if_dispatch(c, p, container_category(c), iterator_stability(c));\n  }\n\n  // Push\n  template <class Container, class T>\n  std::pair<typename Container::iterator, bool>\n  push_dispatch(Container& c, const T& v, back_insertion_sequence_tag)\n  {\n    c.push_back(v);\n    return std::make_pair(boost::prior(c.end()), true);\n  }\n\n  template <class Container, class T>\n  std::pair<typename Container::iterator, bool>\n  push_dispatch(Container& c, const T& v, front_insertion_sequence_tag)\n  {\n    c.push_front(v);\n    return std::make_pair(c.begin(), true);\n  }\n\n  template <class AssociativeContainer, class T>\n  std::pair<typename AssociativeContainer::iterator, bool>\n  push_dispatch(AssociativeContainer& c, const T& v, \n                unique_associative_container_tag)\n  {\n    return c.insert(v);\n  }\n\n  template <class AssociativeContainer, class T>\n  std::pair<typename AssociativeContainer::iterator, bool>\n  push_dispatch(AssociativeContainer& c, const T& v,\n                multiple_associative_container_tag)\n  {\n    return std::make_pair(c.insert(v), true);\n  }\n\n  template <class Container, class T>\n  std::pair<typename Container::iterator,bool>\n  push(Container& c, const T& v)\n  {\n    return push_dispatch(c, v, container_category(c));\n  }\n\n  // Find\n  template <class Container, class Value>\n  typename Container::iterator\n  find_dispatch(Container& c,\n                const Value& value,\n                container_tag)\n  {\n    return std::find(c.begin(), c.end(), value);\n  }\n\n  template <class AssociativeContainer, class Value>\n  typename AssociativeContainer::iterator\n  find_dispatch(AssociativeContainer& c,\n                const Value& value,\n                associative_container_tag)\n  {\n    return c.find(value);\n  }\n\n  template <class Container, class Value>\n  typename Container::iterator\n  find(Container& c,\n       const Value& value)\n  {\n    return find_dispatch(c, value,\n                         graph_detail::container_category(c));\n  }\n\n  // Find (const versions)\n  template <class Container, class Value>\n  typename Container::const_iterator\n  find_dispatch(const Container& c,\n                const Value& value,\n                container_tag)\n  {\n    return std::find(c.begin(), c.end(), value);\n  }\n\n  template <class AssociativeContainer, class Value>\n  typename AssociativeContainer::const_iterator\n  find_dispatch(const AssociativeContainer& c,\n                const Value& value,\n                associative_container_tag)\n  {\n    return c.find(value);\n  }\n\n  template <class Container, class Value>\n  typename Container::const_iterator\n  find(const Container& c,\n       const Value& value)\n  {\n    return find_dispatch(c, value,\n                         graph_detail::container_category(c));\n  }\n\n  // Equal range\n#if 0\n  // Make the dispatch fail if c is not an Associative Container (and thus\n  // doesn't have equal_range unless it is sorted, which we cannot check\n  // statically and is not typically true for BGL's uses of this function).\n  template <class Container,\n            class LessThanComparable>\n  std::pair<typename Container::iterator, typename Container::iterator>\n  equal_range_dispatch(Container& c,\n                       const LessThanComparable& value,\n                       container_tag)\n  {\n    // c must be sorted for std::equal_range to behave properly.\n    return std::equal_range(c.begin(), c.end(), value);\n  }\n#endif\n\n  template <class AssociativeContainer, class Value>\n  std::pair<typename AssociativeContainer::iterator,\n            typename AssociativeContainer::iterator>\n  equal_range_dispatch(AssociativeContainer& c,\n                       const Value& value,\n                       associative_container_tag)\n  {\n    return c.equal_range(value);\n  }\n\n  template <class Container, class Value>\n  std::pair<typename Container::iterator, typename Container::iterator>\n  equal_range(Container& c,\n              const Value& value)\n  {\n    return equal_range_dispatch(c, value,\n                                graph_detail::container_category(c));\n  }\n\n}} // namespace boost::graph_detail\n\n#if BOOST_WORKAROUND(BOOST_MSVC, < 1300)\n// Stay out of the way of concept checking class templates\n# undef Container\n# undef AssociativeContainer\n#endif\n\n#endif // BOOST_GRAPH_DETAIL_CONTAINER_TRAITS_H\n","// Copyright (C) 2007 Douglas Gregor\n\n// Use, modification and distribution is subject to the Boost Software\n// License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at\n// http://www.boost.org/LICENSE_1_0.txt)\n\n// Provides support for named vertices in graphs, allowing one to more\n// easily associate unique external names (URLs, city names, employee\n// ID numbers, etc.) with the vertices of a graph.\n#ifndef BOOST_GRAPH_NAMED_GRAPH_HPP\n#define BOOST_GRAPH_NAMED_GRAPH_HPP\n\n#include <boost/config.hpp>\n#include <boost/static_assert.hpp>\n#include <boost/functional/hash.hpp>\n#include <boost/graph/graph_traits.hpp>\n#include <boost/graph/properties.hpp>\n#include <boost/multi_index/hashed_index.hpp>\n#include <boost/multi_index/member.hpp>\n#include <boost/multi_index_container.hpp>\n#include <boost/optional.hpp>\n#include <boost/pending/property.hpp> // for boost::lookup_one_property\n#include <boost/pending/container_traits.hpp>\n#include <boost/throw_exception.hpp>\n#include <boost/tuple/tuple.hpp> // for boost::make_tuple\n#include <boost/type_traits/is_same.hpp>\n#include <boost/type_traits/is_base_of.hpp>\n#include <boost/type_traits/remove_cv.hpp>\n#include <boost/type_traits/remove_reference.hpp>\n#include <boost/utility/enable_if.hpp>\n#include <functional> // for std::equal_to\n#include <stdexcept> // for std::runtime_error\n#include <utility> // for std::pair\n\nnamespace boost { namespace graph {\n\n/*******************************************************************\n * User-customized traits                                          *\n *******************************************************************/\n\n/**\n * @brief Trait used to extract the internal vertex name from a vertex\n * property.\n *\n * To enable the use of internal vertex names in a graph type,\n * specialize the @c internal_vertex_name trait for your graph\n * property (e.g., @c a City class, which stores information about the\n * vertices in a road map).\n */\ntemplate<typename VertexProperty>\nstruct internal_vertex_name\n{\n  /**\n   *  The @c type field provides a function object that extracts a key\n   *  from the @c VertexProperty. The function object type must have a\n   *  nested @c result_type that provides the type of the key. For\n   *  more information, see the @c KeyExtractor concept in the\n   *  Boost.MultiIndex documentation: @c type must either be @c void\n   *  (if @c VertexProperty does not have an internal vertex name) or\n   *  a model of @c KeyExtractor.\n   */\n  typedef void type;\n};\n\n#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n/**\n * Extract the internal vertex name from a @c property structure by\n * looking at its base.\n */\ntemplate<typename Tag, typename T, typename Base>\nstruct internal_vertex_name<property<Tag, T, Base> >\n  : internal_vertex_name<Base> { };\n#endif\n\n/**\n * Construct an instance of @c VertexProperty directly from its\n * name. This function object should be used within the @c\n * internal_vertex_constructor trait.\n */\ntemplate<typename VertexProperty>\nstruct vertex_from_name\n{\nprivate:\n  typedef typename internal_vertex_name<VertexProperty>::type extract_name_type;\n\n  typedef typename remove_cv<\n            typename remove_reference<\n              typename extract_name_type::result_type>::type>::type\n    vertex_name_type;\n\npublic:\n  typedef vertex_name_type argument_type;\n  typedef VertexProperty result_type;\n\n  VertexProperty operator()(const vertex_name_type& name)\n  {\n    return VertexProperty(name);\n  }\n};\n\n/**\n * Throw an exception whenever one tries to construct a @c\n * VertexProperty instance from its name.\n */\ntemplate<typename VertexProperty>\nstruct cannot_add_vertex\n{\nprivate:\n  typedef typename internal_vertex_name<VertexProperty>::type extract_name_type;\n\n  typedef typename remove_cv<\n            typename remove_reference<\n              typename extract_name_type::result_type>::type>::type\n    vertex_name_type;\n\npublic:\n  typedef vertex_name_type argument_type;\n  typedef VertexProperty result_type;\n\n  VertexProperty operator()(const vertex_name_type&)\n  {\n      boost::throw_exception(std::runtime_error(\"add_vertex: \"\n                                                \"unable to create a vertex from its name\"));\n  }\n};\n\n/**\n * @brief Trait used to construct an instance of a @c VertexProperty,\n * which is a class type that stores the properties associated with a\n * vertex in a graph, from just the name of that vertex property. This\n * operation is used when an operation is required to map from a\n * vertex name to a vertex descriptor (e.g., to add an edge outgoing\n * from that vertex), but no vertex by the name exists. The function\n * object provided by this trait will be used to add new vertices\n * based only on their names. Since this cannot be done for arbitrary\n * types, the default behavior is to throw an exception when this\n * routine is called, which requires that all named vertices be added\n * before adding any edges by name.\n */\ntemplate<typename VertexProperty>\nstruct internal_vertex_constructor\n{\n  /**\n   * The @c type field provides a function object that constructs a\n   * new instance of @c VertexProperty from the name of the vertex (as\n   * determined by @c internal_vertex_name). The function object shall\n   * accept a vertex name and return a @c VertexProperty. Predefined\n   * options include:\n   *\n   *   @c vertex_from_name<VertexProperty>: construct an instance of\n   *   @c VertexProperty directly from the name.\n   *\n   *   @c cannot_add_vertex<VertexProperty>: the default value, which\n   *   throws an @c std::runtime_error if one attempts to add a vertex\n   *   given just the name.\n   */\n  typedef cannot_add_vertex<VertexProperty> type;\n};\n\n#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n/**\n * Extract the internal vertex constructor from a @c property structure by\n * looking at its base.\n */\ntemplate<typename Tag, typename T, typename Base>\nstruct internal_vertex_constructor<property<Tag, T, Base> >\n  : internal_vertex_constructor<Base> { };\n#endif\n\n/*******************************************************************\n * Named graph mixin                                               *\n *******************************************************************/\n\n/**\n * named_graph is a mixin that provides names for the vertices of a\n * graph, including a mapping from names to vertices. Graph types that\n * may or may not be have vertex names (depending on the properties\n * supplied by the user) should use maybe_named_graph.\n *\n * Template parameters:\n *\n *   Graph: the graph type that derives from named_graph\n *\n *   Vertex: the type of a vertex descriptor in Graph. Note: we cannot\n *   use graph_traits here, because the Graph is not yet defined.\n *\n *   VertexProperty: the type stored with each vertex in the Graph.\n */\ntemplate<typename Graph, typename Vertex, typename VertexProperty>\nclass named_graph\n{\npublic:\n  /// The type of the function object that extracts names from vertex\n  /// properties.\n  typedef typename internal_vertex_name<VertexProperty>::type extract_name_type;\n  /// The type of the \"bundled\" property, from which the name can be\n  /// extracted.\n  typedef typename lookup_one_property<VertexProperty, vertex_bundle_t>::type\n    bundled_vertex_property_type;\n\n  /// The type of the function object that generates vertex properties\n  /// from names, for the implicit addition of vertices.\n  typedef typename internal_vertex_constructor<VertexProperty>::type\n    vertex_constructor_type;\n\n  /// The type used to name vertices in the graph\n  typedef typename remove_cv<\n            typename remove_reference<\n              typename extract_name_type::result_type>::type>::type\n    vertex_name_type;\n\n  /// The type of vertex descriptors in the graph\n  typedef Vertex vertex_descriptor;\n\nprivate:\n  /// Key extractor for use with the multi_index_container\n  struct extract_name_from_vertex\n  {\n    typedef vertex_name_type result_type;\n\n    extract_name_from_vertex(Graph& graph, const extract_name_type& extract)\n      : graph(graph), extract(extract) { }\n\n    const result_type& operator()(Vertex vertex) const\n    {\n      return extract(graph[vertex]);\n    }\n\n    Graph& graph;\n    extract_name_type extract;\n  };\n\npublic:\n  /// The type that maps names to vertices\n  typedef multi_index::multi_index_container<\n            Vertex,\n            multi_index::indexed_by<\n              multi_index::hashed_unique<multi_index::tag<vertex_name_t>,\n                                         extract_name_from_vertex> >\n          > named_vertices_type;\n\n  /// The set of vertices, indexed by name\n  typedef typename named_vertices_type::template index<vertex_name_t>::type\n    vertices_by_name_type;\n\n  /// Construct an instance of the named graph mixin, using the given\n  /// function object to extract a name from the bundled property\n  /// associated with a vertex.\n  named_graph(const extract_name_type& extract = extract_name_type(),\n              const vertex_constructor_type& vertex_constructor\n                = vertex_constructor_type());\n\n  /// Notify the named_graph that we have added the given vertex. The\n  /// name of the vertex will be added to the mapping.\n  void added_vertex(Vertex vertex);\n\n  /// Notify the named_graph that we are removing the given\n  /// vertex. The name of the vertex will be removed from the mapping.\n  template <typename VertexIterStability>\n  void removing_vertex(Vertex vertex, VertexIterStability);\n\n  /// Notify the named_graph that we are clearing the graph.\n  /// This will clear out all of the name->vertex mappings\n  void clearing_graph();\n\n  /// Retrieve the derived instance\n  Graph&       derived()       { return static_cast<Graph&>(*this); }\n  const Graph& derived() const { return static_cast<const Graph&>(*this); }\n\n  /// Extract the name from a vertex property instance\n  typename extract_name_type::result_type\n  extract_name(const bundled_vertex_property_type& property);\n\n  /// Search for a vertex that has the given property (based on its\n  /// name)\n  optional<vertex_descriptor>\n  vertex_by_property(const bundled_vertex_property_type& property);\n\n  /// Mapping from names to vertices\n  named_vertices_type named_vertices;\n\n  /// Constructs a vertex from the name of that vertex\n  vertex_constructor_type vertex_constructor;\n};\n\n/// Helper macro containing the template parameters of named_graph\n#define BGL_NAMED_GRAPH_PARAMS \\\n  typename Graph, typename Vertex, typename VertexProperty\n/// Helper macro containing the named_graph<...> instantiation\n#define BGL_NAMED_GRAPH \\\n  named_graph<Graph, Vertex, VertexProperty>\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\nBGL_NAMED_GRAPH::named_graph(const extract_name_type& extract,\n                             const vertex_constructor_type& vertex_constructor)\n  : named_vertices(\n      typename named_vertices_type::ctor_args_list(\n        boost::make_tuple(\n          boost::make_tuple(\n            0, // initial number of buckets\n            extract_name_from_vertex(derived(), extract),\n            boost::hash<vertex_name_type>(),\n            std::equal_to<vertex_name_type>())))),\n    vertex_constructor(vertex_constructor)\n{\n}\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\ninline void BGL_NAMED_GRAPH::added_vertex(Vertex vertex)\n{\n  named_vertices.insert(vertex);\n}\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\ntemplate<typename VertexIterStability>\ninline void BGL_NAMED_GRAPH::removing_vertex(Vertex vertex, VertexIterStability)\n{\n  BOOST_STATIC_ASSERT_MSG ((boost::is_base_of<boost::graph_detail::stable_tag, VertexIterStability>::value), \"Named graphs cannot use vecS as vertex container and remove vertices; the lack of vertex descriptor stability (which iterator stability is a proxy for) means that the name -> vertex mapping would need to be completely rebuilt after each deletion.  See https://svn.boost.org/trac/boost/ticket/7863 for more information and a test case.\");\n  typedef typename BGL_NAMED_GRAPH::vertex_name_type vertex_name_type;\n  const vertex_name_type& vertex_name = extract_name(derived()[vertex]);\n  named_vertices.erase(vertex_name);\n}\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\ninline void BGL_NAMED_GRAPH::clearing_graph()\n{\n  named_vertices.clear();\n}\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\ntypename BGL_NAMED_GRAPH::extract_name_type::result_type\nBGL_NAMED_GRAPH::extract_name(const bundled_vertex_property_type& property)\n{\n  return named_vertices.key_extractor().extract(property);\n}\n\ntemplate<BGL_NAMED_GRAPH_PARAMS>\noptional<typename BGL_NAMED_GRAPH::vertex_descriptor>\nBGL_NAMED_GRAPH::\nvertex_by_property(const bundled_vertex_property_type& property)\n{\n  return find_vertex(extract_name(property), *this);\n}\n\n/// Retrieve the vertex associated with the given name\ntemplate<BGL_NAMED_GRAPH_PARAMS>\noptional<Vertex>\nfind_vertex(typename BGL_NAMED_GRAPH::vertex_name_type const& name,\n            const BGL_NAMED_GRAPH& g)\n{\n  typedef typename BGL_NAMED_GRAPH::vertices_by_name_type\n    vertices_by_name_type;\n\n  // Retrieve the set of vertices indexed by name\n  vertices_by_name_type const& vertices_by_name\n    = g.named_vertices.template get<vertex_name_t>();\n\n  /// Look for a vertex with the given name\n  typename vertices_by_name_type::const_iterator iter\n    = vertices_by_name.find(name);\n\n  if (iter == vertices_by_name.end())\n    return optional<Vertex>(); // vertex not found\n  else\n    return *iter;\n}\n\n/// Retrieve the vertex associated with the given name, or add a new\n/// vertex with that name if no such vertex is available.\n/// Note: This is enabled only when the vertex property type is different\n///       from the vertex name to avoid ambiguous overload problems with\n///       the add_vertex() function that takes a vertex property.\ntemplate<BGL_NAMED_GRAPH_PARAMS>\n    typename disable_if<is_same<\n        typename BGL_NAMED_GRAPH::vertex_name_type,\n        VertexProperty\n    >,\nVertex>::type\nadd_vertex(typename BGL_NAMED_GRAPH::vertex_name_type const& name,\n           BGL_NAMED_GRAPH& g)\n{\n  if (optional<Vertex> vertex = find_vertex(name, g))\n    /// We found the vertex, so return it\n    return *vertex;\n  else\n    /// There is no vertex with the given name, so create one\n    return add_vertex(g.vertex_constructor(name), g.derived());\n}\n\n/// Add an edge using vertex names to refer to the vertices\ntemplate<BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,\n         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,\n         BGL_NAMED_GRAPH& g)\n{\n  return add_edge(add_vertex(u_name, g.derived()),\n                  add_vertex(v_name, g.derived()),\n                  g.derived());\n}\n\n/// Add an edge using vertex descriptors or names to refer to the vertices\ntemplate<BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_descriptor const& u,\n         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,\n         BGL_NAMED_GRAPH& g)\n{\n  return add_edge(u,\n                  add_vertex(v_name, g.derived()),\n                  g.derived());\n}\n\n/// Add an edge using vertex descriptors or names to refer to the vertices\ntemplate<BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,\n         typename BGL_NAMED_GRAPH::vertex_descriptor const& v,\n         BGL_NAMED_GRAPH& g)\n{\n  return add_edge(add_vertex(u_name, g.derived()),\n                  v,\n                  g.derived());\n}\n\n// Overloads to support EdgeMutablePropertyGraph graphs\ntemplate <BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_descriptor const& u,\n         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,\n         typename edge_property_type<Graph>::type const& p,\n         BGL_NAMED_GRAPH& g) {\n    return add_edge(u, add_vertex(v_name, g.derived()), p, g.derived());\n}\n\ntemplate <BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,\n         typename BGL_NAMED_GRAPH::vertex_descriptor const& v,\n         typename edge_property_type<Graph>::type const& p,\n         BGL_NAMED_GRAPH& g) {\n    return add_edge(add_vertex(u_name, g.derived()), v, p, g.derived());\n}\n\ntemplate <BGL_NAMED_GRAPH_PARAMS>\nstd::pair<typename graph_traits<Graph>::edge_descriptor, bool>\nadd_edge(typename BGL_NAMED_GRAPH::vertex_name_type const& u_name,\n         typename BGL_NAMED_GRAPH::vertex_name_type const& v_name,\n         typename edge_property_type<Graph>::type const& p,\n         BGL_NAMED_GRAPH& g) {\n    return add_edge(add_vertex(u_name, g.derived()),\n                    add_vertex(v_name, g.derived()), p, g.derived());\n}\n\n#undef BGL_NAMED_GRAPH\n#undef BGL_NAMED_GRAPH_PARAMS\n\n/*******************************************************************\n * Maybe named graph mixin                                         *\n *******************************************************************/\n\n#ifndef BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n/**\n * A graph mixin that can provide a mapping from names to vertices,\n * and use that mapping to simplify creation and manipulation of\n * graphs.\n */\ntemplate<typename Graph, typename Vertex, typename VertexProperty,\n         typename ExtractName\n           = typename internal_vertex_name<VertexProperty>::type>\nstruct maybe_named_graph : public named_graph<Graph, Vertex, VertexProperty>\n{\n};\n\n/**\n * A graph mixin that can provide a mapping from names to vertices,\n * and use that mapping to simplify creation and manipulation of\n * graphs. This partial specialization turns off this functionality\n * when the @c VertexProperty does not have an internal vertex name.\n */\ntemplate<typename Graph, typename Vertex, typename VertexProperty>\nstruct maybe_named_graph<Graph, Vertex, VertexProperty, void>\n{\n  /// The type of the \"bundled\" property, from which the name can be\n  /// extracted.\n  typedef typename lookup_one_property<VertexProperty, vertex_bundle_t>::type\n    bundled_vertex_property_type;\n\n  /// Notify the named_graph that we have added the given vertex. This\n  /// is a no-op.\n  void added_vertex(Vertex) { }\n\n  /// Notify the named_graph that we are removing the given\n  /// vertex. This is a no-op.\n  template <typename VertexIterStability>\n  void removing_vertex(Vertex, VertexIterStability) { }\n\n  /// Notify the named_graph that we are clearing the graph. This is a\n  /// no-op.\n  void clearing_graph() { }\n\n  /// Search for a vertex that has the given property (based on its\n  /// name). This always returns an empty optional<>\n  optional<Vertex>\n  vertex_by_property(const bundled_vertex_property_type&)\n  {\n    return optional<Vertex>();\n  }\n};\n#else\ntemplate<typename Graph, typename Vertex, typename VertexProperty,\n         typename ExtractName\n           = typename internal_vertex_name<VertexProperty>::type>\nstruct maybe_named_graph\n{\n  /// The type of the \"bundled\" property, from which the name can be\n  /// extracted.\n  typedef typename detail::extract_bundled_vertex<VertexProperty>::type\n    bundled_vertex_property_type;\n\n  /// Notify the named_graph that we have added the given vertex. This\n  /// is a no-op.\n  void added_vertex(Vertex) { }\n\n  /// Notify the named_graph that we are removing the given\n  /// vertex. This is a no-op.\n  template <typename VertexIterStability>\n  void removing_vertex(Vertex, VertexIterStability) { }\n\n  /// Notify the named_graph that we are clearing the graph. This is a\n  /// no-op.\n  void clearing_graph() { }\n\n  /// Search for a vertex that has the given property (based on its\n  /// name). This always returns an empty optional<>\n  template<typename Property>\n  optional<Vertex>\n  vertex_by_property(const bundled_vertex_property_type&)\n  {\n    return optional<Vertex>();\n  }\n};\n#endif // BOOST_NO_TEMPLATE_PARTIAL_SPECIALIZATION\n\n} } // end namespace boost::graph\n\n#endif // BOOST_GRAPH_NAMED_GRAPH_HPP\n","//  Boost next_prior.hpp header file  ---------------------------------------//\n\n//  (C) Copyright Dave Abrahams and Daniel Walker 1999-2003. Distributed under the Boost\n//  Software License, Version 1.0. (See accompanying file\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)\n\n//  See http://www.boost.org/libs/utility for documentation.\n\n//  Revision History\n//  13 Dec 2003  Added next(x, n) and prior(x, n) (Daniel Walker)\n\n#ifndef BOOST_NEXT_PRIOR_HPP_INCLUDED\n#define BOOST_NEXT_PRIOR_HPP_INCLUDED\n\n#include <iterator>\n\nnamespace boost {\n\n//  Helper functions for classes like bidirectional iterators not supporting\n//  operator+ and operator-\n//\n//  Usage:\n//    const std::list<T>::iterator p = get_some_iterator();\n//    const std::list<T>::iterator prev = boost::prior(p);\n//    const std::list<T>::iterator next = boost::next(prev, 2);\n\n//  Contributed by Dave Abrahams\n\ntemplate <class T>\ninline T next(T x) { return ++x; }\n\ntemplate <class T, class Distance>\ninline T next(T x, Distance n)\n{\n    std::advance(x, n);\n    return x;\n}\n\ntemplate <class T>\ninline T prior(T x) { return --x; }\n\ntemplate <class T, class Distance>\ninline T prior(T x, Distance n)\n{\n    std::advance(x, -n);\n    return x;\n}\n\n} // namespace boost\n\n#endif  // BOOST_NEXT_PRIOR_HPP_INCLUDED\n","/*  \n *  Copyright 2010-2012 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#pragma once\n\n#include <vector>\n\n#include <boost/graph/adjacency_list.hpp>\n\n#include \"common/point.hpp\"\n#include \"common/halfedgediagram.hpp\"\n#include \"vertex.hpp\"\n#include \"site.hpp\"\n#include \"edge.hpp\"\n\n// this file contains typedefs used by voronoidiagram.hpp\nnamespace ovd {\n\n// vecS is slightly faster than listS\n// vecS   5.72us * n log(n)\n// listS  6.18 * n log(n)\n#define OUT_EDGE_CONTAINER boost::listS \n#define VERTEX_CONTAINER boost::listS\n#define EDGE_LIST_CONTAINER boost::listS\n\n/// edge-descriptors in the graph\ntypedef boost::adjacency_list_traits<OUT_EDGE_CONTAINER, \n                                     VERTEX_CONTAINER, \n                                     boost::bidirectionalS, \n                                     EDGE_LIST_CONTAINER >::edge_descriptor HEEdge;\n                                     \n///face-descriptors in the graph \n// (if there were a traits-class for HEDIGraph we could use it here, instead of \"hard coding\" the type)\ntypedef unsigned int HEFace;    \n\n/// Status of faces in the voronoi diagram\nenum VoronoiFaceStatus {\n    INCIDENT,    /*!< INCIDENT faces contain one or more IN-vertex */\n    NONINCIDENT  /*!< NONINCIDENT faces contain only OUT/UNDECIDED-vertices */\n    };\n\n/// \\brief properties of a face in the voronoi diagram\n/// \nstruct FaceProps {\n    FaceProps() {\n        site = 0;\n        null = false;\n    }\n    virtual ~FaceProps() {}\n    /// create face with given edge, generator, and type\n    FaceProps( HEEdge e , Site* s, VoronoiFaceStatus st) : edge(e), site(s), status(st), null(false) {}\n    /// operator for sorting faces\n    bool operator<(const FaceProps& f) const {return (this->idx<f.idx);}\n    HEFace idx;     ///< face index\n    HEEdge edge;     ///< one edge that bounds this face\n    Site* site;     ///< the Site for this face \n    VoronoiFaceStatus status;     ///< face status (either ::INCIDENT or ::NONINCIDENT)\n    bool null;     ///< flag to indicate null-face\n\n};\n\n/// the type of graph with which we construct the voronoi-diagram\ntypedef hedi::half_edge_diagram< OUT_EDGE_CONTAINER,     // out-edges storage\n                       VERTEX_CONTAINER,         // vertex set stored here\n                       boost::bidirectionalS,    // bidirectional graph.\n                       VoronoiVertex,            // vertex properties\n                       EdgeProps,                // edge properties\n                       FaceProps,                // face properties\n                       boost::no_property,       // graph properties\n                       EDGE_LIST_CONTAINER       // edge storage\n                       > HEGraph;\n// NOTE: if these listS etc. arguments ever change, they must also be updated\n// above where we do: adjacency_list_traits\n\ntypedef boost::graph_traits< HEGraph::BGLGraph >::vertex_descriptor  HEVertex;       ///< vertex descriptor\ntypedef boost::graph_traits< HEGraph::BGLGraph >::vertex_iterator    HEVertexItr;    ///< vertex iterator\ntypedef boost::graph_traits< HEGraph::BGLGraph >::edge_iterator      HEEdgeItr;      ///< edge iterator\ntypedef boost::graph_traits< HEGraph::BGLGraph >::out_edge_iterator  HEOutEdgeItr;   ///< out edge iterator\ntypedef boost::graph_traits< HEGraph::BGLGraph >::adjacency_iterator HEAdjacencyItr; ///< adj iterator\ntypedef boost::graph_traits< HEGraph::BGLGraph >::vertices_size_type HEVertexSize;   ///< vertex size\n\n// these containers are used, for simplicity, instead of iterators (like in BGL) when accessing\n// adjacent vertices, edges, faces.\n// FIXME: it may be faster to rewrite the code so it uses iterators, as does the BGL.\ntypedef std::vector<HEVertex> VertexVector; ///< vector of vertices \ntypedef std::vector<HEFace>   FaceVector;  ///< vector of faces\ntypedef std::vector<HEEdge>   EdgeVector;  ///< vector of edges\n\n} // end ovd namespace\n","/*  \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef VODI_VERTEX_HPP\n#define VODI_VERTEX_HPP\n\n#include <map>\n#include <cmath>\n\n#include \"common/point.hpp\"\n#include \"site.hpp\"\n\nnamespace ovd {\n\n/// As we incrementally construct the diagram voronoi-vertices \n/// can have one of these four different states. \nenum VertexStatus {\n    OUT,          /*!< OUT-vertices will not be deleted */\n    IN,           /*!< IN-vertices will be deleted */\n    UNDECIDED,    /*!< UNDECIDED-vertices have not been examied yet */\n    NEW           /*!< NEW-vertices are constructed on OUT-IN edges */\n};\n\n/// This is the permanent type of a vertex in the diagram. \nenum VertexType {\n    OUTER,      /*!< OUTER vertices are special vertices added in init(), should have degree==4 */\n    NORMAL,     /*!< NORMAL are normal voronoi-vertices, should have degree==6  (degree 3 graph with double-edges) */\n    POINTSITE,  /*!< POINTSITE are point sites, should have degree==0 */\n    ENDPOINT,   /*!< ENDPOINT vertices are end-points of line-segments or arc-segments */\n    SEPPOINT,   /*!< separator start-vertices on a null-face */\n    APEX,       /*!< APEX vertices split quadratic edges at their apex(closest point to site) */\n    SPLIT       /*!< split-vertices of degree==2 to avoid loops in the delete-tree */\n};\n\n\n\n\n                                     \n/// \\brief A vertex in the voronoi diagram\n///\n/// an object of this type is held in the BGL-graph for each vertex.\nclass VoronoiVertex {\npublic:\n    VoronoiVertex( Point p, VertexStatus st, VertexType t);\n    VoronoiVertex( Point p, VertexStatus st, VertexType t, double init_radius);\n    VoronoiVertex( Point pos, VertexStatus st, VertexType t, Point initDist);\n    VoronoiVertex( Point pos, VertexStatus st, VertexType t, Point initDist, double k3);\n    virtual ~VoronoiVertex();\n\n    typedef unsigned int HEFace; ///< face-descriptor\n\n    void reset_status();\n    friend class VoronoiDiagramChecker;\n    void init_dist(const Point& p);\n    double dist(const Point& p) const;\n    void zero_dist();\n    double dist() const; \n    double in_circle(const Point& p) const; \n    static void reset_count(); \n    void set_alfa(const Point& dir); ///< set alfa. This is only for debug-drawing of null-face vertices.\n// DATA\n    \n    int index; ///< unique integer index of vertex\n    VertexStatus status; ///< vertex status. updated/changed during an incremental graph update\n    VertexType type; ///< The type of the vertex. Never(?) changes\n    double max_error; ///< \\todo what is this? remove?\n    bool in_queue; ///< flag for indicating wether vertex is in the vertexQueue\n    Point position; ///< the position of the vertex.\n    double k3;  ///< the offset-direction {-1,+1} of this vertex to the newly inserted site.\n    double alfa; ///< diangle for a null-vertex. only for debug-drawing\n    HEFace null_face; ///< if this is a null-face, a handle to the null-face \n    HEFace face; ///< the face of this vertex, if the vertex is a point-site\nprotected:\n    void init();\n    void init(Point p, VertexStatus st);\n    void init(Point p, VertexStatus st, VertexType t);\n    void init(Point p, VertexStatus st, VertexType t, Point initDist);\n    void init(Point p, VertexStatus st, VertexType t, Point initDist, double k3);\n    static int count; ///< global vertex count \\todo hold this in hedigraph instead?\n    /// A map of this type is used by VoronoiDiagramChecker to check that all vertices\n    /// have the expected (correct) degree (i.e. number of edges)\n    typedef std::map<VertexType, unsigned int> VertexDegreeMap;\n    static VertexDegreeMap expected_degree; ///< map for checking topology correctness\n    double r; ///< clearance-disk radius, i.e. the closest Site is at this distance\nprivate:\n    VoronoiVertex();\n};\n\n} // end namespace\n#endif\n","#ifndef BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED\n#define BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED\n\n//  (C) Copyright Greg Colvin and Beman Dawes 1998, 1999.\n//  Copyright (c) 2001, 2002 Peter Dimov\n//\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n//  http://www.boost.org/libs/smart_ptr/scoped_ptr.htm\n//\n\n#include <boost/config.hpp>\n#include <boost/assert.hpp>\n#include <boost/checked_delete.hpp>\n#include <boost/smart_ptr/detail/sp_nullptr_t.hpp>\n#include <boost/detail/workaround.hpp>\n\n#ifndef BOOST_NO_AUTO_PTR\n# include <memory>          // for std::auto_ptr\n#endif\n\nnamespace boost\n{\n\n// Debug hooks\n\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n\nvoid sp_scalar_constructor_hook(void * p);\nvoid sp_scalar_destructor_hook(void * p);\n\n#endif\n\n//  scoped_ptr mimics a built-in pointer except that it guarantees deletion\n//  of the object pointed to, either on destruction of the scoped_ptr or via\n//  an explicit reset(). scoped_ptr is a simple solution for simple needs;\n//  use shared_ptr or std::auto_ptr if your needs are more complex.\n\ntemplate<class T> class scoped_ptr // noncopyable\n{\nprivate:\n\n    T * px;\n\n    scoped_ptr(scoped_ptr const &);\n    scoped_ptr & operator=(scoped_ptr const &);\n\n    typedef scoped_ptr<T> this_type;\n\n    void operator==( scoped_ptr const& ) const;\n    void operator!=( scoped_ptr const& ) const;\n\npublic:\n\n    typedef T element_type;\n\n    explicit scoped_ptr( T * p = 0 ): px( p ) // never throws\n    {\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        boost::sp_scalar_constructor_hook( px );\n#endif\n    }\n\n#ifndef BOOST_NO_AUTO_PTR\n\n    explicit scoped_ptr( std::auto_ptr<T> p ) BOOST_NOEXCEPT : px( p.release() )\n    {\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        boost::sp_scalar_constructor_hook( px );\n#endif\n    }\n\n#endif\n\n    ~scoped_ptr() // never throws\n    {\n#if defined(BOOST_SP_ENABLE_DEBUG_HOOKS)\n        boost::sp_scalar_destructor_hook( px );\n#endif\n        boost::checked_delete( px );\n    }\n\n    void reset(T * p = 0) // never throws\n    {\n        BOOST_ASSERT( p == 0 || p != px ); // catch self-reset errors\n        this_type(p).swap(*this);\n    }\n\n    T & operator*() const // never throws\n    {\n        BOOST_ASSERT( px != 0 );\n        return *px;\n    }\n\n    T * operator->() const // never throws\n    {\n        BOOST_ASSERT( px != 0 );\n        return px;\n    }\n\n    T * get() const BOOST_NOEXCEPT\n    {\n        return px;\n    }\n\n// implicit conversion to \"bool\"\n#include <boost/smart_ptr/detail/operator_bool.hpp>\n\n    void swap(scoped_ptr & b) BOOST_NOEXCEPT\n    {\n        T * tmp = b.px;\n        b.px = px;\n        px = tmp;\n    }\n};\n\n#if !defined( BOOST_NO_CXX11_NULLPTR )\n\ntemplate<class T> inline bool operator==( scoped_ptr<T> const & p, boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT\n{\n    return p.get() == 0;\n}\n\ntemplate<class T> inline bool operator==( boost::detail::sp_nullptr_t, scoped_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return p.get() == 0;\n}\n\ntemplate<class T> inline bool operator!=( scoped_ptr<T> const & p, boost::detail::sp_nullptr_t ) BOOST_NOEXCEPT\n{\n    return p.get() != 0;\n}\n\ntemplate<class T> inline bool operator!=( boost::detail::sp_nullptr_t, scoped_ptr<T> const & p ) BOOST_NOEXCEPT\n{\n    return p.get() != 0;\n}\n\n#endif\n\ntemplate<class T> inline void swap(scoped_ptr<T> & a, scoped_ptr<T> & b) BOOST_NOEXCEPT\n{\n    a.swap(b);\n}\n\n// get_pointer(p) is a generic way to say p.get()\n\ntemplate<class T> inline T * get_pointer(scoped_ptr<T> const & p) BOOST_NOEXCEPT\n{\n    return p.get();\n}\n\n} // namespace boost\n\n#endif // #ifndef BOOST_SMART_PTR_SCOPED_PTR_HPP_INCLUDED\n","#ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED\n#define BOOST_CHECKED_DELETE_HPP_INCLUDED\n\n// MS compatible compilers support #pragma once\n\n#if defined(_MSC_VER) && (_MSC_VER >= 1020)\n# pragma once\n#endif\n\n//\n//  boost/checked_delete.hpp\n//\n//  Copyright (c) 2002, 2003 Peter Dimov\n//  Copyright (c) 2003 Daniel Frey\n//  Copyright (c) 2003 Howard Hinnant\n//\n//  Distributed under the Boost Software License, Version 1.0. (See\n//  accompanying file LICENSE_1_0.txt or copy at\n//  http://www.boost.org/LICENSE_1_0.txt)\n//\n//  See http://www.boost.org/libs/utility/checked_delete.html for documentation.\n//\n\nnamespace boost\n{\n\n// verify that types are complete for increased safety\n\ntemplate<class T> inline void checked_delete(T * x)\n{\n    // intentionally complex - simplification causes regressions\n    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];\n    (void) sizeof(type_must_be_complete);\n    delete x;\n}\n\ntemplate<class T> inline void checked_array_delete(T * x)\n{\n    typedef char type_must_be_complete[ sizeof(T)? 1: -1 ];\n    (void) sizeof(type_must_be_complete);\n    delete [] x;\n}\n\ntemplate<class T> struct checked_deleter\n{\n    typedef void result_type;\n    typedef T * argument_type;\n\n    void operator()(T * x) const\n    {\n        // boost:: disables ADL\n        boost::checked_delete(x);\n    }\n};\n\ntemplate<class T> struct checked_array_deleter\n{\n    typedef void result_type;\n    typedef T * argument_type;\n\n    void operator()(T * x) const\n    {\n        boost::checked_array_delete(x);\n    }\n};\n\n} // namespace boost\n\n#endif  // #ifndef BOOST_CHECKED_DELETE_HPP_INCLUDED\n","/* \n *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenVoronoi is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenVoronoi is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenVoronoi.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"numeric.hpp\"\n\n//#include <qd/qd_real.h>\n#include <cmath>\n#include <cassert>\n\nnamespace ovd {\n\nnamespace numeric {\n    \n    /*\n    double chop8(double a) {\n        double eps = 1e-8;\n        if (fabs(a) < eps)\n            return 0.0;\n        else\n            return a;\n    }*/\n    double chop(double val, double tol) {\n        double _epsilon = tol;\n        if (fabs(val) < _epsilon) \n            return 0;\n        else\n            return val;\n    }\n    \n    double chop(double val) {\n        double _epsilon = 1e-10;\n        if (fabs(val) < _epsilon) \n            return 0;\n        else\n            return val;\n    }\n    qd_real chop(qd_real val) {\n        qd_real _epsilon = 1e-10;\n        if (fabs(val) < _epsilon) \n            return qd_real(0);\n        else\n            return val;\n    }\n\n\n    double diangle(double x, double y) {\n        if (y >= 0)\n            return (x >= 0 ? y/(x+y) : 1-x/(-x+y));\n        else\n            return (x < 0 ? 2-y/(-x-y) : 3+x/(x-y));\n    }\n    double diangle_x(double a) {\n        return (a < 2 ? 1-a : a-3);\n    }\n    double diangle_y(double a) {\n        return (a < 3 ? ((a > 1) ? 2-a : a) : a-4);\n    }\n\n\n    std::pair<double,double> diangle_xy(double a) {\n        double x = diangle_x(a);\n        double y = diangle_y(a);\n        double norm = sqrt(x*x+y*y);\n        return std::make_pair(x/norm,y/norm);\n    }\n    // return true if a lies in [less,more]\n    bool diangle_bracket(double less, double a, double more) {\n        if (less==more) {\n            return false;\n        }else if (less<=more) { // normal case..\n            if ( (less<=a) && (a<more) )\n                return true;\n        } else if (less>more) { // we cross zero\n            if ( ((less<=a) && (a<=4)) || ((0<=a) && (a<more)) )\n                return true;\n        } else {\n            assert(0);\n            return false;\n        }\n        \n        return false;\n    }\n    // return average of input angles\n    double diangle_mid(double alfa1, double alfa2) {\n        if (alfa1<=alfa2)\n            return (alfa1+alfa2)/2;\n        else {\n            double opposite_mid = alfa2 + (alfa1-alfa2)/2;\n            double mid = opposite_mid + 2;\n            if (mid>4)\n                mid=mid-4;\n            assert( (0<=mid) && (mid<=4) );\n            return mid;\n        }\n    }\n} // numeric\n} // ovd\n\n","/*  \n *  Copyright 2010 Anders Wallin (anders.e.e.wallin \"at\" gmail.com)\n *  \n *  This file is part of OpenVoronoi.\n *\n *  OpenCAMlib is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  OpenCAMlib is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with OpenCAMlib.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include <cmath> // sqrt, sin, cos, fabs\n#include <cassert>\n#include <sstream>\n\n#include \"point.hpp\"\n\nnamespace ovd {\n    \n/// create a point at (0,0)\nPoint::Point(): x(0.0), y(0.0) {}\n/// create a point at (x,y)\nPoint::Point(double xi, double yi) : x(xi), y(yi) {}\n/// create a point at p\nPoint::Point(const Point &p): x(p.x), y(p.y) {}\n/// dtor\nPoint::~Point() {}\n\n/// norm of vector, or distance from (0,0,0) to *this\ndouble Point::norm() const {\n    return sqrt( x*x + y*y  );\n}\n/// squared norm (avoiding sqrt() might be faster in some cases)\ndouble Point::norm_sq() const {\n    return x*x + y*y;\n}\n\n/// dot product\ndouble Point::dot(const Point &p) const {\n    return x * p.x + y * p.y ; \n}\n/// 2D cross-product\ndouble Point::cross(const Point &p) const {\n    return x * p.y - y * p.x ; \n}\n/// scales vector so that norm()==1.0\nvoid Point::normalize() {\n    if (this->norm() != 0.0)\n        *this *=(1/this->norm());\n}\n/// return perpendicular in the xy plane, rotated 90 degree to the left\nPoint Point::xy_perp() const {\n    return Point(-y, x);\n    // 2D rotation matrix:\n    //   cos   -sin\n    //   sin   cos\n    // for theta = 90\n    //   0   -1   ( x )\n    //   1    0   ( y )  = ( -y  x )\n    \n}\n\n/// is this Point right of line through points \\a p1 and \\a p2 ?\nbool Point::is_right(const Point &p1, const Point &p2) const {\n    // this is an ugly way of doing a determinant\n    // should be prettyfied sometime...\n    /// \\todo FIXME: what if p1==p2 ? (in the XY plane)\n    double a1 = p2.x - p1.x;\n    double a2 = p2.y - p1.y;\n    double t1 = a2;\n    double t2 = -a1;\n    double b1 = x - p1.x;\n    double b2 = y - p1.y;\n\n    double t = t1 * b1 + t2 * b2;\n    if (t > 0.0) \n        return true;\n    else\n        return false;    \n}\n\n/* **************** Operators ***************  \n *  see\n *  http://www.cs.caltech.edu/courses/cs11/material/cpp/donnie/cpp-ops.html\n*/\n\nPoint& Point::operator=(const Point &p) {\n    if (this == &p)\n        return *this;\n    x=p.x;\n    y=p.y;\n    return *this;\n}\n\n// Point*scalar multiplication\nPoint& Point::operator*=(const double &a) {\n    x*=a;\n    y*=a;\n    return *this;\n}\n\nPoint& Point::operator+=(const Point &p) {\n    x+=p.x;\n    y+=p.y;\n    return *this;\n}\n\nPoint& Point::operator-=(const Point &p) {\n    x-=p.x;\n    y-=p.y;\n    return *this;\n}\n\nconst Point Point::operator+(const Point &p) const {\n    return Point(*this) += p;\n}\n\nconst Point Point::operator-(const Point &p) const {\n    return Point(*this) -= p;\n}\n\nconst Point Point::operator*(const double &a) const {\n    return Point(*this) *= a;\n}\n\n/// scalar*Point\nconst Point operator*(const double &a, const Point &p) {\n    return Point(p) *= a;\n}\n\nbool Point::operator==(const Point &p) const {\n    return (this == &p) || (x==p.x && y==p.y ); \n}\n\nbool Point::operator!=(const Point &p) const {\n    return !(*this == p);\n}\n\nstd::string Point::str() const {\n    std::ostringstream o;\n    o << *this;\n    return o.str();\n}\n\n/// string output for Point\nstd::ostream& operator<<(std::ostream &stream, const Point& p) {\n  stream << \"(\" << p.x << \", \" << p.y << \")\"; \n  return stream;\n}\n\n} // end namespace\n// end file point.cpp\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/instance.h\"\n\n#include \"ppapi/c/pp_errors.h\"\n#include \"ppapi/c/ppb_console.h\"\n#include \"ppapi/c/ppb_input_event.h\"\n#include \"ppapi/c/ppb_instance.h\"\n#include \"ppapi/c/ppb_messaging.h\"\n#include \"ppapi/cpp/graphics_2d.h\"\n#include \"ppapi/cpp/graphics_3d.h\"\n#include \"ppapi/cpp/image_data.h\"\n#include \"ppapi/cpp/instance_handle.h\"\n#include \"ppapi/cpp/logging.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/module_impl.h\"\n#include \"ppapi/cpp/point.h\"\n#include \"ppapi/cpp/resource.h\"\n#include \"ppapi/cpp/var.h\"\n#include \"ppapi/cpp/view.h\"\n\nnamespace pp {\n\nnamespace {\n\ntemplate <> const char* interface_name<PPB_Console_1_0>() {\n  return PPB_CONSOLE_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_InputEvent_1_0>() {\n  return PPB_INPUT_EVENT_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_Instance_1_0>() {\n  return PPB_INSTANCE_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_Messaging_1_0>() {\n  return PPB_MESSAGING_INTERFACE_1_0;\n}\n\n}  // namespace\n\nInstance::Instance(PP_Instance instance) : pp_instance_(instance) {\n}\n\nInstance::~Instance() {\n}\n\nbool Instance::Init(uint32_t /*argc*/, const char* /*argn*/[],\n                    const char* /*argv*/[]) {\n  return true;\n}\n\nvoid Instance::DidChangeView(const View& view) {\n  // Call the deprecated version for source backwards-compat.\n  DidChangeView(view.GetRect(), view.GetClipRect());\n}\n\nvoid Instance::DidChangeView(const pp::Rect& /*position*/,\n                             const pp::Rect& /*clip*/) {\n}\n\nvoid Instance::DidChangeFocus(bool /*has_focus*/) {\n}\n\n\nbool Instance::HandleDocumentLoad(const URLLoader& /*url_loader*/) {\n  return false;\n}\n\nbool Instance::HandleInputEvent(const InputEvent& /*event*/) {\n  return false;\n}\n\nvoid Instance::HandleMessage(const Var& /*message*/) {\n  return;\n}\n\nbool Instance::BindGraphics(const Graphics2D& graphics) {\n  if (!has_interface<PPB_Instance_1_0>())\n    return false;\n  return PP_ToBool(get_interface<PPB_Instance_1_0>()->BindGraphics(\n      pp_instance(), graphics.pp_resource()));\n}\n\nbool Instance::BindGraphics(const Graphics3D& graphics) {\n  if (!has_interface<PPB_Instance_1_0>())\n    return false;\n  return PP_ToBool(get_interface<PPB_Instance_1_0>()->BindGraphics(\n      pp_instance(), graphics.pp_resource()));\n}\n\nbool Instance::IsFullFrame() {\n  if (!has_interface<PPB_Instance_1_0>())\n    return false;\n  return PP_ToBool(get_interface<PPB_Instance_1_0>()->IsFullFrame(\n      pp_instance()));\n}\n\nint32_t Instance::RequestInputEvents(uint32_t event_classes) {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return PP_ERROR_NOINTERFACE;\n  return get_interface<PPB_InputEvent_1_0>()->RequestInputEvents(pp_instance(),\n                                                                 event_classes);\n}\n\nint32_t Instance::RequestFilteringInputEvents(uint32_t event_classes) {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return PP_ERROR_NOINTERFACE;\n  return get_interface<PPB_InputEvent_1_0>()->RequestFilteringInputEvents(\n      pp_instance(), event_classes);\n}\n\nvoid Instance::ClearInputEventRequest(uint32_t event_classes) {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return;\n  get_interface<PPB_InputEvent_1_0>()->ClearInputEventRequest(pp_instance(),\n                                                          event_classes);\n}\n\nvoid Instance::PostMessage(const Var& message) {\n  if (!has_interface<PPB_Messaging_1_0>())\n    return;\n  get_interface<PPB_Messaging_1_0>()->PostMessage(pp_instance(),\n                                              message.pp_var());\n}\n\nvoid Instance::LogToConsole(PP_LogLevel level, const Var& value) {\n  if (!has_interface<PPB_Console_1_0>())\n    return;\n  get_interface<PPB_Console_1_0>()->Log(\n      pp_instance(), level, value.pp_var());\n}\n\nvoid Instance::LogToConsoleWithSource(PP_LogLevel level,\n                                      const Var& source,\n                                      const Var& value) {\n  if (!has_interface<PPB_Console_1_0>())\n    return;\n  get_interface<PPB_Console_1_0>()->LogWithSource(\n      pp_instance(), level, source.pp_var(), value.pp_var());\n}\n\nvoid Instance::AddPerInstanceObject(const std::string& interface_name,\n                                    void* object) {\n  // Ensure we're not trying to register more than one object per interface\n  // type. Otherwise, we'll get confused in GetPerInstanceObject.\n  PP_DCHECK(interface_name_to_objects_.find(interface_name) ==\n            interface_name_to_objects_.end());\n  interface_name_to_objects_[interface_name] = object;\n}\n\nvoid Instance::RemovePerInstanceObject(const std::string& interface_name,\n                                       void* object) {\n  InterfaceNameToObjectMap::iterator found = interface_name_to_objects_.find(\n      interface_name);\n  if (found == interface_name_to_objects_.end()) {\n    // Attempting to unregister an object that doesn't exist or was already\n    // unregistered.\n    PP_DCHECK(false);\n    return;\n  }\n\n  // Validate that we're removing the object we thing we are.\n  PP_DCHECK(found->second == object);\n  (void)object;  // Prevent warning in release mode.\n\n  interface_name_to_objects_.erase(found);\n}\n\n// static\nvoid Instance::RemovePerInstanceObject(const InstanceHandle& instance,\n                                       const std::string& interface_name,\n                                       void* object) {\n  // TODO(brettw) assert we're on the main thread.\n  Instance* that = Module::Get()->InstanceForPPInstance(instance.pp_instance());\n  if (!that)\n    return;\n  that->RemovePerInstanceObject(interface_name, object);\n}\n\n// static\nvoid* Instance::GetPerInstanceObject(PP_Instance instance,\n                                     const std::string& interface_name) {\n  Instance* that = Module::Get()->InstanceForPPInstance(instance);\n  if (!that)\n    return NULL;\n  InterfaceNameToObjectMap::iterator found =\n      that->interface_name_to_objects_.find(interface_name);\n  if (found == that->interface_name_to_objects_.end())\n    return NULL;\n  return found->second;\n}\n\n}  // namespace pp\n","// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_RECT_H_\n#define PPAPI_CPP_RECT_H_\n\n#include \"ppapi/c/pp_rect.h\"\n#include \"ppapi/cpp/point.h\"\n#include \"ppapi/cpp/size.h\"\n\n/// @file\n/// This file defines the APIs for creating a 2 dimensional rectangle.\n\nnamespace pp {\n\n/// A 2 dimensional rectangle. A rectangle is represented by x and y (which\n/// identifies the upper-left corner of the rectangle), width, and height.\nclass Rect {\n public:\n\n  /// The default constructor. Creates a <code>Rect</code> in the upper-left\n  /// at 0,0 with height and width of 0.\n  Rect() {\n    rect_.point.x = 0;\n    rect_.point.y = 0;\n    rect_.size.width = 0;\n    rect_.size.height = 0;\n  }\n\n  /// A constructor accepting a reference to a <code>PP_Rect and</code>\n  /// converting the <code>PP_Rect</code> to a <code>Rect</code>. This is an\n  /// implicit conversion constructor.\n  ///\n  /// @param[in] rect A <code>PP_Rect</code>.\n  Rect(const PP_Rect& rect) {  // Implicit.\n    set_x(rect.point.x);\n    set_y(rect.point.y);\n    set_width(rect.size.width);\n    set_height(rect.size.height);\n  }\n\n  /// A constructor accepting two int32_t values for width and height and\n  /// converting them to a <code>Rect</code> in the upper-left starting\n  /// coordinate of 0,0.\n  ///\n  /// @param[in] w An int32_t value representing a width.\n  /// @param[in] h An int32_t value representing a height.\n  Rect(int32_t w, int32_t h) {\n    set_x(0);\n    set_y(0);\n    set_width(w);\n    set_height(h);\n  }\n\n  /// A constructor accepting four int32_t values for width, height, x, and y.\n  ///\n  /// @param[in] x An int32_t value representing a horizontal coordinate\n  /// of a point, starting with 0 as the left-most coordinate.\n  /// @param[in] y An int32_t value representing a vertical coordinate\n  /// of a point, starting with 0 as the top-most coordinate.\n  /// @param[in] w An int32_t value representing a width.\n  /// @param[in] h An int32_t value representing a height.\n  Rect(int32_t x, int32_t y, int32_t w, int32_t h) {\n    set_x(x);\n    set_y(y);\n    set_width(w);\n    set_height(h);\n  }\n\n  /// A constructor accepting a pointer to a Size and converting the\n  /// <code>Size</code> to a <code>Rect</code> in the upper-left starting\n  /// coordinate of 0,0.\n  ///\n  /// @param[in] s A pointer to a <code>Size</code>.\n  explicit Rect(const Size& s) {\n    set_x(0);\n    set_y(0);\n    set_size(s);\n  }\n\n  /// A constructor accepting a pointer to a <code>Point</code> representing\n  /// the origin of the rectangle and a pointer to a <code>Size</code>\n  /// representing the height and width.\n  ///\n  /// @param[in] origin A pointer to a <code>Point</code> representing the\n  /// upper-left starting coordinate.\n  /// @param[in] size A pointer to a <code>Size</code> representing the height\n  /// and width.\n  Rect(const Point& origin, const Size& size) {\n    set_point(origin);\n    set_size(size);\n  }\n\n  /// Destructor.\n  ~Rect() {\n  }\n\n  /// PP_Rect() allows implicit conversion of a <code>Rect</code> to a\n  /// <code>PP_Rect</code>.\n  ///\n  /// @return A <code>Point</code>.\n  operator PP_Rect() const {\n    return rect_;\n  }\n\n  /// Getter function for returning the internal <code>PP_Rect</code> struct.\n  ///\n  /// @return A const reference to the internal <code>PP_Rect</code> struct.\n  const PP_Rect& pp_rect() const {\n    return rect_;\n  }\n\n  /// Getter function for returning the internal <code>PP_Rect</code> struct.\n  ///\n  /// @return A mutable reference to the <code>PP_Rect</code> struct.\n  PP_Rect& pp_rect() {\n    return rect_;\n  }\n\n\n  /// Getter function for returning the value of x.\n  ///\n  /// @return The value of x for this <code>Point</code>.\n  int32_t x() const {\n    return rect_.point.x;\n  }\n\n  /// Setter function for setting the value of x.\n  ///\n  /// @param[in] in_x A new x value.\n  void set_x(int32_t in_x) {\n    rect_.point.x = in_x;\n  }\n\n  /// Getter function for returning the value of y.\n  ///\n  /// @return The value of y for this <code>Point</code>.\n  int32_t y() const {\n    return rect_.point.y;\n  }\n\n  /// Setter function for setting the value of y.\n  ///\n  /// @param[in] in_y A new y value.\n  void set_y(int32_t in_y) {\n    rect_.point.y = in_y;\n  }\n\n  /// Getter function for returning the value of width.\n  ///\n  /// @return The value of width for this <code>Rect</code>.\n  int32_t width() const {\n    return rect_.size.width;\n  }\n\n  /// Setter function for setting the value of width.\n  ///\n  /// @param[in] w A new width value.\n  void set_width(int32_t w) {\n    if (w < 0) {\n      PP_DCHECK(w >= 0);\n      w = 0;\n    }\n    rect_.size.width = w;\n  }\n\n  /// Getter function for returning the value of height.\n  ///\n  /// @return The value of height for this <code>Rect</code>.\n  int32_t height() const {\n    return rect_.size.height;\n  }\n\n  /// Setter function for setting the value of height.\n  ///\n  /// @param[in] h A new width height.\n  void set_height(int32_t h) {\n    if (h < 0) {\n      PP_DCHECK(h >= 0);\n      h = 0;\n    }\n    rect_.size.height = h;\n  }\n\n  /// Getter function for returning the <code>Point</code>.\n  ///\n  /// @return A <code>Point</code>.\n  Point point() const {\n    return Point(rect_.point);\n  }\n\n  /// Setter function for setting the value of the <code>Point</code>.\n  ///\n  /// @param[in] origin A <code>Point</code> representing the upper-left\n  /// starting coordinate.\n  void set_point(const Point& origin) {\n    rect_.point = origin;\n  }\n\n  /// Getter function for returning the <code>Size</code>.\n  ///\n  /// @return The size of the rectangle.\n  Size size() const {\n    return Size(rect_.size);\n  }\n\n  /// Setter function for setting the <code>Size</code>.\n  ///\n  /// @param[in] s A pointer to a <code>Size</code> representing the height\n  /// and width.\n  void set_size(const Size& s) {\n    rect_.size.width = s.width();\n    rect_.size.height = s.height();\n  }\n\n  /// Getter function to get the upper-bound for the x-coordinates of the\n  /// rectangle.  Note that this coordinate value is one past the highest x\n  /// value of pixels in the rectangle.  This loop will access all the pixels\n  /// in a horizontal line in the rectangle:\n  /// <code>for (int32_t x = rect.x(); x < rect.right(); ++x) {}</code>\n  ///\n  /// @return The value of x + width for this point.\n  int32_t right() const {\n    return x() + width();\n  }\n\n  /// Getter function to get the upper-bound for the y-coordinates of the\n  /// rectangle.  Note that this coordinate value is one past the highest xy\n  /// value of pixels in the rectangle.  This loop will access all the pixels\n  /// in a horizontal line in the rectangle:\n  /// <code>for (int32_t y = rect.y(); y < rect.bottom(); ++y) {}</code>\n  ///\n  /// @return The value of y + height for this point.\n  int32_t bottom() const {\n    return y() + height();\n  }\n\n  /// Setter function for setting the value of the <code>Rect</code>.\n  ///\n  /// @param[in] x A new x value.\n  /// @param[in] y A new y value.\n  /// @param[in] w A new width value.\n  /// @param[in] h A new height value.\n  void SetRect(int32_t x, int32_t y, int32_t w, int32_t h) {\n    set_x(x);\n    set_y(y);\n    set_width(w);\n    set_height(h);\n  }\n\n  /// Setter function for setting the value of the <code>Rect</code>.\n  ///\n  /// @param[in] rect A pointer to a <code>PP_Rect</code>.\n  void SetRect(const PP_Rect& rect) {\n    rect_ = rect;\n  }\n\n  /// Inset() shrinks the rectangle by a horizontal and vertical\n  /// distance on all sides.\n  ///\n  /// @param[in] horizontal An int32_t value representing a horizontal\n  /// shrinking distance.\n  /// @param[in] vertical An int32_t value representing a vertical\n  /// shrinking distance.\n  void Inset(int32_t horizontal, int32_t vertical) {\n    Inset(horizontal, vertical, horizontal, vertical);\n  }\n\n  /// Inset() shrinks the rectangle by the specified amount on each\n  /// side.\n  ///\n  /// @param[in] left An int32_t value representing a left\n  /// shrinking distance.\n  /// @param[in] top An int32_t value representing a top\n  /// shrinking distance.\n  /// @param[in] right An int32_t value representing a right\n  /// shrinking distance.\n  /// @param[in] bottom An int32_t value representing a bottom\n  /// shrinking distance.\n  void Inset(int32_t left, int32_t top, int32_t right, int32_t bottom);\n\n  /// Offset() moves the rectangle by a horizontal and vertical distance.\n  ///\n  /// @param[in] horizontal An int32_t value representing a horizontal\n  /// move distance.\n  /// @param[in] vertical An int32_t value representing a vertical\n  /// move distance.\n  void Offset(int32_t horizontal, int32_t vertical);\n\n  /// Offset() moves the rectangle by a horizontal and vertical distance.\n  ///\n  /// @param[in] point A pointer to a <code>Point</code> representing the\n  /// horizontal and vertical move distances.\n  void Offset(const Point& point) {\n    Offset(point.x(), point.y());\n  }\n\n  /// IsEmpty() determines if the area of a rectangle is zero. Returns true if\n  /// the area of the rectangle is zero.\n  ///\n  /// @return true if the area of the rectangle is zero.\n  bool IsEmpty() const {\n    return rect_.size.width == 0 && rect_.size.height == 0;\n  }\n\n  /// Contains() determines if the point identified by point_x and point_y\n  /// falls inside this rectangle. The point (x, y) is inside the rectangle,\n  /// but the point (x + width, y + height) is not.\n  ///\n  /// @param[in] point_x An int32_t value representing a x value.\n  /// @param[in] point_y An int32_t value representing a y value.\n  ///\n  /// @return true if the point_x and point_y fall inside the rectangle.\n  bool Contains(int32_t point_x, int32_t point_y) const;\n\n  /// Contains() determines if the specified point is contained by this\n  /// rectangle.\n  ///\n  /// @param[in] point A pointer to a Point representing a 2D coordinate.\n  ///\n  /// @return true if the point_x and point_y fall inside the rectangle.\n  bool Contains(const Point& point) const {\n    return Contains(point.x(), point.y());\n  }\n\n  /// Contains() determines if this rectangle contains the specified rectangle.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return true if the rectangle fall inside this rectangle.\n  bool Contains(const Rect& rect) const;\n\n  /// Intersects() determines if this rectangle intersects the specified\n  /// rectangle.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return true if the rectangle intersects  this rectangle.\n  bool Intersects(const Rect& rect) const;\n\n  /// Intersect() computes the intersection of this rectangle with the given\n  /// rectangle.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return A <code>Rect</code> representing the intersection.\n  Rect Intersect(const Rect& rect) const;\n\n  /// Union() computes the union of this rectangle with the given rectangle.\n  /// The union is the smallest rectangle containing both rectangles.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return A <code>Rect</code> representing the union.\n  Rect Union(const Rect& rect) const;\n\n  /// Subtract() computes the rectangle resulting from subtracting\n  /// <code>rect</code> from this Rect.  If <code>rect</code>does not intersect\n  /// completely in either the x or y direction, then <code>*this</code> is\n  /// returned. If <code>rect</code> contains <code>this</code>, then an empty\n  /// <code>Rect</code> is returned.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return A <code>Rect</code> representing the subtraction.\n  Rect Subtract(const Rect& rect) const;\n\n  /// AdjustToFit() fits as much of the receiving rectangle within\n  /// the supplied rectangle as possible, returning the result. For example,\n  /// if the receiver had a x-location of 2 and a width of 4, and the supplied\n  /// rectangle had an x-location of 0 with a width of 5, the returned\n  /// rectangle would have an x-location of 1 with a width of 4.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return A <code>Rect</code> representing the difference between this\n  /// rectangle and the receiving rectangle.\n  Rect AdjustToFit(const Rect& rect) const;\n\n  /// CenterPoint() determines the center of this rectangle.\n  ///\n  /// @return A <code>Point</code> representing the center of this rectangle.\n  Point CenterPoint() const;\n\n  /// SharesEdgeWith() determines if this rectangle shares an entire edge\n  /// (same width or same height) with the given rectangle, and the\n  /// rectangles do not overlap.\n  ///\n  /// @param[in] rect A pointer to a <code>Rect</code>.\n  ///\n  /// @return true if this rectangle and supplied rectangle share an edge.\n  bool SharesEdgeWith(const Rect& rect) const;\n\n private:\n  PP_Rect rect_;\n};\n\n}  // namespace pp\n\n/// This function determines whether the x, y, width, and height values of two\n/// rectangles and are equal.\n///\n/// @param[in] lhs The <code>Rect</code> on the left-hand side of the equation.\n/// @param[in] rhs The <code>Rect</code> on the right-hand side of the equation.\n///\n/// @return true if they are equal, false if unequal.\ninline bool operator==(const pp::Rect& lhs, const pp::Rect& rhs) {\n  return lhs.x() == rhs.x() &&\n         lhs.y() == rhs.y() &&\n         lhs.width() == rhs.width() &&\n         lhs.height() == rhs.height();\n}\n\n/// This function determines whether two Rects are not equal.\n///\n/// @param[in] lhs The <code>Rect</code> on the left-hand side of the equation.\n/// @param[in] rhs The <code>Rect</code> on the right-hand side of the\n/// equation.\n///\n/// @return true if the given Rects are equal, otherwise false.\ninline bool operator!=(const pp::Rect& lhs, const pp::Rect& rhs) {\n  return !(lhs == rhs);\n}\n\n#endif\n\n","/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n/* From pp_bool.idl modified Thu Nov  1 13:48:33 2012. */\n\n#ifndef PPAPI_C_PP_BOOL_H_\n#define PPAPI_C_PP_BOOL_H_\n\n#include \"ppapi/c/pp_macros.h\"\n\n/**\n * @file\n * This file defines the <code>PP_Bool</code> enumeration for use in PPAPI C\n * headers.\n */\n\n\n/**\n * @addtogroup Enums\n * @{\n */\n/**\n * The <code>PP_Bool</code> enum is a boolean value for use in PPAPI C headers.\n * The standard bool type is not available to pre-C99 compilers, and is not\n * guaranteed to be compatible between C and C++, whereas the PPAPI C headers\n * can be included from C or C++ code.\n */\ntypedef enum {\n  PP_FALSE = 0,\n  PP_TRUE = 1\n} PP_Bool;\nPP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_Bool, 4);\n/**\n * @}\n */\n\n#ifdef __cplusplus\n/**\n * Converts a C++ \"bool\" type to a PP_Bool.\n *\n * @param[in] b A C++ \"bool\" type.\n *\n * @return A PP_Bool.\n */\ninline PP_Bool PP_FromBool(bool b) {\n  return b ? PP_TRUE : PP_FALSE;\n}\n\n/**\n * Converts a PP_Bool to a C++ \"bool\" type.\n *\n * @param[in] b A PP_Bool.\n *\n * @return A C++ \"bool\" type.\n */\ninline bool PP_ToBool(PP_Bool b) {\n  return (b != PP_FALSE);\n}\n\n#endif  /* __cplusplus */\n\n#endif  /* PPAPI_C_PP_BOOL_H_ */\n\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_INSTANCE_H_\n#define PPAPI_CPP_INSTANCE_H_\n\n/// @file\n/// This file defines the C++ wrapper for an instance.\n\n#include <map>\n#include <string>\n\n#include \"ppapi/c/pp_instance.h\"\n#include \"ppapi/c/pp_resource.h\"\n#include \"ppapi/c/pp_stdint.h\"\n#include \"ppapi/c/ppb_console.h\"\n#include \"ppapi/cpp/instance_handle.h\"\n#include \"ppapi/cpp/view.h\"\n\n// Windows defines 'PostMessage', so we have to undef it.\n#ifdef PostMessage\n#undef PostMessage\n#endif\n\nstruct PP_InputEvent;\n\n/// The C++ interface to the Pepper API.\nnamespace pp {\n\nclass Graphics2D;\nclass Graphics3D;\nclass InputEvent;\nclass InstanceHandle;\nclass Rect;\nclass URLLoader;\nclass Var;\n\nclass Instance {\n public:\n  /// Default constructor. Construction of an instance should only be done in\n  /// response to a browser request in <code>Module::CreateInstance</code>.\n  /// Otherwise, the instance will lack the proper bookkeeping in the browser\n  /// and in the C++ wrapper.\n  ///\n  /// Init() will be called immediately after the constructor. This allows you\n  /// to perform initialization tasks that can fail and to report that failure\n  /// to the browser.\n  explicit Instance(PP_Instance instance);\n\n  /// Destructor. When the instance is removed from the web page,\n  /// the <code>pp::Instance</code> object will be deleted. You should never\n  /// delete the <code>Instance</code> object yourself since the lifetime is\n  /// handled by the C++ wrapper and is controlled by the browser's calls to\n  /// the <code>PPP_Instance</code> interface.\n  ///\n  /// The <code>PP_Instance</code> identifier will still be valid during this\n  /// call so the instance can perform cleanup-related tasks. Once this function\n  /// returns, the <code>PP_Instance</code> handle will be invalid. This means\n  /// that you can't do any asynchronous operations such as network requests or\n  /// file writes from this destructor since they will be immediately canceled.\n  ///\n  /// <strong>Note:</strong> This function may be skipped in certain\n  /// call so the instance can perform cleanup-related tasks. Once this function\n  /// returns, the <code>PP_Instance</code> handle will be invalid. This means\n  /// that you can't do any asynchronous operations such as network requests or\n  /// file writes from this destructor since they will be immediately canceled.\n  virtual ~Instance();\n\n  /// This function returns the <code>PP_Instance</code> identifying this\n  /// object.\n  ///\n  /// @return A <code>PP_Instance</code> identifying this object.\n  PP_Instance pp_instance() const { return pp_instance_; }\n\n  /// Init() initializes this instance with the provided arguments. This\n  /// function will be called immediately after the instance object is\n  /// constructed.\n  ///\n  /// @param[in] argc The number of arguments contained in <code>argn</code>\n  /// and <code>argv</code>.\n  ///\n  /// @param[in] argn An array of argument names.  These argument names are\n  /// supplied in the \\<embed\\> tag, for example:\n  /// <code>\\<embed id=\"nacl_module\" dimensions=\"2\"\\></code> will produce two\n  /// argument names: \"id\" and \"dimensions\".\n  ///\n  /// @param[in] argv An array of argument values.  These are the values of the\n  /// arguments listed in the \\<embed\\> tag, for example\n  /// <code>\\<embed id=\"nacl_module\" dimensions=\"2\"\\></code> will produce two\n  /// argument values: \"nacl_module\" and \"2\".  The indices of these values\n  /// match the indices of the corresponding names in <code>argn</code>.\n  ///\n  /// @return true on success. Returning false causes the instance to be\n  /// deleted and no other functions to be called.\n  virtual bool Init(uint32_t argc, const char* argn[], const char* argv[]);\n\n  /// @{\n  /// @name PPP_Instance methods for the module to override:\n\n  /// DidChangeView() is called when the view information for the Instance\n  /// has changed. See the <code>View</code> object for information.\n  ///\n  /// Most implementations will want to check if the size and user visibility\n  /// changed, and either resize themselves or start/stop generating updates.\n  ///\n  /// You should not call the default implementation. For\n  /// backwards-compatibility, it will call the deprecated version of\n  /// DidChangeView below.\n  virtual void DidChangeView(const View& view);\n\n  /// Deprecated backwards-compatible version of <code>DidChangeView()</code>.\n  /// New code should derive from the version that takes a\n  /// <code>ViewChanged</code> object rather than this version. This function\n  /// is called by the default implementation of the newer\n  /// <code>DidChangeView</code> function for source compatibility with older\n  /// code.\n  ///\n  /// A typical implementation will check the size of the <code>position</code>\n  /// argument and reallocate the graphics context when a different size is\n  /// received. Note that this function will be called for scroll events where\n  /// the size doesn't change, so you should always check that the size is\n  /// actually different before doing any reallocations.\n  ///\n  /// @param[in] position The location on the page of the instance. The\n  /// position is relative to the top left corner of the viewport, which changes\n  /// as the page is scrolled. Generally the size of this value will be used to\n  /// create a graphics device, and the position is ignored (most things are\n  /// relative to the instance so the absolute position isn't useful in most\n  /// cases).\n  ///\n  /// @param[in] clip The visible region of the instance. This is relative to\n  /// the top left of the instance's coordinate system (not the page).  If the\n  /// instance is invisible, <code>clip</code> will be (0, 0, 0, 0).\n  ///\n  /// It's recommended to check for invisible instances and to stop\n  /// generating graphics updates in this case to save system resources. It's\n  /// not usually worthwhile, however, to generate partial updates according to\n  /// the clip when the instance is partially visible. Instead, update the\n  /// entire region. The time saved doing partial paints is usually not\n  /// significant and it can create artifacts when scrolling (this notification\n  /// is sent asynchronously from scrolling so there can be flashes of old\n  /// content in the exposed regions).\n  virtual void DidChangeView(const Rect& position, const Rect& clip);\n\n  /// DidChangeFocus() is called when an instance has gained or lost focus.\n  /// Having focus means that keyboard events will be sent to the instance.\n  /// An instance's default condition is that it will not have focus.\n  ///\n  /// The focus flag takes into account both browser tab and window focus as\n  /// well as focus of the plugin element on the page. In order to be deemed\n  /// to have focus, the browser window must be topmost, the tab must be\n  /// selected in the window, and the instance must be the focused element on\n  /// the page.\n  ///\n  /// <strong>Note:</strong>Clicks on instances will give focus only if you\n  /// handle the click event. Return <code>true</code> from\n  /// <code>HandleInputEvent</code> in <code>PPP_InputEvent</code> (or use\n  /// unfiltered events) to signal that the click event was handled. Otherwise,\n  /// the browser will bubble the event and give focus to the element on the\n  /// page that actually did end up consuming it. If you're not getting focus,\n  /// check to make sure you're either requesting them via\n  /// <code>RequestInputEvents()<code> (which implicitly marks all input events\n  /// as consumed) or via <code>RequestFilteringInputEvents()</code> and\n  /// returning true from your event handler.\n  ///\n  /// @param[in] has_focus Indicates the new focused state of the instance.\n  virtual void DidChangeFocus(bool has_focus);\n\n  /// HandleInputEvent() handles input events from the browser. The default\n  /// implementation does nothing and returns false.\n  ///\n  /// In order to receive input events, you must register for them by calling\n  /// RequestInputEvents() or RequestFilteringInputEvents(). By\n  /// default, no events are delivered.\n  ///\n  /// If the event was handled, it will not be forwarded to the web page or\n  /// browser. If it was not handled, it will bubble according to the normal\n  /// rules. So it is important that an instance respond accurately with whether\n  /// event propagation should continue.\n  ///\n  /// Event propagation also controls focus. If you handle an event like a mouse\n  /// event, typically the instance will be given focus. Returning false from\n  /// a filtered event handler or not registering for an event type means that\n  /// the click will be given to a lower part of the page and your instance will\n  /// not receive focus. This allows an instance to be partially transparent,\n  /// where clicks on the transparent areas will behave like clicks to the\n  /// underlying page.\n  ///\n  /// In general, you should try to keep input event handling short. Especially\n  /// for filtered input events, the browser or page may be blocked waiting for\n  /// you to respond.\n  ///\n  /// The caller of this function will maintain a reference to the input event\n  /// resource during this call. Unless you take a reference to the resource\n  /// to hold it for later, you don't need to release it.\n  ///\n  /// <strong>Note: </strong>If you're not receiving input events, make sure\n  /// you register for the event classes you want by calling\n  /// <code>RequestInputEvents</code> or\n  /// <code>RequestFilteringInputEvents</code>. If you're still not receiving\n  /// keyboard input events, make sure you're returning true (or using a\n  /// non-filtered event handler) for mouse events. Otherwise, the instance will\n  /// not receive focus and keyboard events will not be sent.\n  ///\n  /// Refer to <code>RequestInputEvents</code> and\n  /// <code>RequestFilteringInputEvents</code> for further information.\n  ///\n  /// @param[in] event The event to handle.\n  ///\n  /// @return true if the event was handled, false if not. If you have\n  /// registered to filter this class of events by calling\n  /// <code>RequestFilteringInputEvents</code>, and you return false,\n  /// the event will be forwarded to the page (and eventually the browser)\n  /// for the default handling. For non-filtered events, the return value\n  /// will be ignored.\n  virtual bool HandleInputEvent(const pp::InputEvent& event);\n\n  /// HandleDocumentLoad() is called after Init() for a full-frame\n  /// instance that was instantiated based on the MIME type of a DOMWindow\n  /// navigation. This situation only applies to modules that are\n  /// pre-registered to handle certain MIME types. If you haven't specifically\n  /// registered to handle a MIME type or aren't positive this applies to you,\n  /// your implementation of this function can just return false.\n  ///\n  /// The given url_loader corresponds to a <code>URLLoader</code> object that\n  /// is already opened. Its response headers may be queried using\n  /// GetResponseInfo(). If you want to use the <code>URLLoader</code> to read\n  /// data, you will need to save a copy of it or the underlying resource will\n  /// be freed when this function returns and the load will be canceled.\n  ///\n  /// This method returns false if the module cannot handle the data. In\n  /// response to this method, the module should call ReadResponseBody() to read\n  /// the incoming data.\n  ///\n  /// @param[in] url_loader An open <code>URLLoader</code> instance.\n  ///\n  /// @return true if the data was handled, false otherwise.\n  virtual bool HandleDocumentLoad(const URLLoader& url_loader);\n\n  /// HandleMessage() is a function that the browser calls when PostMessage()\n  /// is invoked on the DOM element for the instance in JavaScript. Note\n  /// that PostMessage() in the JavaScript interface is asynchronous, meaning\n  /// JavaScript execution will not be blocked while HandleMessage() is\n  /// processing the message.\n  ///\n  /// When converting JavaScript arrays, any object properties whose name\n  /// is not an array index are ignored. When passing arrays and objects, the\n  /// entire reference graph will be converted and transferred. If the reference\n  /// graph has cycles, the message will not be sent and an error will be logged\n  /// to the console.\n  ///\n  /// <strong>Example:</strong>\n  ///\n  /// The following JavaScript code invokes <code>HandleMessage</code>, passing\n  /// the instance on which it was invoked, with <code>message</code> being a\n  /// string <code>Var</code> containing \"Hello world!\"\n  ///\n  /// @code{.html}\n  ///\n  /// <body>\n  ///   <object id=\"plugin\"\n  ///           type=\"application/x-ppapi-postMessage-example\"/>\n  ///   <script type=\"text/javascript\">\n  ///     document.getElementById('plugin').postMessage(\"Hello world!\");\n  ///   </script>\n  /// </body>\n  ///\n  /// @endcode\n  ///\n  /// Refer to PostMessage() for sending messages to JavaScript.\n  ///\n  /// @param[in] message A <code>Var</code> which has been converted from a\n  /// JavaScript value. JavaScript array/object types are supported from Chrome\n  /// M29 onward. All JavaScript values are copied when passing them to the\n  /// plugin.\n  virtual void HandleMessage(const Var& message);\n\n  /// @}\n\n  /// @{\n  /// @name PPB_Instance methods for querying the browser:\n\n  /// BindGraphics() binds the given graphics as the current display surface.\n  /// The contents of this device is what will be displayed in the instance's\n  /// area on the web page. The device must be a 2D or a 3D device.\n  ///\n  /// You can pass an <code>is_null()</code> (default constructed) Graphics2D\n  /// as the device parameter to unbind all devices from the given instance.\n  /// The instance will then appear transparent. Re-binding the same device\n  /// will return <code>true</code> and will do nothing.\n  ///\n  /// Any previously-bound device will be released. It is an error to bind\n  /// a device when it is already bound to another instance. If you want\n  /// to move a device between instances, first unbind it from the old one, and\n  /// then rebind it to the new one.\n  ///\n  /// Binding a device will invalidate that portion of the web page to flush the\n  /// contents of the new device to the screen.\n  ///\n  /// @param[in] graphics A <code>Graphics2D</code> to bind.\n  ///\n  /// @return true if bind was successful or false if the device was not the\n  /// correct type. On success, a reference to the device will be held by the\n  /// instance, so the caller can release its reference if it chooses.\n  bool BindGraphics(const Graphics2D& graphics);\n\n  /// Binds the given Graphics3D as the current display surface.\n  /// Refer to <code>BindGraphics(const Graphics2D& graphics)</code> for\n  /// further information.\n  ///\n  /// @param[in] graphics A <code>Graphics3D</code> to bind.\n  ///\n  /// @return true if bind was successful or false if the device was not the\n  /// correct type. On success, a reference to the device will be held by the\n  /// instance, so the caller can release its reference if it chooses.\n  bool BindGraphics(const Graphics3D& graphics);\n\n  /// IsFullFrame() determines if the instance is full-frame (repr).\n  /// Such an instance represents the entire document in a frame rather than an\n  /// embedded resource. This can happen if the user does a top-level\n  /// navigation or the page specifies an iframe to a resource with a MIME\n  /// type registered by the module.\n  ///\n  /// @return true if the instance is full-frame, false if not.\n  bool IsFullFrame();\n\n  /// RequestInputEvents() requests that input events corresponding to the\n  /// given input events are delivered to the instance.\n  ///\n  /// By default, no input events are delivered. Call this function with the\n  /// classes of events you are interested in to have them be delivered to\n  /// the instance. Calling this function will override any previous setting for\n  /// each specified class of input events (for example, if you previously\n  /// called RequestFilteringInputEvents(), this function will set those events\n  /// to non-filtering mode).\n  ///\n  /// Input events may have high overhead, so you should only request input\n  /// events that your plugin will actually handle. For example, the browser may\n  /// do optimizations for scroll or touch events that can be processed\n  /// substantially faster if it knows there are no non-default receivers for\n  /// that message. Requesting that such messages be delivered, even if they are\n  /// processed very quickly, may have a noticeable effect on the performance of\n  /// the page.\n  ///\n  /// When requesting input events through this function, the events will be\n  /// delivered and <em>not</em> bubbled to the page. This means that even if\n  /// you aren't interested in the message, no other parts of the page will get\n  /// the message.\n  ///\n  /// <strong>Example:</strong>\n  ///\n  /// @code\n  ///   RequestInputEvents(PP_INPUTEVENT_CLASS_MOUSE);\n  ///   RequestFilteringInputEvents(\n  ///       PP_INPUTEVENT_CLASS_WHEEL | PP_INPUTEVENT_CLASS_KEYBOARD);\n  ///\n  /// @endcode\n  ///\n  /// @param event_classes A combination of flags from\n  /// <code>PP_InputEvent_Class</code> that identifies the classes of events\n  /// the instance is requesting. The flags are combined by logically ORing\n  /// their values.\n  ///\n  /// @return <code>PP_OK</code> if the operation succeeded,\n  /// <code>PP_ERROR_BADARGUMENT</code> if instance is invalid, or\n  /// <code>PP_ERROR_NOTSUPPORTED</code> if one of the event class bits were\n  /// illegal. In the case of an invalid bit, all valid bits will be applied\n  /// and only the illegal bits will be ignored.\n  int32_t RequestInputEvents(uint32_t event_classes);\n\n  /// RequestFilteringInputEvents() requests that input events corresponding\n  /// to the given input events are delivered to the instance for filtering.\n  ///\n  /// By default, no input events are delivered. In most cases you would\n  /// register to receive events by calling RequestInputEvents(). In some cases,\n  /// however, you may wish to filter events such that they can be bubbled up\n  /// to the DOM. In this case, register for those classes of events using\n  /// this function instead of RequestInputEvents(). Keyboard events must always\n  /// be registered in filtering mode.\n  ///\n  /// Filtering input events requires significantly more overhead than just\n  /// delivering them to the instance. As such, you should only request\n  /// filtering in those cases where it's absolutely necessary. The reason is\n  /// that it requires the browser to stop and block for the instance to handle\n  /// the input event, rather than sending the input event asynchronously. This\n  /// can have significant overhead.\n  ///\n  /// <strong>Example:</strong>\n  ///\n  /// @code\n  ///\n  ///   RequestInputEvents(PP_INPUTEVENT_CLASS_MOUSE);\n  ///   RequestFilteringInputEvents(\n  ///       PP_INPUTEVENT_CLASS_WHEEL | PP_INPUTEVENT_CLASS_KEYBOARD);\n  ///\n  /// @endcode\n  ///\n  /// @param event_classes A combination of flags from\n  /// <code>PP_InputEvent_Class</code> that identifies the classes of events\n  /// the instance is requesting. The flags are combined by logically ORing\n  /// their values.\n  ///\n  /// @return <code>PP_OK</code> if the operation succeeded,\n  /// <code>PP_ERROR_BADARGUMENT</code> if instance is invalid, or\n  /// <code>PP_ERROR_NOTSUPPORTED</code> if one of the event class bits were\n  /// illegal. In the case of an invalid bit, all valid bits will be applied\n  /// and only the illegal bits will be ignored.\n  int32_t RequestFilteringInputEvents(uint32_t event_classes);\n\n  /// ClearInputEventRequest() requests that input events corresponding to the\n  /// given input classes no longer be delivered to the instance.\n  ///\n  /// By default, no input events are delivered. If you have previously\n  /// requested input events using RequestInputEvents() or\n  /// RequestFilteringInputEvents(), this function will unregister handling\n  /// for the given instance. This will allow greater browser performance for\n  /// those events.\n  ///\n  /// <strong>Note: </strong> You may still get some input events after\n  /// clearing the flag if they were dispatched before the request was cleared.\n  /// For example, if there are 3 mouse move events waiting to be delivered,\n  /// and you clear the mouse event class during the processing of the first\n  /// one, you'll still receive the next two. You just won't get more events\n  /// generated.\n  ///\n  /// @param[in] event_classes A combination of flags from\n  /// <code>PP_InputEvent_Class</code> that identifies the classes of events the\n  /// instance is no longer interested in.\n  void ClearInputEventRequest(uint32_t event_classes);\n\n  /// PostMessage() asynchronously invokes any listeners for message events on\n  /// the DOM element for the given instance. A call to PostMessage() will\n  /// not block while the message is processed.\n  ///\n  /// <strong>Example:</strong>\n  ///\n  /// @code{.html}\n  ///\n  /// <body>\n  ///   <object id=\"plugin\"\n  ///           type=\"application/x-ppapi-postMessage-example\"/>\n  ///   <script type=\"text/javascript\">\n  ///     var plugin = document.getElementById('plugin');\n  ///     plugin.addEventListener(\"message\",\n  ///                             function(message) { alert(message.data); },\n  ///                             false);\n  ///   </script>\n  /// </body>\n  ///\n  /// @endcode\n  ///\n  /// The instance then invokes PostMessage() as follows:\n  ///\n  /// @code\n  ///\n  ///  PostMessage(pp::Var(\"Hello world!\"));\n  ///\n  /// @endcode\n  ///\n  /// The browser will pop-up an alert saying \"Hello world!\"\n  ///\n  /// When passing array or dictionary <code>PP_Var</code>s, the entire\n  /// reference graph will be converted and transferred. If the reference graph\n  /// has cycles, the message will not be sent and an error will be logged to\n  /// the console.\n  ///\n  /// Listeners for message events in JavaScript code will receive an object\n  /// conforming to the HTML 5 <code>MessageEvent</code> interface.\n  /// Specifically, the value of message will be contained as a property called\n  /// data in the received <code>MessageEvent</code>.\n  ///\n  /// This messaging system is similar to the system used for listening for\n  /// messages from Web Workers. Refer to\n  /// <code>http://www.whatwg.org/specs/web-workers/current-work/</code> for\n  /// further information.\n  ///\n  /// Refer to HandleMessage() for receiving events from JavaScript.\n  ///\n  /// @param[in] message A <code>Var</code> containing the data to be sent to\n  /// JavaScript. Message can have a numeric, boolean, or string value.\n  /// Array/Dictionary types are supported from Chrome M29 onward.\n  /// All var types are copied when passing them to JavaScript.\n  void PostMessage(const Var& message);\n\n  /// @}\n\n  /// @{\n  /// @name PPB_Console methods for logging to the console:\n\n  /// Logs the given message to the JavaScript console associated with the\n  /// given plugin instance with the given logging level. The name of the plugin\n  /// issuing the log message will be automatically prepended to the message.\n  /// The value may be any type of Var.\n  void LogToConsole(PP_LogLevel level, const Var& value);\n\n  /// Logs a message to the console with the given source information rather\n  /// than using the internal PPAPI plugin name. The name must be a string var.\n  ///\n  /// The regular log function will automatically prepend the name of your\n  /// plugin to the message as the \"source\" of the message. Some plugins may\n  /// wish to override this. For example, if your plugin is a Python\n  /// interpreter, you would want log messages to contain the source .py file\n  /// doing the log statement rather than have \"python\" show up in the console.\n  void LogToConsoleWithSource(PP_LogLevel level,\n                              const Var& source,\n                              const Var& value);\n\n  /// @}\n\n  /// AddPerInstanceObject() associates an instance with an interface,\n  /// creating an object.\n  ///\n  /// Many optional interfaces are associated with a plugin instance. For\n  /// example, the find in PPP_Find interface receives updates on a per-instance\n  /// basis. This \"per-instance\" tracking allows such objects to associate\n  /// themselves with an instance as \"the\" handler for that interface name.\n  ///\n  /// In the case of the find example, the find object registers with its\n  /// associated instance in its constructor and unregisters in its destructor.\n  /// Then whenever it gets updates with a PP_Instance parameter, it can\n  /// map back to the find object corresponding to that given PP_Instance by\n  /// calling GetPerInstanceObject.\n  ///\n  /// This lookup is done on a per-interface-name basis. This means you can\n  /// only have one object of a given interface name associated with an\n  /// instance.\n  ///\n  /// If you are adding a handler for an additional interface, be sure to\n  /// register with the module (AddPluginInterface) for your interface name to\n  /// get the C calls in the first place.\n  ///\n  /// Refer to RemovePerInstanceObject() and GetPerInstanceObject() for further\n  /// information.\n  ///\n  /// @param[in] interface_name The name of the interface to associate with the\n  /// instance\n  /// @param[in] object\n  void AddPerInstanceObject(const std::string& interface_name, void* object);\n\n  // {PENDING: summarize Remove method here}\n  ///\n  /// Refer to AddPerInstanceObject() for further information.\n  ///\n  /// @param[in] interface_name The name of the interface to associate with the\n  /// instance\n  /// @param[in] object\n  void RemovePerInstanceObject(const std::string& interface_name, void* object);\n\n  /// Static version of AddPerInstanceObject that takes an InstanceHandle. As\n  /// with all other instance functions, this must only be called on the main\n  /// thread.\n  static void RemovePerInstanceObject(const InstanceHandle& instance,\n                                      const std::string& interface_name,\n                                      void* object);\n\n  /// Look up an object previously associated with an instance. Returns NULL\n  /// if the instance is invalid or there is no object for the given interface\n  /// name on the instance.\n  ///\n  /// Refer to AddPerInstanceObject() for further information.\n  ///\n  /// @param[in] instance\n  /// @param[in] interface_name The name of the interface to associate with the\n  /// instance.\n  static void* GetPerInstanceObject(PP_Instance instance,\n                                    const std::string& interface_name);\n\n private:\n  PP_Instance pp_instance_;\n\n  typedef std::map<std::string, void*> InterfaceNameToObjectMap;\n  InterfaceNameToObjectMap interface_name_to_objects_;\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_INSTANCE_H_\n","// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_RESOURCE_H_\n#define PPAPI_CPP_RESOURCE_H_\n\n#include \"ppapi/c/pp_resource.h\"\n#include \"ppapi/cpp/instance_handle.h\"\n#include \"ppapi/cpp/pass_ref.h\"\n\n/// @file\n/// This file defines a <code>Resource</code> type representing data associated\n/// with the module.\nnamespace pp {\n\nclass Var;\n\n/// A reference counted module resource.\nclass Resource {\n public:\n  /// The default constructor.\n  Resource();\n\n  /// A constructor for copying a resource.\n  ///\n  /// @param[in] other A <code>Resource</code>.\n  Resource(const Resource& other);\n\n  /// Destructor.\n  virtual ~Resource();\n\n  /// This function assigns one <code>Resource</code> to another\n  /// <code>Resource</code>.\n  ///\n  /// @param[in] other A Resource.\n  ///\n  /// @return A Resource containing the assigned Resource.\n  Resource& operator=(const Resource& other);\n\n  /// This functions determines if this resource is invalid or\n  /// uninitialized.\n  ///\n  /// @return true if this resource is invalid or uninitialized.\n  bool is_null() const { return !pp_resource_; }\n\n  PP_Resource pp_resource() const { return pp_resource_; }\n\n  /// This function releases ownership of this resource and returns it to the\n  /// caller.\n  ///\n  /// Note that the reference count on the resource is unchanged and the caller\n  /// needs to release the resource.\n  ///\n  /// @return The detached <code>PP_Resource</code>.\n  PP_Resource detach();\n\n protected:\n  /// A constructor used when a <code>PP_Resource</code> is provided as a\n  /// return value whose reference count we need to increment.\n  ///\n  /// @param[in] resource A <code>PP_Resource</code> corresponding to a\n  /// resource.\n  explicit Resource(PP_Resource resource);\n\n  /// Constructor used when a <code>PP_Resource</code> already has a ref count\n  /// assigned. Add additional refcount is not taken.\n  Resource(PassRef, PP_Resource resource);\n\n  /// PassRefFromConstructor is called by derived class' constructors to\n  /// initialize this <code>Resource</code> with a <code>PP_Resource</code>\n  /// that has already had its reference count incremented by\n  /// <code>Core::AddRefResource</code>. It also assumes this object has no\n  /// current resource.\n  ///\n  /// The intended usage of this function that the derived class constructor\n  /// will call the default <code>Resource</code> constructor, then make a call\n  /// to create a resource. It then wants to assign the new resource (which,\n  /// since it was returned by the browser, already had its reference count\n  /// increased).\n  ///\n  /// @param[in] resource A <code>PP_Resource</code> corresponding to a\n  /// resource.\n  void PassRefFromConstructor(PP_Resource resource);\n\n  /// Sets this resource to null. This releases ownership of the resource.\n  void Clear();\n\n private:\n  friend class Var;\n\n  PP_Resource pp_resource_;\n};\n\n}  // namespace pp\n\ninline bool operator==(const pp::Resource& lhs, const pp::Resource& rhs) {\n  return lhs.pp_resource() == rhs.pp_resource();\n}\n\ninline bool operator!=(const pp::Resource& lhs, const pp::Resource& rhs) {\n  return !(lhs == rhs);\n}\n\n#endif // PPAPI_CPP_RESOURCE_H_\n","// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_MODULE_IMPL_H_\n#define PPAPI_CPP_MODULE_IMPL_H_\n\n/// @file\n/// This file defines some simple function templates that help the C++ wrappers\n/// (and are not for external developers to use).\n\n#include \"ppapi/cpp/module.h\"\n\nnamespace pp {\n\nnamespace {\n\n// Specialize this function to return the interface string corresponding to the\n// PP?_XXX structure.\ntemplate <typename T> const char* interface_name() {\n  return NULL;\n}\n\ntemplate <typename T> inline T const* get_interface() {\n  static T const* funcs = reinterpret_cast<T const*>(\n      pp::Module::Get()->GetBrowserInterface(interface_name<T>()));\n  return funcs;\n}\n\ntemplate <typename T> inline bool has_interface() {\n  return get_interface<T>() != NULL;\n}\n\n}  // namespace\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_MODULE_IMPL_H_\n\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// Note that the single accessor, Module::Get(), is not actually implemented\n// in this file.  This is an intentional hook that allows users of ppapi's\n// C++ wrapper objects to provide different semantics for how the singleton\n// object is accessed.\n//\n// In general, users of ppapi will also link in ppp_entrypoints.cc, which\n// provides a simple default implementation of Module::Get().\n//\n// A notable exception where the default ppp_entrypoints will not work is\n// when implementing \"internal plugins\" that are statically linked into the\n// browser. In this case, the process may actually have multiple Modules\n// loaded at once making a traditional \"singleton\" unworkable.  To get around\n// this, the users of ppapi need to get creative about how to properly\n// implement the Module::Get() so that ppapi's C++ wrappers can find the\n// right Module object.  One example solution is to use thread local storage\n// to change the Module* returned based on which thread is invoking the\n// function. Leaving Module::Get() unimplemented provides a hook for\n// implementing such behavior.\n\n#include \"ppapi/cpp/module.h\"\n\n#include <string.h>\n\n#include \"ppapi/c/pp_instance.h\"\n#include \"ppapi/c/pp_var.h\"\n#include \"ppapi/c/ppp_input_event.h\"\n#include \"ppapi/c/ppp_instance.h\"\n#include \"ppapi/c/ppp_messaging.h\"\n#include \"ppapi/cpp/input_event.h\"\n#include \"ppapi/cpp/instance.h\"\n#include \"ppapi/cpp/rect.h\"\n#include \"ppapi/cpp/resource.h\"\n#include \"ppapi/cpp/url_loader.h\"\n#include \"ppapi/cpp/var.h\"\n#include \"ppapi/cpp/view.h\"\n\nnamespace pp {\n\n// PPP_InputEvent implementation -----------------------------------------------\n\nPP_Bool InputEvent_HandleEvent(PP_Instance pp_instance, PP_Resource resource) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return PP_FALSE;\n  Instance* instance = module_singleton->InstanceForPPInstance(pp_instance);\n  if (!instance)\n    return PP_FALSE;\n\n  return PP_FromBool(instance->HandleInputEvent(InputEvent(resource)));\n}\n\nconst PPP_InputEvent input_event_interface = {\n  &InputEvent_HandleEvent\n};\n\n// PPP_Instance implementation -------------------------------------------------\n\nPP_Bool Instance_DidCreate(PP_Instance pp_instance,\n                           uint32_t argc,\n                           const char* argn[],\n                           const char* argv[]) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return PP_FALSE;\n\n  Instance* instance = module_singleton->CreateInstance(pp_instance);\n  if (!instance)\n    return PP_FALSE;\n  module_singleton->current_instances_[pp_instance] = instance;\n  return PP_FromBool(instance->Init(argc, argn, argv));\n}\n\nvoid Instance_DidDestroy(PP_Instance instance) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return;\n  Module::InstanceMap::iterator found =\n      module_singleton->current_instances_.find(instance);\n  if (found == module_singleton->current_instances_.end())\n    return;\n\n  // Remove it from the map before deleting to try to catch reentrancy.\n  Instance* obj = found->second;\n  module_singleton->current_instances_.erase(found);\n  delete obj;\n}\n\nvoid Instance_DidChangeView(PP_Instance pp_instance,\n                            PP_Resource view_resource) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return;\n  Instance* instance = module_singleton->InstanceForPPInstance(pp_instance);\n  if (!instance)\n    return;\n  instance->DidChangeView(View(view_resource));\n}\n\nvoid Instance_DidChangeFocus(PP_Instance pp_instance, PP_Bool has_focus) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return;\n  Instance* instance = module_singleton->InstanceForPPInstance(pp_instance);\n  if (!instance)\n    return;\n  instance->DidChangeFocus(PP_ToBool(has_focus));\n}\n\nPP_Bool Instance_HandleDocumentLoad(PP_Instance pp_instance,\n                                    PP_Resource pp_url_loader) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return PP_FALSE;\n  Instance* instance = module_singleton->InstanceForPPInstance(pp_instance);\n  if (!instance)\n    return PP_FALSE;\n  return PP_FromBool(instance->HandleDocumentLoad(URLLoader(pp_url_loader)));\n}\n\nstatic PPP_Instance instance_interface = {\n  &Instance_DidCreate,\n  &Instance_DidDestroy,\n  &Instance_DidChangeView,\n  &Instance_DidChangeFocus,\n  &Instance_HandleDocumentLoad\n};\n\n// PPP_Messaging implementation ------------------------------------------------\n\nvoid Messaging_HandleMessage(PP_Instance pp_instance, PP_Var var) {\n  Module* module_singleton = Module::Get();\n  if (!module_singleton)\n    return;\n  Instance* instance = module_singleton->InstanceForPPInstance(pp_instance);\n  if (!instance)\n    return;\n  instance->HandleMessage(Var(PASS_REF, var));\n}\n\nstatic PPP_Messaging instance_messaging_interface = {\n  &Messaging_HandleMessage\n};\n\n// Module ----------------------------------------------------------------------\n\nModule::Module() : pp_module_(0), get_browser_interface_(NULL), core_(NULL) {\n}\n\nModule::~Module() {\n  delete core_;\n  core_ = NULL;\n}\n\nbool Module::Init() {\n  return true;\n}\n\nconst void* Module::GetPluginInterface(const char* interface_name) {\n  if (strcmp(interface_name, PPP_INPUT_EVENT_INTERFACE) == 0)\n    return &input_event_interface;\n  if (strcmp(interface_name, PPP_INSTANCE_INTERFACE) == 0)\n    return &instance_interface;\n  if (strcmp(interface_name, PPP_MESSAGING_INTERFACE) == 0)\n    return &instance_messaging_interface;\n\n  // Now see if anything was dynamically registered.\n  InterfaceMap::const_iterator found = additional_interfaces_.find(\n      std::string(interface_name));\n  if (found != additional_interfaces_.end())\n    return found->second;\n\n  return NULL;\n}\n\nconst void* Module::GetBrowserInterface(const char* interface_name) {\n  return get_browser_interface_(interface_name);\n}\n\nInstance* Module::InstanceForPPInstance(PP_Instance instance) {\n  InstanceMap::iterator found = current_instances_.find(instance);\n  if (found == current_instances_.end())\n    return NULL;\n  return found->second;\n}\n\nvoid Module::AddPluginInterface(const std::string& interface_name,\n                                const void* vtable) {\n  // Verify that we're not trying to register an interface that's already\n  // handled, and if it is, that we're re-registering with the same vtable.\n  // Calling GetPluginInterface rather than looking it up in the map allows\n  // us to also catch \"internal\" ones in addition to just previously added ones.\n  const void* existing_interface = GetPluginInterface(interface_name.c_str());\n  if (existing_interface) {\n    PP_DCHECK(vtable == existing_interface);\n    return;\n  }\n  additional_interfaces_[interface_name] = vtable;\n}\n\nbool Module::InternalInit(PP_Module mod,\n                          PPB_GetInterface get_browser_interface) {\n  pp_module_ = mod;\n  get_browser_interface_ = get_browser_interface;\n\n  // Get the core interface which we require to run.\n  const PPB_Core* core = reinterpret_cast<const PPB_Core*>(GetBrowserInterface(\n      PPB_CORE_INTERFACE));\n  if (!core)\n    return false;\n  core_ = new Core(core);\n\n  return Init();\n}\n\n}  // namespace pp\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_VIEW_H_\n#define PPAPI_CPP_VIEW_H_\n\n#include \"ppapi/cpp/resource.h\"\n#include \"ppapi/cpp/rect.h\"\n#include \"ppapi/cpp/size.h\"\n\n/// @file\n/// This file defines the API for getting the state of a the view for an\n/// instance.\n\nnamespace pp {\n\n/// This class represents the state of the view for an instance and contains\n/// functions for retrieving the current state of that view.\nclass View : public Resource {\n public:\n  /// Default constructor for creating an is_null() <code>View</code> object.\n  View();\n\n  /// Creates a View resource, taking and holding an additional reference to\n  /// the given resource handle.\n  View(PP_Resource view_resource);\n\n  /// GetRect() retrieves the rectangle of the module instance associated\n  /// with a view changed notification relative to the upper-left of the browser\n  /// viewport. This position changes when the page is scrolled.\n  ///\n  /// The returned rectangle may not be inside the visible portion of the\n  /// viewport if the module instance is scrolled off the page. Therefore, the\n  /// position may be negative or larger than the size of the page. The size\n  /// will always reflect the size of the module were it to be scrolled\n  /// entirely into view.\n  ///\n  /// In general, most modules will not need to worry about the position of the\n  ///module instance in the viewport, and only need to use the size.\n  ///\n  /// @return The rectangle of the instance. The default return value for\n  /// an invalid View is the empty rectangle.\n  Rect GetRect() const;\n\n  /// IsFullscreen() returns whether the instance is currently\n  /// displaying in fullscreen mode.\n  ///\n  /// @return <code>true</code> if the instance is in full screen mode,\n  /// or <code>false</code> if it's not or the resource is invalid.\n  bool IsFullscreen() const;\n\n  /// IsVisible() determines whether the module instance might be visible to\n  /// the user. For example, the Chrome window could be minimized or another\n  /// window could be over it. In both of these cases, the module instance\n  /// would not be visible to the user, but IsVisible() will return true.\n  ///\n  /// Use the result to speed up or stop updates for invisible module\n  /// instances.\n  ///\n  /// This function performs the duties of GetRect() (determining whether the\n  /// module instance is scrolled into view and the clip rectangle is nonempty)\n  /// and IsPageVisible() (whether the page is visible to the user).\n  ///\n  /// @return <code>true</code> if the instance might be visible to the\n  /// user, <code>false</code> if it is definitely not visible.\n  bool IsVisible() const;\n\n  /// IsPageVisible() determines if the page that contains the module instance\n  /// is visible. The most common cause of invisible pages is that\n  /// the page is in a background tab in the browser.\n  ///\n  /// Most applications should use IsVisible() instead of this function since\n  /// the module instance could be scrolled off of a visible page, and this\n  /// function will still return true. However, depending on how your module\n  /// interacts with the page, there may be certain updates that you may want\n  /// to perform when the page is visible even if your specific module instance\n  /// is not visible.\n  ///\n  /// @return <code>true</code> if the instance might be visible to the\n  /// user, <code>false</code> if it is definitely not visible.\n  bool IsPageVisible() const;\n\n  /// GetClipRect() returns the clip rectangle relative to the upper-left corner\n  /// of the module instance. This rectangle indicates the portions of the\n  /// module instance that are scrolled into view.\n  ///\n  /// If the module instance is scrolled off the view, the return value will be\n  /// (0, 0, 0, 0). This clip rectangle does <i>not</i> take into account page\n  /// visibility. Therefore, if the module instance is scrolled into view, but\n  /// the page itself is on a tab that is not visible, the return rectangle will\n  /// contain the visible rectangle as though the page were visible. Refer to\n  /// IsPageVisible() and IsVisible() if you want to account for page\n  /// visibility.\n  ///\n  /// Most applications will not need to worry about the clip rectangle. The\n  /// recommended behavior is to do full updates if the module instance is\n  /// visible, as determined by IsVisible(), and do no updates if it is not\n  /// visible.\n  ///\n  /// However, if the cost for computing pixels is very high for your\n  /// application, or the pages you're targeting frequently have very large\n  /// module instances with small visible portions, you may wish to optimize\n  /// further. In this case, the clip rectangle will tell you which parts of\n  /// the module to update.\n  ///\n  /// Note that painting of the page and sending of view changed updates\n  /// happens asynchronously. This means when the user scrolls, for example,\n  /// it is likely that the previous backing store of the module instance will\n  /// be used for the first paint, and will be updated later when your\n  /// application generates new content with the new clip. This may cause\n  /// flickering at the boundaries when scrolling. If you do choose to do\n  /// partial updates, you may want to think about what color the invisible\n  /// portions of your backing store contain (be it transparent or some\n  /// background color) or to paint a certain region outside the clip to reduce\n  /// the visual distraction when this happens.\n  ///\n  /// @return The rectangle representing the visible part of the module\n  /// instance. If the resource is invalid, the empty rectangle is returned.\n  Rect GetClipRect() const;\n\n  /// GetDeviceScale returns the scale factor between device pixels and DIPs\n  /// (also known as logical pixels or UI pixels on some platforms). This allows\n  /// the developer to render their contents at device resolution, even as\n  /// coordinates / sizes are given in DIPs through the API.\n  ///\n  /// Note that the coordinate system for Pepper APIs is DIPs. Also note that\n  /// one DIP might not equal one CSS pixel - when page scale/zoom is in effect.\n  ///\n  /// @return A <code>float</code> value representing the number of device\n  /// pixels per DIP.\n  float GetDeviceScale() const;\n\n  /// GetCSSScale returns the scale factor between DIPs and CSS pixels. This\n  /// allows proper scaling between DIPs - as sent via the Pepper API - and CSS\n  /// pixel coordinates used for Web content.\n  ///\n  /// @return A <code>float</code> value representing the number of DIPs per CSS\n  /// pixel.\n  float GetCSSScale() const;\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_VIEW_H_\n","// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_URL_LOADER_H_\n#define PPAPI_CPP_URL_LOADER_H_\n\n#include \"ppapi/c/pp_stdint.h\"\n#include \"ppapi/cpp/resource.h\"\n\n/// @file\n/// This file defines the API for loading URLs.\nnamespace pp {\n\nclass CompletionCallback;\nclass InstanceHandle;\nclass URLRequestInfo;\nclass URLResponseInfo;\n\n/// URLLoader provides an API for loading URLs.\n/// Refer to <code>ppapi/examples/url_loader/streaming.cc</code>\n/// for an example of how to use this class.\nclass URLLoader : public Resource {\n public:\n  /// Default constructor for creating an is_null()\n  /// <code>URLLoader</code> object.\n  URLLoader() {}\n\n  /// A constructor used when a <code>PP_Resource</code> is provided as a\n  /// return value whose reference count we need to increment.\n  ///\n  /// @param[in] resource A <code>PP_Resource</code> corresponding to a\n  /// <code>URLLoader</code> resource.\n  explicit URLLoader(PP_Resource resource);\n\n  /// A constructor used to allocate a new URLLoader in the browser. The\n  /// resulting object will be <code>is_null</code> if the allocation failed.\n  ///\n  /// @param[in] instance The instance with which this resource will be\n  /// associated.\n  explicit URLLoader(const InstanceHandle& instance);\n\n  /// The copy constructor for <code>URLLoader</code>.\n  ///\n  /// @param other A <code>URLLoader</code> to be copied.\n  URLLoader(const URLLoader& other);\n\n  /// This function begins loading the <code>URLRequestInfo</code>.\n  /// The operation completes when response headers are received or when an\n  /// error occurs.  Use GetResponseInfo() to access the response\n  /// headers.\n  ///\n  /// @param[in] request_info A <code>URLRequestInfo</code> corresponding to a\n  /// URLRequestInfo.\n  /// @param[in] cc A <code>CompletionCallback</code> to run on asynchronous\n  /// completion of Open(). This callback will run when response\n  /// headers for the url are received or error occurred. This callback\n  /// will only run if Open() returns <code>PP_OK_COMPLETIONPENDING</code>.\n  ///\n  /// @return An int32_t containing an error code from\n  /// <code>pp_errors.h</code>.\n  int32_t Open(const URLRequestInfo& request_info,\n               const CompletionCallback& cc);\n\n  /// This function can be invoked to follow a\n  /// redirect after Open() completed on receiving redirect headers.\n  ///\n  /// @param[in] cc A <code>CompletionCallback</code> to run on asynchronous\n  /// completion of FollowRedirect(). This callback will run when response\n  /// headers for the redirect url are received or error occurred. This callback\n  /// will only run if FollowRedirect() returns\n  /// <code>PP_OK_COMPLETIONPENDING</code>.\n  ///\n  /// @return An int32_t containing an error code from\n  /// <code>pp_errors.h</code>.\n  int32_t FollowRedirect(const CompletionCallback& cc);\n\n  /// This function returns the current upload progress (which is only\n  /// meaningful after Open() has been called). Progress only refers to the\n  /// request body and does not include the headers.\n  ///\n  /// This data is only available if the <code>URLRequestInfo</code> passed to\n  /// Open() had the\n  /// <code>PP_URLREQUESTPROPERTY_REPORTUPLOADPROGRESS</code> property set to\n  /// <code>PP_TRUE</code>.\n  ///\n  /// @param[in] bytes_sent The number of bytes sent thus far.\n  /// @param[in] total_bytes_to_be_sent The total number of bytes to be sent.\n  ///\n  /// @return true if the upload progress is available, false if it is not\n  /// available.\n  bool GetUploadProgress(int64_t* bytes_sent,\n                         int64_t* total_bytes_to_be_sent) const;\n\n  /// This function returns the current download progress, which is meaningful\n  /// after Open() has been called. Progress only refers to the response body\n  /// and does not include the headers.\n  ///\n  /// This data is only available if the <code>URLRequestInfo</code> passed to\n  /// Open() had the\n  /// <code>PP_URLREQUESTPROPERTY_REPORTDOWNLOADPROGRESS</code> property set to\n  /// PP_TRUE.\n  ///\n  /// @param[in] bytes_received The number of bytes received thus far.\n  /// @param[in] total_bytes_to_be_received The total number of bytes to be\n  /// received. The total bytes to be received may be unknown, in which case\n  /// <code>total_bytes_to_be_received</code> will be set to -1.\n  ///\n  /// @return true if the download progress is available, false if it is\n  /// not available.\n  bool GetDownloadProgress(int64_t* bytes_received,\n                           int64_t* total_bytes_to_be_received) const;\n\n  /// This is a function that returns the current\n  /// <code>URLResponseInfo</code> object.\n  ///\n  /// @return A <code>URLResponseInfo</code> corresponding to the\n  /// <code>URLResponseInfo</code> if successful, an <code>is_null</code>\n  /// object if the loader is not a valid resource or if Open() has not been\n  /// called.\n  URLResponseInfo GetResponseInfo() const;\n\n  /// This function is used to read the response body. The size of the buffer\n  /// must be large enough to hold the specified number of bytes to read.\n  /// This function might perform a partial read.\n  ///\n  /// @param[in,out] buffer A pointer to the buffer for the response body.\n  /// @param[in] bytes_to_read The number of bytes to read.\n  /// @param[in] cc A <code>CompletionCallback</code> to run on asynchronous\n  /// completion. The callback will run if the bytes (full or partial) are\n  /// read or an error occurs asynchronously. This callback will run only if\n  /// this function returns <code>PP_OK_COMPLETIONPENDING</code>.\n  ///\n  /// @return An int32_t containing the number of bytes read or an error code\n  /// from <code>pp_errors.h</code>.\n  int32_t ReadResponseBody(void* buffer,\n                           int32_t bytes_to_read,\n                           const CompletionCallback& cc);\n\n  /// This function is used to wait for the response body to be completely\n  /// downloaded to the file provided by the GetBodyAsFileRef() in the current\n  /// <code>URLResponseInfo</code>. This function is only used if\n  /// <code>PP_URLREQUESTPROPERTY_STREAMTOFILE</code> was set on the\n  /// <code>URLRequestInfo</code> passed to Open().\n  ///\n  /// @param[in] cc A <code>CompletionCallback</code> to run on asynchronous\n  /// completion. This callback will run when body is downloaded or an error\n  /// occurs after FinishStreamingToFile() returns\n  /// <code>PP_OK_COMPLETIONPENDING</code>.\n  ///\n  /// @return An int32_t containing the number of bytes read or an error code\n  /// from <code>pp_errors.h</code>.\n  int32_t FinishStreamingToFile(const CompletionCallback& cc);\n\n  /// This function is used to cancel any pending IO and close the URLLoader\n  /// object. Any pending callbacks will still run, reporting\n  /// <code>PP_ERROR_ABORTED</code> if pending IO was interrupted.  It is NOT\n  /// valid to call Open() again after a call to this function.\n  ///\n  /// <strong>Note:</strong> If the <code>URLLoader</code> object is destroyed\n  /// while it is still open, then it will be implicitly closed so you are not\n  /// required to call Close().\n  void Close();\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_URL_LOADER_H_\n","// Copyright (c) 2011 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_CORE_H_\n#define PPAPI_CPP_CORE_H_\n\n#include \"ppapi/c/ppb_core.h\"\n\n/// @file\n/// This file defines APIs related to memory management, time, and threads.\n\nnamespace pp {\n\nclass CompletionCallback;\nclass Module;\n\n/// APIs related to memory management, time, and threads.\nclass Core {\n public:\n  // Note that we explicitly don't expose Resource& versions of this function\n  // since Resource will normally manage the refcount properly. These should\n  // be called only when doing manual management on raw PP_Resource handles,\n  // which should be fairly rare.\n\n  /// AddRefResource() increments the reference count for the provided\n  /// <code>resource</code>.\n  ///\n  /// @param[in] resource A <code>PP_Resource</code> corresponding to a\n  /// resource.\n  void AddRefResource(PP_Resource resource) {\n    interface_->AddRefResource(resource);\n  }\n\n  /// ReleaseResource() decrements the reference count for the provided\n  /// <code>resource</code>. The resource will be deallocated if the\n  /// reference count reaches zero.\n  ///\n  /// @param[in] resource A <code>PP_Resource</code> corresponding to a\n  /// resource.\n  void ReleaseResource(PP_Resource resource) {\n    interface_->ReleaseResource(resource);\n  }\n\n  /// GetTime() returns the \"wall clock time\" according to the\n  /// browser.\n  ///\n  /// @return A <code>PP_Time</code> containing the \"wall clock time\" according\n  /// to the browser.\n  PP_Time GetTime() {\n    return interface_->GetTime();\n  }\n\n  /// GetTimeTicks() returns the \"tick time\" according to the browser.\n  /// This clock is used by the browser when passing some event times to the\n  /// module (for example, using the\n  /// <code>PP_InputEvent::time_stamp_seconds</code> field). It is not\n  /// correlated to any actual wall clock time (like GetTime()). Because\n  /// of this, it will not change if the user changes their computer clock.\n  ///\n  /// @return A <code>PP_TimeTicks</code> containing the \"tick time\" according\n  /// to the browser.\n  PP_TimeTicks GetTimeTicks() {\n    return interface_->GetTimeTicks();\n  }\n\n  /// CallOnMainThread() schedules work to be executed on the main pepper\n  /// thread after the specified delay. The delay may be 0 to specify a call\n  /// back as soon as possible.\n  ///\n  /// The |result| parameter will just be passed as the second argument to the\n  /// callback. Many applications won't need this, but it allows a module to\n  /// emulate calls of some callbacks which do use this value.\n  ///\n  /// <strong>Note:</strong> CallOnMainThread(), even when used from the main\n  /// thread with a delay of 0 milliseconds, will never directly invoke the\n  /// callback.  Even in this case, the callback will be scheduled\n  /// asynchronously.\n  ///\n  /// <strong>Note:</strong> If the browser is shutting down or if the module\n  /// has no instances, then the callback function may not be called.\n  ///\n  /// @param[in] delay_in_milliseconds An int32_t delay in milliseconds.\n  /// @param[in] callback A <code>CompletionCallback</code> callback function\n  /// that the browser will call after the specified delay.\n  /// @param[in] result An int32_t that the browser will pass to the given\n  /// <code>CompletionCallback</code>.\n  void CallOnMainThread(int32_t delay_in_milliseconds,\n                        const CompletionCallback& callback,\n                        int32_t result = 0);\n\n\n  /// IsMainThread() returns true if the current thread is the main pepper\n  /// thread.\n  ///\n  /// This function is useful for implementing sanity checks, and deciding if\n  /// dispatching using CallOnMainThread() is required.\n  ///\n  /// @return true if the current thread is the main pepper thread, otherwise\n  /// false.\n  bool IsMainThread();\n\n private:\n  // Allow Module to construct.\n  friend class Module;\n\n  // Only module should make this class so this constructor is private.\n  Core(const PPB_Core* inter) : interface_(inter) {}\n\n  // Copy and assignment are disallowed.\n  Core(const Core& other);\n  Core& operator=(const Core& other);\n\n  const PPB_Core* interface_;\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_CORE_H_\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n// When used in conjunction with module_embedder.h, this gives a default\n// implementation of ppp.h for clients of the ppapi C++ interface.  Most\n// plugin implementors can export their derivation of Module by just\n// linking to this implementation.\n\n#include \"ppapi/c/ppb.h\"\n#include \"ppapi/c/ppp.h\"\n#include \"ppapi/c/pp_errors.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/module_embedder.h\"\n\nstatic pp::Module* g_module_singleton = NULL;\nstatic PP_GetInterface_Func g_broker_get_interface = NULL;\n\nnamespace pp {\n\n// Give a default implementation of Module::Get().  See module.cc for details.\npp::Module* Module::Get() {\n  return g_module_singleton;\n}\n\nvoid SetBrokerGetInterfaceFunc(PP_GetInterface_Func broker_get_interface) {\n  g_broker_get_interface = broker_get_interface;\n}\n\n}  // namespace pp\n\n// Global PPP functions --------------------------------------------------------\n\nPP_EXPORT int32_t PPP_InitializeModule(PP_Module module_id,\n                                       PPB_GetInterface get_browser_interface) {\n  pp::Module* module = pp::CreateModule();\n  if (!module)\n    return PP_ERROR_FAILED;\n\n  if (!module->InternalInit(module_id, get_browser_interface)) {\n    delete module;\n    return PP_ERROR_FAILED;\n  }\n  g_module_singleton = module;\n  return PP_OK;\n}\n\nPP_EXPORT void PPP_ShutdownModule() {\n  delete g_module_singleton;\n  g_module_singleton = NULL;\n}\n\nPP_EXPORT const void* PPP_GetInterface(const char* interface_name) {\n  if (g_module_singleton)\n    return g_module_singleton->GetPluginInterface(interface_name);\n  if (g_broker_get_interface)\n    return g_broker_get_interface(interface_name);\n  return NULL;\n}\n","// Copyright (c) 2010 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/resource.h\"\n\n#include <algorithm>\n\n#include \"ppapi/cpp/logging.h\"\n#include \"ppapi/cpp/module.h\"\n\nnamespace pp {\n\nResource::Resource() : pp_resource_(0) {\n}\n\nResource::Resource(const Resource& other) : pp_resource_(other.pp_resource_) {\n  if (!is_null())\n    Module::Get()->core()->AddRefResource(pp_resource_);\n}\n\nResource::~Resource() {\n  if (!is_null())\n    Module::Get()->core()->ReleaseResource(pp_resource_);\n}\n\nResource& Resource::operator=(const Resource& other) {\n  if (!other.is_null())\n    Module::Get()->core()->AddRefResource(other.pp_resource_);\n  if (!is_null())\n    Module::Get()->core()->ReleaseResource(pp_resource_);\n  pp_resource_ = other.pp_resource_;\n  return *this;\n}\n\nPP_Resource Resource::detach() {\n  PP_Resource ret = pp_resource_;\n  pp_resource_ = 0;\n  return ret;\n}\n\nResource::Resource(PP_Resource resource) : pp_resource_(resource) {\n  if (!is_null())\n    Module::Get()->core()->AddRefResource(pp_resource_);\n}\n\nResource::Resource(PassRef, PP_Resource resource) : pp_resource_(resource) {\n}\n\nvoid Resource::PassRefFromConstructor(PP_Resource resource) {\n  PP_DCHECK(!pp_resource_);\n  pp_resource_ = resource;\n}\n\nvoid Resource::Clear() {\n  if (is_null())\n    return;\n  Module::Get()->core()->ReleaseResource(pp_resource_);\n  pp_resource_ = 0;\n}\n\n}  // namespace pp\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#ifndef PPAPI_CPP_MODULE_H_\n#define PPAPI_CPP_MODULE_H_\n\n#include <map>\n#include <string>\n\n#include \"ppapi/c/pp_instance.h\"\n#include \"ppapi/c/pp_module.h\"\n#include \"ppapi/c/pp_stdint.h\"\n#include \"ppapi/c/ppb.h\"\n#include \"ppapi/c/ppb_core.h\"\n#include \"ppapi/cpp/core.h\"\n\n\n/// @file\n/// This file defines a Module class.\nnamespace pp {\n\nclass Instance;\n\n/// The Module class.  The browser calls CreateInstance() to create\n/// an instance of your module on the web page.  The browser creates a new\n/// instance for each <code>\\<embed></code> tag with\n/// <code>type=\"application/x-nacl\"</code>\nclass Module {\n public:\n  typedef std::map<PP_Instance, Instance*> InstanceMap;\n\n  // You may not call any other PP functions from the constructor, put them\n  // in Init instead. Various things will not be set up until the constructor\n  // completes.\n  Module();\n  virtual ~Module();\n\n  /// Get() returns the global instance of this module object, or NULL if the\n  /// module is not initialized yet.\n  ///\n  /// @return The global instance of the module object.\n  static Module* Get();\n\n  /// Init() is automatically called after the object is created. This is where\n  /// you can put functions that rely on other parts of the API, now that the\n  /// module has been created.\n  ///\n  /// @return true if successful, otherwise false.\n  virtual bool Init();\n\n  /// The pp_module() function returns the internal module handle.\n  ///\n  /// @return A <code>PP_Module</code> internal module handle.\n  PP_Module pp_module() const { return pp_module_; }\n\n  /// The get_browser_interface() function returns the internal\n  /// <code>get_browser_interface</code> pointer.\n  ///\n  /// @return A <code>PPB_GetInterface</code> internal pointer.\n  // TODO(sehr): This should be removed once the NaCl browser plugin no longer\n  // needs it.\n  PPB_GetInterface get_browser_interface() const {\n    return get_browser_interface_;\n  }\n\n  /// The core() function returns the core interface for doing basic\n  /// global operations. The return value is guaranteed to be non-NULL once the\n  /// module has successfully initialized and during the Init() call.\n  ///\n  /// It will be NULL before Init() has been called.\n  ///\n  /// @return The core interface for doing basic global operations.\n  Core* core() { return core_; }\n\n  /// GetPluginInterface() implements <code>GetInterface</code> for the browser\n  /// to get module interfaces. If you need to provide your own implementations\n  /// of new interfaces, use AddPluginInterface() which this function will use.\n  ///\n  /// @param[in] interface_name The module interface for the browser to get.\n  const void* GetPluginInterface(const char* interface_name);\n\n  /// GetBrowserInterface() returns interfaces which the browser implements\n  /// (i.e. PPB interfaces).\n  /// @param[in] interface_name The browser interface for the module to get.\n  const void* GetBrowserInterface(const char* interface_name);\n\n  /// InstanceForPPInstance() returns the object associated with this\n  /// <code>PP_Instance</code>, or NULL if one is not found. This should only\n  /// be called from the main thread! This instance object may be destroyed at\n  /// any time on the main thread, so using it on other threads may cause a\n  /// crash.\n  ///\n  /// @param[in] instance This <code>PP_Instance</code>.\n  ///\n  /// @return The object associated with this <code>PP_Instance</code>,\n  /// or NULL if one is not found.\n  Instance* InstanceForPPInstance(PP_Instance instance);\n\n  /// AddPluginInterface() adds a handler for a provided interface name. When\n  /// the browser requests that interface name, the provided\n  /// <code>vtable</code> will be returned.\n  ///\n  /// In general, modules will not need to call this directly. Instead, the\n  /// C++ wrappers for each interface will register themselves with this\n  /// function.\n  ///\n  /// This function may be called more than once with the same interface name\n  /// and vtable with no effect. However, it may not be used to register a\n  /// different vtable for an already-registered interface. It will assert for\n  /// a different registration for an already-registered interface in debug\n  /// mode, and just ignore the registration in release mode.\n  ///\n  /// @param[in] interface_name The interface name that will receive a handler.\n  /// @param[in,out] vtable The vtable to return for\n  /// <code>interface_name</code>.\n  void AddPluginInterface(const std::string& interface_name,\n                          const void* vtable);\n\n  // InternalInit() sets the browser interface and calls the regular Init()\n  /// function that can be overridden by the base classes.\n  ///\n  /// @param[in] mod A <code>PP_Module</code>.\n  /// @param[in] get_browser_interface The browser interface to set.\n  ///\n  /// @return true if successful, otherwise false.\n  // TODO(brettw) make this private when I can figure out how to make the\n  // initialize function a friend.\n  bool InternalInit(PP_Module mod,\n                    PPB_GetInterface get_browser_interface);\n\n  /// The current_instances() function allows iteration over the\n  /// current instances in the module.\n  ///\n  /// @return An <code>InstanceMap</code> of all instances in the module.\n  const InstanceMap& current_instances() const { return current_instances_; }\n\n protected:\n  /// CreateInstance() should be overridden to create your own module type.\n  ///\n  /// @param[in] instance A <code>PP_Instance</code>.\n  ///\n  /// @return The resulting instance.\n  virtual Instance* CreateInstance(PP_Instance instance) = 0;\n\n private:\n  friend PP_Bool Instance_DidCreate(PP_Instance pp_instance,\n                                    uint32_t argc,\n                                    const char* argn[],\n                                    const char* argv[]);\n  friend void Instance_DidDestroy(PP_Instance instance);\n\n  // Unimplemented (disallow copy and assign).\n  Module(const Module&);\n  Module& operator=(const Module&);\n\n  // Instance tracking.\n  InstanceMap current_instances_;\n\n  PP_Module pp_module_;\n  PPB_GetInterface get_browser_interface_;\n\n  Core* core_;\n\n  // All additional interfaces this plugin can handle as registered by\n  // AddPluginInterface.\n  typedef std::map<std::string, const void*> InterfaceMap;\n  InterfaceMap additional_interfaces_;\n};\n\n}  // namespace pp\n\n#endif  // PPAPI_CPP_MODULE_H_\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/url_loader.h\"\n\n#include \"ppapi/c/ppb_url_loader.h\"\n#include \"ppapi/c/pp_errors.h\"\n#include \"ppapi/cpp/completion_callback.h\"\n#include \"ppapi/cpp/file_ref.h\"\n#include \"ppapi/cpp/instance_handle.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/module_impl.h\"\n#include \"ppapi/cpp/url_request_info.h\"\n#include \"ppapi/cpp/url_response_info.h\"\n\nnamespace pp {\n\nnamespace {\n\ntemplate <> const char* interface_name<PPB_URLLoader_1_0>() {\n  return PPB_URLLOADER_INTERFACE_1_0;\n}\n\n}  // namespace\n\nURLLoader::URLLoader(PP_Resource resource) : Resource(resource) {\n}\n\nURLLoader::URLLoader(const InstanceHandle& instance) {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return;\n  PassRefFromConstructor(get_interface<PPB_URLLoader_1_0>()->Create(\n      instance.pp_instance()));\n}\n\nURLLoader::URLLoader(const URLLoader& other) : Resource(other) {\n}\n\nint32_t URLLoader::Open(const URLRequestInfo& request_info,\n                        const CompletionCallback& cc) {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return cc.MayForce(PP_ERROR_NOINTERFACE);\n  return get_interface<PPB_URLLoader_1_0>()->Open(pp_resource(),\n                                              request_info.pp_resource(),\n                                              cc.pp_completion_callback());\n}\n\nint32_t URLLoader::FollowRedirect(const CompletionCallback& cc) {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return cc.MayForce(PP_ERROR_NOINTERFACE);\n  return get_interface<PPB_URLLoader_1_0>()->FollowRedirect(\n      pp_resource(), cc.pp_completion_callback());\n}\n\nbool URLLoader::GetUploadProgress(int64_t* bytes_sent,\n                                  int64_t* total_bytes_to_be_sent) const {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return false;\n  return PP_ToBool(get_interface<PPB_URLLoader_1_0>()->GetUploadProgress(\n      pp_resource(), bytes_sent, total_bytes_to_be_sent));\n}\n\nbool URLLoader::GetDownloadProgress(\n    int64_t* bytes_received,\n    int64_t* total_bytes_to_be_received) const {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return false;\n  return PP_ToBool(get_interface<PPB_URLLoader_1_0>()->GetDownloadProgress(\n      pp_resource(), bytes_received, total_bytes_to_be_received));\n}\n\nURLResponseInfo URLLoader::GetResponseInfo() const {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return URLResponseInfo();\n  return URLResponseInfo(PASS_REF,\n                         get_interface<PPB_URLLoader_1_0>()->GetResponseInfo(\n                             pp_resource()));\n}\n\nint32_t URLLoader::ReadResponseBody(void* buffer,\n                                    int32_t bytes_to_read,\n                                    const CompletionCallback& cc) {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return cc.MayForce(PP_ERROR_NOINTERFACE);\n  return get_interface<PPB_URLLoader_1_0>()->ReadResponseBody(\n      pp_resource(), buffer, bytes_to_read, cc.pp_completion_callback());\n}\n\nint32_t URLLoader::FinishStreamingToFile(const CompletionCallback& cc) {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return cc.MayForce(PP_ERROR_NOINTERFACE);\n  return get_interface<PPB_URLLoader_1_0>()->FinishStreamingToFile(\n      pp_resource(), cc.pp_completion_callback());\n}\n\nvoid URLLoader::Close() {\n  if (!has_interface<PPB_URLLoader_1_0>())\n    return;\n  get_interface<PPB_URLLoader_1_0>()->Close(pp_resource());\n}\n\n}  // namespace pp\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/var.h\"\n\n#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\n\n#include \"ppapi/c/pp_var.h\"\n#include \"ppapi/c/ppb_var.h\"\n#include \"ppapi/cpp/instance.h\"\n#include \"ppapi/cpp/logging.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/module_impl.h\"\n\n// Define equivalent to snprintf on Windows.\n#if defined(_MSC_VER)\n#  define snprintf sprintf_s\n#endif\n\nnamespace pp {\n\nnamespace {\n\ntemplate <> const char* interface_name<PPB_Var_1_2>() {\n  return PPB_VAR_INTERFACE_1_2;\n}\ntemplate <> const char* interface_name<PPB_Var_1_1>() {\n  return PPB_VAR_INTERFACE_1_1;\n}\ntemplate <> const char* interface_name<PPB_Var_1_0>() {\n  return PPB_VAR_INTERFACE_1_0;\n}\n\n// Technically you can call AddRef and Release on any Var, but it may involve\n// cross-process calls depending on the plugin. This is an optimization so we\n// only do refcounting on the necessary objects.\ninline bool NeedsRefcounting(const PP_Var& var) {\n  return var.type > PP_VARTYPE_DOUBLE;\n}\n\n// This helper function uses the latest available version of VarFromUtf8. Note\n// that version 1.0 of this method has a different API to later versions.\nPP_Var VarFromUtf8Helper(const char* utf8_str, uint32_t len) {\n  if (has_interface<PPB_Var_1_2>()) {\n    return get_interface<PPB_Var_1_2>()->VarFromUtf8(utf8_str, len);\n  } else if (has_interface<PPB_Var_1_1>()) {\n    return get_interface<PPB_Var_1_1>()->VarFromUtf8(utf8_str, len);\n  } else if (has_interface<PPB_Var_1_0>()) {\n    return get_interface<PPB_Var_1_0>()->VarFromUtf8(Module::Get()->pp_module(),\n                                                     utf8_str,\n                                                     len);\n  }\n  return PP_MakeNull();\n}\n\n// This helper function uses the latest available version of AddRef.\n// Returns true on success, false if no appropriate interface was available.\nbool AddRefHelper(const PP_Var& var) {\n  if (has_interface<PPB_Var_1_2>()) {\n    get_interface<PPB_Var_1_2>()->AddRef(var);\n    return true;\n  } else if (has_interface<PPB_Var_1_1>()) {\n    get_interface<PPB_Var_1_1>()->AddRef(var);\n    return true;\n  } else if (has_interface<PPB_Var_1_0>()) {\n    get_interface<PPB_Var_1_0>()->AddRef(var);\n    return true;\n  }\n  return false;\n}\n\n// This helper function uses the latest available version of Release.\n// Returns true on success, false if no appropriate interface was available.\nbool ReleaseHelper(const PP_Var& var) {\n  if (has_interface<PPB_Var_1_2>()) {\n    get_interface<PPB_Var_1_2>()->Release(var);\n    return true;\n  } else if (has_interface<PPB_Var_1_1>()) {\n    get_interface<PPB_Var_1_1>()->Release(var);\n    return true;\n  } else if (has_interface<PPB_Var_1_0>()) {\n    get_interface<PPB_Var_1_0>()->Release(var);\n    return true;\n  }\n  return false;\n}\n\n}  // namespace\n\nVar::Var() {\n  memset(&var_, 0, sizeof(var_));\n  var_.type = PP_VARTYPE_UNDEFINED;\n  is_managed_ = true;\n}\n\nVar::Var(Null) {\n  memset(&var_, 0, sizeof(var_));\n  var_.type = PP_VARTYPE_NULL;\n  is_managed_ = true;\n}\n\nVar::Var(bool b) {\n  var_.type = PP_VARTYPE_BOOL;\n  var_.padding = 0;\n  var_.value.as_bool = PP_FromBool(b);\n  is_managed_ = true;\n}\n\nVar::Var(int32_t i) {\n  var_.type = PP_VARTYPE_INT32;\n  var_.padding = 0;\n  var_.value.as_int = i;\n  is_managed_ = true;\n}\n\nVar::Var(double d) {\n  var_.type = PP_VARTYPE_DOUBLE;\n  var_.padding = 0;\n  var_.value.as_double = d;\n  is_managed_ = true;\n}\n\nVar::Var(const char* utf8_str) {\n  uint32_t len = utf8_str ? static_cast<uint32_t>(strlen(utf8_str)) : 0;\n  var_ = VarFromUtf8Helper(utf8_str, len);\n  is_managed_ = true;\n}\n\nVar::Var(const std::string& utf8_str) {\n  var_ = VarFromUtf8Helper(utf8_str.c_str(),\n                           static_cast<uint32_t>(utf8_str.size()));\n  is_managed_ = true;\n}\n\nVar::Var(const pp::Resource& resource) {\n  if (has_interface<PPB_Var_1_2>()) {\n    var_ = get_interface<PPB_Var_1_2>()->VarFromResource(\n        resource.pp_resource());\n  } else {\n    PP_NOTREACHED();\n    return;\n  }\n  // Set |is_managed_| to true, so |var_| will be properly released upon\n  // destruction.\n  is_managed_ = true;\n}\n\n\nVar::Var(const PP_Var& var) {\n  var_ = var;\n  is_managed_ = true;\n  if (NeedsRefcounting(var_)) {\n    if (!AddRefHelper(var_))\n      var_.type = PP_VARTYPE_NULL;\n  }\n}\n\nVar::Var(const Var& other) {\n  var_ = other.var_;\n  is_managed_ = true;\n  if (NeedsRefcounting(var_)) {\n    if (!AddRefHelper(var_))\n      var_.type = PP_VARTYPE_NULL;\n  }\n}\n\nVar::~Var() {\n  if (NeedsRefcounting(var_) && is_managed_)\n    ReleaseHelper(var_);\n}\n\nVar& Var::operator=(const Var& other) {\n  // Early return for self-assignment. Note however, that two distinct vars\n  // can refer to the same object, so we still need to be careful about the\n  // refcounting below.\n  if (this == &other)\n    return *this;\n\n  // Be careful to keep the ref alive for cases where we're assigning an\n  // object to itself by addrefing the new one before releasing the old one.\n  bool old_is_managed = is_managed_;\n  is_managed_ = true;\n  if (NeedsRefcounting(other.var_)) {\n    AddRefHelper(other.var_);\n  }\n  if (NeedsRefcounting(var_) && old_is_managed)\n    ReleaseHelper(var_);\n\n  var_ = other.var_;\n  return *this;\n}\n\nbool Var::operator==(const Var& other) const {\n  if (var_.type != other.var_.type)\n    return false;\n  switch (var_.type) {\n    case PP_VARTYPE_UNDEFINED:\n    case PP_VARTYPE_NULL:\n      return true;\n    case PP_VARTYPE_BOOL:\n      return AsBool() == other.AsBool();\n    case PP_VARTYPE_INT32:\n      return AsInt() == other.AsInt();\n    case PP_VARTYPE_DOUBLE:\n      return AsDouble() == other.AsDouble();\n    case PP_VARTYPE_STRING:\n      if (var_.value.as_id == other.var_.value.as_id)\n        return true;\n      return AsString() == other.AsString();\n    case PP_VARTYPE_OBJECT:\n    case PP_VARTYPE_ARRAY:\n    case PP_VARTYPE_ARRAY_BUFFER:\n    case PP_VARTYPE_DICTIONARY:\n    case PP_VARTYPE_RESOURCE:\n    default:  // Objects, arrays, dictionaries, resources.\n      return var_.value.as_id == other.var_.value.as_id;\n  }\n}\n\nbool Var::AsBool() const {\n  if (!is_bool()) {\n    PP_NOTREACHED();\n    return false;\n  }\n  return PP_ToBool(var_.value.as_bool);\n}\n\nint32_t Var::AsInt() const {\n  if (is_int())\n    return var_.value.as_int;\n  if (is_double())\n    return static_cast<int>(var_.value.as_double);\n  PP_NOTREACHED();\n  return 0;\n}\n\ndouble Var::AsDouble() const {\n  if (is_double())\n    return var_.value.as_double;\n  if (is_int())\n    return static_cast<double>(var_.value.as_int);\n  PP_NOTREACHED();\n  return 0.0;\n}\n\nstd::string Var::AsString() const {\n  if (!is_string()) {\n    PP_NOTREACHED();\n    return std::string();\n  }\n\n  uint32_t len;\n  const char* str;\n  if (has_interface<PPB_Var_1_2>())\n    str = get_interface<PPB_Var_1_2>()->VarToUtf8(var_, &len);\n  else if (has_interface<PPB_Var_1_1>())\n    str = get_interface<PPB_Var_1_1>()->VarToUtf8(var_, &len);\n  else if (has_interface<PPB_Var_1_0>())\n    str = get_interface<PPB_Var_1_0>()->VarToUtf8(var_, &len);\n  else\n    return std::string();\n  return std::string(str, len);\n}\n\npp::Resource Var::AsResource() const {\n  if (!is_resource()) {\n    PP_NOTREACHED();\n    return pp::Resource();\n  }\n\n  if (has_interface<PPB_Var_1_2>()) {\n    return pp::Resource(pp::PASS_REF,\n                        get_interface<PPB_Var_1_2>()->VarToResource(var_));\n  } else {\n    return pp::Resource();\n  }\n}\n\nstd::string Var::DebugString() const {\n  char buf[256];\n  if (is_undefined()) {\n    snprintf(buf, sizeof(buf), \"Var(UNDEFINED)\");\n  } else if (is_null()) {\n    snprintf(buf, sizeof(buf), \"Var(NULL)\");\n  } else if (is_bool()) {\n    snprintf(buf, sizeof(buf), AsBool() ? \"Var(true)\" : \"Var(false)\");\n  } else if (is_int()) {\n    snprintf(buf, sizeof(buf), \"Var(%d)\", static_cast<int>(AsInt()));\n  } else if (is_double()) {\n    snprintf(buf, sizeof(buf), \"Var(%f)\", AsDouble());\n  } else if (is_string()) {\n    char format[] = \"Var<'%s'>\";\n    size_t decoration = sizeof(format) - 2;  // The %s is removed.\n    size_t available = sizeof(buf) - decoration;\n    std::string str = AsString();\n    if (str.length() > available) {\n      str.resize(available - 3);  // Reserve space for ellipsis.\n      str.append(\"...\");\n    }\n    snprintf(buf, sizeof(buf), format, str.c_str());\n  } else if (is_object()) {\n    snprintf(buf, sizeof(buf), \"Var(OBJECT)\");\n  } else if (is_array()) {\n    snprintf(buf, sizeof(buf), \"Var(ARRAY)\");\n  } else if (is_dictionary()) {\n    snprintf(buf, sizeof(buf), \"Var(DICTIONARY)\");\n  } else if (is_array_buffer()) {\n    snprintf(buf, sizeof(buf), \"Var(ARRAY_BUFFER)\");\n  } else if (is_resource()) {\n    snprintf(buf, sizeof(buf), \"Var(RESOURCE)\");\n  } else {\n    buf[0] = '\\0';\n  }\n  return buf;\n}\n\n}  // namespace pp\n","/* Copyright (c) 2012 The Chromium Authors. All rights reserved.\n * Use of this source code is governed by a BSD-style license that can be\n * found in the LICENSE file.\n */\n\n/* From pp_var.idl modified Thu Sep 12 16:41:36 2013. */\n\n#ifndef PPAPI_C_PP_VAR_H_\n#define PPAPI_C_PP_VAR_H_\n\n#include \"ppapi/c/pp_bool.h\"\n#include \"ppapi/c/pp_macros.h\"\n#include \"ppapi/c/pp_stdint.h\"\n\n/**\n * @file\n * This file defines the API for handling the passing of data types between\n * your module and the page.\n */\n\n\n/**\n * @addtogroup Enums\n * @{\n */\n/**\n * The <code>PP_VarType</code> is an enumeration of the different types that\n * can be contained within a <code>PP_Var</code> structure.\n */\ntypedef enum {\n  /**\n   * An undefined value.\n   */\n  PP_VARTYPE_UNDEFINED = 0,\n  /**\n   * A NULL value. This is similar to undefined, but JavaScript differentiates\n   * the two so it is exposed here as well.\n   */\n  PP_VARTYPE_NULL = 1,\n  /**\n   * A boolean value, use the <code>as_bool</code> member of the var.\n   */\n  PP_VARTYPE_BOOL = 2,\n  /**\n   * A 32-bit integer value. Use the <code>as_int</code> member of the var.\n   */\n  PP_VARTYPE_INT32 = 3,\n  /**\n   * A double-precision floating point value. Use the <code>as_double</code>\n   * member of the var.\n   */\n  PP_VARTYPE_DOUBLE = 4,\n  /**\n   * The Var represents a string. The <code>as_id</code> field is used to\n   * identify the string, which may be created and retrieved from the\n   * <code>PPB_Var</code> interface. These objects are reference counted, so\n   * AddRef and Release must be used properly to avoid memory leaks.\n   */\n  PP_VARTYPE_STRING = 5,\n  /**\n   * Represents a JavaScript object. This vartype is not currently usable\n   * from modules, although it is used internally for some tasks. These objects\n   * are reference counted, so AddRef and Release must be used properly to avoid\n   * memory leaks.\n   */\n  PP_VARTYPE_OBJECT = 6,\n  /**\n   * Represents an array of Vars. The <code>as_id</code> field is used to\n   * identify the array, which may be created and manipulated from the\n   * <code>PPB_VarArray</code> interface. These objects are reference counted,\n   * so AddRef and Release must be used properly to avoid memory leaks.\n   */\n  PP_VARTYPE_ARRAY = 7,\n  /**\n   * Represents a mapping from strings to Vars. The <code>as_id</code> field is\n   * used to identify the dictionary, which may be created and manipulated from\n   * the <code>PPB_VarDictionary</code> interface. These objects are reference\n   * counted, so AddRef and Release must be used properly to avoid memory leaks.\n   */\n  PP_VARTYPE_DICTIONARY = 8,\n  /**\n   * ArrayBuffer represents a JavaScript ArrayBuffer. This is the type which\n   * represents Typed Arrays in JavaScript. Unlike JavaScript 'Array', it is\n   * only meant to contain basic numeric types, and is always stored\n   * contiguously. See PPB_VarArrayBuffer_Dev for functions special to\n   * ArrayBuffer vars. These objects are reference counted, so AddRef and\n   * Release must be used properly to avoid memory leaks.\n   */\n  PP_VARTYPE_ARRAY_BUFFER = 9,\n  /**\n   * Resources are not currently supported but will be added in the future\n   * These objects are reference counted, so AddRef and Release must be used\n   * properly to avoid memory leaks.\n   */\n  PP_VARTYPE_RESOURCE = 10\n} PP_VarType;\nPP_COMPILE_ASSERT_SIZE_IN_BYTES(PP_VarType, 4);\n/**\n * @}\n */\n\n/**\n * @addtogroup Structs\n * @{\n */\n/**\n * The PP_VarValue union stores the data for any one of the types listed\n * in the PP_VarType enum.\n */\nunion PP_VarValue {\n  /**\n   * If <code>type</code> is <code>PP_VARTYPE_BOOL</code>,\n   * <code>as_bool</code> represents the value of this <code>PP_Var</code> as\n   * <code>PP_Bool</code>.\n   */\n  PP_Bool as_bool;\n  /**\n   * If <code>type</code> is <code>PP_VARTYPE_INT32</code>,\n   * <code>as_int</code> represents the value of this <code>PP_Var</code> as\n   * <code>int32_t</code>.\n   */\n  int32_t as_int;\n  /**\n   * If <code>type</code> is <code>PP_VARTYPE_DOUBLE</code>,\n   * <code>as_double</code> represents the value of this <code>PP_Var</code>\n   * as <code>double</code>.\n   */\n  double as_double;\n  /**\n   * If <code>type</code> is <code>PP_VARTYPE_STRING</code>,\n   * <code>PP_VARTYPE_OBJECT</code>, <code>PP_VARTYPE_ARRAY</code>,\n   * <code>PP_VARTYPE_DICTIONARY</code>, <code>PP_VARTYPE_ARRAY_BUFFER</code>,\n   * or <code>PP_VARTYPE_RESOURCE</code>, <code>as_id</code> represents the\n   * value of this <code>PP_Var</code> as an opaque handle assigned by the\n   * browser. This handle is guaranteed never to be 0, so a module can\n   * initialize this ID to 0 to indicate a \"NULL handle.\"\n   */\n  int64_t as_id;\n};\n\n/**\n * The <code>PP_VAR</code> struct is a variant data type and can contain any\n * value of one of the types named in the <code>PP_VarType</code> enum. This\n * structure is for passing data between native code which can be strongly\n * typed and the browser (JavaScript) which isn't strongly typed.\n *\n * JavaScript has a \"number\" type for holding a number, and does not\n * differentiate between floating point and integer numbers. The\n * JavaScript operations will try to optimize operations by using\n * integers when possible, but could end up with doubles. Therefore,\n * you can't assume a numeric <code>PP_Var</code> will be the type you expect.\n * Your code should be capable of handling either int32_t or double for numeric\n * PP_Vars sent from JavaScript.\n */\nstruct PP_Var {\n  PP_VarType type;\n  /**\n   * The <code>padding</code> ensures <code>value</code> is aligned on an\n   * 8-byte boundary relative to the start of the struct. Some compilers\n   * align doubles on 8-byte boundaries for 32-bit x86, and some align on\n   * 4-byte boundaries.\n   */\n  int32_t padding;\n  /**\n   * This <code>value</code> represents the contents of the PP_Var. Only one of\n   * the fields of <code>value</code> is valid at a time based upon\n   * <code>type</code>.\n   */\n  union PP_VarValue value;\n};\nPP_COMPILE_ASSERT_STRUCT_SIZE_IN_BYTES(PP_Var, 16);\n/**\n * @}\n */\n\n/**\n * @addtogroup Functions\n * @{\n */\n\n/**\n * PP_MakeUndefined() is used to wrap an undefined value into a\n * <code>PP_Var</code> struct for passing to the browser.\n *\n * @return A <code>PP_Var</code> structure.\n */\nPP_INLINE struct PP_Var PP_MakeUndefined(void) {\n  struct PP_Var result = { PP_VARTYPE_UNDEFINED, 0, {PP_FALSE} };\n  return result;\n}\n\n/**\n * PP_MakeNull() is used to wrap a null value into a\n * <code>PP_Var</code> struct for passing to the browser.\n *\n * @return A <code>PP_Var</code> structure,\n */\nPP_INLINE struct PP_Var PP_MakeNull(void) {\n  struct PP_Var result = { PP_VARTYPE_NULL, 0, {PP_FALSE} };\n  return result;\n}\n\n/**\n * PP_MakeBool() is used to wrap a boolean value into a\n * <code>PP_Var</code> struct for passing to the browser.\n *\n * @param[in] value A <code>PP_Bool</code> enumeration to\n * wrap.\n *\n * @return A <code>PP_Var</code> structure.\n */\nPP_INLINE struct PP_Var PP_MakeBool(PP_Bool value) {\n  struct PP_Var result = { PP_VARTYPE_BOOL, 0, {PP_FALSE} };\n  result.value.as_bool = value;\n  return result;\n}\n\n/**\n * PP_MakeInt32() is used to wrap a 32 bit integer value\n * into a <code>PP_Var</code> struct for passing to the browser.\n *\n * @param[in] value An int32 to wrap.\n *\n * @return A <code>PP_Var</code> structure.\n */\nPP_INLINE struct PP_Var PP_MakeInt32(int32_t value) {\n  struct PP_Var result = { PP_VARTYPE_INT32, 0, {PP_FALSE} };\n  result.value.as_int = value;\n  return result;\n}\n\n/**\n * PP_MakeDouble() is used to wrap a double value into a\n * <code>PP_Var</code> struct for passing to the browser.\n *\n * @param[in] value A double to wrap.\n *\n * @return A <code>PP_Var</code> structure.\n */\nPP_INLINE struct PP_Var PP_MakeDouble(double value) {\n  struct PP_Var result = { PP_VARTYPE_DOUBLE, 0, {PP_FALSE} };\n  result.value.as_double = value;\n  return result;\n}\n/**\n * @}\n */\n\n#endif  /* PPAPI_C_PP_VAR_H_ */\n\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/view.h\"\n\n#include \"ppapi/c/ppb_view.h\"\n#include \"ppapi/cpp/module_impl.h\"\n\nnamespace pp {\n\nnamespace {\n\ntemplate <> const char* interface_name<PPB_View_1_0>() {\n  return PPB_VIEW_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_View_1_1>() {\n  return PPB_VIEW_INTERFACE_1_1;\n}\n\n}  // namespace\n\nView::View() : Resource() {\n}\n\nView::View(PP_Resource view_resource) : Resource(view_resource) {\n}\n\nRect View::GetRect() const {\n  PP_Rect out;\n  if (has_interface<PPB_View_1_1>()) {\n    if (PP_ToBool(get_interface<PPB_View_1_1>()->GetRect(pp_resource(), &out)))\n      return Rect(out);\n  } else if (has_interface<PPB_View_1_0>()) {\n    if (PP_ToBool(get_interface<PPB_View_1_0>()->GetRect(pp_resource(), &out)))\n      return Rect(out);\n  }\n  return Rect();\n}\n\nbool View::IsFullscreen() const {\n  if (has_interface<PPB_View_1_1>()) {\n    return PP_ToBool(get_interface<PPB_View_1_1>()->IsFullscreen(\n        pp_resource()));\n  } else if (has_interface<PPB_View_1_0>()) {\n    return PP_ToBool(get_interface<PPB_View_1_0>()->IsFullscreen(\n        pp_resource()));\n  }\n  return false;\n}\n\nbool View::IsVisible() const {\n  if (has_interface<PPB_View_1_1>())\n    return PP_ToBool(get_interface<PPB_View_1_1>()->IsVisible(pp_resource()));\n  else if (has_interface<PPB_View_1_0>())\n    return PP_ToBool(get_interface<PPB_View_1_0>()->IsVisible(pp_resource()));\n  return false;\n}\n\nbool View::IsPageVisible() const {\n  if (has_interface<PPB_View_1_1>()) {\n    return PP_ToBool(get_interface<PPB_View_1_1>()->IsPageVisible(\n        pp_resource()));\n  } else if (has_interface<PPB_View_1_0>()) {\n    return PP_ToBool(get_interface<PPB_View_1_0>()->IsPageVisible(\n        pp_resource()));\n  }\n  return true;\n}\n\nRect View::GetClipRect() const {\n  PP_Rect out;\n  if (has_interface<PPB_View_1_1>()) {\n    if (PP_ToBool(get_interface<PPB_View_1_1>()->GetClipRect(pp_resource(),\n                                                             &out)))\n      return Rect(out);\n  } else if (has_interface<PPB_View_1_0>()) {\n    if (PP_ToBool(get_interface<PPB_View_1_0>()->GetClipRect(pp_resource(),\n                                                             &out)))\n      return Rect(out);\n  }\n  return Rect();\n}\n\nfloat View::GetDeviceScale() const {\n  if (has_interface<PPB_View_1_1>())\n    return get_interface<PPB_View_1_1>()->GetDeviceScale(pp_resource());\n  return 1.0f;\n}\n\nfloat View::GetCSSScale() const {\n  if (has_interface<PPB_View_1_1>())\n    return get_interface<PPB_View_1_1>()->GetCSSScale(pp_resource());\n  return 1.0f;\n}\n\n}  // namespace pp\n","// Copyright (c) 2012 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n#include \"ppapi/cpp/input_event.h\"\n\n#include \"ppapi/cpp/instance_handle.h\"\n#include \"ppapi/cpp/module.h\"\n#include \"ppapi/cpp/module_impl.h\"\n#include \"ppapi/cpp/point.h\"\n#include \"ppapi/cpp/touch_point.h\"\n#include \"ppapi/cpp/var.h\"\n\nnamespace pp {\n\nnamespace {\n\ntemplate <> const char* interface_name<PPB_InputEvent_1_0>() {\n  return PPB_INPUT_EVENT_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_KeyboardInputEvent_1_2>() {\n  return PPB_KEYBOARD_INPUT_EVENT_INTERFACE_1_2;\n}\n\ntemplate <> const char* interface_name<PPB_KeyboardInputEvent_1_0>() {\n  return PPB_KEYBOARD_INPUT_EVENT_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_MouseInputEvent_1_1>() {\n  return PPB_MOUSE_INPUT_EVENT_INTERFACE_1_1;\n}\n\ntemplate <> const char* interface_name<PPB_WheelInputEvent_1_0>() {\n  return PPB_WHEEL_INPUT_EVENT_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_TouchInputEvent_1_0>() {\n  return PPB_TOUCH_INPUT_EVENT_INTERFACE_1_0;\n}\n\ntemplate <> const char* interface_name<PPB_IMEInputEvent_1_0>() {\n  return PPB_IME_INPUT_EVENT_INTERFACE_1_0;\n}\n\n}  // namespace\n\n// InputEvent ------------------------------------------------------------------\n\nInputEvent::InputEvent() : Resource() {\n}\n\nInputEvent::InputEvent(PP_Resource input_event_resource) : Resource() {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return;\n  if (get_interface<PPB_InputEvent_1_0>()->IsInputEvent(input_event_resource)) {\n    Module::Get()->core()->AddRefResource(input_event_resource);\n    PassRefFromConstructor(input_event_resource);\n  }\n}\n\nInputEvent::~InputEvent() {\n}\n\nPP_InputEvent_Type InputEvent::GetType() const {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return PP_INPUTEVENT_TYPE_UNDEFINED;\n  return get_interface<PPB_InputEvent_1_0>()->GetType(pp_resource());\n}\n\nPP_TimeTicks InputEvent::GetTimeStamp() const {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return 0.0f;\n  return get_interface<PPB_InputEvent_1_0>()->GetTimeStamp(pp_resource());\n}\n\nuint32_t InputEvent::GetModifiers() const {\n  if (!has_interface<PPB_InputEvent_1_0>())\n    return 0;\n  return get_interface<PPB_InputEvent_1_0>()->GetModifiers(pp_resource());\n}\n\n// MouseInputEvent -------------------------------------------------------------\n\nMouseInputEvent::MouseInputEvent() : InputEvent() {\n}\n\nMouseInputEvent::MouseInputEvent(const InputEvent& event) : InputEvent() {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return;\n  if (get_interface<PPB_MouseInputEvent_1_1>()->IsMouseInputEvent(\n          event.pp_resource())) {\n    Module::Get()->core()->AddRefResource(event.pp_resource());\n    PassRefFromConstructor(event.pp_resource());\n  }\n}\n\nMouseInputEvent::MouseInputEvent(const InstanceHandle& instance,\n                                 PP_InputEvent_Type type,\n                                 PP_TimeTicks time_stamp,\n                                 uint32_t modifiers,\n                                 PP_InputEvent_MouseButton mouse_button,\n                                 const Point& mouse_position,\n                                 int32_t click_count,\n                                 const Point& mouse_movement) {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return;\n  PassRefFromConstructor(get_interface<PPB_MouseInputEvent_1_1>()->Create(\n      instance.pp_instance(), type, time_stamp, modifiers, mouse_button,\n      &mouse_position.pp_point(), click_count, &mouse_movement.pp_point()));\n}\n\nPP_InputEvent_MouseButton MouseInputEvent::GetButton() const {\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return PP_INPUTEVENT_MOUSEBUTTON_NONE;\n  return get_interface<PPB_MouseInputEvent_1_1>()->GetButton(pp_resource());\n}\n\nPoint MouseInputEvent::GetPosition() const {\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return Point();\n  return get_interface<PPB_MouseInputEvent_1_1>()->GetPosition(pp_resource());\n}\n\nint32_t MouseInputEvent::GetClickCount() const {\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return 0;\n  return get_interface<PPB_MouseInputEvent_1_1>()->GetClickCount(pp_resource());\n}\n\nPoint MouseInputEvent::GetMovement() const {\n  if (!has_interface<PPB_MouseInputEvent_1_1>())\n    return Point();\n  return get_interface<PPB_MouseInputEvent_1_1>()->GetMovement(pp_resource());\n}\n\n// WheelInputEvent -------------------------------------------------------------\n\nWheelInputEvent::WheelInputEvent() : InputEvent() {\n}\n\nWheelInputEvent::WheelInputEvent(const InputEvent& event) : InputEvent() {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_WheelInputEvent_1_0>())\n    return;\n  if (get_interface<PPB_WheelInputEvent_1_0>()->IsWheelInputEvent(\n          event.pp_resource())) {\n    Module::Get()->core()->AddRefResource(event.pp_resource());\n    PassRefFromConstructor(event.pp_resource());\n  }\n}\n\nWheelInputEvent::WheelInputEvent(const InstanceHandle& instance,\n                                 PP_TimeTicks time_stamp,\n                                 uint32_t modifiers,\n                                 const FloatPoint& wheel_delta,\n                                 const FloatPoint& wheel_ticks,\n                                 bool scroll_by_page) {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_WheelInputEvent_1_0>())\n    return;\n  PassRefFromConstructor(get_interface<PPB_WheelInputEvent_1_0>()->Create(\n      instance.pp_instance(), time_stamp, modifiers,\n      &wheel_delta.pp_float_point(), &wheel_ticks.pp_float_point(),\n      PP_FromBool(scroll_by_page)));\n}\n\nFloatPoint WheelInputEvent::GetDelta() const {\n  if (!has_interface<PPB_WheelInputEvent_1_0>())\n    return FloatPoint();\n  return get_interface<PPB_WheelInputEvent_1_0>()->GetDelta(pp_resource());\n}\n\nFloatPoint WheelInputEvent::GetTicks() const {\n  if (!has_interface<PPB_WheelInputEvent_1_0>())\n    return FloatPoint();\n  return get_interface<PPB_WheelInputEvent_1_0>()->GetTicks(pp_resource());\n}\n\nbool WheelInputEvent::GetScrollByPage() const {\n  if (!has_interface<PPB_WheelInputEvent_1_0>())\n    return false;\n  return PP_ToBool(\n      get_interface<PPB_WheelInputEvent_1_0>()->GetScrollByPage(pp_resource()));\n}\n\n// KeyboardInputEvent ----------------------------------------------------------\n\nKeyboardInputEvent::KeyboardInputEvent() : InputEvent() {\n}\n\nKeyboardInputEvent::KeyboardInputEvent(const InputEvent& event) : InputEvent() {\n  PP_Bool is_keyboard_event = PP_FALSE;\n\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    is_keyboard_event =\n        get_interface<PPB_KeyboardInputEvent_1_2>()->IsKeyboardInputEvent(\n            event.pp_resource());\n  } else if (has_interface<PPB_KeyboardInputEvent_1_0>()) {\n    is_keyboard_event =\n        get_interface<PPB_KeyboardInputEvent_1_0>()->IsKeyboardInputEvent(\n            event.pp_resource());\n  }\n\n  if (PP_ToBool(is_keyboard_event)) {\n    Module::Get()->core()->AddRefResource(event.pp_resource());\n    PassRefFromConstructor(event.pp_resource());\n  }\n}\n\nKeyboardInputEvent::KeyboardInputEvent(const InstanceHandle& instance,\n                                       PP_InputEvent_Type type,\n                                       PP_TimeTicks time_stamp,\n                                       uint32_t modifiers,\n                                       uint32_t key_code,\n                                       const Var& character_text) {\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    PassRefFromConstructor(get_interface<PPB_KeyboardInputEvent_1_2>()->Create(\n        instance.pp_instance(), type, time_stamp, modifiers, key_code,\n        character_text.pp_var(), Var().pp_var()));\n  } else if (has_interface<PPB_KeyboardInputEvent_1_0>()) {\n    PassRefFromConstructor(get_interface<PPB_KeyboardInputEvent_1_0>()->Create(\n        instance.pp_instance(), type, time_stamp, modifiers, key_code,\n        character_text.pp_var()));\n  }\n}\n\nKeyboardInputEvent::KeyboardInputEvent(const InstanceHandle& instance,\n                                       PP_InputEvent_Type type,\n                                       PP_TimeTicks time_stamp,\n                                       uint32_t modifiers,\n                                       uint32_t key_code,\n                                       const Var& character_text,\n                                       const Var& code) {\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    PassRefFromConstructor(get_interface<PPB_KeyboardInputEvent_1_2>()->Create(\n        instance.pp_instance(), type, time_stamp, modifiers, key_code,\n        character_text.pp_var(), code.pp_var()));\n  } else if (has_interface<PPB_KeyboardInputEvent_1_0>()) {\n    PassRefFromConstructor(get_interface<PPB_KeyboardInputEvent_1_0>()->Create(\n        instance.pp_instance(), type, time_stamp, modifiers, key_code,\n        character_text.pp_var()));\n  }\n}\n\nuint32_t KeyboardInputEvent::GetKeyCode() const {\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    return get_interface<PPB_KeyboardInputEvent_1_2>()->GetKeyCode(\n        pp_resource());\n  } else if (has_interface<PPB_KeyboardInputEvent_1_0>()) {\n    return get_interface<PPB_KeyboardInputEvent_1_0>()->GetKeyCode(\n        pp_resource());\n  }\n  return 0;\n}\n\nVar KeyboardInputEvent::GetCharacterText() const {\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    return Var(PASS_REF,\n               get_interface<PPB_KeyboardInputEvent_1_2>()->GetCharacterText(\n                   pp_resource()));\n  } else if (has_interface<PPB_KeyboardInputEvent_1_0>()) {\n    return Var(PASS_REF,\n               get_interface<PPB_KeyboardInputEvent_1_0>()->GetCharacterText(\n                 pp_resource()));\n  }\n  return Var();\n}\n\nVar KeyboardInputEvent::GetCode() const {\n  if (has_interface<PPB_KeyboardInputEvent_1_2>()) {\n    return Var(PASS_REF,\n               get_interface<PPB_KeyboardInputEvent_1_2>()->GetCode(\n                   pp_resource()));\n  }\n  return Var();\n}\n\n// TouchInputEvent ------------------------------------------------------------\nTouchInputEvent::TouchInputEvent() : InputEvent() {\n}\n\nTouchInputEvent::TouchInputEvent(const InputEvent& event) : InputEvent() {\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return;\n  // Type check the input event before setting it.\n  if (get_interface<PPB_TouchInputEvent_1_0>()->IsTouchInputEvent(\n      event.pp_resource())) {\n    Module::Get()->core()->AddRefResource(event.pp_resource());\n    PassRefFromConstructor(event.pp_resource());\n  }\n}\n\nTouchInputEvent::TouchInputEvent(const InstanceHandle& instance,\n                                 PP_InputEvent_Type type,\n                                 PP_TimeTicks time_stamp,\n                                 uint32_t modifiers) {\n  // Type check the input event before setting it.\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return;\n  PassRefFromConstructor(get_interface<PPB_TouchInputEvent_1_0>()->Create(\n      instance.pp_instance(), type, time_stamp, modifiers));\n}\n\nvoid TouchInputEvent::AddTouchPoint(PP_TouchListType list,\n                                    PP_TouchPoint point) {\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return;\n  get_interface<PPB_TouchInputEvent_1_0>()->AddTouchPoint(pp_resource(), list,\n                                                          &point);\n}\n\nuint32_t TouchInputEvent::GetTouchCount(PP_TouchListType list) const {\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return 0;\n  return get_interface<PPB_TouchInputEvent_1_0>()->GetTouchCount(pp_resource(),\n                                                                 list);\n}\n\nTouchPoint TouchInputEvent::GetTouchById(PP_TouchListType list,\n                                             uint32_t id) const {\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return TouchPoint();\n  return TouchPoint(get_interface<PPB_TouchInputEvent_1_0>()->\n                        GetTouchById(pp_resource(), list, id));\n}\n\nTouchPoint TouchInputEvent::GetTouchByIndex(PP_TouchListType list,\n                                                uint32_t index) const {\n  if (!has_interface<PPB_TouchInputEvent_1_0>())\n    return TouchPoint();\n  return TouchPoint(get_interface<PPB_TouchInputEvent_1_0>()->\n                        GetTouchByIndex(pp_resource(), list, index));\n}\n\n// IMEInputEvent -------------------------------------------------------\n\nIMEInputEvent::IMEInputEvent() : InputEvent() {\n}\n\nIMEInputEvent::IMEInputEvent(const InputEvent& event) : InputEvent() {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    if (get_interface<PPB_IMEInputEvent_1_0>()->IsIMEInputEvent(\n            event.pp_resource())) {\n      Module::Get()->core()->AddRefResource(event.pp_resource());\n      PassRefFromConstructor(event.pp_resource());\n    }\n  }\n}\n\nIMEInputEvent::IMEInputEvent(\n    const InstanceHandle& instance,\n    PP_InputEvent_Type type,\n    PP_TimeTicks time_stamp,\n    const Var& text,\n    const std::vector<uint32_t>& segment_offsets,\n    int32_t target_segment,\n    const std::pair<uint32_t, uint32_t>& selection) : InputEvent() {\n  if (!has_interface<PPB_IMEInputEvent_1_0>())\n    return;\n  uint32_t dummy = 0;\n  PassRefFromConstructor(get_interface<PPB_IMEInputEvent_1_0>()->Create(\n      instance.pp_instance(), type, time_stamp, text.pp_var(),\n      segment_offsets.empty() ? 0 : segment_offsets.size() - 1,\n      segment_offsets.empty() ? &dummy : &segment_offsets[0],\n      target_segment, selection.first, selection.second));\n}\n\n\nVar IMEInputEvent::GetText() const {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    return Var(PASS_REF,\n               get_interface<PPB_IMEInputEvent_1_0>()->GetText(\n                   pp_resource()));\n  }\n  return Var();\n}\n\nuint32_t IMEInputEvent::GetSegmentNumber() const {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    return get_interface<PPB_IMEInputEvent_1_0>()->GetSegmentNumber(\n        pp_resource());\n  }\n  return 0;\n}\n\nuint32_t IMEInputEvent::GetSegmentOffset(uint32_t index) const {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    return get_interface<PPB_IMEInputEvent_1_0>()->GetSegmentOffset(\n        pp_resource(), index);\n  }\n  return 0;\n}\n\nint32_t IMEInputEvent::GetTargetSegment() const {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    return get_interface<PPB_IMEInputEvent_1_0>()->GetTargetSegment(\n        pp_resource());\n  }\n  return 0;\n}\n\nvoid IMEInputEvent::GetSelection(uint32_t* start, uint32_t* end) const {\n  if (has_interface<PPB_IMEInputEvent_1_0>()) {\n    get_interface<PPB_IMEInputEvent_1_0>()->GetSelection(pp_resource(),\n                                                         start,\n                                                         end);\n  }\n}\n\n}  // namespace pp\n","#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"ppapi/c/pp_errors.h\"\n\n#include \"ppapi/c/ppb_var.h\"\n#include \"ppapi/c/ppp.h\"\n#include \"ppapi/c/ppp_input_event.h\"\n#include \"ppapi/c/ppp_instance.h\"\n#include \"ppapi/c/ppp_messaging.h\"\n\nextern \"C\" {\n  const void* GetBrowserInterface(const char* interface_name);\n\n  void DoPostMessage(PP_Instance instance, const PP_Var* var) {\n    const PPP_Messaging* messaging_interface = (const PPP_Messaging*)PPP_GetInterface(PPP_MESSAGING_INTERFACE);\n    if (!messaging_interface) {\n      return;\n    }\n    messaging_interface->HandleMessage(instance, *var);\n    // It appears that the callee own the var, so no need to release it?\n  }\n\n  void DoChangeView(PP_Instance instance, PP_Resource resource) {\n    const PPP_Instance* instance_interface = (const PPP_Instance*)PPP_GetInterface(PPP_INSTANCE_INTERFACE);\n    if (instance_interface == NULL) {\n      printf(\"STUB: Failed to get instance interface.\\n\");\n      return;\n    }\n    instance_interface->DidChangeView(instance, resource);\n  }\n\n  void DoChangeFocus(PP_Instance instance, PP_Bool hasFocus) {\n    const PPP_Instance* instance_interface = (const PPP_Instance*)PPP_GetInterface(PPP_INSTANCE_INTERFACE);\n    if (instance_interface == NULL) {\n      printf(\"STUB: Failed to get instance interface.\\n\");\n      return;\n    }\n    instance_interface->DidChangeFocus(instance, hasFocus);\n  }\n\n  void Shutdown(PP_Instance instance) {\n    // Work around a bug in Emscripten that prevent malloc from being included unless it is referenced from native code.\n    // This appears to be live to the compiler, but instance will never be 0.\n    // TODO(ncbray): fix the bug and remove this hack.\n    if (instance == 0) {\n      free(malloc(1));\n    }\n    const PPP_Instance* instance_interface = (const PPP_Instance*)PPP_GetInterface(PPP_INSTANCE_INTERFACE);\n    if (instance_interface) {\n      instance_interface->DidDestroy(instance);\n    }\n    PPP_ShutdownModule();\n  }\n\n  void NativeCreateInstance(PP_Instance instance, uint32_t argc, const char *argn[], const char *argv[]) {\n    int32_t status = PPP_InitializeModule(1, &GetBrowserInterface);\n    if (status != PP_OK) {\n      printf(\"STUB: Failed to initialize module.\\n\");\n      return;\n    }\n\n    const PPP_Instance* instance_interface = (const PPP_Instance*)PPP_GetInterface(PPP_INSTANCE_INTERFACE);\n    if (instance_interface == NULL) {\n      printf(\"STUB: Failed to get instance interface.\\n\");\n      return;\n    }\n\n    status = instance_interface->DidCreate(instance, argc, argn, argv);\n    if (status != PP_TRUE) {\n      printf(\"STUB: Failed to create instance.\\n\");\n      Shutdown(instance);\n      return;\n    }\n  }\n\n  PP_Bool HandleInputEvent(PP_Instance instance, PP_Resource input_event) {\n    const PPP_InputEvent* event_interface = (const PPP_InputEvent*)PPP_GetInterface(PPP_INPUT_EVENT_INTERFACE);\n    if (event_interface == NULL) {\n      printf(\"STUB: Failed to get input event interface.\\n\");\n      return PP_FALSE;\n    }\n    return event_interface->HandleInputEvent(instance, input_event);\n  }\n\n}\n"]}