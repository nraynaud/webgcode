<!DOCTYPE html >
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>Visual CAM</title>
    <script src="webapp/libs/require.js"></script>
    <script src="webapp/config.js"></script>
    <script>
        requirejs.config({
            baseUrl: 'webapp'
        });
    </script>
    <link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
    <link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
    <link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
    <link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
    <style>

        body, html {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            background: #fafafa;
            color: #444;
        }

        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
        }

        canvas {
            flex: 1;
        }

        .moving {
            cursor: move;
        }
    </style>
    <script>
        require(['jQuery', 'THREE', 'Piecon', 'cnc/cam/3D/toolProfile', 'cnc/cam/3D/modelProjector', 'cnc/cam/3D/minkowskiPass',
                    'libs/threejs/STLLoader', 'libs/threejs/postprocessing/ShaderPass', 'libs/threejs/postprocessing/CopyShader'],
                function ($, THREE, Piecon, toolProfile, ModelStage, MinkowskiPass, STLLoader, ShaderPass, CopyShader) {
                    if (window['Notification'] && Notification.permission === 'default') {
                        Notification.requestPermission(function (permission) {
                            console.log('Notification.permision', permission);
                        });
                    }
                    var $container = $('body');
                    var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: false, preserveDrawingBuffer: true});
                    $container.append(renderer.domElement);
                    var outputWidth = $container.width();
                    var outputHeight = $container.height();
                    renderer.sortObjects = false;
                    renderer.setSize(outputWidth, outputHeight);
                    renderer.setViewport(0, 0, outputWidth, outputHeight);
                    new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                        function draw() {
                            displayGeometry(geometry);
                        }

                        draw();
                    });

                    function displayGeometry(geometry) {
                        var modelStage = new ModelStage();
                        modelStage.setGeometry(geometry);
                        var toolSamples = 30;
                        var sampleRate = 30;
                        var toolradius = toolSamples / sampleRate;
                        var profile = toolProfile.createSphericalTool(toolSamples, modelStage.zRatio, toolradius, 0);
                        var minX = Math.floor(modelStage.modelBbox.min.x * sampleRate);
                        var maxX = Math.ceil(modelStage.modelBbox.max.x * sampleRate);
                        var minY = Math.floor(modelStage.modelBbox.min.y * sampleRate);
                        var maxY = Math.ceil(modelStage.modelBbox.max.y * sampleRate);

                        function setCameraPix(minX, maxX, minY, maxY) {
                            modelStage.setCamera(minX / sampleRate, maxX / sampleRate, minY / sampleRate, maxY / sampleRate);
                        }

                        function setTilePos(x, y) {
                            setCameraPix(minX + x - toolSamples, minX + x + tileSizeX + toolSamples, minY + y - toolSamples, minY + y + tileSizeY + toolSamples);
                        }

                        var globalWidth = maxX - minX;
                        var globalHeight = maxY - minY;
                        var pixelsPerTile = 30000000;
                        var tileArea = pixelsPerTile / (4 * toolSamples * toolSamples);
                        var tileSizeX = Math.ceil(Math.sqrt(tileArea));
                        var tileSizeY = Math.ceil(Math.sqrt(tileArea));
                        console.log(globalWidth, globalHeight, tileSizeX, tileSizeY);
                        console.log('tile area', tileArea);
                        console.log('pixels per tile', toolSamples * toolSamples * 4 * tileSizeX * tileSizeY);
                        console.log('total pixels', toolSamples * toolSamples * 4 * globalWidth * globalHeight);
                        var modelBuffer = new THREE.WebGLRenderTarget(tileSizeX + 2 * toolSamples, tileSizeY + 2 * toolSamples,
                                {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.UnsignedByteType});

                        var minkowskiPass = new MinkowskiPass();
                        minkowskiPass.setParams(profile, new THREE.Vector2(toolSamples / modelBuffer.width, toolSamples / modelBuffer.height));
                        var minkowskiBuffer = new THREE.WebGLRenderTarget(tileSizeX, tileSizeY,
                                {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.UnsignedByteType});

                        var copyPass = new ShaderPass(CopyShader);
                        copyPass.quad.geometry.applyMatrix(new THREE.Matrix4().makeTranslation(1, 1, 0));
                        var matrix = new THREE.Matrix4().makeScale(0.5 * tileSizeX, 0.5 * tileSizeY, 1);
                        copyPass.quad.geometry.applyMatrix(matrix);
                        copyPass.camera.left = 0;
                        copyPass.camera.right = globalWidth;
                        copyPass.camera.bottom = 0;
                        copyPass.camera.top = globalHeight;
                        copyPass.camera.updateProjectionMatrix();
                        copyPass.renderToScreen = true;
                        renderer.autoClear = false;

                        var sequence = [];
                        for (var j = 0; j < globalHeight; j += tileSizeY)
                            for (var i = 0; i < globalWidth; i += tileSizeX)
                                sequence.push([i, j]);
                        var resultBuffer = new Float32Array(globalHeight * globalWidth);
                        var resultTile = new Uint8Array(tileSizeX * tileSizeY * 4);
                        var worker = new Worker('worker.js');
                        var factor = (Math.pow(2, 24.0) - 1.0) / Math.pow(2, 24.0);

                        function decodeFloatRgb(r, g, b) {
                            return  (r / 255 + g / 255 / 255 + b / 255 / 255 / 255 ) / factor;
                        }

                        function copyResultTileToResultBuffer(x, y) {
                            for (var j = 0; j < tileSizeY; j++)
                                for (var i = 0; i < tileSizeX; i++) {
                                    var pixIndex = ((j * tileSizeX + i) * 4);
                                    resultBuffer[(y + j) * globalWidth + i + x] = decodeFloatRgb(resultTile[pixIndex], resultTile[pixIndex + 1], resultTile[pixIndex + 2]);
                                }
                        }

                        //compensate because the model tile has a margin of 1 tool radius around it
                        var terrainRatio = new THREE.Vector2(tileSizeX / modelBuffer.width, tileSizeY / modelBuffer.height);
                        var terrainTranslation = new THREE.Vector2(toolSamples / modelBuffer.width, toolSamples / modelBuffer.height);
                        var percentage = null;

                        function drawTile(sequenceIndex) {
                            if (sequenceIndex < sequence.length) {
                                var newPercentage = Math.round(sequenceIndex / sequence.length * 25) * 4;
                                if (newPercentage != percentage)
                                    Piecon.setProgress(newPercentage);
                                percentage = newPercentage;
                                var x = sequence[sequenceIndex][0];
                                var y = sequence[sequenceIndex][1];
                                setTilePos(x, y);
                                var gl = renderer.getContext();
                                modelStage.render(renderer, modelBuffer);
                                minkowskiPass.render(renderer, minkowskiBuffer, modelBuffer, terrainRatio, terrainTranslation);
                                copyPass.quad.position.x = x;
                                copyPass.quad.position.y = y;
                                copyPass.render(renderer, null, minkowskiBuffer);
                                renderer.setRenderTarget(minkowskiBuffer);
                                gl.readPixels(0, 0, tileSizeX, tileSizeY, gl.RGBA, gl.UNSIGNED_BYTE, resultTile);
                                //by keeping this loop in the main thread, I think we leaving some time for hte GPU to breathe.
                                copyResultTileToResultBuffer(x, y);
                                //setTimeout is not throttled in workers
                                $(worker).one('message', function () {
                                    drawTile(sequenceIndex + 1);
                                });
                                worker.postMessage('ping');
                            } else {
                                console.timeEnd('computation');
                                Piecon.reset();
                                if (window['Notification'] && document['visibilityState'] == 'hidden')
                                    new Notification("Computation is done.", {icon: 'webapp/images/icon_fraise_48.png'})
                            }
                        }

                        Piecon.setOptions({
                            color: '#752D2D', // Pie chart color
                            background: '#A9BBD1', // Empty pie chart color
                            shadow: '#849DBD'
                        });
                        console.time('computation');
                        drawTile(0);
                    }
                });
    </script>
</head>
<body>
<div class="btn-toolbar" role="toolbar">

</div>
</body>

</html>
