<!doctype html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>CNC Text Tool</title>
    <script src="webapp/libs/jquery.min.js"></script>
    <script src="webapp/libs/svg.js"></script>
    <script src="webapp/libs/jquery.mousewheel.js"></script>
    <script src="webapp/libs/opentype.js"></script>
    <script src="webapp/libs/extractedRaphael.js"></script>
    <script src="webapp/libs/require.js"></script>
    <script src="webapp/libs/handlebars-v1.3.0.js"></script>
    <script src="webapp/libs/ember-1.5.0-beta5.pre7.js"></script>
    <script src="webapp/libs/ember-data-1.0.0-beta7.js"></script>

    <script>
        requirejs.config({
            baseUrl: 'webapp'
        });
    </script>

    <link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
    <style>
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        body {
            display: flex;
            display: -webkit-box;
            display: -webkit-flex;
            display: -ms-flexbox;
        }

        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
        }

        #drawing, #code {
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            flex: 1;
            -webkit-flex: 1;
            border: solid;
            padding: 0;
            margin: 0;
        }

        #code {
            flex: 0.5;
        }

        .emberPart {
            align-items: stretch;
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            padding: 0;
            margin: 0;
            flex: 1;
            -webkit-flex: 1;
        }

        .controls {
            flex: 0 0 auto;
            -webkit-flex: 0 0 auto;

            align-items: stretch;
        }

    </style>
</head>
<body>

<script type="text/x-handlebars" data-template-name="text">
    <div class="controls">
        <label for="text">Text:</label><br>
        {{input type="text" id="text" valueBinding="text" title="your text"}}
        <br>
        <label for="toolDiameter" title="in mm">Tool Diameter:</label><br>
        {{view TextApplication.NumberField id="toolDiameter" placeholder="tool diameter"
        numericValueBinding="toolDiameter" min="0" action="launchComputationImmediately"}}
        <br>
        <label for="radialEngagement" title="ratio ]0-1]">Radial Engagement:</label><br>
        {{view TextApplication.NumberField id="radialEngagement" placeholder="radial engagement"
        numericValueBinding="radialEngagementRatio" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
        <br>
        <label for="depth" title="in mm">Depth:</label><br>
        {{view TextApplication.NumberField id="depth" placeholder="depth"
        numericValueBinding="depth" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
        <br>

    </div>
    <div id="drawing">
        {{view TextApplication.OperationView}}
    </div>
    <textarea id="code"></textarea>

</script>

<script>
var drawing = $('#drawing');
require(['cnc/ui/emberTwoDView', 'cnc/cam', 'samples/fontExample.js', 'cnc/text', 'cnc/pocket', 'cnc/ui/views', 'libs/rbrush'], function (emberTwoDView, cam, fontExample, text, pocket, views, rbrush) {
    window.TextApplication = Ember.Application.create({
        customEvents: {
            mousewheel: "mousewheel"
        }
    });
    TextApplication.Router.reopen({
        rootURL: '/webgcode/'
    });
    TextApplication.Router.map(function () {
        this.resource('text', {path: '/'});
    });
    //TODO: find how to inject this into the template scope directly
    TextApplication.NumberField = views.NumberField;

    function toggleClass(svgElement, className, toggle) {
        var classAttr = svgElement.attr('class');
        var classes = classAttr.split(' ');
        var index = classes.indexOf(className);
        if (toggle) {
            if (index == -1)
                svgElement.attr('class', classAttr + ' ' + className);
        } else if (index != -1) {
            classes.splice(index, 1);
            svgElement.attr('class', classes.join(' '));
        }
    }

    function simplifyScaleAndCreatePathDef(polygons, scale, tolerance) {
        polygons = cam.simplifyPolygons(polygons, tolerance * scale);
        var d = '';
        polygons.forEach(function (poly) {
            var firstPoint = poly[0];
            d += ' M ' + firstPoint.X / scale + ',' + firstPoint.Y / scale;
            for (var i = 1; i < poly.length; i++)
                d += ' L ' + poly[i].X / scale + ',' + poly[i].Y / scale;
        });
        return d;
    }

    function unionBox(box1, box2) {
        var x = Math.min(box1.x, box2.x);
        var y = Math.min(box1.y, box2.y);
        var x2 = Math.max(box1.x + box1.width, box2.x + box2.width);
        var y2 = Math.max(box1.y + box1.height, box2.y + box2.height);
        return {x: x, y: y, width: x2 - x, height: y2 - y};
    }

    function getbBox(polygons, scale) {
        var minX = Number.POSITIVE_INFINITY;
        var maxX = Number.NEGATIVE_INFINITY;
        var minY = Number.POSITIVE_INFINITY;
        var maxY = Number.NEGATIVE_INFINITY;

        for (var i = 0; i < polygons.length; i++) {
            var polygon = polygons[i];
            for (var j = 0; j < polygon.length; j++) {
                var point = polygon[j];
                var x = point.X / scale;
                minX = Math.min(x, minX);
                maxX = Math.max(x, maxX);
                var y = point.Y / scale;
                minY = Math.min(y, minY);
                maxY = Math.max(y, maxY);
            }
        }
        return {x: minX, y: minY, width: maxX - minX, height: maxY - minY, x2: maxX, y2: maxY};
    }

    function lerp(min, max, ratio) {
        return min + ratio * (max - min);
    }

    function bboxIntersect(a, b) {
        return !(a.x >= b.x + b.width || a.y >= b.y + b.height
                || b.x >= a.x + a.width || b.y >= a.y + a.height);
    }

    TextApplication.MultiLODPolylineView = Ember.Object.extend({
        lodLevels: [0.2, 0.5, 0.75, 1],
        init: function () {
            var parent = this.get('parent');
            var polyline = this.get('polyline');
            this.set('lods', []);
            var bbox = getbBox(polyline, machine.clipperScale);
            this.set('bbox', bbox);
            this.set('treeKey', [bbox.x, bbox.y, bbox.x2, bbox.y2, this]);
            this.refreshVisibility(this.get('operationView.nativeComponent.visibleBox'));
        },
        installLodRepresentation: function (index) {
            var lods = this.get('lods');
            var newElement = index.isNaN ? this.get('emptyPath') : lods[index];
            if (index.isNaN && newElement == null) {
                newElement = this.get('parent').path('M0,0');
                this.set('emptyPath', newElement);
            }
            var element = this.get('pathElement');
            if (newElement == null) {
                var interpolationPoints = this.get('lodLevels');
                var minZoom = this.get('operationView.nativeComponent.minZoom');
                var maxZoom = this.get('operationView.nativeComponent.maxZoom');
                var d = simplifyScaleAndCreatePathDef(this.get('polyline'), machine.clipperScale,
                        2 / lerp(minZoom, maxZoom, interpolationPoints[index]));
                newElement = this.get('parent').path(d).attr(this.get('attr'));
                lods[index] = newElement;
            }
            if (element != null)
                element.replace(newElement);
            this.set('pathElement', newElement);
        },
        lodIndex: function () {
            var zoomLevel = this.get('operationView.nativeComponent.zoomLevel');
            var minZoom = this.get('operationView.nativeComponent.minZoom');
            var maxZoom = this.get('operationView.nativeComponent.maxZoom');
            var zoomRatio = (zoomLevel - minZoom) / (maxZoom - minZoom);
            var interpolationPoints = this.get('lodLevels');
            for (var i = 0; i < interpolationPoints.length; i++)
                if (zoomRatio < interpolationPoints[i])
                    return i;
            return interpolationPoints.length - 1;
        }.property('operationView.nativeComponent.zoomLevel'),
        willDestroy: function () {
            this.get('pathElement').remove();
        },
        refreshVisibility: function (viewBox) {
            var lodIndex = this.get('lodIndex');
            var inViewPort = bboxIntersect(viewBox, this.get('bbox'));
            if (this.get('currentLodIndex') === lodIndex && this.get('currentVisibility') === inViewPort)
                return;
            this.set('currentLodIndex', lodIndex);
            this.set('currentVisibility', inViewPort);
            this.installLodRepresentation(inViewPort ? lodIndex : NaN);
        }
    });

    TextApplication.PocketView = Ember.Object.extend({
        init: function () {
            this._super();
            this.set('layerViews', new Ember.Set());
        },
        willDestroy: function () {
            while (this.get('layerViews.firstObject'))
                this.removePolyline(this.get('layerViews.firstObject'));
        },
        pocketGroupChanged: function () {
            var pocketGroup = this.get('pocketGroup');
            if (pocketGroup != null) {
                var toolPathArray = this.get('pocket.toolPathArray');
                if (toolPathArray != null) {
                    for (var i = 0; i < toolPathArray.length; i++)
                        this.recursivelyDisplayLayers(toolPathArray[i], pocketGroup);
                    if (this.get('computingView') != null) {
                        this.removePolyline(this.get('computingView'));
                        this.set('computingView', null);
                    }
                } else
                    this.set('computingView', this.displayPolyline(this.get('pocket.polygon'),
                            {class: 'computing', fill: 'url(#computingFill)'}));
            }
        }.observes('pocketGroup', 'pocket.toolPathArray').on('init'),
        recursivelyDisplayLayers: function (pocket, group) {
            for (var j = 0; j < pocket.children.length; j++)
                this.recursivelyDisplayLayers(pocket.children[j], group);
            if (pocket.spiraledToolPath) {
                this.displayPolyline(pocket.spiraledToolPath.shell, {class: 'spiralPocketOutline'});
                this.displayPolyline([pocket.spiraledToolPath.path], {class: 'pocket'});
            } else
                this.displayPolyline(pocket.contour, {class: 'pocket'});
        },
        displayPolyline: function (polyline, attr) {
            var params = {polyline: polyline, parent: this.get('pocketGroup'), operationView: this.get('operationView'), attr: attr};
            var layerView = TextApplication.MultiLODPolylineView.create(params);
            this.get('operationView.tree').insert(layerView.get('treeKey'));
            this.get('layerViews').add(layerView);
            return layerView;
        },
        removePolyline: function (polyline) {
            this.get('layerViews').remove(polyline);
            this.get('operationView.tree').remove(polyline.get('treeKey'));
            polyline.destroy();
        }
    });
    TextApplication.OperationView = Ember.View.extend({
        classNames: ['TwoDView'],
        init: function () {
            this._super();
            //http://emberjs.com/guides/object-model/observers/#toc_unconsumed-computed-properties-do-not-trigger-observers
            this.get('controller');
            var undercuts = [];
            var tree = rbrush();
            this.set('tree', tree);
            this.set('undercuts', undercuts);
            var _this = this;
            this.get('controller.undercut').addArrayObserver({
                arrayWillChange: function (observedObj, start, removeCount, addCount) {
                    for (var i = 0; i < removeCount; i++)
                        undercuts[start + i].remove();
                    undercuts.splice(start, removeCount);
                },
                arrayDidChange: function (observedObj, start, removeCount, addCount) {
                    var pocketGroup = _this.get('pocketGroup');
                    var add = [];
                    for (var i = 0; i < addCount; i++)
                        add.push(_this.displayClipper(pocketGroup, _this.simplify(observedObj[start + i]), {class: 'undercut'}));
                    Array.prototype.splice.apply(undercuts, [start, 0].concat(add));
                }
            });
            var pocketViews = [];
            this.set('pocketViews', pocketViews);
            this.get('controller.pocketToolPaths').addArrayObserver({
                arrayWillChange: function (observedObj, start, removeCount, addCount) {
                    for (var i = 0; i < removeCount; i++) {
                        var pocketView = pocketViews[start + i];
                        pocketView.destroy();
                    }
                    pocketViews.splice(start, removeCount);
                },
                arrayDidChange: function (observedObj, start, removeCount, addCount) {
                    var pocketGroup = _this.get('pocketGroup');
                    var add = [];
                    for (var i = 0; i < addCount; i++) {
                        var pocket = observedObj[start + i];
                        add.pushObject(TextApplication.PocketView.create({pocket: pocket, pocketGroup: pocketGroup, operationView: _this}));
                    }
                    Array.prototype.splice.apply(pocketViews, [start, 0].concat(add));
                }
            });
        },
        didInsertElement: function () {
            var view = emberTwoDView.EmberTwoDView.create({element: this.$()});
            this.set('nativeComponent', view);
            var outline = view.paper.path('M0,0').attr({class: 'outline'});
            outline.remove();
            this.set('outline', outline);
            this.set('pocketGroup', view.paper.group());
        },
        simplify: function (poly) {
            return cam.simplifyPolygons(poly, machine.clipperScale / 100);
        },
        clear: function () {
            this.get('pocketGroup').clear();
        },
        viewPointWasChanged: function () {
            Ember.run.debounce(this, this.updateRepresentationsToView, 50);
        }.observes('nativeComponent.visibleBox'),
        updateRepresentationsToView: function () {
            var vbox = this.get('nativeComponent.visibleBox');
            if (vbox) {
                var previousVbox = this.get('vbox');
                var tree = this.get('tree');
                var union = previousVbox != null ? unionBox(vbox, previousVbox) : vbox;
                var refreshList = tree.search([union.x, union.y, union.x + union.width, union.y + union.height]);
                for (var i = 0; i < refreshList.length; i++)
                    refreshList[i][4].refreshVisibility(vbox);
                this.set('vbox', vbox);
            }
        }.on('didInsertElement'),
        synchronizeOutline: function () {
            this.clear();
            var d = this.get('controller.textOutline');
            var paper = this.get('nativeComponent.paper');
            if (d != null) {
                paper.add(this.get('outline').attr({d: d}));
                Ember.run.scheduleOnce('afterRender', this.get('nativeComponent'), 'zoomExtent');
            } else
                this.get('outline').remove();
        }.observes('controller.textOutline'),
        displayClipper: function (parent, clipperPoly, attr) {
            var d = '';
            machine.fromClipper(clipperPoly).forEach(function (poly) {
                var firstPoint = poly.getStartPoint();
                d += ' M ' + firstPoint.x + ',' + firstPoint.y;
                poly.forEachPoint(function (x, y) {
                    d += ' L ' + x + ',' + y;
                }, null);
            });
            return parent.path(d).attr(attr);
        }
    });

    TextApplication.TextView = Ember.View.extend({
        classNames: ['emberPart'],
        templateName: 'text'
    });
    TextApplication.TextController = Ember.ObjectController.extend({
        actions: {
            launchComputationImmediately: function () {
                this.computePocket();
            }
        },
        undercut: [],
        pocketToolPaths: [],
        textChanged: function () {
            this.abortComputation();
            var t = this.get('text');
            if (t == null)
                return;
            var _this = this;
            text.getText('Seymour One', t, 30).then(function (textOutline) {
                _this.set('textOutline', textOutline);
                _this.computePocket();
            }).catch(function (error) {
                        console.error(error.stack);
                    });
        }.observes('text').on('init'),
        computing: function () {
            return this.get('pocketToolPaths').isAny('isComputing');
        }.property('pocketToolPaths.@each.isComputing'),
        timeComputing: function () {
            if (this.get('computing'))
                console.time('computing');
            else
                console.timeEnd('computing');
        }.observes('computing').on('init'),
        computePocket: function () {
            var _this = this;
            var toolRadius = this.get('toolDiameter') / 2 * machine.clipperScale;
            var textOutline = this.get('textOutline');
            _this.get('undercut').clear();
            _this.get('pocketToolPaths').clear();
            this.abortComputation();
            var poly2 = machine.pathDefToClipper(textOutline);
            var display = {
                displayUndercutPoly: function (poly) {
                    _this.get('undercut').pushObject(poly);
                }};
            var work = pocket.createPocket2(poly2, toolRadius, this.get('radialEngagementRatio'), display, false);
            _this.set('workBatch', work);
            _this.get('pocketToolPaths').pushObjects(work.polygons.map(function (polygon, index) {
                return TextApplication.PocketToolPath.create({polygon: polygon, promise: work.promises[index]});
            }));
        },
        abortComputation: function () {
            var work = this.get('workBatch');
            if (work == null)
                return;
            work.abort();
            this.set('workBatch', null);
        }
    });

    TextApplication.PocketToolPath = Ember.Object.extend({
        init: function () {
            var _this = this;
            this.get('promise').then(function (toolPathArray) {
                _this.set('toolPathArray', toolPathArray);
            }).catch(function (error) {
                        console.error(error.stack);
                    }).finally(function () {
                        _this.set('isComputing', false);
                    });
        },
        isComputing: true
    });
    TextApplication.TextRoute = Ember.Route.extend({
        model: function () {
            return {
                id: 1,
                text: 'Quite Long Text',
                toolDiameter: 2,
                radialEngagementRatio: 0.9,
                depth: 1
            }
        },
        controllerName: 'text'
    });
    TextApplication.ApplicationAdapter = DS.FixtureAdapter.extend();
    var machine = new cam.Machine(null);
})
</script>
</body>
</html>

