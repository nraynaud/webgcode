<!doctype html>
<html>
<head>
    <meta http-equiv="X-UA-Compatible" content="chrome=1"/>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
    <title>CNC Text Tool</title>
    <script src="webapp/libs/jquery.min.js"></script>
    <script src="webapp/libs/svg.js"></script>
    <script src="webapp/libs/jquery.mousewheel.js"></script>
    <script src="webapp/libs/opentype.js"></script>
    <script src="webapp/libs/extractedRaphael.js"></script>
    <script src="webapp/libs/require.js"></script>
    <script src="webapp/libs/handlebars-v1.3.0.js"></script>
    <script src="webapp/libs/ember-1.5.0-beta5.pre7.js"></script>
    <script src="webapp/libs/ember-data-1.0.0-beta7.js"></script>

    <script>
        requirejs.config({
            baseUrl: 'webapp'
        });
    </script>

    <link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
    <style>
        * {
            -webkit-box-sizing: border-box;
            -moz-box-sizing: border-box;
            box-sizing: border-box;
        }

        body {
            display: flex;
            display: -webkit-box;
            display: -webkit-flex;
            display: -ms-flexbox;
        }

        html, body {
            height: 100%;
            padding: 0;
            margin: 0;
        }

        #drawing, #code {
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            flex: 1;
            -webkit-flex: 1;
            border: solid;
            padding: 0;
            margin: 0;
        }

        #code {
            flex: 0.5;
        }

        .emberPart {
            align-items: stretch;
            display: flex;
            display: -webkit-flex;
            align-items: stretch;
            padding: 0;
            margin: 0;
            flex: 1;
            -webkit-flex: 1;
        }

        .controls {
            flex: 0 0 auto;
            -webkit-flex: 0 0 auto;

            align-items: stretch;
        }

    </style>
</head>
<body>

<script type="text/x-handlebars" data-template-name="text">
    <div class="controls">
        <label for="text">Text:</label><br>
        {{input type="text" id="text" valueBinding="text" title="your text" action="launchComputationImmediately"}}
        <br>
        <label for="toolDiameter" title="in mm">Tool Diameter:</label><br>
        {{view TextApplication.NumberField id="toolDiameter" placeholder="toolDiameter"
        numericValueBinding="toolDiameter" min="0" action="launchComputationImmediately"}}
        <br>
        <label for="radialEngagement" title="ratio [0-1]">Radial Engagement:</label><br>
        {{view TextApplication.NumberField id="radialEngagement" placeholder="radialEngagement"
        numericValueBinding="radialEngagementRatio" min="0" max="1" step="0.05" action="launchComputationImmediately"}}
        <br>
    </div>
    <div id="drawing">
        {{view TextApplication.TwoDView}}
    </div>
    <textarea id="code"></textarea>

</script>

<script>
var drawing = $('#drawing');
require(['cnc/ui/emberTwoDView', 'cnc/cam', 'samples/fontExample.js', 'cnc/text', 'cnc/pocket', 'cnc/ui/views', 'libs/simplify'], function (emberTwoDView, cam, fontExample, text, pocket, views, simplify) {
    window.TextApplication = Ember.Application.create({
        customEvents: {
            mousewheel: "mousewheel"
        }
    });
    TextApplication.Router.reopen({
        rootURL: '/webgcode/'
    });
    TextApplication.Router.map(function () {
        this.resource('text', {path: '/'});
    });
    //TODO: find how to inject this into the template scope directly
    TextApplication.NumberField = views.NumberField;

    function toggleClass(svgElement, className, toggle) {
        var classAttr = svgElement.attr('class');
        var classes = classAttr.split(' ');
        var index = classes.indexOf(className);
        if (toggle) {
            if (index == -1)
                svgElement.attr('class', classAttr + ' ' + className);
        } else if (index != -1) {
            classes.splice(index, 1);
            svgElement.attr('class', classes.join(' '));
        }
    }

    TextApplication.TwoDView = Ember.View.extend({
        classNames: ['TwoDView'],
        init: function () {
            this._super();
            //http://emberjs.com/guides/object-model/observers/#toc_unconsumed-computed-properties-do-not-trigger-observers
            this.get('controller');
            var undercuts = [];
            this.set('undercuts', undercuts);
            var self = this;
            this.get('controller.undercut').addArrayObserver({
                arrayWillChange: function (observedObj, start, removeCount, addCount) {
                    for (var i = 0; i < removeCount; i++)
                        undercuts[start + i].remove();
                    undercuts.splice(start, removeCount);
                },
                arrayDidChange: function (observedObj, start, removeCount, addCount) {
                    var pocketGroup = self.get('pocketGroup');
                    var add = [];
                    for (var i = 0; i < addCount; i++)
                        add.push(self.displayClipper(pocketGroup, self.simplify(observedObj[start + i]), {class: 'undercut'}));
                    Array.prototype.splice.apply(undercuts, [start, 0].concat(add));
                }
            });
        },
        simplify: function (poly) {
            return cam.simplifyPolygons(poly, machine.clipperScale / 100);
        },
        didInsertElement: function () {
            var view = emberTwoDView.EmberTwoDView.create({element: this.$()});
            this.set('nativeComponent', view);
            var outline = view.paper.path('M0,0').attr({class: 'outline', fill: 'url(#computingFill)'});
            outline.remove();
            this.set('outline', outline);
            this.set('pocketGroup', view.paper.group());

        },
        clear: function () {
            this.get('pocketGroup').clear();
        },
        synchronizeOutline: function () {
            this.clear();
            var d = this.get('controller.textOutline');
            var paper = this.get('nativeComponent.paper');
            if (d != null) {
                paper.add(this.get('outline').attr({d: d}));
                this.synchronizeComputing();
                Ember.run.scheduleOnce('afterRender', this.get('nativeComponent'), 'zoomExtent');
            } else
                this.get('outline').remove();
        }.observes('controller.textOutline'),
        synchronizeComputing: function () {
            var computing = this.get('controller.computing');
            if (computing)
                this.clear();
            toggleClass(this.get('outline'), 'computing', computing);
        }.observes('controller.computing'),
        synchronizePocket: function () {
            var paper = this.get('nativeComponent.paper');
            var pocketGroup = this.get('pocketGroup');
            var self = this;

            function registerPocket(pocket) {
                for (var j = 0; j < pocket.children.length; j++)
                    registerPocket(pocket.children[j]);
                if (pocket.spiraledToolPath) {
                    self.displayClipper(pocketGroup, self.simplify([pocket.spiraledToolPath.path]), {stroke: 'blue', fill: 'none'});
                    self.displayClipper(pocketGroup, self.simplify(pocket.spiraledToolPath.shell), {stroke: 'none', fill: 'rgba(100, 100, 255, 0.2)',
                        'fill-rule': 'evenodd', title: 'spiral toolpath'});
                } else
                    self.displayClipper(pocketGroup, self.simplify(pocket.contour), {stroke: 'blue', fill: 'none'});
            }

            var pocketToolPaths = this.get('controller.pocketToolPaths');
            for (var i = 0; i < pocketToolPaths.length; i++)
                for (var j = 0; j < pocketToolPaths[i].length; j++)
                    registerPocket(pocketToolPaths[i][j]);

        }.observes('controller.pocketToolPaths'),
        displayClipper: function (parent, clipperPoly, attr) {
            var d = '';
            machine.fromClipper(clipperPoly).map(function (poly) {
                var firstPoint = poly.getStartPoint();
                d += ' M ' + firstPoint.x + ',' + firstPoint.y;
                poly.forEachPoint(function (x, y) {
                    d += ' L ' + x + ',' + y;
                }, null);
            });
            return parent.path(d).attr(attr);
        }
    });

    TextApplication.TextView = Ember.View.extend({
        classNames: ['emberPart'],
        templateName: 'text'
    });
    TextApplication.TextController = Ember.ObjectController.extend({
        actions: {
            launchComputationImmediately: function () {
                this.computePocket();
            }
        },
        toolDiameter: 2,
        radialEngagementRatio: 0.9,
        undercut: [],
        toolChanged: function () {
            Ember.run.debounce(this, this.computePocket, 2000);
        }.observes('toolDiameter', 'radialEngagementRatio'),
        textChanged: function () {
            var t = this.get('text');
            if (t == null)
                return;
            var self = this;
            text.getText('Seymour One', t, 30).then(function (textOutline) {
                self.set('textOutline', textOutline);
                Ember.run.debounce(self, self.computePocket, 2000);
            }).catch(function (error) {
                        console.error(error.stack);
                    });
        }.observes('text').on('init'),
        computing: Ember.computed.bool('computationPromise'),
        computePocket: function () {
            var self = this;
            var toolRadius = this.get('toolDiameter') / 2;
            var radialEngagementRatio = this.get('radialEngagementRatio');
            var textOutline = this.get('textOutline');
            var text = this.get('text');
            self.get('undercut').clear();
            this.abortComputation();
            var poly2 = machine.pathDefToClipper(textOutline);
            console.time('computation');
            var promise = pocket.createPocket(poly2, toolRadius * machine.clipperScale, radialEngagementRatio, {
                displayClipperComputingPoly: function () {
                    return {remove: function () {
                    }};
                },
                displayUndercutPoly: function (poly) {
                    self.get('undercut').pushObject(poly);
                }}, false);
            self.set('computationPromise', promise);
            promise.then(function (pocketToolPaths) {
                self.set('pocketToolPaths', pocketToolPaths);
                console.log('done');
            },function (error) {
                console.log(error.stack);
            }).finally(function () {
                        console.timeEnd('computation');
                        self.set('computationPromise', null);
                    });
        },
        abortComputation: function () {
            var promise = this.get('computationPromise');
            if (promise == null)
                return;
            promise.abort();
            this.set('computationPromise', null);
        }
    });

    TextApplication.TextRoute = Ember.Route.extend({
        model: function () {
            return {
                id: 1,
                text: 'Quite long text'
            }
        },
        controllerName: 'text'
    });
    TextApplication.ApplicationAdapter = DS.FixtureAdapter.extend();

    var machine = new cam.Machine(null);
})
</script>
</body>
</html>
