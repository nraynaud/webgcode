/*! Sortable 1.2.1 - MIT | git://github.com/rubaxa/Sortable.git */
!function (a) {
    "use strict";
    "function" == typeof define && define.amd ? define(a) : "undefined" != typeof module && "undefined" != typeof module.exports ? module.exports = a() : "undefined" != typeof Package ? Sortable = a() : window.Sortable = a()
}(function () {
    "use strict";
    function a(a, b) {
        this.el = a, this.options = b = s({}, b), a[J] = this;
        var d = {
            group: Math.random(),
            sort: !0,
            disabled: !1,
            store: null,
            handle: null,
            scroll: !0,
            scrollSensitivity: 30,
            scrollSpeed: 10,
            draggable: /[uo]l/i.test(a.nodeName) ? "li" : ">*",
            ghostClass: "sortable-ghost",
            ignore: "a, img",
            filter: null,
            animation: 0,
            setData: function (a, b) {
                a.setData("Text", b.textContent)
            },
            dropBubble: !1,
            dragoverBubble: !1,
            dataIdAttr: "data-id",
            delay: 0
        };
        for (var e in d)!(e in b) && (b[e] = d[e]);
        var g = b.group;
        g && "object" == typeof g || (g = b.group = {name: g}), ["pull", "put"].forEach(function (a) {
            a in g || (g[a] = !0)
        }), b.groups = " " + g.name + (g.put.join ? " " + g.put.join(" ") : "") + " ";
        for (var h in this)"_" === h.charAt(0) && (this[h] = c(this, this[h]));
        f(a, "mousedown", this._onTapStart), f(a, "touchstart", this._onTapStart), f(a, "dragover", this), f(a, "dragenter", this), R.push(this._onDragOver), b.store && this.sort(b.store.get(this))
    }

    function b(a) {
        v && v.state !== a && (i(v, "display", a ? "none" : ""), !a && v.state && w.insertBefore(v, t), v.state = a)
    }

    function c(a, b) {
        var c = Q.call(arguments, 2);
        return b.bind ? b.bind.apply(b, [a].concat(c)) : function () {
            return b.apply(a, c.concat(Q.call(arguments)))
        }
    }

    function d(a, b, c) {
        if (a) {
            c = c || L, b = b.split(".");
            var d = b.shift().toUpperCase(), e = new RegExp("\\s(" + b.join("|") + ")(?=\\s)", "g");
            do if (">*" === d && a.parentNode === c || ("" === d || a.nodeName.toUpperCase() == d) && (!b.length || ((" " + a.className + " ").match(e) || []).length == b.length))return a; while (a !== c && (a = a.parentNode))
        }
        return null
    }

    function e(a) {
        a.dataTransfer.dropEffect = "move", a.preventDefault()
    }

    function f(a, b, c) {
        a.addEventListener(b, c, !1)
    }

    function g(a, b, c) {
        a.removeEventListener(b, c, !1)
    }

    function h(a, b, c) {
        if (a)if (a.classList)a.classList[c ? "add" : "remove"](b); else {
            var d = (" " + a.className + " ").replace(I, " ").replace(" " + b + " ", " ");
            a.className = (d + (c ? " " + b : "")).replace(I, " ")
        }
    }

    function i(a, b, c) {
        var d = a && a.style;
        if (d) {
            if (void 0 === c)return L.defaultView && L.defaultView.getComputedStyle ? c = L.defaultView.getComputedStyle(a, "") : a.currentStyle && (c = a.currentStyle), void 0 === b ? c : c[b];
            b in d || (b = "-webkit-" + b), d[b] = c + ("string" == typeof c ? "" : "px")
        }
    }

    function j(a, b, c) {
        if (a) {
            var d = a.getElementsByTagName(b), e = 0, f = d.length;
            if (c)for (; f > e; e++)c(d[e], e);
            return d
        }
        return []
    }

    function k(a, b, c, d, e, f, g) {
        var h = L.createEvent("Event"), i = (a || b[J]).options, j = "on" + c.charAt(0).toUpperCase() + c.substr(1);
        h.initEvent(c, !0, !0), h.to = b, h.from = e || b, h.item = d || b, h.clone = v, h.oldIndex = f, h.newIndex = g, b.dispatchEvent(h), i[j] && i[j].call(a, h)
    }

    function l(a, b, c, d, e, f) {
        var g, h, i = a[J], j = i.options.onMove;
        return j && (g = L.createEvent("Event"), g.initEvent("move", !0, !0), g.to = b, g.from = a, g.dragged = c, g.draggedRect = d, g.related = e || b, g.relatedRect = f || b.getBoundingClientRect(), h = j.call(i, g)), h
    }

    function m(a) {
        a.draggable = !1
    }

    function n() {
        O = !1
    }

    function o(a, b) {
        var c = a.lastElementChild, d = c.getBoundingClientRect();
        return b.clientY - (d.top + d.height) > 5 && c
    }

    function p(a) {
        for (var b = a.tagName + a.className + a.src + a.href + a.textContent, c = b.length, d = 0; c--;)d += b.charCodeAt(c);
        return d.toString(36)
    }

    function q(a) {
        for (var b = 0; a && (a = a.previousElementSibling);)"TEMPLATE" !== a.nodeName.toUpperCase() && b++;
        return b
    }

    function r(a, b) {
        var c, d;
        return function () {
            void 0 === c && (c = arguments, d = this, setTimeout(function () {
                1 === c.length ? a.call(d, c[0]) : a.apply(d, c), c = void 0
            }, b))
        }
    }

    function s(a, b) {
        if (a && b)for (var c in b)b.hasOwnProperty(c) && (a[c] = b[c]);
        return a
    }

    var t, u, v, w, x, y, z, A, B, C, D, E, F, G, H = {}, I = /\s+/g, J = "Sortable" + (new Date).getTime(), K = window, L = K.document, M = K.parseInt, N = !!("draggable"in L.createElement("div")), O = !1, P = Math.abs, Q = [].slice, R = [], S = r(function (a, b, c) {
        if (c && b.scroll) {
            var d, e, f, g, h = b.scrollSensitivity, i = b.scrollSpeed, j = a.clientX, k = a.clientY, l = window.innerWidth, m = window.innerHeight;
            if (z !== c && (y = b.scroll, z = c, y === !0)) {
                y = c;
                do if (y.offsetWidth < y.scrollWidth || y.offsetHeight < y.scrollHeight)break; while (y = y.parentNode)
            }
            y && (d = y, e = y.getBoundingClientRect(), f = (P(e.right - j) <= h) - (P(e.left - j) <= h), g = (P(e.bottom - k) <= h) - (P(e.top - k) <= h)), f || g || (f = (h >= l - j) - (h >= j), g = (h >= m - k) - (h >= k), (f || g) && (d = K)), (H.vx !== f || H.vy !== g || H.el !== d) && (H.el = d, H.vx = f, H.vy = g, clearInterval(H.pid), d && (H.pid = setInterval(function () {
                d === K ? K.scrollTo(K.pageXOffset + f * i, K.pageYOffset + g * i) : (g && (d.scrollTop += g * i), f && (d.scrollLeft += f * i))
            }, 24)))
        }
    }, 30);
    return a.prototype = {
        constructor: a, _onTapStart: function (a) {
            var b = this, c = this.el, e = this.options, f = a.type, g = a.touches && a.touches[0], h = (g || a).target, i = h, j = e.filter;
            if (!("mousedown" === f && 0 !== a.button || e.disabled) && (h = d(h, e.draggable, c))) {
                if (C = q(h), "function" == typeof j) {
                    if (j.call(this, a, h, this))return k(b, i, "filter", h, c, C), void a.preventDefault()
                } else if (j && (j = j.split(",").some(function (a) {
                        return a = d(i, a.trim(), c), a ? (k(b, a, "filter", h, c, C), !0) : void 0
                    })))return void a.preventDefault();
                (!e.handle || d(i, e.handle, c)) && this._prepareDragStart(a, g, h)
            }
        }, _prepareDragStart: function (a, b, c) {
            var d, e = this, g = e.el, h = e.options, i = g.ownerDocument;
            c && !t && c.parentNode === g && (F = a, w = g, t = c, x = t.nextSibling, E = h.group, d = function () {
                e._disableDelayedDrag(), t.draggable = !0, h.ignore.split(",").forEach(function (a) {
                    j(t, a.trim(), m)
                }), e._triggerDragStart(b)
            }, f(i, "mouseup", e._onDrop), f(i, "touchend", e._onDrop), f(i, "touchcancel", e._onDrop), h.delay ? (f(i, "mousemove", e._disableDelayedDrag), f(i, "touchmove", e._disableDelayedDrag), e._dragStartTimer = setTimeout(d, h.delay)) : d())
        }, _disableDelayedDrag: function () {
            var a = this.el.ownerDocument;
            clearTimeout(this._dragStartTimer), g(a, "mousemove", this._disableDelayedDrag), g(a, "touchmove", this._disableDelayedDrag)
        }, _triggerDragStart: function (a) {
            a ? (F = {
                target: t,
                clientX: a.clientX,
                clientY: a.clientY
            }, this._onDragStart(F, "touch")) : N ? (f(t, "dragend", this), f(w, "dragstart", this._onDragStart)) : this._onDragStart(F, !0);
            try {
                L.selection ? L.selection.empty() : window.getSelection().removeAllRanges()
            } catch (b) {
            }
        }, _dragStarted: function () {
            w && t && (h(t, this.options.ghostClass, !0), a.active = this, k(this, w, "start", t, w, C))
        }, _emulateDragOver: function () {
            if (G) {
                i(u, "display", "none");
                var a = L.elementFromPoint(G.clientX, G.clientY), b = a, c = " " + this.options.group.name, d = R.length;
                if (b)do {
                    if (b[J] && b[J].options.groups.indexOf(c) > -1) {
                        for (; d--;)R[d]({clientX: G.clientX, clientY: G.clientY, target: a, rootEl: b});
                        break
                    }
                    a = b
                } while (b = b.parentNode);
                i(u, "display", "")
            }
        }, _onTouchMove: function (a) {
            if (F) {
                var b = a.touches ? a.touches[0] : a, c = b.clientX - F.clientX, d = b.clientY - F.clientY, e = a.touches ? "translate3d(" + c + "px," + d + "px,0)" : "translate(" + c + "px," + d + "px)";
                G = b, i(u, "webkitTransform", e), i(u, "mozTransform", e), i(u, "msTransform", e), i(u, "transform", e), a.preventDefault()
            }
        }, _onDragStart: function (a, b) {
            var c = a.dataTransfer, d = this.options;
            if (this._offUpEvents(), "clone" == E.pull && (v = t.cloneNode(!0), i(v, "display", "none"), w.insertBefore(v, t)), b) {
                var e, g = t.getBoundingClientRect(), h = i(t);
                u = t.cloneNode(!0), i(u, "top", g.top - M(h.marginTop, 10)), i(u, "left", g.left - M(h.marginLeft, 10)), i(u, "width", g.width), i(u, "height", g.height), i(u, "opacity", "0.8"), i(u, "position", "fixed"), i(u, "zIndex", "100000"), w.appendChild(u), e = u.getBoundingClientRect(), i(u, "width", 2 * g.width - e.width), i(u, "height", 2 * g.height - e.height), "touch" === b ? (f(L, "touchmove", this._onTouchMove), f(L, "touchend", this._onDrop), f(L, "touchcancel", this._onDrop)) : (f(L, "mousemove", this._onTouchMove), f(L, "mouseup", this._onDrop)), this._loopId = setInterval(this._emulateDragOver, 150)
            } else c && (c.effectAllowed = "move", d.setData && d.setData.call(this, c, t)), f(L, "drop", this);
            setTimeout(this._dragStarted, 0)
        }, _onDragOver: function (a) {
            var c, e, f, g = this.el, h = this.options, j = h.group, k = j.put, m = E === j, p = h.sort;
            if (void 0 !== a.preventDefault && (a.preventDefault(), !h.dragoverBubble && a.stopPropagation()), E && !h.disabled && (m ? p || (f = !w.contains(t)) : E.pull && k && (E.name === j.name || k.indexOf && ~k.indexOf(E.name))) && (void 0 === a.rootEl || a.rootEl === this.el)) {
                if (S(a, h, this.el), O)return;
                if (c = d(a.target, h.draggable, g), e = t.getBoundingClientRect(), f)return b(!0), void(v || x ? w.insertBefore(t, v || x) : p || w.appendChild(t));
                if (0 === g.children.length || g.children[0] === u || g === a.target && (c = o(g, a))) {
                    if (c) {
                        if (c.animated)return;
                        r = c.getBoundingClientRect()
                    }
                    b(m), l(w, g, t, e, c, r) !== !1 && (g.appendChild(t), this._animate(e, t), c && this._animate(r, c))
                } else if (c && !c.animated && c !== t && void 0 !== c.parentNode[J]) {
                    A !== c && (A = c, B = i(c));
                    var q, r = c.getBoundingClientRect(), s = r.right - r.left, y = r.bottom - r.top, z = /left|right|inline/.test(B.cssFloat + B.display), C = c.offsetWidth > t.offsetWidth, D = c.offsetHeight > t.offsetHeight, F = (z ? (a.clientX - r.left) / s : (a.clientY - r.top) / y) > .5, G = c.nextElementSibling, H = l(w, g, t, e, c, r);
                    H !== !1 && (O = !0, setTimeout(n, 30), b(m), q = 1 === H || -1 === H ? 1 === H : z ? c.previousElementSibling === t && !C || F && C : G !== t && !D || F && D, q && !G ? g.appendChild(t) : c.parentNode.insertBefore(t, q ? G : c), this._animate(e, t), this._animate(r, c))
                }
            }
        }, _animate: function (a, b) {
            var c = this.options.animation;
            if (c) {
                var d = b.getBoundingClientRect();
                i(b, "transition", "none"), i(b, "transform", "translate3d(" + (a.left - d.left) + "px," + (a.top - d.top) + "px,0)"), b.offsetWidth, i(b, "transition", "all " + c + "ms"), i(b, "transform", "translate3d(0,0,0)"), clearTimeout(b.animated), b.animated = setTimeout(function () {
                    i(b, "transition", ""), i(b, "transform", ""), b.animated = !1
                }, c)
            }
        }, _offUpEvents: function () {
            var a = this.el.ownerDocument;
            g(L, "touchmove", this._onTouchMove), g(a, "mouseup", this._onDrop), g(a, "touchend", this._onDrop), g(a, "touchcancel", this._onDrop)
        }, _onDrop: function (b) {
            var c = this.el, d = this.options;
            clearInterval(this._loopId), clearInterval(H.pid), clearTimeout(this._dragStartTimer), g(L, "drop", this), g(L, "mousemove", this._onTouchMove), g(c, "dragstart", this._onDragStart), this._offUpEvents(), b && (b.preventDefault(), !d.dropBubble && b.stopPropagation(), u && u.parentNode.removeChild(u), t && (g(t, "dragend", this), m(t), h(t, this.options.ghostClass, !1), w !== t.parentNode ? (D = q(t), k(null, t.parentNode, "sort", t, w, C, D), k(this, w, "sort", t, w, C, D), k(null, t.parentNode, "add", t, w, C, D), k(this, w, "remove", t, w, C, D)) : (v && v.parentNode.removeChild(v), t.nextSibling !== x && (D = q(t), k(this, w, "update", t, w, C, D), k(this, w, "sort", t, w, C, D))), a.active && (k(this, w, "end", t, w, C, D), this.save())), w = t = u = x = v = y = z = F = G = A = B = E = a.active = null)
        }, handleEvent: function (a) {
            var b = a.type;
            "dragover" === b || "dragenter" === b ? t && (this._onDragOver(a), e(a)) : ("drop" === b || "dragend" === b) && this._onDrop(a)
        }, toArray: function () {
            for (var a, b = [], c = this.el.children, e = 0, f = c.length, g = this.options; f > e; e++)a = c[e], d(a, g.draggable, this.el) && b.push(a.getAttribute(g.dataIdAttr) || p(a));
            return b
        }, sort: function (a) {
            var b = {}, c = this.el;
            this.toArray().forEach(function (a, e) {
                var f = c.children[e];
                d(f, this.options.draggable, c) && (b[a] = f)
            }, this), a.forEach(function (a) {
                b[a] && (c.removeChild(b[a]), c.appendChild(b[a]))
            })
        }, save: function () {
            var a = this.options.store;
            a && a.set(this)
        }, closest: function (a, b) {
            return d(a, b || this.options.draggable, this.el)
        }, option: function (a, b) {
            var c = this.options;
            return void 0 === b ? c[a] : void(c[a] = b)
        }, destroy: function () {
            var a = this.el;
            a[J] = null, g(a, "mousedown", this._onTapStart), g(a, "touchstart", this._onTapStart), g(a, "dragover", this), g(a, "dragenter", this), Array.prototype.forEach.call(a.querySelectorAll("[draggable]"), function (a) {
                a.removeAttribute("draggable")
            }), R.splice(R.indexOf(this._onDragOver), 1), this._onDrop(), this.el = a = null
        }
    }, a.utils = {
        on: f, off: g, css: i, find: j, bind: c, is: function (a, b) {
            return !!d(a, b, a)
        }, extend: s, throttle: r, closest: d, toggleClass: h, index: q
    }, a.version = "1.2.1", a.create = function (b, c) {
        return new a(b, c)
    }, a
});