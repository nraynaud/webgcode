<!DOCTYPE html >
<html>
<head>
<meta http-equiv="X-UA-Compatible" content="chrome=1"/>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<title>Visual CAM</title>
<script src="webapp/libs/require.js"></script>
<script src="webapp/config.js"></script>
<script>
    requirejs.config({
        baseUrl: 'webapp'
    });
</script>
<link rel="shortcut icon" href="webapp/images/icon_fraise_48.png"/>
<link rel="stylesheet" href="webapp/twoDView.css" type="text/css">
<link rel="stylesheet" href="webapp/threeDView.css" type="text/css">
<link rel="stylesheet" href="webapp/libs/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="webapp/libs/font-awesome-4.2.0/css/font-awesome.min.css">
<style>

    body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        padding: 0;
        background: #fafafa;
        color: #444;
    }

    body {
        font-family: sans-serif;
        display: flex;
        flex-direction: column;
    }

    canvas {
        flex: 1;
    }

    .moving {
        cursor: move;
    }
</style>
<script>
require(['jQuery', 'THREE', 'libs/threejs/STLLoader', 'libs/threejs/postprocessing/EffectComposer',
            'libs/threejs/postprocessing/RenderPass', 'libs/threejs/postprocessing/ShaderPass',
            'libs/threejs/OrbitControls', 'libs/threejs/postprocessing/CopyShader'],
        function ($, THREE, STLLoader, EffectComposer, RenderPass, ShaderPass, OrbitControls, CopyShader) {
            var pixelsOnRadius = 10;
            var $container = $('body');
            var renderer = new THREE.WebGLRenderer({antialias: false, alpha: true, precision: 'highp', autoClear: true});
            renderer.autoClear = true;
            $container.append(renderer.domElement);
            var outputWidth = $container.width();
            var outputHeight = $container.height();
            renderer.sortObjects = false;
            renderer.setSize(outputWidth, outputHeight);
            renderer.setViewport(0, 0, outputWidth, outputHeight);
            renderer.clear();
            new STLLoader().load('webapp/samples/soap.stl', function (geometry) {
                function draw() {
                    displayGeometry(geometry);
                }

                draw();
            });
            function createSphericalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                var maxIndex = sampleCount - 1;
                for (var i = 0; i < sampleCount; i++) {
                    var relativeI = i / maxIndex;
                    samples.push((1 - Math.sqrt(1 - relativeI * relativeI)) * radiusMM * zRatio);
                }
                return samples;
            }

            function createVTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(i / (sampleCount - 1) * radiusMM * zRatio);
                return samples;
            }

            function createCylindricalTool(sampleCount, zRatio, radiusMM) {
                var samples = [];
                for (var i = 0; i < sampleCount; i++)
                    samples.push(0);
                return samples;
            }

            function ModelStage() {
                var scene = new THREE.Scene();
                this.scene = scene;
                var operation = {
                    depthTest: true,
                    size: 1,
                    sizeAttenuation: false,
                    linewidth: 1,
                    vertexShader: [
                        'void main() {',
                        '   gl_PointSize = 2.0;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'].join('\n'),
                    // depth encoding : http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/
                    fragmentShader: [
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'void main() {',
                        '   gl_FragData[0] = vec4(1.0 - gl_FragCoord.z, 0.0, 0.0, 1.0);',
                        '}'].join('\n')
                };

                this.scene.overrideMaterial = new THREE.ShaderMaterial(operation);
                this.displaySide = 1024;
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 1, 100);
                scene.add(this.camera);
                this.modelBuffer = new THREE.WebGLRenderTarget(this.displaySide, this.displaySide,
                        {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.FloatType});
            }

            ModelStage.prototype = {
                render: function (renderer) {
                    renderer.render(this.scene, this.camera, this.modelBuffer, true);
                },
                setGeometry: function (geometry) {
                    if (this.model) {
                        this.scene.remove(this.model);
                        this.model = null;
                    }
                    this.model = new THREE.Object3D();
                    var mesh = new THREE.Mesh(geometry, this.renderMaterial);
                    this.model.add(mesh);

                    // we add the vertices to force webgl to raster on at least 1 pixel
                    // in case a "mountain" is spiky enough to slip thought the sampling grid.
                    var pointsGeom = new THREE.BufferGeometry();
                    pointsGeom.addAttribute('position', geometry.attributes.position.clone());
                    this.model.add(new THREE.PointCloud(pointsGeom, new THREE.ShaderMaterial(this.renderMaterial)));

                    // we should add all the edges too because a whole "ridge" might be sharp enough to slip through
                    // the raster grid
                    // I have a problem where the end of some lines "poke" slightly through the surface I don't know why.
                    // question here: http://stackoverflow.com/questions/27097236/strange-artefacts-in-depth-buffer-with-lines
                    // by orienting the lines towards -z, I don't get the poky things
                    var array = geometry.attributes.position.array;
                    var lines = [];
                    var vertical = new THREE.Vector3(0, 0, 1);

                    function push(x1, y1, z1, x2, y2, z2) {
                        var v = new THREE.Vector3(x2 - x1, y2 - y1, z2 - z1);
                        if (v.dot(vertical) / v.length() / vertical.length() > 0)
                            lines.push(x1, y1, z1, x2, y2, z2);
                        else
                            lines.push(x2, y2, z2, x1, y1, z1);
                    }

                    for (var i = 0; i < array.length; i += 9) {
                        var x1 = array[i];
                        var y1 = array[i + 1];
                        var z1 = array[i + 2];

                        var x2 = array[i + 3];
                        var y2 = array[i + 4];
                        var z2 = array[i + 5];

                        var x3 = array[i + 6];
                        var y3 = array[i + 7];
                        var z3 = array[i + 8];

                        push(x1, y1, z1, x2, y2, z2);
                        push(x2, y2, z2, x3, y3, z3);
                        push(x3, y3, z3, x1, y1, z1);
                    }

                    var geom = new THREE.BufferGeometry();
                    geom.addAttribute('position', new THREE.BufferAttribute(new Float32Array(lines), 3));
                    this.model.add(new THREE.Line(geom, undefined, THREE.LinePieces));

                    mesh.geometry.computeBoundingBox();
                    this.modelBbox = mesh.geometry.boundingBox;
                    this.scene.add(this.model);
                    this.model.updateMatrixWorld();
                    this.resetCamera();
                },
                resetCamera: function () {
                    var bbox = this.modelBbox;
                    var bboxSize = bbox.size();
                    var modelRatio = bboxSize.y / bboxSize.x;
                    var center = new THREE.Vector2(0, 0);
                    console.log('modelRatio', modelRatio);
                    this.displaySideMm = (bboxSize.x > bboxSize.y ? bboxSize.x : bboxSize.y) * 1.1;
                    this.displaySide = this.sampleRate * this.displaySideMm;
                    this.bufferOrigin = center.clone().addScalar(-this.displaySideMm / 2);
                    this.bufferSize = new THREE.Vector2(this.displaySideMm, this.displaySideMm);
                    this.camera.left = this.bufferOrigin.x;
                    this.camera.right = this.bufferOrigin.x + this.bufferSize.x;
                    this.camera.bottom = this.bufferOrigin.y;
                    this.camera.top = this.bufferOrigin.y + this.bufferSize.y;
                    this.camera.position.set(0, 0, bbox.max.z + 1);
                    this.camera.lookAt(new THREE.Vector3(0, 0, bbox.min.z));
                    this.camera.far = bbox.max.z - bbox.min.z + 1;
                    this.zRatio = 1 / (this.camera.far - this.camera.near);
                    console.log('near, far', this.camera.near, this.camera.far);
                    this.camera.updateProjectionMatrix();
                    this.camera.updateMatrixWorld();
                    if (this.modelBuffer)
                        this.modelBuffer.dispose();
                    console.log('this.displaySide', this.displaySide);
                    this.modelBuffer = new THREE.WebGLRenderTarget(this.displaySide, this.displaySide,
                            {minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, type: THREE.FloatType});
                },
                setSampleRate: function (newSampleRate) {
                    console.log('sampleRate', newSampleRate);
                    this.sampleRate = newSampleRate;
                    this.resetCamera();
                }
            };

            function TerrainStage(geometry) {
                function divV(v1, v2) {
                    return v1.set(v1.x / v2.x, v1.y / v2.y);
                }

                this.modelStage = new ModelStage();
                this.modelStage.setGeometry(geometry);
                var toolRadiusMm = 2;
                var toolTexture = new THREE.DataTexture(new Float32Array(pixelsOnRadius), pixelsOnRadius, 1, THREE.LuminanceFormat, THREE.FloatType);
                var bufferOffset = new THREE.Vector2(0, 0);
                this.bufferOrigin = this.modelStage.bufferOrigin.clone().add(bufferOffset);
                this.bufferSize = this.modelStage.bufferSize.clone().multiply(new THREE.Vector2(1, 1));
                var terrainRatio = divV(this.bufferSize.clone(), this.modelStage.bufferSize);
                var terrainTranslation = this.bufferOrigin.clone().sub(this.modelStage.bufferOrigin).divide(this.modelStage.bufferSize);
                this.minkowskiPass = new ShaderPass({
                    uniforms: {
                        tDiffuse: {type: 't'},
                        toolProfile: {type: 't', value: toolTexture},
                        toolToPartRatio: {type: 'f', value: toolRadiusMm / this.modelStage.displaySideMm},
                        terrainRatio: {type: 'v2', value: terrainRatio},
                        terrainTranslation: {type: 'v2', value: terrainTranslation}
                    },
                    defines: {
                        radialSamples: null
                    },
                    vertexShader: [
                        'varying vec2 vUv;',
                        'void main() {',
                        '   vUv = uv;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'uniform sampler2D tDiffuse;',
                        'uniform sampler2D toolProfile;',
                        'uniform float toolToPartRatio;',
                        'uniform vec2 terrainRatio;',
                        'uniform vec2 terrainTranslation;',
                        'varying vec2 vUv;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'vec3 EncodeFloatRGB(highp float v) {',
                        '   vec3 enc = fract(vec3(1.0, 255.0, 255.0 * 255.0) * factor * v);',
                        '   enc -= enc.yzz * vec3(1.0 / 255.0, 1.0 / 255.0, 0.0);',
                        '   return enc;',
                        '}',
                        'highp float DecodeFloatRGB(vec3 rgb) {',
                        '   return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 255.0 / 255.0)) / factor;',
                        '}',
                        'highp float readHeight(vec2 pos) {',
                        '   highp vec4 color = texture2D(tDiffuse, terrainRatio * vUv + terrainTranslation + pos * toolToPartRatio);',
                        '   highp float displacement = texture2D(toolProfile, vec2(length(pos), 0.0)).r;',
                        '   return color.r - displacement;',
                        '}',
                        'void main() {',
                        '   highp int radiusSquared = radialSamples * radialSamples;',
                        '   highp float sum = readHeight(vec2(0.0, 0.0));',
                        '   for (int i = -radialSamples; i <= radialSamples; i++)',
                        '       for (int j = -radialSamples; j <= radialSamples; j++)',
                        '           if (i * i + j * j <= radiusSquared)',
                        '               sum = max(sum, readHeight(vec2(i, j) / float(radialSamples)));',
                        '   gl_FragColor = vec4(sum, 0.0, 0.0, 1.0);',
                        '}'].join('\n')
                });
                this.slicingPass = new ShaderPass({
                    uniforms: {
                        tDiffuse: {type: 't', value: null},
                        zCutoff: {type: 'f', value: null}
                    },
                    vertexShader: [
                        'varying vec2 vUv;',
                        'void main() {',
                        '   vUv = uv;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'uniform sampler2D tDiffuse;',
                        'uniform float zCutoff;',
                        'varying vec2 vUv;',
                        'void main() {',
                        '   gl_FragColor = vec4(max(zCutoff, texture2D(tDiffuse, vUv).r), 0.0, 0.0, 1.0);',
                        '}'].join('\n')
                });
                this.setSliceZ(-7);
                this.copy = new ShaderPass(CopyShader);
                this.copy.renderToScreen = true;
                this.toolRadiusMm = toolRadiusMm;
                this.toolType = 'ball';
                this.renderer = renderer;
                this.updateToolShape();
            }

            TerrainStage.prototype = {
                render: function (renderer) {
                    if (!this.modelStageClean) {
                        this.modelStage.render(renderer);
                        this.modelStageClean = true;
                        this.minkowskiPassClean = false;
                    }
                    if (!this.minkowskiPassClean) {
                        this.minkowskiPass.render(renderer, this.toolPosBuffer, this.modelStage.modelBuffer);
                        this.minkowskiPassClean = true;
                        this.slicingPassClean = false;
                    }
                    if (!this.slicingPassClean) {
                        this.slicingPass.render(renderer, this.slicingBuffer, this.toolPosBuffer);
                        this.slicingPassClean = true;
                    }
                    //this.copy.render(renderer, null, this.slicingBuffer);
                    //this.copy.render(renderer, null, this.toolPosBuffer);
                },
                updateToolShape: function () {
                    var totalPixels = 22000000;
                    var ySamples = 100;
                    var pixelsOnRadius = Math.floor(Math.pow(totalPixels * this.toolRadiusMm / (ySamples * this.modelStage.displaySideMm * 4), 1 / 3)) + 1;
                    this.modelStage.setSampleRate(pixelsOnRadius / this.toolRadiusMm);
                    var pixelCount = (pixelsOnRadius * 2) * (pixelsOnRadius * 2) * ySamples * this.modelStage.displaySide;
                    console.log('initial: pixels (millions): ', pixelCount / 1000000);
                    var types = {cylinder: createCylindricalTool, ball: createSphericalTool, v: createVTool};
                    var samples = types[this.toolType](pixelsOnRadius, this.modelStage.zRatio, this.toolRadiusMm);
                    this.minkowskiPass.material.uniforms.toolProfile.value.image.data = new Float32Array(samples);
                    this.minkowskiPass.material.uniforms.toolProfile.value.width = new Float32Array(samples);
                    this.minkowskiPass.material.uniforms.toolProfile.value.needsUpdate = true;
                    this.minkowskiPass.material.defines.radialSamples = pixelsOnRadius;
                    this.minkowskiPass.material.needsUpdate = true;
                    console.log('radialSamples', this.minkowskiPass.material.defines.radialSamples);
                    this.minkowskiPass.material.uniforms.toolToPartRatio.value = (this.toolRadiusMm / this.modelStage.displaySideMm).toPrecision(10);
                    this.minkowskiPass.material.needsUpdate = true;
                    if (this.toolPosBuffer)
                        this.toolPosBuffer.dispose();
                    this.toolPosBuffer = new THREE.WebGLRenderTarget(this.modelStage.displaySide, ySamples,
                            {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, type: THREE.FloatType});
                    if (this.slicingBuffer)
                        this.slicingBuffer.dispose();
                    this.slicingBuffer = new THREE.WebGLRenderTarget(this.modelStage.displaySide, ySamples,
                            {minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, type: THREE.FloatType});
                    this.modelStageClean = false;
                },
                setToolType: function (type) {
                    this.toolType = type;
                    this.updateToolShape();
                },
                setToolRadius: function (radius) {
                    this.toolRadiusMm = radius;
                    this.updateToolShape();
                },
                setSliceZ: function (z) {
                    this.slicingPass.material.uniforms.zCutoff.value = (z + (this.modelStage.camera.far - 1)) * this.modelStage.zRatio;
                    this.slicingPass.material.uniforms.zCutoff.value.needsUpdate = true;
                    this.slicingPassClean = false;
                }
            };

            function displayGeometry(geometry) {
                var clonedGeometry = geometry.clone();
                var pipeline = new TerrainStage(geometry);
                var scene2 = new THREE.Scene();
                var camera2 = new THREE.PerspectiveCamera(45, outputWidth / outputHeight, 0.1, 1500);
                camera2.up.set(0, 0, 1);
                camera2.position.z = 100;
                scene2.add(camera2);
                camera2.updateMatrixWorld();
                var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(1000, 1000, 1000);
                scene2.add(directionalLight);
                var directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
                directionalLight2.position.set(-1000, -1000, 1000);
                scene2.add(directionalLight2);

                var terrainToworldOffset = new THREE.Vector3(pipeline.bufferOrigin.x, pipeline.bufferOrigin.y, -(pipeline.modelStage.camera.far - 1));
                var terrainShader = {
                    wireframe: false,
                    size: 2,
                    uniforms: {
                        tDisplacement: {type: 't', value: null},
                        terrainToWorldRatio: {type: 'v3', value: new THREE.Vector3(pipeline.bufferSize.x, pipeline.bufferSize.y, 1 / pipeline.modelStage.zRatio)},
                        terrainToWorldOffset: {type: 'v3', value: terrainToworldOffset},
                        samplingDensity: {type: 'v2', value: new THREE.Vector2(pipeline.toolPosBuffer.width, pipeline.toolPosBuffer.height)}
                    },
                    vertexShader: [
                        'uniform sampler2D tDisplacement;',
                        'uniform vec3 terrainToWorldRatio;',
                        'uniform vec3 terrainToWorldOffset;',
                        'varying vec4 color;',
                        'highp float factor = (exp2(24.0) - 1.0) / exp2(24.0);',
                        'void main() {',
                        '   vec2 uv = position.xy;',
                        '   color = texture2D(tDisplacement, vec2(uv));',
                        '   vec3 pos = vec3(uv, color.r) * terrainToWorldRatio + terrainToWorldOffset;',
                        '   gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);',
                        '}'
                    ].join('\n'),
                    fragmentShader: [
                        'varying vec4 color;',
                        'void main() {',
                        '   gl_FragColor = vec4(color.r, 0.6 - abs(color.r - 0.5), 1.0 - color.r, 1.0);',
                        '}'].join('\n')
                };

                var terrainMaterial = new THREE.ShaderMaterial(terrainShader);

                function createGrid(xRes, yRes, points, avoidX, avoidY) {
                    var geometry = new THREE.BufferGeometry();
                    var vertices = [];
                    var offset = 0;

                    function pushVertex(i, j) {
                        vertices.push(i / (xRes - 1), j / (yRes - 1), 0);
                    }

                    for (var i = 0; i < xRes; i++)
                        for (var j = 0; j < yRes; j++) {
                            if (points)
                                pushVertex(i, j);
                            else {
                                if (i != 0 && !avoidX) {
                                    pushVertex(i - 1, j);
                                    pushVertex(i, j);
                                }
                                if (j != 0 && !avoidY) {
                                    pushVertex(i, j - 1);
                                    pushVertex(i, j);
                                }
                            }
                            offset += 3
                        }
                    geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(vertices), 3));
                    if (points)
                        return new THREE.PointCloud(geometry, terrainMaterial);
                    else
                        return new THREE.Line(geometry, terrainMaterial, THREE.LinePieces);
                }

                var grid = createGrid(pipeline.toolPosBuffer.width, pipeline.toolPosBuffer.height, false, false, true);
                grid.frustumCulled = false;
                scene2.add(grid);
                scene2.add(new THREE.Mesh(clonedGeometry, new THREE.MeshLambertMaterial({color: 0xFEEFFE, shading: THREE.SmoothShading})));

                document.documentElement.addEventListener('keydown', function (event) {
                    if (event.shiftKey === true) {
                        document.body.classList.add('moving');
                    }
                });

                document.documentElement.addEventListener('keyup', function (event) {
                    if (event.shiftKey === false) {
                        document.body.classList.remove('moving');
                    }
                });

                var controls = new OrbitControls(camera2, renderer.domElement);
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.8;
                controls.noZoom = false;
                controls.noPan = false;
                controls.staticMoving = true;
                controls.dynamicDampingFactor = 0.3;
                controls.minDistance = 3;
                controls.keys = [ 65, 83, 68 ];
                controls.addEventListener('change', function () {
                    reRenderPipeline();
                });
                function reRender() {
                    terrainMaterial.uniforms.tDisplacement.value = pipeline.slicingBuffer;
                    renderer.render(scene2, camera2);
                }

                function setToolType(type) {
                    console.time('tool change');
                    pipeline.setToolType(type);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function setToolRadius(radius) {
                    $('#radius').text(radius);
                    console.time('tool change');
                    pipeline.setToolRadius(radius);
                    reRenderPipeline();
                    console.timeEnd('tool change');
                }

                function reRenderPipeline() {
                    console.time('complete render');
                    pipeline.render(renderer);
                    reRender();

                    //for pessimistic computation time measure, since gl.finish() is faked.
                    var gl = renderer.getContext();
                    gl.flush();
                    var pixelBuffer = new Uint8Array(4);
                    gl.readPixels(1, 1, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);
                    console.timeEnd('complete render');
                }

                window.setToolType = setToolType;
                window.setToolRadius = setToolRadius;
                window.setSliceZ = function (z) {
                    console.log('setSliceZ');
                    $('#slice').text(z);
                    console.time('tool change');
                    pipeline.setSliceZ(parseFloat(z));
                    reRenderPipeline();
                    console.timeEnd('tool change');
                };
                //pipeline.render(renderer);
                reRenderPipeline();
            }
        });
</script>
</head>
<body>
<div class="btn-toolbar" role="toolbar">
    <div class="btn-group" role="group">
        <label>shape: <select name="select" onChange="setToolType(this.value);">
            <option value="cylinder">Cylinder</option>
            <option value="ball" selected>Ball Nose</option>
            <option value="v">V Carving</option>
        </select></label>
        <label>Radius (
            <span id="radius">2</span>
            ): <input type="range" min="0" max="10" value="1" step="0.1"
                      oninput="setToolRadius(this.value)"></label>
        <label>Slice Z (
            <span id="slice">-7</span>
            ): <input type="range" min="-25" max="0" value="-7" step="0.5"
                      oninput="setSliceZ(this.value)"></label>
    </div>

</div>
</body>

</html>
